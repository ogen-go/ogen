// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"mime"
	"mime/multipart"
	"net/http"
	"strings"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

func encodeAllRequestBodiesRequest(
	req AllRequestBodiesReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AllRequestBodiesApplicationJSON:
		const contentType = "application/json"
		e := jx.GetEncoder()
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AllRequestBodiesReqApplicationOctetStream:
		const contentType = "application/octet-stream"
		ht.SetBody(r, req, contentType)
		return nil
	case *AllRequestBodiesApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		request := req

		q := uri.NewQueryEncoder()
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "age" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "age",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Age.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *AllRequestBodiesMultipartFormData:
		const contentType = "multipart/form-data"
		request := req

		q := uri.NewQueryEncoder()
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "age" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "age",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Age.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	case *AllRequestBodiesReqTextPlain:
		const contentType = "text/plain"
		ht.SetBody(r, req, contentType)
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}
func encodeAllRequestBodiesOptionalRequest(
	req AllRequestBodiesOptionalReq,
	r *http.Request,
) error {
	switch req := req.(type) {
	case *AllRequestBodiesOptionalApplicationJSON:
		const contentType = "application/json"
		if !req.Set {
			// Keep request with empty body if value is not set.
			return nil
		}
		e := jx.GetEncoder()
		{
			req.Encode(e)
		}
		encoded := e.Bytes()
		ht.SetBody(r, bytes.NewReader(encoded), contentType)
		return nil
	case *AllRequestBodiesOptionalReqApplicationOctetStream:
		const contentType = "application/octet-stream"
		ht.SetBody(r, req, contentType)
		return nil
	case *AllRequestBodiesOptionalApplicationXWwwFormUrlencoded:
		const contentType = "application/x-www-form-urlencoded"
		if !req.Set {
			// Keep request with empty body if value is not set.
			return nil
		}
		request := req.Value

		q := uri.NewQueryEncoder()
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "age" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "age",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Age.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		encoded := q.Values().Encode()
		ht.SetBody(r, strings.NewReader(encoded), contentType)
		return nil
	case *AllRequestBodiesOptionalMultipartFormData:
		const contentType = "multipart/form-data"
		if !req.Set {
			// Keep request with empty body if value is not set.
			return nil
		}
		request := req.Value

		q := uri.NewQueryEncoder()
		{
			// Encode "name" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				return e.EncodeValue(conv.StringToString(request.Name))
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		{
			// Encode "age" form field.
			cfg := uri.QueryParameterEncodingConfig{
				Name:    "age",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := request.Age.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode query")
			}
		}
		body, boundary := ht.CreateMultipartBody(func(w *multipart.Writer) error {
			if err := q.WriteMultipart(w); err != nil {
				return errors.Wrap(err, "write multipart")
			}
			return nil
		})
		ht.SetBody(r, body, mime.FormatMediaType(contentType, map[string]string{"boundary": boundary}))
		return nil
	case *AllRequestBodiesOptionalReqTextPlain:
		const contentType = "text/plain"
		ht.SetBody(r, req, contentType)
		return nil
	default:
		return errors.Errorf("unexpected request type: %T", req)
	}
}
