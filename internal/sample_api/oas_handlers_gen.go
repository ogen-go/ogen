// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// HandleDataGetFormatRequest handles dataGetFormat operation.
//
// GET /name/{id}/{foo}1234{bar}-{baz}!{kek}
func (s *Server) handleDataGetFormatRequest(args [5]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("dataGetFormat"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "DataGetFormat",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DataGetFormat",
			ID:   "dataGetFormat",
		}
	)
	params, err := decodeDataGetFormatParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response string
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "DataGetFormat",
			OperationID:   "dataGetFormat",
			Body:          nil,
			Params: map[string]any{
				"id":  params.ID,
				"foo": params.Foo,
				"bar": params.Bar,
				"baz": params.Baz,
				"kek": params.Kek,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DataGetFormatParams
			Response = string
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.DataGetFormat(ctx, params)
			},
		)
	} else {
		response, err = s.h.DataGetFormat(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDataGetFormatResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleDefaultTestRequest handles defaultTest operation.
//
// POST /defaultTest
func (s *Server) handleDefaultTestRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("defaultTest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "DefaultTest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DefaultTest",
			ID:   "defaultTest",
		}
	)
	params, err := decodeDefaultTestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeDefaultTestRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response int32
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "DefaultTest",
			OperationID:   "defaultTest",
			Body:          request,
			Params: map[string]any{
				"default": params.Default,
			},
			Raw: r,
		}

		type (
			Request  = DefaultTest
			Params   = DefaultTestParams
			Response = int32
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.DefaultTest(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.DefaultTest(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDefaultTestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleErrorGetRequest handles errorGet operation.
//
// GET /error
func (s *Server) handleErrorGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("errorGet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ErrorGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response ErrorStatusCode
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "ErrorGet",
			OperationID:   "errorGet",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = ErrorStatusCode
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.ErrorGet(ctx)
			},
		)
	} else {
		response, err = s.h.ErrorGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeErrorGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleFoobarGetRequest handles foobarGet operation.
//
// GET /foobar
func (s *Server) handleFoobarGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("foobarGet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "FoobarGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "FoobarGet",
			ID:   "foobarGet",
		}
	)
	params, err := decodeFoobarGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response FoobarGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "FoobarGet",
			OperationID:   "foobarGet",
			Body:          nil,
			Params: map[string]any{
				"inlinedParam": params.InlinedParam,
				"skip":         params.Skip,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = FoobarGetParams
			Response = FoobarGetRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.FoobarGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.FoobarGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeFoobarGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleFoobarPostRequest handles foobarPost operation.
//
// POST /foobar
func (s *Server) handleFoobarPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("foobarPost"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "FoobarPost",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "FoobarPost",
			ID:   "foobarPost",
		}
	)
	request, close, err := s.decodeFoobarPostRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response FoobarPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "FoobarPost",
			OperationID:   "foobarPost",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptPet
			Params   = struct{}
			Response = FoobarPostRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.FoobarPost(ctx, request)
			},
		)
	} else {
		response, err = s.h.FoobarPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeFoobarPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleFoobarPutRequest handles PUT /foobar operation.
//
// PUT /foobar
func (s *Server) handleFoobarPutRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "FoobarPut",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response FoobarPutDef
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "FoobarPut",
			OperationID:   "",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = FoobarPutDef
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.FoobarPut(ctx)
			},
		)
	} else {
		response, err = s.h.FoobarPut(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeFoobarPutResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleGetHeaderRequest handles getHeader operation.
//
// GET /test/header
func (s *Server) handleGetHeaderRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getHeader"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetHeader",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHeader",
			ID:   "getHeader",
		}
	)
	params, err := decodeGetHeaderParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Hash
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "GetHeader",
			OperationID:   "getHeader",
			Body:          nil,
			Params: map[string]any{
				"x-auth-token": params.XAuthToken,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHeaderParams
			Response = Hash
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.GetHeader(ctx, params)
			},
		)
	} else {
		response, err = s.h.GetHeader(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHeaderResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleNoAdditionalPropertiesTestRequest handles noAdditionalPropertiesTest operation.
//
// GET /noAdditionalPropertiesTest
func (s *Server) handleNoAdditionalPropertiesTestRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("noAdditionalPropertiesTest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "NoAdditionalPropertiesTest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response NoAdditionalPropertiesTest
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "NoAdditionalPropertiesTest",
			OperationID:   "noAdditionalPropertiesTest",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = NoAdditionalPropertiesTest
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.NoAdditionalPropertiesTest(ctx)
			},
		)
	} else {
		response, err = s.h.NoAdditionalPropertiesTest(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeNoAdditionalPropertiesTestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleNullableDefaultResponseRequest handles nullableDefaultResponse operation.
//
// GET /nullableDefaultResponse
func (s *Server) handleNullableDefaultResponseRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("nullableDefaultResponse"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "NullableDefaultResponse",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response NilIntStatusCode
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "NullableDefaultResponse",
			OperationID:   "nullableDefaultResponse",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = NilIntStatusCode
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.NullableDefaultResponse(ctx)
			},
		)
	} else {
		response, err = s.h.NullableDefaultResponse(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeNullableDefaultResponseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleOneofBugRequest handles oneofBug operation.
//
// POST /oneofBug
func (s *Server) handleOneofBugRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oneofBug"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OneofBug",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "OneofBug",
			ID:   "oneofBug",
		}
	)
	request, close, err := s.decodeOneofBugRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OneofBugOK
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "OneofBug",
			OperationID:   "oneofBug",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OneOfBugs
			Params   = struct{}
			Response = OneofBugOK
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.OneofBug(ctx, request)
			},
		)
	} else {
		response, err = s.h.OneofBug(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOneofBugResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePatternRecursiveMapGetRequest handles GET /patternRecursiveMap operation.
//
// GET /patternRecursiveMap
func (s *Server) handlePatternRecursiveMapGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PatternRecursiveMapGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response PatternRecursiveMap
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PatternRecursiveMapGet",
			OperationID:   "",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = PatternRecursiveMap
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PatternRecursiveMapGet(ctx)
			},
		)
	} else {
		response, err = s.h.PatternRecursiveMapGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePatternRecursiveMapGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetCreateRequest handles petCreate operation.
//
// POST /pet
func (s *Server) handlePetCreateRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petCreate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetCreate",
			ID:   "petCreate",
		}
	)
	request, close, err := s.decodePetCreateRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response Pet
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetCreate",
			OperationID:   "petCreate",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptPet
			Params   = struct{}
			Response = Pet
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetCreate(ctx, request)
			},
		)
	} else {
		response, err = s.h.PetCreate(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetFriendsNamesByIDRequest handles petFriendsNamesByID operation.
//
// GET /pet/friendNames/{id}
func (s *Server) handlePetFriendsNamesByIDRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petFriendsNamesByID"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetFriendsNamesByID",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetFriendsNamesByID",
			ID:   "petFriendsNamesByID",
		}
	)
	params, err := decodePetFriendsNamesByIDParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []string
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetFriendsNamesByID",
			OperationID:   "petFriendsNamesByID",
			Body:          nil,
			Params: map[string]any{
				"id": params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetFriendsNamesByIDParams
			Response = []string
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetFriendsNamesByID(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetFriendsNamesByID(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetFriendsNamesByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetGetRequest handles petGet operation.
//
// GET /pet
func (s *Server) handlePetGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petGet"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetGet",
			ID:   "petGet",
		}
	)
	params, err := decodePetGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PetGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetGet",
			OperationID:   "petGet",
			Body:          nil,
			Params: map[string]any{
				"petID":   params.PetID,
				"x-tags":  params.XTags,
				"x-scope": params.XScope,
				"token":   params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetGetParams
			Response = PetGetRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetGet(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetGetAvatarByIDRequest handles petGetAvatarByID operation.
//
// GET /pet/avatar
func (s *Server) handlePetGetAvatarByIDRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petGetAvatarByID"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetGetAvatarByID",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetGetAvatarByID",
			ID:   "petGetAvatarByID",
		}
	)
	params, err := decodePetGetAvatarByIDParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PetGetAvatarByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetGetAvatarByID",
			OperationID:   "petGetAvatarByID",
			Body:          nil,
			Params: map[string]any{
				"petID": params.PetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetGetAvatarByIDParams
			Response = PetGetAvatarByIDRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetGetAvatarByID(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetGetAvatarByID(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetGetAvatarByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetGetAvatarByNameRequest handles petGetAvatarByName operation.
//
// GET /pet/{name}/avatar
func (s *Server) handlePetGetAvatarByNameRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petGetAvatarByName"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetGetAvatarByName",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetGetAvatarByName",
			ID:   "petGetAvatarByName",
		}
	)
	params, err := decodePetGetAvatarByNameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PetGetAvatarByNameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetGetAvatarByName",
			OperationID:   "petGetAvatarByName",
			Body:          nil,
			Params: map[string]any{
				"name": params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetGetAvatarByNameParams
			Response = PetGetAvatarByNameRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetGetAvatarByName(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetGetAvatarByName(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetGetAvatarByNameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetGetByNameRequest handles petGetByName operation.
//
// GET /pet/{name}
func (s *Server) handlePetGetByNameRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petGetByName"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetGetByName",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetGetByName",
			ID:   "petGetByName",
		}
	)
	params, err := decodePetGetByNameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Pet
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetGetByName",
			OperationID:   "petGetByName",
			Body:          nil,
			Params: map[string]any{
				"name": params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetGetByNameParams
			Response = Pet
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetGetByName(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetGetByName(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetGetByNameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetNameByIDRequest handles petNameByID operation.
//
// GET /pet/name/{id}
func (s *Server) handlePetNameByIDRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petNameByID"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetNameByID",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetNameByID",
			ID:   "petNameByID",
		}
	)
	params, err := decodePetNameByIDParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response string
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetNameByID",
			OperationID:   "petNameByID",
			Body:          nil,
			Params: map[string]any{
				"id": params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PetNameByIDParams
			Response = string
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetNameByID(ctx, params)
			},
		)
	} else {
		response, err = s.h.PetNameByID(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetNameByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetUpdateNameAliasPostRequest handles POST /pet/updateNameAlias operation.
//
// POST /pet/updateNameAlias
func (s *Server) handlePetUpdateNameAliasPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetUpdateNameAliasPost",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetUpdateNameAliasPost",
			ID:   "",
		}
	)
	request, close, err := s.decodePetUpdateNameAliasPostRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PetUpdateNameAliasPostDef
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetUpdateNameAliasPost",
			OperationID:   "",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptPetName
			Params   = struct{}
			Response = PetUpdateNameAliasPostDef
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetUpdateNameAliasPost(ctx, request)
			},
		)
	} else {
		response, err = s.h.PetUpdateNameAliasPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetUpdateNameAliasPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetUpdateNamePostRequest handles POST /pet/updateName operation.
//
// POST /pet/updateName
func (s *Server) handlePetUpdateNamePostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetUpdateNamePost",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetUpdateNamePost",
			ID:   "",
		}
	)
	request, close, err := s.decodePetUpdateNamePostRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PetUpdateNamePostDef
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetUpdateNamePost",
			OperationID:   "",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = OptString
			Params   = struct{}
			Response = PetUpdateNamePostDef
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetUpdateNamePost(ctx, request)
			},
		)
	} else {
		response, err = s.h.PetUpdateNamePost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetUpdateNamePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandlePetUploadAvatarByIDRequest handles petUploadAvatarByID operation.
//
// POST /pet/avatar
func (s *Server) handlePetUploadAvatarByIDRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("petUploadAvatarByID"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PetUploadAvatarByID",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PetUploadAvatarByID",
			ID:   "petUploadAvatarByID",
		}
	)
	params, err := decodePetUploadAvatarByIDParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePetUploadAvatarByIDRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PetUploadAvatarByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "PetUploadAvatarByID",
			OperationID:   "petUploadAvatarByID",
			Body:          request,
			Params: map[string]any{
				"petID": params.PetID,
			},
			Raw: r,
		}

		type (
			Request  = PetUploadAvatarByIDReq
			Params   = PetUploadAvatarByIDParams
			Response = PetUploadAvatarByIDRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.PetUploadAvatarByID(ctx, request, params)
			},
		)
	} else {
		response, err = s.h.PetUploadAvatarByID(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePetUploadAvatarByIDResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleRecursiveArrayGetRequest handles GET /recursiveArray operation.
//
// GET /recursiveArray
func (s *Server) handleRecursiveArrayGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RecursiveArrayGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response RecursiveArray
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "RecursiveArrayGet",
			OperationID:   "",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RecursiveArray
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.RecursiveArrayGet(ctx)
			},
		)
	} else {
		response, err = s.h.RecursiveArrayGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRecursiveArrayGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleRecursiveMapGetRequest handles GET /recursiveMap operation.
//
// GET /recursiveMap
func (s *Server) handleRecursiveMapGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RecursiveMapGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response RecursiveMap
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "RecursiveMapGet",
			OperationID:   "",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RecursiveMap
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.RecursiveMapGet(ctx)
			},
		)
	} else {
		response, err = s.h.RecursiveMapGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRecursiveMapGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleSecurityTestRequest handles securityTest operation.
//
// GET /securityTest
func (s *Server) handleSecurityTestRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("securityTest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecurityTest",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SecurityTest",
			ID:   "securityTest",
		}
	)
	ctx, err = s.securityAPIKey(ctx, "SecurityTest", r)
	if err != nil {
		err = &ogenerrors.SecurityError{
			OperationContext: opErrContext,
			Security:         "APIKey",
			Err:              err,
		}
		recordError("Security:APIKey", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response string
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "SecurityTest",
			OperationID:   "securityTest",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = string
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.SecurityTest(ctx)
			},
		)
	} else {
		response, err = s.h.SecurityTest(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecurityTestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleStringIntMapGetRequest handles GET /stringIntMap operation.
//
// GET /stringIntMap
func (s *Server) handleStringIntMapGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "StringIntMapGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response StringIntMap
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "StringIntMapGet",
			OperationID:   "",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = StringIntMap
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.StringIntMapGet(ctx)
			},
		)
	} else {
		response, err = s.h.StringIntMapGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeStringIntMapGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleTestContentParameterRequest handles testContentParameter operation.
//
// GET /testContentParameter
func (s *Server) handleTestContentParameterRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("testContentParameter"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TestContentParameter",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TestContentParameter",
			ID:   "testContentParameter",
		}
	)
	params, err := decodeTestContentParameterParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response string
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "TestContentParameter",
			OperationID:   "testContentParameter",
			Body:          nil,
			Params: map[string]any{
				"param": params.Param,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TestContentParameterParams
			Response = string
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.TestContentParameter(ctx, params)
			},
		)
	} else {
		response, err = s.h.TestContentParameter(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTestContentParameterResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleTestFloatValidationRequest handles testFloatValidation operation.
//
// POST /testFloatValidation
func (s *Server) handleTestFloatValidationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("testFloatValidation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TestFloatValidation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TestFloatValidation",
			ID:   "testFloatValidation",
		}
	)
	request, close, err := s.decodeTestFloatValidationRequest(r, span)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TestFloatValidationOK
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "TestFloatValidation",
			OperationID:   "testFloatValidation",
			Body:          request,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = TestFloatValidation
			Params   = struct{}
			Response = TestFloatValidationOK
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.TestFloatValidation(ctx, request)
			},
		)
	} else {
		response, err = s.h.TestFloatValidation(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTestFloatValidationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleTestNullableOneofsRequest handles testNullableOneofs operation.
//
// GET /testNullableOneofs
func (s *Server) handleTestNullableOneofsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("testNullableOneofs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TestNullableOneofs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response TestNullableOneofsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "TestNullableOneofs",
			OperationID:   "testNullableOneofs",
			Body:          nil,
			Params:        map[string]any{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = TestNullableOneofsRes
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			struct{}{},
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.TestNullableOneofs(ctx)
			},
		)
	} else {
		response, err = s.h.TestNullableOneofs(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTestNullableOneofsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// HandleTestObjectQueryParameterRequest handles testObjectQueryParameter operation.
//
// GET /testObjectQueryParameter
func (s *Server) handleTestObjectQueryParameterRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("testObjectQueryParameter"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TestObjectQueryParameter",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TestObjectQueryParameter",
			ID:   "testObjectQueryParameter",
		}
	)
	params, err := decodeTestObjectQueryParameterParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TestObjectQueryParameterOK
	if m := s.cfg.Middleware; m != nil {
		mreq := MiddlewareRequest{
			Context:       ctx,
			OperationName: "TestObjectQueryParameter",
			OperationID:   "testObjectQueryParameter",
			Body:          nil,
			Params: map[string]any{
				"formObject": params.FormObject,
				"deepObject": params.DeepObject,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TestObjectQueryParameterParams
			Response = TestObjectQueryParameterOK
		)
		response, err = hookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			params,
			mreq,
			func(ctx context.Context, params Params, request Request) (Response, error) {
				return s.h.TestObjectQueryParameter(ctx, params)
			},
		)
	} else {
		response, err = s.h.TestObjectQueryParameter(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTestObjectQueryParameterResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
