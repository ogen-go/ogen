// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestLocation_EncodeDecode(t *testing.T) {
	var typ Location
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Location
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectsWithConflictingArrayPropertyReq_EncodeDecode(t *testing.T) {
	var typ ObjectsWithConflictingArrayPropertyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectsWithConflictingArrayPropertyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectsWithConflictingPropertiesReq_EncodeDecode(t *testing.T) {
	var typ ObjectsWithConflictingPropertiesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectsWithConflictingPropertiesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferencedAllOfNullable_EncodeDecode(t *testing.T) {
	var typ ReferencedAllOfNullable
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferencedAllOfNullable
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferencedAllOfNullableAllOfLocation_EncodeDecode(t *testing.T) {
	var typ ReferencedAllOfNullableAllOfLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferencedAllOfNullableAllOfLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferencedAllOfNullableMultipartAllOfLocation_EncodeDecode(t *testing.T) {
	var typ ReferencedAllOfNullableMultipartAllOfLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferencedAllOfNullableMultipartAllOfLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferencedAllOfNullableMultipartNullableAllOfLocation_EncodeDecode(t *testing.T) {
	var typ ReferencedAllOfNullableMultipartNullableAllOfLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferencedAllOfNullableMultipartNullableAllOfLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferencedAllOfNullableNullableAllOfLocation_EncodeDecode(t *testing.T) {
	var typ ReferencedAllOfNullableNullableAllOfLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferencedAllOfNullableNullableAllOfLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRobot_EncodeDecode(t *testing.T) {
	var typ Robot
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Robot
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRobotState_EncodeDecode(t *testing.T) {
	var typ RobotState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RobotState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleObjectsReq_EncodeDecode(t *testing.T) {
	var typ SimpleObjectsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleObjectsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
