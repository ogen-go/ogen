// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// DataGetFormatParams is parameters of dataGetFormat operation.
type DataGetFormatParams struct {
	ID  int
	Foo string
	Bar string
	Baz string
	Kek string
}

func unpackDataGetFormatParams(packed map[string]any) (params DataGetFormatParams) {
	params.ID = packed["id"].(int)
	params.Foo = packed["foo"].(string)
	params.Bar = packed["bar"].(string)
	params.Baz = packed["baz"].(string)
	params.Kek = packed["kek"].(string)
	return params
}

func decodeDataGetFormatParams(args [5]string, r *http.Request) (params DataGetFormatParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.ID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: invalid")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode path: foo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "foo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Foo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: foo: parse")
			}
		} else {
			return params, errors.New("path: foo: not specified")
		}
	}
	// Decode path: bar.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "bar",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Bar = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: bar: parse")
			}
		} else {
			return params, errors.New("path: bar: not specified")
		}
	}
	// Decode path: baz.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "baz",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Baz = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: baz: parse")
			}
		} else {
			return params, errors.New("path: baz: not specified")
		}
	}
	// Decode path: kek.
	{
		param := args[4]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "kek",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Kek = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: kek: parse")
			}
		} else {
			return params, errors.New("path: kek: not specified")
		}
	}
	return params, nil
}

// DefaultTestParams is parameters of defaultTest operation.
type DefaultTestParams struct {
	Default OptInt32 `json:",omitempty"`
}

func unpackDefaultTestParams(packed map[string]any) (params DefaultTestParams) {
	if v, ok := packed["default"]; ok {
		params.Default = v.(OptInt32)
	}
	return params
}

func decodeDefaultTestParams(args [0]string, r *http.Request) (params DefaultTestParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: default.
	{
		val := int32(10)
		params.Default.SetTo(val)
	}
	// Decode query: default.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "default",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDefaultVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotDefaultVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Default.SetTo(paramsDotDefaultVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: default: parse")
			}
		}
	}
	return params, nil
}

// FoobarGetParams is parameters of foobarGet operation.
type FoobarGetParams struct {
	// InlinedParam.
	InlinedParam int64
	// Number of items to skip.
	Skip int32
}

func unpackFoobarGetParams(packed map[string]any) (params FoobarGetParams) {
	params.InlinedParam = packed["inlinedParam"].(int64)
	params.Skip = packed["skip"].(int32)
	return params
}

func decodeFoobarGetParams(args [0]string, r *http.Request) (params FoobarGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: inlinedParam.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "inlinedParam",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.InlinedParam = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: inlinedParam: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: skip.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "skip",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.Skip = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: skip: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// GetHeaderParams is parameters of getHeader operation.
type GetHeaderParams struct {
	XAuthToken string
}

func unpackGetHeaderParams(packed map[string]any) (params GetHeaderParams) {
	params.XAuthToken = packed["x-auth-token"].(string)
	return params
}

func decodeGetHeaderParams(args [0]string, r *http.Request) (params GetHeaderParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: x-auth-token.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-auth-token",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.XAuthToken = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "header: x-auth-token: parse")
			}
		} else {
			return params, errors.New("header: x-auth-token: not specified")
		}
	}
	return params, nil
}

// PetFriendsNamesByIDParams is parameters of petFriendsNamesByID operation.
type PetFriendsNamesByIDParams struct {
	// Pet ID.
	ID int
}

func unpackPetFriendsNamesByIDParams(packed map[string]any) (params PetFriendsNamesByIDParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodePetFriendsNamesByIDParams(args [1]string, r *http.Request) (params PetFriendsNamesByIDParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

// PetGetParams is parameters of petGet operation.
type PetGetParams struct {
	// ID of pet.
	PetID int64
	// Tags of pets.
	XTags []uuid.UUID
	// Pet scopes.
	XScope []string
	// Token.
	Token string
}

func unpackPetGetParams(packed map[string]any) (params PetGetParams) {
	params.PetID = packed["petID"].(int64)
	params.XTags = packed["x-tags"].([]uuid.UUID)
	params.XScope = packed["x-scope"].([]string)
	params.Token = packed["token"].(string)
	return params
}

func decodePetGetParams(args [0]string, r *http.Request) (params PetGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	h := uri.NewHeaderDecoder(r.Header)
	// Decode query: petID.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "petID",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.PetID = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: petID: parse")
			}
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1337,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(params.PetID)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: petID: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode header: x-tags.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-tags",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotXTagsVal uuid.UUID
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToUUID(val)
						if err != nil {
							return err
						}

						paramsDotXTagsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.XTags = append(params.XTags, paramsDotXTagsVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "header: x-tags: parse")
			}
			if err := func() error {
				if params.XTags == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "header: x-tags: invalid")
			}
		} else {
			return params, errors.New("header: x-tags: not specified")
		}
	}
	// Decode header: x-scope.
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "x-scope",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotXScopeVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotXScopeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.XScope = append(params.XScope, paramsDotXScopeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "header: x-scope: parse")
			}
			if err := func() error {
				if params.XScope == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "header: x-scope: invalid")
			}
		} else {
			return params, errors.New("header: x-scope: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Token = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// PetGetAvatarByIDParams is parameters of petGetAvatarByID operation.
type PetGetAvatarByIDParams struct {
	// ID of pet.
	PetID int64
}

func unpackPetGetAvatarByIDParams(packed map[string]any) (params PetGetAvatarByIDParams) {
	params.PetID = packed["petID"].(int64)
	return params
}

func decodePetGetAvatarByIDParams(args [0]string, r *http.Request) (params PetGetAvatarByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: petID.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "petID",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.PetID = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: petID: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// PetGetAvatarByNameParams is parameters of petGetAvatarByName operation.
type PetGetAvatarByNameParams struct {
	// Name of pet.
	Name string
}

func unpackPetGetAvatarByNameParams(packed map[string]any) (params PetGetAvatarByNameParams) {
	params.Name = packed["name"].(string)
	return params
}

func decodePetGetAvatarByNameParams(args [1]string, r *http.Request) (params PetGetAvatarByNameParams, _ error) {
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// PetGetByNameParams is parameters of petGetByName operation.
type PetGetByNameParams struct {
	// Name of pet.
	Name string
}

func unpackPetGetByNameParams(packed map[string]any) (params PetGetByNameParams) {
	params.Name = packed["name"].(string)
	return params
}

func decodePetGetByNameParams(args [1]string, r *http.Request) (params PetGetByNameParams, _ error) {
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// PetNameByIDParams is parameters of petNameByID operation.
type PetNameByIDParams struct {
	// Pet ID.
	ID int
}

func unpackPetNameByIDParams(packed map[string]any) (params PetNameByIDParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodePetNameByIDParams(args [1]string, r *http.Request) (params PetNameByIDParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

// PetUploadAvatarByIDParams is parameters of petUploadAvatarByID operation.
type PetUploadAvatarByIDParams struct {
	// ID of pet.
	PetID int64
}

func unpackPetUploadAvatarByIDParams(packed map[string]any) (params PetUploadAvatarByIDParams) {
	params.PetID = packed["petID"].(int64)
	return params
}

func decodePetUploadAvatarByIDParams(args [0]string, r *http.Request) (params PetUploadAvatarByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: petID.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "petID",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.PetID = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: petID: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	return params, nil
}

// TestContentParameterParams is parameters of testContentParameter operation.
type TestContentParameterParams struct {
	Param OptTestContentParameterParam `json:",omitempty"`
}

func unpackTestContentParameterParams(packed map[string]any) (params TestContentParameterParams) {
	if v, ok := packed["param"]; ok {
		params.Param = v.(OptTestContentParameterParam)
	}
	return params
}

func decodeTestContentParameterParams(args [0]string, r *http.Request) (params TestContentParameterParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: param.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "param",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}
				if err := func(d *jx.Decoder) error {
					params.Param.Reset()
					if err := params.Param.Decode(d); err != nil {
						return err
					}
					return nil
				}(jx.DecodeStr(val)); err != nil {
					return err
				}
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: param: parse")
			}
		}
	}
	return params, nil
}

// TestObjectQueryParameterParams is parameters of testObjectQueryParameter operation.
type TestObjectQueryParameterParams struct {
	FormObject OptTestObjectQueryParameterFormObject `json:",omitempty"`
	DeepObject OptTestObjectQueryParameterDeepObject `json:",omitempty"`
}

func unpackTestObjectQueryParameterParams(packed map[string]any) (params TestObjectQueryParameterParams) {
	if v, ok := packed["formObject"]; ok {
		params.FormObject = v.(OptTestObjectQueryParameterFormObject)
	}
	if v, ok := packed["deepObject"]; ok {
		params.DeepObject = v.(OptTestObjectQueryParameterDeepObject)
	}
	return params
}

func decodeTestObjectQueryParameterParams(args [0]string, r *http.Request) (params TestObjectQueryParameterParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: formObject.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "formObject",
			Style:   uri.QueryStyleForm,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{"min", true}, {"max", true}, {"filter", true}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFormObjectVal TestObjectQueryParameterFormObject
				if err := func() error {
					return paramsDotFormObjectVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.FormObject.SetTo(paramsDotFormObjectVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: formObject: parse")
			}
		}
	}
	// Decode query: deepObject.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "deepObject",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
			Fields:  []uri.QueryParameterObjectField{{"min", true}, {"max", true}, {"filter", true}},
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDeepObjectVal TestObjectQueryParameterDeepObject
				if err := func() error {
					return paramsDotDeepObjectVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.DeepObject.SetTo(paramsDotDeepObjectVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: deepObject: parse")
			}
		}
	}
	return params, nil
}
