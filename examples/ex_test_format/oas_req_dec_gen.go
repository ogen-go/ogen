// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"io"
	"net/http"
	"net/netip"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

func decodeTestRequestAnyRequest(r *http.Request, span trace.Span) (req jx.Raw, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request jx.Raw
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.RawAppend(nil)
			request = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestAny:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanRequest(r *http.Request, span trace.Span) (req OptBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBoolean:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableRequest(r *http.Request, span trace.Span) (req OptNilBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestEmptyStructRequest(r *http.Request, span trace.Span) (req *TestRequestEmptyStructReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request *TestRequestEmptyStructReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = nil
			var elem TestRequestEmptyStructReq
			if err := elem.Decode(d); err != nil {
				return err
			}
			request = &elem
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestEmptyStruct:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestFormatTestRequest(r *http.Request, span trace.Span) (req OptTestRequestFormatTestReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTestRequestFormatTestReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestFormatTest:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := request.Value.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestFormatTest request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerRequest(r *http.Request, span trace.Span) (req OptInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestInteger:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableRequest(r *http.Request, span trace.Span) (req OptNilInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullRequest(r *http.Request, span trace.Span) (req OptNull, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNull
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNull:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNullArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNullArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNullArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableRequest(r *http.Request, span trace.Span) (req OptNull, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNull
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNullNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNullNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNullNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNullNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumber:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumber request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDouble:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDouble request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullableArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatRequest(r *http.Request, span trace.Span) (req OptFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloat:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloat request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullableArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullableArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredAnyRequest(r *http.Request, span trace.Span) (req jx.Raw, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request jx.Raw
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.RawAppend(nil)
			request = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredAny:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanRequest(r *http.Request, span trace.Span) (req bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Bool()
			request = bool(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBoolean:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBooleanArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredBooleanArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBooleanArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredBooleanArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableRequest(r *http.Request, span trace.Span) (req NilBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBooleanNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBooleanNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredBooleanNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredBooleanNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredBooleanNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredEmptyStructRequest(r *http.Request, span trace.Span) (req TestRequestRequiredEmptyStructReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request TestRequestRequiredEmptyStructReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredEmptyStruct:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredFormatTestRequest(r *http.Request, span trace.Span) (req TestRequestRequiredFormatTestReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request TestRequestRequiredFormatTestReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredFormatTest:application/json request")
		}
		if err := func() error {
			if err := request.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredFormatTest request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerRequest(r *http.Request, span trace.Span) (req int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int()
			request = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredInteger:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int32()
			request = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt32Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req NilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt32NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int64()
			request = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt64Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req NilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt64NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableRequest(r *http.Request, span trace.Span) (req NilInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredIntegerNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredIntegerNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullRequest(r *http.Request, span trace.Span) (req struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := d.Null(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNull:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNullArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNullArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNullArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNullArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableRequest(r *http.Request, span trace.Span) (req struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := d.Null(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNullNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNullNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNullNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNullNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNullNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberRequest(r *http.Request, span trace.Span) (req float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float64()
			request = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumber:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumber request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleRequest(r *http.Request, span trace.Span) (req float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float64()
			request = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDouble:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDouble request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDoubleArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDoubleArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDoubleArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDoubleArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req NilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDoubleNullable:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDoubleNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDoubleNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDoubleNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberDoubleNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberDoubleNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatRequest(r *http.Request, span trace.Span) (req float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float32()
			request = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloat:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloat request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloatArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloatArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloatArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloatArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableRequest(r *http.Request, span trace.Span) (req NilFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloatNullable:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloatNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloatNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloatNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberFloatNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberFloatNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int32()
			request = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt32Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableRequest(r *http.Request, span trace.Span) (req NilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt32NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int64()
			request = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt64Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableRequest(r *http.Request, span trace.Span) (req NilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt64NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableRequest(r *http.Request, span trace.Span) (req NilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberNullable:application/json request")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredNumberNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredNumberNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredString:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinary:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinaryArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringBinaryArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinaryArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringBinaryArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinaryNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinaryNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringBinaryNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringBinaryNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringBinaryNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByte:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByteArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringByteArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByteArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringByteArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByteNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByteNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringByteNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringByteNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringByteNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDate(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDate:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableRequest(r *http.Request, span trace.Span) (req NilDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDateTime(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTimeArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateTimeArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTimeArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req NilDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTimeNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateTimeNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDateTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDateTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationRequest(r *http.Request, span trace.Span) (req time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDuration(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDuration:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDurationArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDurationArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDurationArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDurationArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableRequest(r *http.Request, span trace.Span) (req NilDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDurationNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDurationNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDurationNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringDurationNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringDurationNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmail:application/json request")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        true,
				Hostname:     false,
				Regex:        nil,
			}).Validate(string(request)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmail request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmailArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmailArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmailArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmailArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmailNullable:application/json request")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        true,
				Hostname:     false,
				Regex:        nil,
			}).Validate(string(request.Value)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmailNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmailNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmailNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringEmailNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringEmailNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostname:application/json request")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        false,
				Hostname:     true,
				Regex:        nil,
			}).Validate(string(request)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostname request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostnameArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostnameArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostnameArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostnameArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostnameNullable:application/json request")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        false,
				Hostname:     true,
				Regex:        nil,
			}).Validate(string(request.Value)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostnameNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostnameNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostnameNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringHostnameNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringHostnameNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPRequest(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIP:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIPArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIPArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIPArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIPArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableRequest(r *http.Request, span trace.Span) (req NilIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIPNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIPNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIPNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIPNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIPNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeStringInt32(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt32Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableRequest(r *http.Request, span trace.Span) (req NilStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt32NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeStringInt64(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt64Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableRequest(r *http.Request, span trace.Span) (req NilStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt64NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4Request(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv4Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv4ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableRequest(r *http.Request, span trace.Span) (req NilIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv4NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv4NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv4NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6Request(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6Array:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv6Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6ArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv6ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableRequest(r *http.Request, span trace.Span) (req NilIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6NullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv6NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringIpv6NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringIpv6NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPassword:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPasswordArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringPasswordArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPasswordArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringPasswordArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPasswordNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPasswordNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringPasswordNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringPasswordNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringPasswordNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeTime(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTimeArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringTimeArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTimeArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableRequest(r *http.Request, span trace.Span) (req NilTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTimeNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringTimeNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIRequest(r *http.Request, span trace.Span) (req url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeURI(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURI:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURIArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringURIArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURIArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringURIArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableRequest(r *http.Request, span trace.Span) (req NilURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURINullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURINullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringURINullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringURINullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringURINullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDRequest(r *http.Request, span trace.Span) (req uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUUID(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUID:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUIDArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringUUIDArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUIDArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringUUIDArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableRequest(r *http.Request, span trace.Span) (req NilUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUIDNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUIDNullableArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringUUIDNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestRequiredStringUUIDNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestRequiredStringUUIDNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestString:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinary:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinaryArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinaryArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringBinaryArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinaryNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinaryNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringBinaryNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringBinaryNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByte:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableRequest(r *http.Request, span trace.Span) (req OptNilByte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilByte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateRequest(r *http.Request, span trace.Span) (req OptDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDate:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableRequest(r *http.Request, span trace.Span) (req OptNilDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeRequest(r *http.Request, span trace.Span) (req OptDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req OptNilDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationRequest(r *http.Request, span trace.Span) (req OptDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDuration:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableRequest(r *http.Request, span trace.Span) (req OptNilDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmail:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmail request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmailArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmailArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmailArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmailArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmailNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmailNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmailNullableArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmailNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringEmailNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringEmailNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostname:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostname request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostnameArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostnameArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostnameArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostnameArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostnameNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostnameNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostnameNullableArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostnameNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringHostnameNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringHostnameNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIP:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableRequest(r *http.Request, span trace.Span) (req OptNilIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32Request(r *http.Request, span trace.Span) (req OptStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64Request(r *http.Request, span trace.Span) (req OptStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4Request(r *http.Request, span trace.Span) (req OptIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableRequest(r *http.Request, span trace.Span) (req OptNilIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6Request(r *http.Request, span trace.Span) (req OptIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6ArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableRequest(r *http.Request, span trace.Span) (req OptNilIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6NullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPassword:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableRequest(r *http.Request, span trace.Span) (req OptNilTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIRequest(r *http.Request, span trace.Span) (req OptURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURI:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURIArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURIArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURIArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableRequest(r *http.Request, span trace.Span) (req OptNilURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURINullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDRequest(r *http.Request, span trace.Span) (req OptUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUID:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableRequest(r *http.Request, span trace.Span) (req OptNilUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullableArrayArray:application/json request")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseAnyRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseAny:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBoolean:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseEmptyStructRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseEmptyStruct:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseFormatTestRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseFormatTest:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseInteger:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNull:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNullArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNullArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNullNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNullNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNullNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumber:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDouble:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloat:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseString:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinary:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinaryArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinaryArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinaryNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinaryNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringBinaryNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByte:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDate:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDuration:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmail:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmailArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmailArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmailNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmailNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringEmailNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostname:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostnameArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostnameArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostnameNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostnameNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringHostnameNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIP:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt32NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringInt64NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPassword:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURI:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURIArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURIArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUID:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}
