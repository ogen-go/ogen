// Code generated by ogen, DO NOT EDIT.

package api

import (
	"mime"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func (s *Server) decodeUserPassloginPostRequest(r *http.Request) (
	req OptUserPassloginPostReq,
	rawBody []byte,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = errors.Join(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = errors.Join(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, rawBody, close, nil
	}
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, rawBody, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, rawBody, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, rawBody, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request OptUserPassloginPostReq
		{
			var optForm UserPassloginPostReq
			q := uri.NewQueryDecoder(form)
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "passcode",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						optForm.Passcode = c
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"passcode\"")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			request = OptUserPassloginPostReq{
				Value: optForm,
				Set:   true,
			}
		}
		return request, rawBody, close, nil
	default:
		return req, rawBody, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeUserPostingPostRequest(r *http.Request) (
	req OptUserPostingPostReq,
	rawBody []byte,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = errors.Join(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = errors.Join(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, rawBody, close, nil
	}
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, rawBody, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, rawBody, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, rawBody, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request OptUserPostingPostReq
		{
			var optForm UserPostingPostReq
			q := uri.NewQueryDecoder(form)
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "captcha_type",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						optForm.CaptchaType = CaptchaType(c)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"captcha_type\"")
					}
					if err := func() error {
						if err := optForm.CaptchaType.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return req, rawBody, close, errors.Wrap(err, "validate")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "board",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						optForm.Board = c
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"board\"")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "thread",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotThreadVal int
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToInt(val)
							if err != nil {
								return err
							}

							optFormDotThreadVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Thread.SetTo(optFormDotThreadVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"thread\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "name",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotNameVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							optFormDotNameVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Name.SetTo(optFormDotNameVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"name\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "email",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotEmailVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							optFormDotEmailVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Email.SetTo(optFormDotEmailVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"email\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "tags",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotTagsVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							optFormDotTagsVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Tags.SetTo(optFormDotTagsVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"tags\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "subject",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotSubjectVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							optFormDotSubjectVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Subject.SetTo(optFormDotSubjectVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"subject\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "comment",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotCommentVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							optFormDotCommentVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Comment.SetTo(optFormDotCommentVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"comment\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "icon",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotIconVal int
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToInt(val)
							if err != nil {
								return err
							}

							optFormDotIconVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.Icon.SetTo(optFormDotIconVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"icon\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "op_mark",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						var optFormDotOpMarkVal int
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToInt(val)
							if err != nil {
								return err
							}

							optFormDotOpMarkVal = c
							return nil
						}(); err != nil {
							return err
						}
						optForm.OpMark.SetTo(optFormDotOpMarkVal)
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"op_mark\"")
					}
				}
			}
			{
				if err := func() error {
					files, ok := r.MultipartForm.File["file[]"]
					_ = ok
					optForm.File = make([]ht.MultipartFile, 0, len(files))
					for _, fh := range files {
						f, err := fh.Open()
						if err != nil {
							return errors.Wrap(err, "open")
						}
						closers = append(closers, f.Close)

						optForm.File = append(optForm.File, ht.MultipartFile{
							Name:   fh.Filename,
							File:   f,
							Size:   fh.Size,
							Header: fh.Header,
						})
					}
					return nil
				}(); err != nil {
					return req, rawBody, close, errors.Wrap(err, "decode \"file[]\"")
				}
			}
			request = OptUserPostingPostReq{
				Value: optForm,
				Set:   true,
			}
		}
		return request, rawBody, close, nil
	default:
		return req, rawBody, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeUserReportPostRequest(r *http.Request) (
	req OptUserReportPostReq,
	rawBody []byte,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = errors.Join(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = errors.Join(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, rawBody, close, nil
	}
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, rawBody, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, rawBody, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, rawBody, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request OptUserReportPostReq
		{
			var optForm UserReportPostReq
			q := uri.NewQueryDecoder(form)
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "board",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						optForm.Board = c
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"board\"")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "thread",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToInt(val)
						if err != nil {
							return err
						}

						optForm.Thread = c
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"thread\"")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "post",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						return d.DecodeArray(func(d uri.Decoder) error {
							var optFormDotPostVal int
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToInt(val)
								if err != nil {
									return err
								}

								optFormDotPostVal = c
								return nil
							}(); err != nil {
								return err
							}
							optForm.Post = append(optForm.Post, optFormDotPostVal)
							return nil
						})
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"post\"")
					}
				}
			}
			{
				cfg := uri.QueryParameterDecodingConfig{
					Name:    "comment",
					Style:   uri.QueryStyleForm,
					Explode: true,
				}
				if err := q.HasParam(cfg); err == nil {
					if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						optForm.Comment = c
						return nil
					}); err != nil {
						return req, rawBody, close, errors.Wrap(err, "decode \"comment\"")
					}
				} else {
					return req, rawBody, close, errors.Wrap(err, "query")
				}
			}
			request = OptUserReportPostReq{
				Value: optForm,
				Set:   true,
			}
		}
		return request, rawBody, close, nil
	default:
		return req, rawBody, close, validate.InvalidContentType(ct)
	}
}
