// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [5]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				switch r.Method {
				case "GET":
					s.handleMetaRootRequest([0]string{}, elemIsEscaped, w, r)
				default:
					s.notAllowed(w, r, "GET")
				}

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"

				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"

					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleAppsGetAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '-': // Prefix: "-manifests/"

						if l := len("-manifests/"); len(elem) >= l && elem[0:l] == "-manifests/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "code"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/conversions"

							if l := len("/conversions"); len(elem) >= l && elem[0:l] == "/conversions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAppsCreateFromManifestRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/"

							if l := len("hook/"); len(elem) >= l && elem[0:l] == "hook/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "config"

								if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsGetWebhookConfigForAppRequest([0]string{}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleAppsUpdateWebhookConfigForAppRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}

							case 'd': // Prefix: "deliveries"

								if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleAppsListWebhookDeliveriesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleAppsGetWebhookDeliveryRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"

										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAppsRedeliverWebhookDeliveryRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						case 'i': // Prefix: "installations/"

							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleAppsDeleteInstallationRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "access_tokens"

									if l := len("access_tokens"); len(elem) >= l && elem[0:l] == "access_tokens" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleAppsCreateInstallationAccessTokenRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 's': // Prefix: "suspended"

									if l := len("suspended"); len(elem) >= l && elem[0:l] == "suspended" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleAppsUnsuspendInstallationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleAppsSuspendInstallationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,PUT")
										}

										return
									}

								}

							}

						}

					case 'l': // Prefix: "lications/"

						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants"
							origElem := elem
							if l := len("grants"); len(elem) >= l && elem[0:l] == "grants" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOAuthAuthorizationsListGrantsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "grant_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleOAuthAuthorizationsDeleteGrantRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleOAuthAuthorizationsGetGrantRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"

								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleAppsDeleteAuthorizationRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

							case 't': // Prefix: "token"

								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleAppsDeleteTokenRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleAppsResetTokenRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleAppsCheckTokenRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PATCH,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/scoped"

									if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleAppsScopeTokenRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAppsGetBySlugRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 'u': // Prefix: "uthorizations"

					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleOAuthAuthorizationsListAuthorizationsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleOAuthAuthorizationsCreateAuthorizationRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "clients/"
							origElem := elem
							if l := len("clients/"); len(elem) >= l && elem[0:l] == "clients/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "client_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "PUT":
									s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "fingerprint"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "authorization_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleOAuthAuthorizationsDeleteAuthorizationRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleOAuthAuthorizationsGetAuthorizationRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PATCH":
								s.handleOAuthAuthorizationsUpdateAuthorizationRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}

					}

				}

			case 'c': // Prefix: "codes_of_conduct"

				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleCodesOfConductGetAllCodesOfConductRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleCodesOfConductGetConductCodeRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'e': // Prefix: "e"

				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"

					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleEmojisGetRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'n': // Prefix: "nterprises/"

					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"

							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"

								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"

									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"

											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "org_id"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}

											}

										case 's': // Prefix: "selected-actions"

											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}

										}

									}

								case 'r': // Prefix: "runner"

									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"

										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PATCH":
													s.handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"

													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "org_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}

													}

												case 'r': // Prefix: "runners"

													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}

													}

												}

											}

										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												origElem := elem
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											case 'r': // Prefix: "re"
												origElem := elem
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"

													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest([1]string{
																args[0],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 'm': // Prefix: "move-token"

													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest([1]string{
																args[0],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

												elem = origElem
											}
											// Param: "runner_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}

										}

									}

								}

							case 'u': // Prefix: "udit-log"

								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminGetAuditLogRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 's': // Prefix: "settings/billing/"

							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"

								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetGithubActionsBillingGheRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'p': // Prefix: "packages"

								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetGithubPackagesBillingGheRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 's': // Prefix: "shared-storage"

								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleBillingGetSharedStorageBillingGheRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					}

				case 'v': // Prefix: "vents"

					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleActivityListPublicEventsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'f': // Prefix: "feeds"

				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleActivityGetFeedsRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 'g': // Prefix: "gi"

				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "sts"

					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGistsListRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleGistsCreateRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							origElem := elem
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsListPublicRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "starred"
							origElem := elem
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsListStarredRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleGistsDeleteRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGistsGetRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								origElem := elem
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"

									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGistsListCommentsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleGistsCreateCommentRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleGistsDeleteCommentRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleGistsGetCommentRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleGistsUpdateCommentRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PATCH")
											}

											return
										}

									}

								case 'i': // Prefix: "its"

									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGistsListCommitsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

								elem = origElem
							case 'f': // Prefix: "forks"
								origElem := elem
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGistsListForksRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleGistsForkRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "star"
								origElem := elem
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleGistsUnstarRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGistsCheckIsStarredRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleGistsStarRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

								elem = origElem
							}
							// Param: "sha"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGistsGetRevisionRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 't': // Prefix: "tignore/templates"

					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGitignoreGetAllTemplatesRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGitignoreGetTemplateRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				}

			case 'i': // Prefix: "i"

				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/"

					if l := len("nstallation/"); len(elem) >= l && elem[0:l] == "nstallation/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "repositories"

						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAppsListReposAccessibleToInstallationRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 't': // Prefix: "token"

						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleAppsRevokeInstallationAccessTokenRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}

					}

				case 's': // Prefix: "ssues"

					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleIssuesListRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'l': // Prefix: "licenses"

				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleLicensesGetAllCommonlyUsedRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleLicensesGetRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'm': // Prefix: "m"

				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ark"

					if l := len("ark"); len(elem) >= l && elem[0:l] == "ark" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "down"

						if l := len("down"); len(elem) >= l && elem[0:l] == "down" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "POST":
								s.handleMarkdownRenderRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/raw"

							if l := len("/raw"); len(elem) >= l && elem[0:l] == "/raw" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleMarkdownRenderRawRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					case 'e': // Prefix: "etplace_listing/"

						if l := len("etplace_listing/"); len(elem) >= l && elem[0:l] == "etplace_listing/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"

							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAppsGetSubscriptionPlanForAccountRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'p': // Prefix: "plans"

							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleAppsListPlansRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"

									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAppsListAccountsForPlanRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 's': // Prefix: "stubbed/"

							if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "accounts/"

								if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "account_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsGetSubscriptionPlanForAccountStubbedRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'p': // Prefix: "plans"

								if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleAppsListPlansStubbedRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "plan_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/accounts"

										if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleAppsListAccountsForPlanStubbedRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						}

					}

				case 'e': // Prefix: "eta"

					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleMetaGetRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'n': // Prefix: "n"

				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"

					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"

							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleActivityListPublicEventsForRepoNetworkRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'o': // Prefix: "otifications"

					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleActivityListNotificationsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
						case "PUT":
							s.handleActivityMarkNotificationsAsReadRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,PUT")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"

						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleActivityGetThreadRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PATCH":
								s.handleActivityMarkThreadAsReadRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"

							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleActivityDeleteThreadSubscriptionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleActivityGetThreadSubscriptionForAuthenticatedUserRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleActivitySetThreadSubscriptionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						}

					}

				}

			case 'o': // Prefix: "o"

				if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "ctocat"

					if l := len("ctocat"); len(elem) >= l && elem[0:l] == "ctocat" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleMetaGetOctocatRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'r': // Prefix: "rg"

					if l := len("rg"); len(elem) >= l && elem[0:l] == "rg" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "anizations"

						if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleOrgsListRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleOrgsGetRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "a"

								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"

									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"

										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsGetGithubActionsPermissionsOrganizationRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleActionsSetGithubActionsPermissionsOrganizationRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "repositories"

												if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PUT")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repository_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[1] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,PUT")
														}

														return
													}

												}

											case 's': // Prefix: "selected-actions"

												if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsGetAllowedActionsOrganizationRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleActionsSetAllowedActionsOrganizationRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PUT")
													}

													return
												}

											}

										}

									case 'r': // Prefix: "runner"

										if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '-': // Prefix: "-groups"

											if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleActionsListSelfHostedRunnerGroupsForOrgRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_group_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleActionsGetSelfHostedRunnerGroupForOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handleActionsUpdateSelfHostedRunnerGroupForOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/r"

													if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "epositories"

														if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,PUT")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "repository_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "PUT":
																	s.handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,PUT")
																}

																return
															}

														}

													case 'u': // Prefix: "unners"

														if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleActionsListSelfHostedRunnersInGroupForOrgRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleActionsSetSelfHostedRunnersInGroupForOrgRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,PUT")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "runner_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "PUT":
																	s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,PUT")
																}

																return
															}

														}

													}

												}

											}

										case 's': // Prefix: "s"

											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleActionsListSelfHostedRunnersForOrgRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "downloads"
													origElem := elem
													if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleActionsListRunnerApplicationsForOrgRequest([1]string{
																args[0],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

													elem = origElem
												case 'r': // Prefix: "re"
													origElem := elem
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'g': // Prefix: "gistration-token"

														if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleActionsCreateRegistrationTokenForOrgRequest([1]string{
																	args[0],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}

													case 'm': // Prefix: "move-token"

														if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleActionsCreateRemoveTokenForOrgRequest([1]string{
																	args[0],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}

													}

													elem = origElem
												}
												// Param: "runner_id"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleActionsDeleteSelfHostedRunnerFromOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleActionsGetSelfHostedRunnerForOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}

											}

										}

									case 's': // Prefix: "secrets"

										if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsListOrgSecretsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												origElem := elem
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsGetOrgPublicKeyRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											}
											// Param: "secret_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleActionsDeleteOrgSecretRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleActionsGetOrgSecretRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleActionsCreateOrUpdateOrgSecretRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/repositories"

												if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListSelectedReposForOrgSecretRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleActionsSetSelectedReposForOrgSecretRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PUT")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repository_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleActionsRemoveSelectedRepoFromOrgSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleActionsAddSelectedRepoToOrgSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,PUT")
														}

														return
													}

												}

											}

										}

									}

								case 'u': // Prefix: "udit-log"

									if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleOrgsGetAuditLogRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'b': // Prefix: "blocks"

								if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListBlockedUsersRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsUnblockUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleOrgsCheckBlockedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleOrgsBlockUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}

								}

							case 'c': // Prefix: "credential-authorizations"

								if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListSamlSSOAuthorizationsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "credential_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsRemoveSamlSSOAuthorizationRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}

								}

							case 'e': // Prefix: "events"

								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleActivityListPublicOrgEventsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'f': // Prefix: "failed_invitations"

								if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsListFailedInvitationsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'h': // Prefix: "hooks"

								if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListWebhooksRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleOrgsCreateWebhookRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleOrgsDeleteWebhookRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleOrgsGetWebhookRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleOrgsUpdateWebhookRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "config"

											if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleOrgsGetWebhookConfigForOrgRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PATCH":
													s.handleOrgsUpdateWebhookConfigForOrgRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,PATCH")
												}

												return
											}

										case 'd': // Prefix: "deliveries"

											if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleOrgsListWebhookDeliveriesRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "delivery_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleOrgsGetWebhookDeliveryRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/attempts"

													if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleOrgsRedeliverWebhookDeliveryRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										case 'p': // Prefix: "pings"

											if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleOrgsPingWebhookRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								}

							case 'i': // Prefix: "i"

								if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "n"

									if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "teraction-limits"

										if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleInteractionsRemoveRestrictionsForOrgRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleInteractionsSetRestrictionsForOrgRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,PUT")
											}

											return
										}

									case 'v': // Prefix: "vitations"

										if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleOrgsListPendingInvitationsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleOrgsCreateInvitationRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleOrgsCancelInvitationRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/teams"

												if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleOrgsListInvitationTeamsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										}

									}

								case 's': // Prefix: "ssues"

									if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleIssuesListForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'm': // Prefix: "m"

								if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "embers"

									if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleOrgsListMembersRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleOrgsRemoveMemberRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleOrgsCheckMembershipForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET")
											}

											return
										}

									case 'h': // Prefix: "hips/"

										if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleOrgsRemoveMembershipForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleOrgsGetMembershipForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleOrgsSetMembershipForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}

									}

								case 'i': // Prefix: "igrations"

									if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleMigrationsListForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleMigrationsStartForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "migration_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleMigrationsGetStatusForOrgRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "archive"

												if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleMigrationsDeleteArchiveForOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleMigrationsDownloadArchiveForOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}

											case 'r': // Prefix: "repos"

												if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo_name"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/lock"

														if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleMigrationsUnlockRepoForOrgRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE")
															}

															return
														}

													}

												case 'i': // Prefix: "itories"

													if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleMigrationsListReposForOrgRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

										}

									}

								}

							case 'o': // Prefix: "outside_collaborators"

								if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleOrgsListOutsideCollaboratorsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleOrgsRemoveOutsideCollaboratorRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleOrgsConvertMemberToOutsideCollaboratorRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,PUT")
										}

										return
									}

								}

							case 'p': // Prefix: "p"

								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"

									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handlePackagesListPackagesForOrganizationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handlePackagesDeletePackageForOrgRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handlePackagesGetPackageForOrganizationRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"

													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handlePackagesRestorePackageForOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 'v': // Prefix: "versions"

													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handlePackagesDeletePackageVersionForOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handlePackagesGetPackageVersionForOrganizationRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"

															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handlePackagesRestorePackageVersionForOrgRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}

														}

													}

												}

											}

										}

									}

								case 'r': // Prefix: "rojects"

									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleProjectsListForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleProjectsCreateForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

								case 'u': // Prefix: "ublic_members"

									if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleOrgsListPublicMembersRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleOrgsRemovePublicMembershipForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleOrgsCheckPublicMembershipForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleOrgsSetPublicMembershipForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}

									}

								}

							case 'r': // Prefix: "repos"

								if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleReposListForOrgRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleReposCreateInOrgRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cret-scanning/alerts"

									if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSecretScanningListAlertsForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 't': // Prefix: "ttings/billing/"

									if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"

										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubActionsBillingOrgRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'p': // Prefix: "packages"

										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubPackagesBillingOrgRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 's': // Prefix: "shared-storage"

										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetSharedStorageBillingOrgRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							case 't': // Prefix: "team"

								if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-sync/groups"

									if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleTeamsListIdpGroupsForOrgRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleTeamsListRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleTeamsCreateRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "team_slug"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleTeamsDeleteInOrgRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleTeamsGetByNameRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleTeamsUpdateInOrgRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PATCH")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "discussions"

												if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleTeamsListDiscussionsInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "POST":
														s.handleTeamsCreateDiscussionInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "discussion_number"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleTeamsDeleteDiscussionInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleTeamsGetDiscussionInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleTeamsUpdateDiscussionInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PATCH")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "comments"

															if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleTeamsListDiscussionCommentsInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handleTeamsCreateDiscussionCommentInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_number"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch r.Method {
																	case "DELETE":
																		s.handleTeamsDeleteDiscussionCommentInOrgRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	case "GET":
																		s.handleTeamsGetDiscussionCommentInOrgRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	case "PATCH":
																		s.handleTeamsUpdateDiscussionCommentInOrgRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET,PATCH")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/reactions"

																	if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch r.Method {
																		case "GET":
																			s.handleReactionsListForTeamDiscussionCommentInOrgRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, elemIsEscaped, w, r)
																		case "POST":
																			s.handleReactionsCreateForTeamDiscussionCommentInOrgRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "GET,POST")
																		}

																		return
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"

																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		// Param: "reaction_id"
																		// Leaf parameter, slashes are prohibited
																		idx := strings.IndexByte(elem, '/')
																		if idx >= 0 {
																			break
																		}
																		args[4] = elem
																		elem = ""

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReactionsDeleteForTeamDiscussionCommentRequest([5]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																					args[4],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE")
																			}

																			return
																		}

																	}

																}

															}

														case 'r': // Prefix: "reactions"

															if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReactionsListForTeamDiscussionInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handleReactionsCreateForTeamDiscussionInOrgRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleReactionsDeleteForTeamDiscussionRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}

															}

														}

													}

												}

											case 'i': // Prefix: "invitations"

												if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleTeamsListPendingInvitationsInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											case 'm': // Prefix: "members"

												if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleTeamsListMembersInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case 'h': // Prefix: "hips/"

													if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleTeamsRemoveMembershipForUserInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleTeamsGetMembershipForUserInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleTeamsAddOrUpdateMembershipForUserInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}

												}

											case 'p': // Prefix: "projects"

												if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleTeamsListProjectsInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "project_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleTeamsRemoveProjectInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleTeamsCheckPermissionsForProjectInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}

												}

											case 'r': // Prefix: "repos"

												if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleTeamsListReposInOrgRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "owner"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "repo"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleTeamsRemoveRepoInOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handleTeamsCheckPermissionsForRepoInOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleTeamsAddOrUpdateRepoPermissionsInOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET,PUT")
															}

															return
														}

													}

												}

											case 't': // Prefix: "team"

												if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '-': // Prefix: "-sync/group-mappings"

													if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleTeamsListIdpGroupsInOrgRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,PATCH")
														}

														return
													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleTeamsListChildInOrgRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

										}

									}

								}

							}

						}

					}

				}

			case 'p': // Prefix: "projects/"

				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					origElem := elem
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						origElem := elem
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleProjectsDeleteCardRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleProjectsGetCardRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PATCH":
								s.handleProjectsUpdateCardRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"

							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsMoveCardRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

						elem = origElem
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleProjectsDeleteColumnRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleProjectsGetColumnRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PATCH":
							s.handleProjectsUpdateColumnRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PATCH")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "cards"

							if l := len("cards"); len(elem) >= l && elem[0:l] == "cards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleProjectsListCardsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'm': // Prefix: "moves"

							if l := len("moves"); len(elem) >= l && elem[0:l] == "moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsMoveColumnRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

					elem = origElem
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch r.Method {
					case "DELETE":
						s.handleProjectsDeleteRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "GET":
						s.handleProjectsGetRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "PATCH":
						s.handleProjectsUpdateRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "DELETE,GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/col"

					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"

						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleProjectsListCollaboratorsRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleProjectsRemoveCollaboratorRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleProjectsAddCollaboratorRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"

								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleProjectsGetPermissionForUserRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					case 'u': // Prefix: "umns"

						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleProjectsListColumnsRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleProjectsCreateColumnRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}

					}

				}

			case 'r': // Prefix: "r"

				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"

					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleRateLimitGetRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'e': // Prefix: "e"

					if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"

						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "reaction_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleReactionsDeleteLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}

					case 'p': // Prefix: "pos"

						if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleReposDeleteRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleReposGetRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleReposUpdateRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "a"

										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "ctions/"

											if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "artifacts"

												if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListArtifactsForRepoRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "artifact_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleActionsDeleteArtifactRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleActionsGetArtifactRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "archive_format"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleActionsDownloadArtifactRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											case 'j': // Prefix: "jobs/"

												if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "job_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsGetJobForWorkflowRunRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"

													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleActionsDownloadJobLogsForWorkflowRunRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 'p': // Prefix: "permissions"

												if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsGetGithubActionsPermissionsRepositoryRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleActionsSetGithubActionsPermissionsRepositoryRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PUT")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/selected-actions"

													if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleActionsGetAllowedActionsRepositoryRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleActionsSetAllowedActionsRepositoryRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,PUT")
														}

														return
													}

												}

											case 'r': // Prefix: "run"

												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'n': // Prefix: "ners"

													if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListSelfHostedRunnersForRepoRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'd': // Prefix: "downloads"
															origElem := elem
															if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleActionsListRunnerApplicationsForRepoRequest([2]string{
																		args[0],
																		args[1],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

															elem = origElem
														case 'r': // Prefix: "re"
															origElem := elem
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'g': // Prefix: "gistration-token"

																if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCreateRegistrationTokenForRepoRequest([2]string{
																			args[0],
																			args[1],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															case 'm': // Prefix: "move-token"

																if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCreateRemoveTokenForRepoRequest([2]string{
																			args[0],
																			args[1],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															}

															elem = origElem
														}
														// Param: "runner_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleActionsDeleteSelfHostedRunnerFromRepoRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handleActionsGetSelfHostedRunnerForRepoRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}

													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleActionsListWorkflowRunsForRepoRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "run_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handleActionsDeleteWorkflowRunRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handleActionsGetWorkflowRunRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'a': // Prefix: "a"

																if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pprov"

																	if l := len("pprov"); len(elem) >= l && elem[0:l] == "pprov" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "als"

																		if l := len("als"); len(elem) >= l && elem[0:l] == "als" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleActionsGetReviewsForRunRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}

																	case 'e': // Prefix: "e"

																		if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "POST":
																				s.handleActionsApproveWorkflowRunRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "POST")
																			}

																			return
																		}

																	}

																case 'r': // Prefix: "rtifacts"

																	if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleActionsListWorkflowRunArtifactsRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}

																}

															case 'c': // Prefix: "cancel"

																if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsCancelWorkflowRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															case 'j': // Prefix: "jobs"

																if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleActionsListJobsForWorkflowRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}

															case 'l': // Prefix: "logs"

																if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleActionsDeleteWorkflowRunLogsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	case "GET":
																		s.handleActionsDownloadWorkflowRunLogsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET")
																	}

																	return
																}

															case 'p': // Prefix: "pending_deployments"

																if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleActionsReviewPendingDeploymentsForRunRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															case 'r': // Prefix: "re"

																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'r': // Prefix: "run"

																	if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handleActionsReRunWorkflowRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}

																case 't': // Prefix: "try"

																	if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handleActionsRetryWorkflowRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}

																}

															case 't': // Prefix: "timing"

																if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleActionsGetWorkflowRunUsageRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}

															}

														}

													}

												}

											case 's': // Prefix: "secrets"

												if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleActionsListRepoSecretsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "public-key"
														origElem := elem
														if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleActionsGetRepoPublicKeyRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

														elem = origElem
													}
													// Param: "secret_name"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleActionsDeleteRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleActionsGetRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleActionsCreateOrUpdateRepoSecretRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}

												}

											case 'w': // Prefix: "workflows"

												if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsListRepoWorkflowsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 's': // Prefix: "ssignees"

											if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListAssigneesRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "assignee"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleIssuesCheckUserCanBeAssignedRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 'u': // Prefix: "uto"

											if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "links"

												if l := len("links"); len(elem) >= l && elem[0:l] == "links" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListAutolinksRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "POST":
														s.handleReposCreateAutolinkRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteAutolinkRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleReposGetAutolinkRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET")
														}

														return
													}

												}

											case 'm': // Prefix: "mated-security-fixes"

												if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleReposDisableAutomatedSecurityFixesRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleReposEnableAutomatedSecurityFixesRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}

											}

										}

									case 'b': // Prefix: "branches"

										if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListBranchesRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "branch"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposGetBranchRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'p': // Prefix: "protection"

													if l := len("protection"); len(elem) >= l && elem[0:l] == "protection" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleReposGetBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleReposUpdateBranchProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "enforce_admins"

															if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleReposDeleteAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "GET":
																	s.handleReposGetAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handleReposSetAdminBranchProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET,POST")
																}

																return
															}

														case 'r': // Prefix: "re"

															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'q': // Prefix: "quired_"

																if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pull_request_reviews"

																	if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "DELETE":
																			s.handleReposDeletePullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		case "GET":
																			s.handleReposGetPullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		case "PATCH":
																			s.handleReposUpdatePullRequestReviewProtectionRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "DELETE,GET,PATCH")
																		}

																		return
																	}

																case 's': // Prefix: "s"

																	if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'i': // Prefix: "ignatures"

																		if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposDeleteCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "GET":
																				s.handleReposGetCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "POST":
																				s.handleReposCreateCommitSignatureProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST")
																			}

																			return
																		}

																	case 't': // Prefix: "tatus_checks"

																		if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveStatusCheckProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "GET":
																				s.handleReposGetStatusChecksProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "PATCH":
																				s.handleReposUpdateStatusCheckProtectionRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,PATCH")
																			}

																			return
																		}
																		switch elem[0] {
																		case '/': // Prefix: "/contexts"

																			if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "DELETE":
																					s.handleReposRemoveStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				case "GET":
																					s.handleReposGetAllStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				case "POST":
																					s.handleReposAddStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				case "PUT":
																					s.handleReposSetStatusCheckContextsRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				default:
																					s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																				}

																				return
																			}

																		}

																	}

																}

															case 's': // Prefix: "strictions"

																if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "DELETE":
																		s.handleReposDeleteAccessRestrictionsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	case "GET":
																		s.handleReposGetAccessRestrictionsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "apps"

																		if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "GET":
																				s.handleReposGetAppsWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "POST":
																				s.handleReposAddAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "PUT":
																				s.handleReposSetAppAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}

																	case 't': // Prefix: "teams"

																		if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "GET":
																				s.handleReposGetTeamsWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "POST":
																				s.handleReposAddTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "PUT":
																				s.handleReposSetTeamAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}

																	case 'u': // Prefix: "users"

																		if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "DELETE":
																				s.handleReposRemoveUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "GET":
																				s.handleReposGetUsersWithAccessToProtectedBranchRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "POST":
																				s.handleReposAddUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "PUT":
																				s.handleReposSetUserAccessRestrictionsRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "DELETE,GET,POST,PUT")
																			}

																			return
																		}

																	}

																}

															}

														}

													}

												case 'r': // Prefix: "rename"

													if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposRenameBranchRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										}

									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "heck-"

											if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "runs/"

												if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "check_run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleChecksGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/annotations"

													if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleChecksListAnnotationsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 's': // Prefix: "suites"

												if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleChecksCreateSuiteRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "preferences"
														origElem := elem
														if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleChecksSetSuitesPreferencesRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}

														elem = origElem
													}
													// Param: "check_suite_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleChecksGetSuiteRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "check-runs"

															if l := len("check-runs"); len(elem) >= l && elem[0:l] == "check-runs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleChecksListForSuiteRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

														case 'r': // Prefix: "rerequest"

															if l := len("rerequest"); len(elem) >= l && elem[0:l] == "rerequest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleChecksRerequestSuiteRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}

														}

													}

												}

											}

										case 'o': // Prefix: "o"

											if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "de-scanning/"

												if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "a"

													if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'l': // Prefix: "lerts"

														if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleCodeScanningListAlertsForRepoRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "alert_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleCodeScanningGetAlertRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "PATCH":
																	s.handleCodeScanningUpdateAlertRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,PATCH")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/instances"

																if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "GET":
																		s.handleCodeScanningListAlertInstancesRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}

															}

														}

													case 'n': // Prefix: "nalyses"

														if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleCodeScanningListRecentAnalysesRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "analysis_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleCodeScanningDeleteAnalysisRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "GET":
																	s.handleCodeScanningGetAnalysisRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}

														}

													}

												case 's': // Prefix: "sarifs"

													if l := len("sarifs"); len(elem) >= l && elem[0:l] == "sarifs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleCodeScanningUploadSarifRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "sarif_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleCodeScanningGetSarifRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											case 'l': // Prefix: "llaborators"

												if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListCollaboratorsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleReposRemoveCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleReposCheckCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PUT":
															s.handleReposAddCollaboratorRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PUT")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/permission"

														if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCollaboratorPermissionLevelRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											case 'm': // Prefix: "m"

												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'm': // Prefix: "m"

													if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"

														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposListCommitCommentsForRepoRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "DELETE":
																	s.handleReposDeleteCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "GET":
																	s.handleReposGetCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "PATCH":
																	s.handleReposUpdateCommitCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET,PATCH")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"

																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "GET":
																		s.handleReactionsListForCommitCommentRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	case "POST":
																		s.handleReactionsCreateForCommitCommentRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "GET,POST")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter, slashes are prohibited
																	idx := strings.IndexByte(elem, '/')
																	if idx >= 0 {
																		break
																	}
																	args[3] = elem
																	elem = ""

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "DELETE":
																			s.handleReactionsDeleteForCommitCommentRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "DELETE")
																		}

																		return
																	}

																}

															}

														}

													case 'i': // Prefix: "its"

														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposListCommitsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "ref"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReposGetCommitRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'b': // Prefix: "branches-where-head"

																	if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleReposListBranchesForHeadCommitRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}

																case 'c': // Prefix: "c"

																	if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'h': // Prefix: "heck-"

																		if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			break
																		}
																		switch elem[0] {
																		case 'r': // Prefix: "runs"

																			if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "GET":
																					s.handleChecksListForRefRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				default:
																					s.notAllowed(w, r, "GET")
																				}

																				return
																			}

																		case 's': // Prefix: "suites"

																			if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch r.Method {
																				case "GET":
																					s.handleChecksListSuitesForRefRequest([3]string{
																						args[0],
																						args[1],
																						args[2],
																					}, elemIsEscaped, w, r)
																				default:
																					s.notAllowed(w, r, "GET")
																				}

																				return
																			}

																		}

																	case 'o': // Prefix: "omments"

																		if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleReposListCommentsForCommitRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			case "POST":
																				s.handleReposCreateCommitCommentRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "GET,POST")
																			}

																			return
																		}

																	}

																case 'p': // Prefix: "pulls"

																	if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "GET":
																			s.handleReposListPullRequestsAssociatedWithCommitRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}

																case 's': // Prefix: "status"

																	if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch r.Method {
																		case "GET":
																			s.handleReposGetCombinedStatusForRefRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "GET")
																		}

																		return
																	}
																	switch elem[0] {
																	case 'e': // Prefix: "es"

																		if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleReposListCommitStatusesForRefRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}

																	}

																}

															}

														}

													case 'u': // Prefix: "unity/profile"

														if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCommunityProfileMetricsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												case 'p': // Prefix: "pare/"

													if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "basehead"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposCompareCommitsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 'n': // Prefix: "nt"

												if l := len("nt"); len(elem) >= l && elem[0:l] == "nt" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "ent"

													if l := len("ent"); len(elem) >= l && elem[0:l] == "ent" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '_': // Prefix: "_references/"

														if l := len("_references/"); len(elem) >= l && elem[0:l] == "_references/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "content_reference_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/attachments"

															if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleAppsCreateContentAttachmentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}

														}

													case 's': // Prefix: "s/"

														if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "path"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleReposDeleteFileRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleReposCreateOrUpdateFileContentsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}

													}

												case 'r': // Prefix: "ributors"

													if l := len("ributors"); len(elem) >= l && elem[0:l] == "ributors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposListContributorsRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

										}

									case 'd': // Prefix: "d"

										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "eployments"

											if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposListDeploymentsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleReposCreateDeploymentRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "deployment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleReposDeleteDeploymentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleReposGetDeploymentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/statuses"

													if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListDeploymentStatusesRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "POST":
															s.handleReposCreateDeploymentStatusRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "status_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetDeploymentStatusRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											}

										case 'i': // Prefix: "ispatches"

											if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleReposCreateDispatchEventRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									case 'e': // Prefix: "e"

										if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'n': // Prefix: "nvironments/"

											if l := len("nvironments/"); len(elem) >= l && elem[0:l] == "nvironments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "environment_name"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteAnEnvironmentRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}

										case 'v': // Prefix: "vents"

											if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleActivityListRepoEventsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									case 'f': // Prefix: "forks"

										if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleReposListForksRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleReposCreateForkRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}

									case 'g': // Prefix: "g"

										if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "enerate"

											if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleReposCreateUsingTemplateRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										case 'i': // Prefix: "it/"

											if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "blobs"

												if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleGitCreateBlobRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "file_sha"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetBlobRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 'c': // Prefix: "commits"

												if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleGitCreateCommitRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "commit_sha"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetCommitRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 'm': // Prefix: "matching-refs/"

												if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGitListMatchingRefsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											case 'r': // Prefix: "ref"

												if l := len("ref"); len(elem) >= l && elem[0:l] == "ref" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ref"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleGitGetRefRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateRefRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleGitDeleteRefRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PATCH":
																s.handleGitUpdateRefRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PATCH")
															}

															return
														}

													}

												}

											case 't': // Prefix: "t"

												if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "ags"

													if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateTagRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tag_sha"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGitGetTagRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												case 'r': // Prefix: "rees"

													if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleGitCreateTreeRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tree_sha"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGitGetTreeRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											}

										}

									case 'h': // Prefix: "hooks"

										if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListWebhooksRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleReposCreateWebhookRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "hook_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleReposGetWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "PATCH":
													s.handleReposUpdateWebhookRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"

													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetWebhookConfigForRepoRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleReposUpdateWebhookConfigForRepoRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,PATCH")
														}

														return
													}

												case 'd': // Prefix: "deliveries"

													if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListWebhookDeliveriesRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "delivery_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReposGetWebhookDeliveryRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/attempts"

															if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handleReposRedeliverWebhookDeliveryRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}

														}

													}

												case 'p': // Prefix: "pings"

													if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposPingWebhookRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 't': // Prefix: "tests"

													if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleReposTestPushWebhookRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										}

									case 'i': // Prefix: "i"

										if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'm': // Prefix: "mport"

											if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleMigrationsCancelImportRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleMigrationsGetImportStatusRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PATCH":
													s.handleMigrationsUpdateImportRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleMigrationsStartImportRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "authors"

													if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleMigrationsGetCommitAuthorsRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "author_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleMigrationsMapCommitAuthorRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}

													}

												case 'l': // Prefix: "l"

													if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "arge_files"

														if l := len("arge_files"); len(elem) >= l && elem[0:l] == "arge_files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleMigrationsGetLargeFilesRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'f': // Prefix: "fs"

														if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PATCH":
																s.handleMigrationsSetLfsPreferenceRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "PATCH")
															}

															return
														}

													}

												}

											}

										case 'n': // Prefix: "n"

											if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "teraction-limits"

												if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleInteractionsRemoveRestrictionsForRepoRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleInteractionsSetRestrictionsForRepoRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,PUT")
													}

													return
												}

											case 'v': // Prefix: "vitations"

												if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleReposListInvitationsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "invitation_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteInvitationRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleReposUpdateInvitationRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,PATCH")
														}

														return
													}

												}

											}

										case 's': // Prefix: "ssues"

											if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleIssuesCreateRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													origElem := elem
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleIssuesListCommentsForRepoRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handleIssuesDeleteCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handleIssuesGetCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PATCH":
																s.handleIssuesUpdateCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET,PATCH")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"

															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReactionsListForIssueCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handleReactionsCreateForIssueCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleReactionsDeleteForIssueCommentRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}

															}

														}

													}

													elem = origElem
												case 'e': // Prefix: "events"
													origElem := elem
													if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleIssuesListEventsForRepoRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "event_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleIssuesGetEventRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

													elem = origElem
												}
												// Param: "issue_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleIssuesGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handleIssuesUpdateRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assignees"

														if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleIssuesRemoveAssigneesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "POST":
																s.handleIssuesAddAssigneesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,POST")
															}

															return
														}

													case 'c': // Prefix: "comments"

														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleIssuesListCommentsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "POST":
																s.handleIssuesCreateCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}

													case 'l': // Prefix: "l"

														if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "abels"

															if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "DELETE":
																	s.handleIssuesRemoveAllLabelsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "GET":
																	s.handleIssuesListLabelsOnIssueRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "name"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleIssuesRemoveLabelRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}

															}

														case 'o': // Prefix: "ock"

															if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleIssuesUnlockRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "PUT":
																	s.handleIssuesLockRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,PUT")
																}

																return
															}

														}

													case 'r': // Prefix: "reactions"

														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleReactionsListForIssueRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "POST":
																s.handleReactionsCreateForIssueRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handleReactionsDeleteForIssueRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE")
																}

																return
															}

														}

													}

												}

											}

										}

									case 'k': // Prefix: "keys"

										if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleReposListDeployKeysRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleReposCreateDeployKeyRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "key_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDeleteDeployKeyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleReposGetDeployKeyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}

										}

									case 'l': // Prefix: "l"

										if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"

											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bels"

												if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleIssuesListLabelsForRepoRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "POST":
														s.handleIssuesCreateLabelRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "name"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleIssuesDeleteLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleIssuesGetLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleIssuesUpdateLabelRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PATCH")
														}

														return
													}

												}

											case 'n': // Prefix: "nguages"

												if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposListLanguagesRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 'f': // Prefix: "fs"

											if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleReposDisableLfsForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleReposEnableLfsForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,PUT")
												}

												return
											}

										case 'i': // Prefix: "icense"

											if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleLicensesGetForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									case 'm': // Prefix: "m"

										if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "erge"

											if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-upstream"

												if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposMergeUpstreamRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											case 's': // Prefix: "s"

												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposMergeRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										case 'i': // Prefix: "ilestones"

											if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleIssuesListMilestonesRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleIssuesCreateMilestoneRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "milestone_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleIssuesDeleteMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleIssuesGetMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handleIssuesUpdateMilestoneRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/labels"

													if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleIssuesListLabelsForMilestoneRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

										}

									case 'n': // Prefix: "notifications"

										if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListRepoNotificationsForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleActivityMarkRepoNotificationsAsReadRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PUT")
											}

											return
										}

									case 'p': // Prefix: "p"

										if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ages"

											if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleReposDeletePagesSiteRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleReposGetPagesRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleReposCreatePagesSiteRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'b': // Prefix: "builds"

													if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handleReposListPagesBuildsRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "POST":
															s.handleReposRequestPagesBuildRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET,POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'l': // Prefix: "latest"
															origElem := elem
															if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleReposGetLatestPagesBuildRequest([2]string{
																		args[0],
																		args[1],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

															elem = origElem
														}
														// Param: "build_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetPagesBuildRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												case 'h': // Prefix: "health"

													if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetPagesHealthCheckRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

										case 'r': // Prefix: "rojects"

											if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleProjectsListForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleProjectsCreateForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}

										case 'u': // Prefix: "ulls"

											if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handlePullsListRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handlePullsCreateRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													origElem := elem
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handlePullsListReviewCommentsForRepoRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handlePullsDeleteReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handlePullsGetReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PATCH":
																s.handlePullsUpdateReviewCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET,PATCH")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"

															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleReactionsListForPullRequestReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handleReactionsCreateForPullRequestReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "DELETE":
																		s.handleReactionsDeleteForPullRequestCommentRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE")
																	}

																	return
																}

															}

														}

													}

													elem = origElem
												}
												// Param: "pull_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handlePullsGetRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handlePullsUpdateRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comm"

														if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "ents"

															if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handlePullsListReviewCommentsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handlePullsCreateReviewCommentRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/replies"

																	if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch r.Method {
																		case "POST":
																			s.handlePullsCreateReplyForReviewCommentRequest([4]string{
																				args[0],
																				args[1],
																				args[2],
																				args[3],
																			}, elemIsEscaped, w, r)
																		default:
																			s.notAllowed(w, r, "POST")
																		}

																		return
																	}

																}

															}

														case 'i': // Prefix: "its"

															if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handlePullsListCommitsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

														}

													case 'f': // Prefix: "files"

														if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handlePullsListFilesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'm': // Prefix: "merge"

														if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handlePullsCheckIfMergedRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handlePullsMergeRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,PUT")
															}

															return
														}

													case 'r': // Prefix: "re"

														if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'q': // Prefix: "quested_reviewers"

															if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "DELETE":
																	s.handlePullsRemoveRequestedReviewersRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "GET":
																	s.handlePullsListRequestedReviewersRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "DELETE,GET")
																}

																return
															}

														case 'v': // Prefix: "views"

															if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handlePullsListReviewsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																case "POST":
																	s.handlePullsCreateReviewRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET,POST")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "review_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch r.Method {
																	case "DELETE":
																		s.handlePullsDeletePendingReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	case "GET":
																		s.handlePullsGetReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	case "PUT":
																		s.handlePullsUpdateReviewRequest([4]string{
																			args[0],
																			args[1],
																			args[2],
																			args[3],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "DELETE,GET,PUT")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'c': // Prefix: "comments"

																		if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handlePullsListCommentsForReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}

																	case 'd': // Prefix: "dismissals"

																		if l := len("dismissals"); len(elem) >= l && elem[0:l] == "dismissals" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "PUT":
																				s.handlePullsDismissReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "PUT")
																			}

																			return
																		}

																	case 'e': // Prefix: "events"

																		if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "POST":
																				s.handlePullsSubmitReviewRequest([4]string{
																					args[0],
																					args[1],
																					args[2],
																					args[3],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "POST")
																			}

																			return
																		}

																	}

																}

															}

														}

													case 'u': // Prefix: "update-branch"

														if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "PUT":
																s.handlePullsUpdateBranchRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "PUT")
															}

															return
														}

													}

												}

											}

										}

									case 'r': // Prefix: "re"

										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "adme"

											if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposGetReadmeRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "dir"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposGetReadmeInDirectoryRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 'l': // Prefix: "leases"

											if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleReposListReleasesRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleReposCreateReleaseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "assets/"
													origElem := elem
													if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "asset_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleReposDeleteReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "GET":
															s.handleReposGetReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														case "PATCH":
															s.handleReposUpdateReleaseAssetRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,GET,PATCH")
														}

														return
													}

													elem = origElem
												case 'l': // Prefix: "latest"
													origElem := elem
													if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetLatestReleaseRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

													elem = origElem
												case 't': // Prefix: "tags/"
													origElem := elem
													if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tag"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetReleaseByTagRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

													elem = origElem
												}
												// Param: "release_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleReposDeleteReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleReposGetReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handleReposUpdateReleaseRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assets"

														if l := len("assets"); len(elem) >= l && elem[0:l] == "assets" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposListReleaseAssetsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "POST":
																s.handleReposUploadReleaseAssetRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET,POST")
															}

															return
														}

													case 'r': // Prefix: "reactions"

														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleReactionsCreateForReleaseRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}

													}

												}

											}

										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "ecret-scanning/alerts"

											if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleSecretScanningListAlertsForRepoRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "alert_number"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleSecretScanningGetAlertRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PATCH":
														s.handleSecretScanningUpdateAlertRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,PATCH")
													}

													return
												}

											}

										case 't': // Prefix: "tat"

											if l := len("tat"); len(elem) >= l && elem[0:l] == "tat" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 's': // Prefix: "s/"

												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "co"

													if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "de_frequency"

														if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCodeFrequencyStatsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'm': // Prefix: "mmit_activity"

														if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetCommitActivityStatsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'n': // Prefix: "ntributors"

														if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetContributorsStatsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												case 'p': // Prefix: "p"

													if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "articipation"

														if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetParticipationStatsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'u': // Prefix: "unch_card"

														if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetPunchCardStatsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											case 'u': // Prefix: "uses/"

												if l := len("uses/"); len(elem) >= l && elem[0:l] == "uses/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sha"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposCreateCommitStatusRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										case 'u': // Prefix: "ubscri"

											if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bers"

												if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActivityListWatchersForRepoRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											case 'p': // Prefix: "ption"

												if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleActivityDeleteRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleActivityGetRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleActivitySetRepoSubscriptionRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}

											}

										}

									case 't': // Prefix: "t"

										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"

											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'g': // Prefix: "gs"

												if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposListTagsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											case 'r': // Prefix: "rball/"

												if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleReposDownloadTarballArchiveRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 'e': // Prefix: "eams"

											if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReposListTeamsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'o': // Prefix: "opics"

											if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReposGetAllTopicsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleReposReplaceAllTopicsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}

										case 'r': // Prefix: "ra"

											if l := len("ra"); len(elem) >= l && elem[0:l] == "ra" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "ffic/"

												if l := len("ffic/"); len(elem) >= l && elem[0:l] == "ffic/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "clones"

													if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetClonesRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												case 'p': // Prefix: "popular/"

													if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "paths"

														if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetTopPathsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 'r': // Prefix: "referrers"

														if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleReposGetTopReferrersRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												case 'v': // Prefix: "views"

													if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleReposGetViewsRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											case 'n': // Prefix: "nsfer"

												if l := len("nsfer"); len(elem) >= l && elem[0:l] == "nsfer" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleReposTransferRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										}

									case 'v': // Prefix: "vulnerability-alerts"

										if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleReposDisableVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleReposCheckVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleReposEnableVulnerabilityAlertsRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}

									case 'z': // Prefix: "zipball/"

										if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleReposDownloadZipballArchiveRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						case 'i': // Prefix: "itories"

							if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleReposListPublicRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/environments/"

									if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/secrets"

										if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleActionsListEnvironmentSecretsRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												origElem := elem
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleActionsGetEnvironmentPublicKeyRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											}
											// Param: "secret_name"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleActionsDeleteEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleActionsGetEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleActionsCreateOrUpdateEnvironmentSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PUT")
												}

												return
											}

										}

									}

								}

							}

						}

					}

				}

			case 's': // Prefix: "s"

				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/"

					if l := len("cim/v2/"); len(elem) >= l && elem[0:l] == "cim/v2/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "enterprises/"

						if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "enterprise"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups"

								if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_group_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
										}

										return
									}

								}

							case 'U': // Prefix: "Users"

								if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_user_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH,PUT")
										}

										return
									}

								}

							}

						}

					case 'o': // Prefix: "organizations/"

						if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/Users/"

							if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleScimDeleteUserFromOrgRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}

						}

					}

				case 'e': // Prefix: "earch/"

					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"

						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "de"

							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleSearchCodeRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'm': // Prefix: "mmits"

							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleSearchCommitsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'i': // Prefix: "issues"

						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchIssuesAndPullRequestsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'l': // Prefix: "labels"

						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchLabelsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'r': // Prefix: "repositories"

						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchReposRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 't': // Prefix: "topics"

						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchTopicsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'u': // Prefix: "users"

						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleSearchUsersRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				}

			case 't': // Prefix: "teams/"

				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch r.Method {
					case "DELETE":
						s.handleTeamsDeleteLegacyRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "GET":
						s.handleTeamsGetLegacyRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "PATCH":
						s.handleTeamsUpdateLegacyRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "DELETE,GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"

						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListDiscussionsLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleTeamsCreateDiscussionLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleTeamsDeleteDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleTeamsGetDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handleTeamsUpdateDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"

									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleTeamsListDiscussionCommentsLegacyRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleTeamsCreateDiscussionCommentLegacyRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleTeamsDeleteDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleTeamsGetDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleTeamsUpdateDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PATCH")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"

											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleReactionsListForTeamDiscussionCommentLegacyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleReactionsCreateForTeamDiscussionCommentLegacyRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}

										}

									}

								case 'r': // Prefix: "reactions"

									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleReactionsListForTeamDiscussionLegacyRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleReactionsCreateForTeamDiscussionLegacyRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

								}

							}

						}

					case 'i': // Prefix: "invitations"

						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTeamsListPendingInvitationsLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'm': // Prefix: "members"

						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListMembersLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleTeamsGetMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleTeamsAddMemberLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						case 'h': // Prefix: "hips/"

							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleTeamsGetMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						}

					case 'p': // Prefix: "projects"

						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListProjectsLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleTeamsRemoveProjectLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleTeamsCheckPermissionsForProjectLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						}

					case 'r': // Prefix: "repos"

						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleTeamsListReposLegacyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleTeamsRemoveRepoLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleTeamsCheckPermissionsForRepoLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleTeamsAddOrUpdateRepoPermissionsLegacyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

							}

						}

					case 't': // Prefix: "team"

						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"

							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTeamsListIdpGroupsForLegacyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,PATCH")
								}

								return
							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTeamsListChildLegacyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				}

			case 'u': // Prefix: "user"

				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleUsersGetAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
					case "PATCH":
						s.handleUsersUpdateAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"

						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListBlockedByAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersUnblockRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleUsersCheckBlockedRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUsersBlockRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						}

					case 'e': // Prefix: "email"

						if l := len("email"); len(elem) >= l && elem[0:l] == "email" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/visibility"

							if l := len("/visibility"); len(elem) >= l && elem[0:l] == "/visibility" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "PATCH":
									s.handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "PATCH")
								}

								return
							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeleteEmailForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								case "GET":
									s.handleUsersListEmailsForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleUsersAddEmailForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,POST")
								}

								return
							}

						}

					case 'f': // Prefix: "follow"

						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"

							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleUsersListFollowersForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'i': // Prefix: "ing"

							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleUsersListFollowedByAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleUsersUnfollowRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleUsersCheckPersonIsFollowedByAuthenticatedRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUsersFollowRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

							}

						}

					case 'g': // Prefix: "gpg_keys"

						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListGpgKeysForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleUsersCreateGpgKeyForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeleteGpgKeyForAuthenticatedRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleUsersGetGpgKeyForAuthenticatedRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

						}

					case 'i': // Prefix: "i"

						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'n': // Prefix: "n"

							if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "stallations/"

								if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "installation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories"

									if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleAppsListInstallationReposForAuthenticatedUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleAppsRemoveRepoFromInstallationRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleAppsAddRepoToInstallationRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,PUT")
											}

											return
										}

									}

								}

							case 't': // Prefix: "teraction-limits"

								if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
									case "PUT":
										s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PUT")
									}

									return
								}

							}

						case 's': // Prefix: "ssues"

							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleIssuesListForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'k': // Prefix: "keys"

						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersListPublicSSHKeysForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleUsersCreatePublicSSHKeyForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleUsersDeletePublicSSHKeyForAuthenticatedRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleUsersGetPublicSSHKeyForAuthenticatedRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

						}

					case 'm': // Prefix: "m"

						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"

							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleAppsListSubscriptionsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"

								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 'e': // Prefix: "emberships/orgs"

							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleOrgsListMembershipsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsGetMembershipForAuthenticatedUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleOrgsUpdateMembershipForAuthenticatedUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}

							}

						case 'i': // Prefix: "igrations"

							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleMigrationsListForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleMigrationsStartForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleMigrationsGetStatusForAuthenticatedUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"

										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleMigrationsDeleteArchiveForAuthenticatedUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleMigrationsGetArchiveForAuthenticatedUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET")
											}

											return
										}

									case 'r': // Prefix: "repos"

										if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repo_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/lock"

												if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleMigrationsUnlockRepoForAuthenticatedUserRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE")
													}

													return
												}

											}

										case 'i': // Prefix: "itories"

											if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleMigrationsListReposForUserRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									}

								}

							}

						}

					case 'o': // Prefix: "orgs"

						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleOrgsListForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'p': // Prefix: "p"

						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"

							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handlePackagesListPackagesForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handlePackagesDeletePackageForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handlePackagesGetPackageForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "restore"

											if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePackagesRestorePackageForAuthenticatedUserRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										case 'v': // Prefix: "versions"

											if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handlePackagesDeletePackageVersionForAuthenticatedUserRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handlePackagesGetPackageVersionForAuthenticatedUserRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/restore"

													if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										}

									}

								}

							}

						case 'r': // Prefix: "rojects"

							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleProjectsCreateForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'u': // Prefix: "ublic_emails"

							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleUsersListPublicEmailsForAuthenticatedRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'r': // Prefix: "repos"

						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleReposListForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleReposCreateForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"

							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleReposListInvitationsForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleReposDeclineInvitationRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleReposAcceptInvitationRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PATCH")
									}

									return
								}

							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"

							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleActivityListReposStarredByAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleActivityUnstarRepoForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleActivityCheckRepoIsStarredByAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleActivityStarRepoForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}

								}

							}

						case 'u': // Prefix: "ubscriptions"

							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleActivityListWatchedReposForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 't': // Prefix: "teams"

						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTeamsListForAuthenticatedUserRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 's': // Prefix: "s"

					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleUsersListRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleUsersGetByUsernameRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "events"

								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleActivityListEventsForAuthenticatedUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"

										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListOrgEventsForAuthenticatedUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'p': // Prefix: "public"

										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListPublicEventsForUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							case 'f': // Prefix: "follow"

								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"

									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleUsersListFollowersForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'i': // Prefix: "ing"

									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleUsersListFollowingForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleUsersCheckFollowingForUserRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							case 'g': // Prefix: "g"

								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"

									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGistsListForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'p': // Prefix: "pg_keys"

									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleUsersListGpgKeysForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'h': // Prefix: "hovercard"

								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleUsersGetContextForUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'k': // Prefix: "keys"

								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleUsersListPublicKeysForUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'o': // Prefix: "orgs"

								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleOrgsListForUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'p': // Prefix: "p"

								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"

									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handlePackagesListPackagesForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handlePackagesDeletePackageForUserRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handlePackagesGetPackageForUserRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"

													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handlePackagesRestorePackageForUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 'v': // Prefix: "versions"

													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "GET":
															s.handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch r.Method {
															case "DELETE":
																s.handlePackagesDeletePackageVersionForUserRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															case "GET":
																s.handlePackagesGetPackageVersionForUserRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"

															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "POST":
																	s.handlePackagesRestorePackageVersionForUserRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "POST")
																}

																return
															}

														}

													}

												}

											}

										}

									}

								case 'r': // Prefix: "rojects"

									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleProjectsListForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'r': // Prefix: "re"

								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"

									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleActivityListReceivedEventsForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/public"

										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleActivityListReceivedPublicEventsForUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 'p': // Prefix: "pos"

									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleReposListForUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"

									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"

										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubActionsBillingUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'p': // Prefix: "packages"

										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetGithubPackagesBillingUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 's': // Prefix: "shared-storage"

										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleBillingGetSharedStorageBillingUserRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 'u': // Prefix: "ubscriptions"

									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleActivityListReposWatchedByUserRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					}

				}

			case 'z': // Prefix: "zen"

				if l := len("zen"); len(elem) >= l && elem[0:l] == "zen" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleMetaGetZenRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [5]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				switch method {
				case "GET":
					r.name = MetaRootOperation
					r.summary = "GitHub API Root"
					r.operationID = "meta/root"
					r.pathPattern = "/"
					r.args = args
					r.count = 0
					return r, true
				default:
					return
				}
			}
			switch elem[0] {
			case 'a': // Prefix: "a"

				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"

					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = AppsGetAuthenticatedOperation
							r.summary = "Get the authenticated app"
							r.operationID = "apps/get-authenticated"
							r.pathPattern = "/app"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '-': // Prefix: "-manifests/"

						if l := len("-manifests/"); len(elem) >= l && elem[0:l] == "-manifests/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "code"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/conversions"

							if l := len("/conversions"); len(elem) >= l && elem[0:l] == "/conversions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = AppsCreateFromManifestOperation
									r.summary = "Create a GitHub App from a manifest"
									r.operationID = "apps/create-from-manifest"
									r.pathPattern = "/app-manifests/{code}/conversions"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/"

							if l := len("hook/"); len(elem) >= l && elem[0:l] == "hook/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "config"

								if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = AppsGetWebhookConfigForAppOperation
										r.summary = "Get a webhook configuration for an app"
										r.operationID = "apps/get-webhook-config-for-app"
										r.pathPattern = "/app/hook/config"
										r.args = args
										r.count = 0
										return r, true
									case "PATCH":
										r.name = AppsUpdateWebhookConfigForAppOperation
										r.summary = "Update a webhook configuration for an app"
										r.operationID = "apps/update-webhook-config-for-app"
										r.pathPattern = "/app/hook/config"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'd': // Prefix: "deliveries"

								if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = AppsListWebhookDeliveriesOperation
										r.summary = "List deliveries for an app webhook"
										r.operationID = "apps/list-webhook-deliveries"
										r.pathPattern = "/app/hook/deliveries"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = AppsGetWebhookDeliveryOperation
											r.summary = "Get a delivery for an app webhook"
											r.operationID = "apps/get-webhook-delivery"
											r.pathPattern = "/app/hook/deliveries/{delivery_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"

										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AppsRedeliverWebhookDeliveryOperation
												r.summary = "Redeliver a delivery for an app webhook"
												r.operationID = "apps/redeliver-webhook-delivery"
												r.pathPattern = "/app/hook/deliveries/{delivery_id}/attempts"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 'i': // Prefix: "installations/"

							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = AppsDeleteInstallationOperation
									r.summary = "Delete an installation for the authenticated app"
									r.operationID = "apps/delete-installation"
									r.pathPattern = "/app/installations/{installation_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "access_tokens"

									if l := len("access_tokens"); len(elem) >= l && elem[0:l] == "access_tokens" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = AppsCreateInstallationAccessTokenOperation
											r.summary = "Create an installation access token for an app"
											r.operationID = "apps/create-installation-access-token"
											r.pathPattern = "/app/installations/{installation_id}/access_tokens"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "suspended"

									if l := len("suspended"); len(elem) >= l && elem[0:l] == "suspended" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = AppsUnsuspendInstallationOperation
											r.summary = "Unsuspend an app installation"
											r.operationID = "apps/unsuspend-installation"
											r.pathPattern = "/app/installations/{installation_id}/suspended"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = AppsSuspendInstallationOperation
											r.summary = "Suspend an app installation"
											r.operationID = "apps/suspend-installation"
											r.pathPattern = "/app/installations/{installation_id}/suspended"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'l': // Prefix: "lications/"

						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants"
							origElem := elem
							if l := len("grants"); len(elem) >= l && elem[0:l] == "grants" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = OAuthAuthorizationsListGrantsOperation
									r.summary = "List your grants"
									r.operationID = "oauth-authorizations/list-grants"
									r.pathPattern = "/applications/grants"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "grant_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = OAuthAuthorizationsDeleteGrantOperation
										r.summary = "Delete a grant"
										r.operationID = "oauth-authorizations/delete-grant"
										r.pathPattern = "/applications/grants/{grant_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = OAuthAuthorizationsGetGrantOperation
										r.summary = "Get a single grant"
										r.operationID = "oauth-authorizations/get-grant"
										r.pathPattern = "/applications/grants/{grant_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"

								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = AppsDeleteAuthorizationOperation
										r.summary = "Delete an app authorization"
										r.operationID = "apps/delete-authorization"
										r.pathPattern = "/applications/{client_id}/grant"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 't': // Prefix: "token"

								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = AppsDeleteTokenOperation
										r.summary = "Delete an app token"
										r.operationID = "apps/delete-token"
										r.pathPattern = "/applications/{client_id}/token"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = AppsResetTokenOperation
										r.summary = "Reset a token"
										r.operationID = "apps/reset-token"
										r.pathPattern = "/applications/{client_id}/token"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = AppsCheckTokenOperation
										r.summary = "Check a token"
										r.operationID = "apps/check-token"
										r.pathPattern = "/applications/{client_id}/token"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/scoped"

									if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = AppsScopeTokenOperation
											r.summary = "Create a scoped access token"
											r.operationID = "apps/scope-token"
											r.pathPattern = "/applications/{client_id}/token/scoped"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = AppsGetBySlugOperation
								r.summary = "Get an app"
								r.operationID = "apps/get-by-slug"
								r.pathPattern = "/apps/{app_slug}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				case 'u': // Prefix: "uthorizations"

					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = OAuthAuthorizationsListAuthorizationsOperation
							r.summary = "List your authorizations"
							r.operationID = "oauth-authorizations/list-authorizations"
							r.pathPattern = "/authorizations"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = OAuthAuthorizationsCreateAuthorizationOperation
							r.summary = "Create a new authorization"
							r.operationID = "oauth-authorizations/create-authorization"
							r.pathPattern = "/authorizations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "clients/"
							origElem := elem
							if l := len("clients/"); len(elem) >= l && elem[0:l] == "clients/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "client_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "PUT":
									r.name = OAuthAuthorizationsGetOrCreateAuthorizationForAppOperation
									r.summary = "Get-or-create an authorization for a specific app"
									r.operationID = "oauth-authorizations/get-or-create-authorization-for-app"
									r.pathPattern = "/authorizations/clients/{client_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "fingerprint"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "PUT":
										r.name = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintOperation
										r.summary = "Get-or-create an authorization for a specific app and fingerprint"
										r.operationID = "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"
										r.pathPattern = "/authorizations/clients/{client_id}/{fingerprint}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "authorization_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = OAuthAuthorizationsDeleteAuthorizationOperation
								r.summary = "Delete an authorization"
								r.operationID = "oauth-authorizations/delete-authorization"
								r.pathPattern = "/authorizations/{authorization_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = OAuthAuthorizationsGetAuthorizationOperation
								r.summary = "Get a single authorization"
								r.operationID = "oauth-authorizations/get-authorization"
								r.pathPattern = "/authorizations/{authorization_id}"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = OAuthAuthorizationsUpdateAuthorizationOperation
								r.summary = "Update an existing authorization"
								r.operationID = "oauth-authorizations/update-authorization"
								r.pathPattern = "/authorizations/{authorization_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'c': // Prefix: "codes_of_conduct"

				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = CodesOfConductGetAllCodesOfConductOperation
						r.summary = "Get all codes of conduct"
						r.operationID = "codes-of-conduct/get-all-codes-of-conduct"
						r.pathPattern = "/codes_of_conduct"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = CodesOfConductGetConductCodeOperation
							r.summary = "Get a code of conduct"
							r.operationID = "codes-of-conduct/get-conduct-code"
							r.pathPattern = "/codes_of_conduct/{key}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'e': // Prefix: "e"

				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"

					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = EmojisGetOperation
							r.summary = "Get emojis"
							r.operationID = "emojis/get"
							r.pathPattern = "/emojis"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'n': // Prefix: "nterprises/"

					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"

							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"

								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"

									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = EnterpriseAdminGetGithubActionsPermissionsEnterpriseOperation
											r.summary = "Get GitHub Actions permissions for an enterprise"
											r.operationID = "enterprise-admin/get-github-actions-permissions-enterprise"
											r.pathPattern = "/enterprises/{enterprise}/actions/permissions"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = EnterpriseAdminSetGithubActionsPermissionsEnterpriseOperation
											r.summary = "Set GitHub Actions permissions for an enterprise"
											r.operationID = "enterprise-admin/set-github-actions-permissions-enterprise"
											r.pathPattern = "/enterprises/{enterprise}/actions/permissions"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"

											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOperation
													r.summary = "List selected organizations enabled for GitHub Actions in an enterprise"
													r.operationID = "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/permissions/organizations"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													r.name = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseOperation
													r.summary = "Set selected organizations enabled for GitHub Actions in an enterprise"
													r.operationID = "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/permissions/organizations"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "org_id"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseOperation
														r.summary = "Disable a selected organization for GitHub Actions in an enterprise"
														r.operationID = "enterprise-admin/disable-selected-organization-github-actions-enterprise"
														r.pathPattern = "/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseOperation
														r.summary = "Enable a selected organization for GitHub Actions in an enterprise"
														r.operationID = "enterprise-admin/enable-selected-organization-github-actions-enterprise"
														r.pathPattern = "/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 's': // Prefix: "selected-actions"

											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = EnterpriseAdminGetAllowedActionsEnterpriseOperation
													r.summary = "Get allowed actions for an enterprise"
													r.operationID = "enterprise-admin/get-allowed-actions-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/permissions/selected-actions"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													r.name = EnterpriseAdminSetAllowedActionsEnterpriseOperation
													r.summary = "Set allowed actions for an enterprise"
													r.operationID = "enterprise-admin/set-allowed-actions-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/permissions/selected-actions"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								case 'r': // Prefix: "runner"

									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"

										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOperation
												r.summary = "List self-hosted runner groups for an enterprise"
												r.operationID = "enterprise-admin/list-self-hosted-runner-groups-for-enterprise"
												r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseOperation
												r.summary = "Create a self-hosted runner group for an enterprise"
												r.operationID = "enterprise-admin/create-self-hosted-runner-group-for-enterprise"
												r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseOperation
													r.summary = "Delete a self-hosted runner group from an enterprise"
													r.operationID = "enterprise-admin/delete-self-hosted-runner-group-from-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseOperation
													r.summary = "Get a self-hosted runner group for an enterprise"
													r.operationID = "enterprise-admin/get-self-hosted-runner-group-for-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseOperation
													r.summary = "Update a self-hosted runner group for an enterprise"
													r.operationID = "enterprise-admin/update-self-hosted-runner-group-for-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"

													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation
															r.summary = "List organization access to a self-hosted runner group in an enterprise"
															r.operationID = "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation
															r.summary = "Set organization access for a self-hosted runner group in an enterprise"
															r.operationID = "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "org_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation
																r.summary = "Remove organization access to a self-hosted runner group in an enterprise"
																r.operationID = "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"
																r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																r.name = EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation
																r.summary = "Add organization access to a self-hosted runner group in an enterprise"
																r.operationID = "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"
																r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'r': // Prefix: "runners"

													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOperation
															r.summary = "List self-hosted runners in a group for an enterprise"
															r.operationID = "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseOperation
															r.summary = "Set self-hosted runners in a group for an enterprise"
															r.operationID = "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "runner_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseOperation
																r.summary = "Remove a self-hosted runner from a group for an enterprise"
																r.operationID = "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"
																r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																r.name = EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseOperation
																r.summary = "Add a self-hosted runner to a group for an enterprise"
																r.operationID = "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"
																r.pathPattern = "/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = EnterpriseAdminListSelfHostedRunnersForEnterpriseOperation
												r.summary = "List self-hosted runners for an enterprise"
												r.operationID = "enterprise-admin/list-self-hosted-runners-for-enterprise"
												r.pathPattern = "/enterprises/{enterprise}/actions/runners"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												origElem := elem
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = EnterpriseAdminListRunnerApplicationsForEnterpriseOperation
														r.summary = "List runner applications for an enterprise"
														r.operationID = "enterprise-admin/list-runner-applications-for-enterprise"
														r.pathPattern = "/enterprises/{enterprise}/actions/runners/downloads"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											case 'r': // Prefix: "re"
												origElem := elem
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'g': // Prefix: "gistration-token"

													if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = EnterpriseAdminCreateRegistrationTokenForEnterpriseOperation
															r.summary = "Create a registration token for an enterprise"
															r.operationID = "enterprise-admin/create-registration-token-for-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runners/registration-token"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}

												case 'm': // Prefix: "move-token"

													if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = EnterpriseAdminCreateRemoveTokenForEnterpriseOperation
															r.summary = "Create a remove token for an enterprise"
															r.operationID = "enterprise-admin/create-remove-token-for-enterprise"
															r.pathPattern = "/enterprises/{enterprise}/actions/runners/remove-token"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}

												}

												elem = origElem
											}
											// Param: "runner_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseOperation
													r.summary = "Delete a self-hosted runner from an enterprise"
													r.operationID = "enterprise-admin/delete-self-hosted-runner-from-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/runners/{runner_id}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = EnterpriseAdminGetSelfHostedRunnerForEnterpriseOperation
													r.summary = "Get a self-hosted runner for an enterprise"
													r.operationID = "enterprise-admin/get-self-hosted-runner-for-enterprise"
													r.pathPattern = "/enterprises/{enterprise}/actions/runners/{runner_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							case 'u': // Prefix: "udit-log"

								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = EnterpriseAdminGetAuditLogOperation
										r.summary = "Get the audit log for an enterprise"
										r.operationID = "enterprise-admin/get-audit-log"
										r.pathPattern = "/enterprises/{enterprise}/audit-log"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 's': // Prefix: "settings/billing/"

							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"

								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = BillingGetGithubActionsBillingGheOperation
										r.summary = "Get GitHub Actions billing for an enterprise"
										r.operationID = "billing/get-github-actions-billing-ghe"
										r.pathPattern = "/enterprises/{enterprise}/settings/billing/actions"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "packages"

								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = BillingGetGithubPackagesBillingGheOperation
										r.summary = "Get GitHub Packages billing for an enterprise"
										r.operationID = "billing/get-github-packages-billing-ghe"
										r.pathPattern = "/enterprises/{enterprise}/settings/billing/packages"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "shared-storage"

								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = BillingGetSharedStorageBillingGheOperation
										r.summary = "Get shared storage billing for an enterprise"
										r.operationID = "billing/get-shared-storage-billing-ghe"
										r.pathPattern = "/enterprises/{enterprise}/settings/billing/shared-storage"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'v': // Prefix: "vents"

					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = ActivityListPublicEventsOperation
							r.summary = "List public events"
							r.operationID = "activity/list-public-events"
							r.pathPattern = "/events"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'f': // Prefix: "feeds"

				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = ActivityGetFeedsOperation
						r.summary = "Get feeds"
						r.operationID = "activity/get-feeds"
						r.pathPattern = "/feeds"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 'g': // Prefix: "gi"

				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 's': // Prefix: "sts"

					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GistsListOperation
							r.summary = "List gists for the authenticated user"
							r.operationID = "gists/list"
							r.pathPattern = "/gists"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = GistsCreateOperation
							r.summary = "Create a gist"
							r.operationID = "gists/create"
							r.pathPattern = "/gists"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							origElem := elem
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GistsListPublicOperation
									r.summary = "List public gists"
									r.operationID = "gists/list-public"
									r.pathPattern = "/gists/public"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "starred"
							origElem := elem
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GistsListStarredOperation
									r.summary = "List starred gists"
									r.operationID = "gists/list-starred"
									r.pathPattern = "/gists/starred"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = GistsDeleteOperation
								r.summary = "Delete a gist"
								r.operationID = "gists/delete"
								r.pathPattern = "/gists/{gist_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GistsGetOperation
								r.summary = "Get a gist"
								r.operationID = "gists/get"
								r.pathPattern = "/gists/{gist_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								origElem := elem
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"

									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GistsListCommentsOperation
											r.summary = "List gist comments"
											r.operationID = "gists/list-comments"
											r.pathPattern = "/gists/{gist_id}/comments"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = GistsCreateCommentOperation
											r.summary = "Create a gist comment"
											r.operationID = "gists/create-comment"
											r.pathPattern = "/gists/{gist_id}/comments"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = GistsDeleteCommentOperation
												r.summary = "Delete a gist comment"
												r.operationID = "gists/delete-comment"
												r.pathPattern = "/gists/{gist_id}/comments/{comment_id}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = GistsGetCommentOperation
												r.summary = "Get a gist comment"
												r.operationID = "gists/get-comment"
												r.pathPattern = "/gists/{gist_id}/comments/{comment_id}"
												r.args = args
												r.count = 2
												return r, true
											case "PATCH":
												r.name = GistsUpdateCommentOperation
												r.summary = "Update a gist comment"
												r.operationID = "gists/update-comment"
												r.pathPattern = "/gists/{gist_id}/comments/{comment_id}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								case 'i': // Prefix: "its"

									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GistsListCommitsOperation
											r.summary = "List gist commits"
											r.operationID = "gists/list-commits"
											r.pathPattern = "/gists/{gist_id}/commits"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							case 'f': // Prefix: "forks"
								origElem := elem
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GistsListForksOperation
										r.summary = "List gist forks"
										r.operationID = "gists/list-forks"
										r.pathPattern = "/gists/{gist_id}/forks"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = GistsForkOperation
										r.summary = "Fork a gist"
										r.operationID = "gists/fork"
										r.pathPattern = "/gists/{gist_id}/forks"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "star"
								origElem := elem
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = GistsUnstarOperation
										r.summary = "Unstar a gist"
										r.operationID = "gists/unstar"
										r.pathPattern = "/gists/{gist_id}/star"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GistsCheckIsStarredOperation
										r.summary = "Check if a gist is starred"
										r.operationID = "gists/check-is-starred"
										r.pathPattern = "/gists/{gist_id}/star"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = GistsStarOperation
										r.summary = "Star a gist"
										r.operationID = "gists/star"
										r.pathPattern = "/gists/{gist_id}/star"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "sha"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GistsGetRevisionOperation
									r.summary = "Get a gist revision"
									r.operationID = "gists/get-revision"
									r.pathPattern = "/gists/{gist_id}/{sha}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					}

				case 't': // Prefix: "tignore/templates"

					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GitignoreGetAllTemplatesOperation
							r.summary = "Get all gitignore templates"
							r.operationID = "gitignore/get-all-templates"
							r.pathPattern = "/gitignore/templates"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = GitignoreGetTemplateOperation
								r.summary = "Get a gitignore template"
								r.operationID = "gitignore/get-template"
								r.pathPattern = "/gitignore/templates/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'i': // Prefix: "i"

				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/"

					if l := len("nstallation/"); len(elem) >= l && elem[0:l] == "nstallation/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'r': // Prefix: "repositories"

						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = AppsListReposAccessibleToInstallationOperation
								r.summary = "List repositories accessible to the app installation"
								r.operationID = "apps/list-repos-accessible-to-installation"
								r.pathPattern = "/installation/repositories"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "token"

						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = AppsRevokeInstallationAccessTokenOperation
								r.summary = "Revoke an installation access token"
								r.operationID = "apps/revoke-installation-access-token"
								r.pathPattern = "/installation/token"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 's': // Prefix: "ssues"

					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = IssuesListOperation
							r.summary = "List issues assigned to the authenticated user"
							r.operationID = "issues/list"
							r.pathPattern = "/issues"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'l': // Prefix: "licenses"

				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = LicensesGetAllCommonlyUsedOperation
						r.summary = "Get all commonly used licenses"
						r.operationID = "licenses/get-all-commonly-used"
						r.pathPattern = "/licenses"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = LicensesGetOperation
							r.summary = "Get a license"
							r.operationID = "licenses/get"
							r.pathPattern = "/licenses/{license}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'm': // Prefix: "m"

				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ark"

					if l := len("ark"); len(elem) >= l && elem[0:l] == "ark" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "down"

						if l := len("down"); len(elem) >= l && elem[0:l] == "down" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								r.name = MarkdownRenderOperation
								r.summary = "Render a Markdown document"
								r.operationID = "markdown/render"
								r.pathPattern = "/markdown"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/raw"

							if l := len("/raw"); len(elem) >= l && elem[0:l] == "/raw" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = MarkdownRenderRawOperation
									r.summary = "Render a Markdown document in raw mode"
									r.operationID = "markdown/render-raw"
									r.pathPattern = "/markdown/raw"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'e': // Prefix: "etplace_listing/"

						if l := len("etplace_listing/"); len(elem) >= l && elem[0:l] == "etplace_listing/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"

							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = AppsGetSubscriptionPlanForAccountOperation
									r.summary = "Get a subscription plan for an account"
									r.operationID = "apps/get-subscription-plan-for-account"
									r.pathPattern = "/marketplace_listing/accounts/{account_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 'p': // Prefix: "plans"

							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = AppsListPlansOperation
									r.summary = "List plans"
									r.operationID = "apps/list-plans"
									r.pathPattern = "/marketplace_listing/plans"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"

									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AppsListAccountsForPlanOperation
											r.summary = "List accounts for a plan"
											r.operationID = "apps/list-accounts-for-plan"
											r.pathPattern = "/marketplace_listing/plans/{plan_id}/accounts"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 's': // Prefix: "stubbed/"

							if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "accounts/"

								if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "account_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = AppsGetSubscriptionPlanForAccountStubbedOperation
										r.summary = "Get a subscription plan for an account (stubbed)"
										r.operationID = "apps/get-subscription-plan-for-account-stubbed"
										r.pathPattern = "/marketplace_listing/stubbed/accounts/{account_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "plans"

								if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = AppsListPlansStubbedOperation
										r.summary = "List plans (stubbed)"
										r.operationID = "apps/list-plans-stubbed"
										r.pathPattern = "/marketplace_listing/stubbed/plans"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "plan_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/accounts"

										if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = AppsListAccountsForPlanStubbedOperation
												r.summary = "List accounts for a plan (stubbed)"
												r.operationID = "apps/list-accounts-for-plan-stubbed"
												r.pathPattern = "/marketplace_listing/stubbed/plans/{plan_id}/accounts"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					}

				case 'e': // Prefix: "eta"

					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = MetaGetOperation
							r.summary = "Get GitHub meta information"
							r.operationID = "meta/get"
							r.pathPattern = "/meta"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'n': // Prefix: "n"

				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"

					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"

							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ActivityListPublicEventsForRepoNetworkOperation
									r.summary = "List public events for a network of repositories"
									r.operationID = "activity/list-public-events-for-repo-network"
									r.pathPattern = "/networks/{owner}/{repo}/events"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'o': // Prefix: "otifications"

					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ActivityListNotificationsForAuthenticatedUserOperation
							r.summary = "List notifications for the authenticated user"
							r.operationID = "activity/list-notifications-for-authenticated-user"
							r.pathPattern = "/notifications"
							r.args = args
							r.count = 0
							return r, true
						case "PUT":
							r.name = ActivityMarkNotificationsAsReadOperation
							r.summary = "Mark notifications as read"
							r.operationID = "activity/mark-notifications-as-read"
							r.pathPattern = "/notifications"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"

						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ActivityGetThreadOperation
								r.summary = "Get a thread"
								r.operationID = "activity/get-thread"
								r.pathPattern = "/notifications/threads/{thread_id}"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = ActivityMarkThreadAsReadOperation
								r.summary = "Mark a thread as read"
								r.operationID = "activity/mark-thread-as-read"
								r.pathPattern = "/notifications/threads/{thread_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"

							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = ActivityDeleteThreadSubscriptionOperation
									r.summary = "Delete a thread subscription"
									r.operationID = "activity/delete-thread-subscription"
									r.pathPattern = "/notifications/threads/{thread_id}/subscription"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = ActivityGetThreadSubscriptionForAuthenticatedUserOperation
									r.summary = "Get a thread subscription for the authenticated user"
									r.operationID = "activity/get-thread-subscription-for-authenticated-user"
									r.pathPattern = "/notifications/threads/{thread_id}/subscription"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = ActivitySetThreadSubscriptionOperation
									r.summary = "Set a thread subscription"
									r.operationID = "activity/set-thread-subscription"
									r.pathPattern = "/notifications/threads/{thread_id}/subscription"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'o': // Prefix: "o"

				if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "ctocat"

					if l := len("ctocat"); len(elem) >= l && elem[0:l] == "ctocat" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = MetaGetOctocatOperation
							r.summary = "Get Octocat"
							r.operationID = "meta/get-octocat"
							r.pathPattern = "/octocat"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'r': // Prefix: "rg"

					if l := len("rg"); len(elem) >= l && elem[0:l] == "rg" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "anizations"

						if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = OrgsListOperation
								r.summary = "List organizations"
								r.operationID = "orgs/list"
								r.pathPattern = "/organizations"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 's': // Prefix: "s/"

						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = OrgsGetOperation
								r.summary = "Get an organization"
								r.operationID = "orgs/get"
								r.pathPattern = "/orgs/{org}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "a"

								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"

									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"

										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ActionsGetGithubActionsPermissionsOrganizationOperation
												r.summary = "Get GitHub Actions permissions for an organization"
												r.operationID = "actions/get-github-actions-permissions-organization"
												r.pathPattern = "/orgs/{org}/actions/permissions"
												r.args = args
												r.count = 1
												return r, true
											case "PUT":
												r.name = ActionsSetGithubActionsPermissionsOrganizationOperation
												r.summary = "Set GitHub Actions permissions for an organization"
												r.operationID = "actions/set-github-actions-permissions-organization"
												r.pathPattern = "/orgs/{org}/actions/permissions"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "repositories"

												if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOperation
														r.summary = "List selected repositories enabled for GitHub Actions in an organization"
														r.operationID = "actions/list-selected-repositories-enabled-github-actions-organization"
														r.pathPattern = "/orgs/{org}/actions/permissions/repositories"
														r.args = args
														r.count = 1
														return r, true
													case "PUT":
														r.name = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOperation
														r.summary = "Set selected repositories enabled for GitHub Actions in an organization"
														r.operationID = "actions/set-selected-repositories-enabled-github-actions-organization"
														r.pathPattern = "/orgs/{org}/actions/permissions/repositories"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repository_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[1] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ActionsDisableSelectedRepositoryGithubActionsOrganizationOperation
															r.summary = "Disable a selected repository for GitHub Actions in an organization"
															r.operationID = "actions/disable-selected-repository-github-actions-organization"
															r.pathPattern = "/orgs/{org}/actions/permissions/repositories/{repository_id}"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = ActionsEnableSelectedRepositoryGithubActionsOrganizationOperation
															r.summary = "Enable a selected repository for GitHub Actions in an organization"
															r.operationID = "actions/enable-selected-repository-github-actions-organization"
															r.pathPattern = "/orgs/{org}/actions/permissions/repositories/{repository_id}"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											case 's': // Prefix: "selected-actions"

												if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ActionsGetAllowedActionsOrganizationOperation
														r.summary = "Get allowed actions for an organization"
														r.operationID = "actions/get-allowed-actions-organization"
														r.pathPattern = "/orgs/{org}/actions/permissions/selected-actions"
														r.args = args
														r.count = 1
														return r, true
													case "PUT":
														r.name = ActionsSetAllowedActionsOrganizationOperation
														r.summary = "Set allowed actions for an organization"
														r.operationID = "actions/set-allowed-actions-organization"
														r.pathPattern = "/orgs/{org}/actions/permissions/selected-actions"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

										}

									case 'r': // Prefix: "runner"

										if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '-': // Prefix: "-groups"

											if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ActionsListSelfHostedRunnerGroupsForOrgOperation
													r.summary = "List self-hosted runner groups for an organization"
													r.operationID = "actions/list-self-hosted-runner-groups-for-org"
													r.pathPattern = "/orgs/{org}/actions/runner-groups"
													r.args = args
													r.count = 1
													return r, true
												case "POST":
													r.name = ActionsCreateSelfHostedRunnerGroupForOrgOperation
													r.summary = "Create a self-hosted runner group for an organization"
													r.operationID = "actions/create-self-hosted-runner-group-for-org"
													r.pathPattern = "/orgs/{org}/actions/runner-groups"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_group_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = ActionsDeleteSelfHostedRunnerGroupFromOrgOperation
														r.summary = "Delete a self-hosted runner group from an organization"
														r.operationID = "actions/delete-self-hosted-runner-group-from-org"
														r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														r.name = ActionsGetSelfHostedRunnerGroupForOrgOperation
														r.summary = "Get a self-hosted runner group for an organization"
														r.operationID = "actions/get-self-hosted-runner-group-for-org"
														r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}"
														r.args = args
														r.count = 2
														return r, true
													case "PATCH":
														r.name = ActionsUpdateSelfHostedRunnerGroupForOrgOperation
														r.summary = "Update a self-hosted runner group for an organization"
														r.operationID = "actions/update-self-hosted-runner-group-for-org"
														r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/r"

													if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "epositories"

														if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOperation
																r.summary = "List repository access to a self-hosted runner group in an organization"
																r.operationID = "actions/list-repo-access-to-self-hosted-runner-group-in-org"
																r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
																r.args = args
																r.count = 2
																return r, true
															case "PUT":
																r.name = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgOperation
																r.summary = "Set repository access for a self-hosted runner group in an organization"
																r.operationID = "actions/set-repo-access-to-self-hosted-runner-group-in-org"
																r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "repository_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgOperation
																	r.summary = "Remove repository access to a self-hosted runner group in an organization"
																	r.operationID = "actions/remove-repo-access-to-self-hosted-runner-group-in-org"
																	r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PUT":
																	r.name = ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgOperation
																	r.summary = "Add repository access to a self-hosted runner group in an organization"
																	r.operationID = "actions/add-repo-access-to-self-hosted-runner-group-in-org"
																	r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													case 'u': // Prefix: "unners"

														if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ActionsListSelfHostedRunnersInGroupForOrgOperation
																r.summary = "List self-hosted runners in a group for an organization"
																r.operationID = "actions/list-self-hosted-runners-in-group-for-org"
																r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
																r.args = args
																r.count = 2
																return r, true
															case "PUT":
																r.name = ActionsSetSelfHostedRunnersInGroupForOrgOperation
																r.summary = "Set self-hosted runners in a group for an organization"
																r.operationID = "actions/set-self-hosted-runners-in-group-for-org"
																r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "runner_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = ActionsRemoveSelfHostedRunnerFromGroupForOrgOperation
																	r.summary = "Remove a self-hosted runner from a group for an organization"
																	r.operationID = "actions/remove-self-hosted-runner-from-group-for-org"
																	r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PUT":
																	r.name = ActionsAddSelfHostedRunnerToGroupForOrgOperation
																	r.summary = "Add a self-hosted runner to a group for an organization"
																	r.operationID = "actions/add-self-hosted-runner-to-group-for-org"
																	r.pathPattern = "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											}

										case 's': // Prefix: "s"

											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ActionsListSelfHostedRunnersForOrgOperation
													r.summary = "List self-hosted runners for an organization"
													r.operationID = "actions/list-self-hosted-runners-for-org"
													r.pathPattern = "/orgs/{org}/actions/runners"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "downloads"
													origElem := elem
													if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ActionsListRunnerApplicationsForOrgOperation
															r.summary = "List runner applications for an organization"
															r.operationID = "actions/list-runner-applications-for-org"
															r.pathPattern = "/orgs/{org}/actions/runners/downloads"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}

													elem = origElem
												case 'r': // Prefix: "re"
													origElem := elem
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'g': // Prefix: "gistration-token"

														if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "POST":
																r.name = ActionsCreateRegistrationTokenForOrgOperation
																r.summary = "Create a registration token for an organization"
																r.operationID = "actions/create-registration-token-for-org"
																r.pathPattern = "/orgs/{org}/actions/runners/registration-token"
																r.args = args
																r.count = 1
																return r, true
															default:
																return
															}
														}

													case 'm': // Prefix: "move-token"

														if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "POST":
																r.name = ActionsCreateRemoveTokenForOrgOperation
																r.summary = "Create a remove token for an organization"
																r.operationID = "actions/create-remove-token-for-org"
																r.pathPattern = "/orgs/{org}/actions/runners/remove-token"
																r.args = args
																r.count = 1
																return r, true
															default:
																return
															}
														}

													}

													elem = origElem
												}
												// Param: "runner_id"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = ActionsDeleteSelfHostedRunnerFromOrgOperation
														r.summary = "Delete a self-hosted runner from an organization"
														r.operationID = "actions/delete-self-hosted-runner-from-org"
														r.pathPattern = "/orgs/{org}/actions/runners/{runner_id}"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														r.name = ActionsGetSelfHostedRunnerForOrgOperation
														r.summary = "Get a self-hosted runner for an organization"
														r.operationID = "actions/get-self-hosted-runner-for-org"
														r.pathPattern = "/orgs/{org}/actions/runners/{runner_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									case 's': // Prefix: "secrets"

										if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ActionsListOrgSecretsOperation
												r.summary = "List organization secrets"
												r.operationID = "actions/list-org-secrets"
												r.pathPattern = "/orgs/{org}/actions/secrets"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												origElem := elem
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ActionsGetOrgPublicKeyOperation
														r.summary = "Get an organization public key"
														r.operationID = "actions/get-org-public-key"
														r.pathPattern = "/orgs/{org}/actions/secrets/public-key"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}
											// Param: "secret_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = ActionsDeleteOrgSecretOperation
													r.summary = "Delete an organization secret"
													r.operationID = "actions/delete-org-secret"
													r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = ActionsGetOrgSecretOperation
													r.summary = "Get an organization secret"
													r.operationID = "actions/get-org-secret"
													r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = ActionsCreateOrUpdateOrgSecretOperation
													r.summary = "Create or update an organization secret"
													r.operationID = "actions/create-or-update-org-secret"
													r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/repositories"

												if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsListSelectedReposForOrgSecretOperation
														r.summary = "List selected repositories for an organization secret"
														r.operationID = "actions/list-selected-repos-for-org-secret"
														r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}/repositories"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = ActionsSetSelectedReposForOrgSecretOperation
														r.summary = "Set selected repositories for an organization secret"
														r.operationID = "actions/set-selected-repos-for-org-secret"
														r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}/repositories"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repository_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ActionsRemoveSelectedRepoFromOrgSecretOperation
															r.summary = "Remove selected repository from an organization secret"
															r.operationID = "actions/remove-selected-repo-from-org-secret"
															r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = ActionsAddSelectedRepoToOrgSecretOperation
															r.summary = "Add selected repository to an organization secret"
															r.operationID = "actions/add-selected-repo-to-org-secret"
															r.pathPattern = "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									}

								case 'u': // Prefix: "udit-log"

									if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = OrgsGetAuditLogOperation
											r.summary = "Get the audit log for an organization"
											r.operationID = "orgs/get-audit-log"
											r.pathPattern = "/orgs/{org}/audit-log"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'b': // Prefix: "blocks"

								if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = OrgsListBlockedUsersOperation
										r.summary = "List users blocked by an organization"
										r.operationID = "orgs/list-blocked-users"
										r.pathPattern = "/orgs/{org}/blocks"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = OrgsUnblockUserOperation
											r.summary = "Unblock a user from an organization"
											r.operationID = "orgs/unblock-user"
											r.pathPattern = "/orgs/{org}/blocks/{username}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = OrgsCheckBlockedUserOperation
											r.summary = "Check if a user is blocked by an organization"
											r.operationID = "orgs/check-blocked-user"
											r.pathPattern = "/orgs/{org}/blocks/{username}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = OrgsBlockUserOperation
											r.summary = "Block a user from an organization"
											r.operationID = "orgs/block-user"
											r.pathPattern = "/orgs/{org}/blocks/{username}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							case 'c': // Prefix: "credential-authorizations"

								if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = OrgsListSamlSSOAuthorizationsOperation
										r.summary = "List SAML SSO authorizations for an organization"
										r.operationID = "orgs/list-saml-sso-authorizations"
										r.pathPattern = "/orgs/{org}/credential-authorizations"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "credential_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = OrgsRemoveSamlSSOAuthorizationOperation
											r.summary = "Remove a SAML SSO authorization for an organization"
											r.operationID = "orgs/remove-saml-sso-authorization"
											r.pathPattern = "/orgs/{org}/credential-authorizations/{credential_id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							case 'e': // Prefix: "events"

								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ActivityListPublicOrgEventsOperation
										r.summary = "List public organization events"
										r.operationID = "activity/list-public-org-events"
										r.pathPattern = "/orgs/{org}/events"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'f': // Prefix: "failed_invitations"

								if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = OrgsListFailedInvitationsOperation
										r.summary = "List failed organization invitations"
										r.operationID = "orgs/list-failed-invitations"
										r.pathPattern = "/orgs/{org}/failed_invitations"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'h': // Prefix: "hooks"

								if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = OrgsListWebhooksOperation
										r.summary = "List organization webhooks"
										r.operationID = "orgs/list-webhooks"
										r.pathPattern = "/orgs/{org}/hooks"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = OrgsCreateWebhookOperation
										r.summary = "Create an organization webhook"
										r.operationID = "orgs/create-webhook"
										r.pathPattern = "/orgs/{org}/hooks"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = OrgsDeleteWebhookOperation
											r.summary = "Delete an organization webhook"
											r.operationID = "orgs/delete-webhook"
											r.pathPattern = "/orgs/{org}/hooks/{hook_id}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = OrgsGetWebhookOperation
											r.summary = "Get an organization webhook"
											r.operationID = "orgs/get-webhook"
											r.pathPattern = "/orgs/{org}/hooks/{hook_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											r.name = OrgsUpdateWebhookOperation
											r.summary = "Update an organization webhook"
											r.operationID = "orgs/update-webhook"
											r.pathPattern = "/orgs/{org}/hooks/{hook_id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "config"

											if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = OrgsGetWebhookConfigForOrgOperation
													r.summary = "Get a webhook configuration for an organization"
													r.operationID = "orgs/get-webhook-config-for-org"
													r.pathPattern = "/orgs/{org}/hooks/{hook_id}/config"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = OrgsUpdateWebhookConfigForOrgOperation
													r.summary = "Update a webhook configuration for an organization"
													r.operationID = "orgs/update-webhook-config-for-org"
													r.pathPattern = "/orgs/{org}/hooks/{hook_id}/config"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'd': // Prefix: "deliveries"

											if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = OrgsListWebhookDeliveriesOperation
													r.summary = "List deliveries for an organization webhook"
													r.operationID = "orgs/list-webhook-deliveries"
													r.pathPattern = "/orgs/{org}/hooks/{hook_id}/deliveries"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "delivery_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = OrgsGetWebhookDeliveryOperation
														r.summary = "Get a webhook delivery for an organization webhook"
														r.operationID = "orgs/get-webhook-delivery"
														r.pathPattern = "/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/attempts"

													if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = OrgsRedeliverWebhookDeliveryOperation
															r.summary = "Redeliver a delivery for an organization webhook"
															r.operationID = "orgs/redeliver-webhook-delivery"
															r.pathPattern = "/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										case 'p': // Prefix: "pings"

											if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = OrgsPingWebhookOperation
													r.summary = "Ping an organization webhook"
													r.operationID = "orgs/ping-webhook"
													r.pathPattern = "/orgs/{org}/hooks/{hook_id}/pings"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							case 'i': // Prefix: "i"

								if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "n"

									if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 't': // Prefix: "teraction-limits"

										if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = InteractionsRemoveRestrictionsForOrgOperation
												r.summary = "Remove interaction restrictions for an organization"
												r.operationID = "interactions/remove-restrictions-for-org"
												r.pathPattern = "/orgs/{org}/interaction-limits"
												r.args = args
												r.count = 1
												return r, true
											case "PUT":
												r.name = InteractionsSetRestrictionsForOrgOperation
												r.summary = "Set interaction restrictions for an organization"
												r.operationID = "interactions/set-restrictions-for-org"
												r.pathPattern = "/orgs/{org}/interaction-limits"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'v': // Prefix: "vitations"

										if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = OrgsListPendingInvitationsOperation
												r.summary = "List pending organization invitations"
												r.operationID = "orgs/list-pending-invitations"
												r.pathPattern = "/orgs/{org}/invitations"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = OrgsCreateInvitationOperation
												r.summary = "Create an organization invitation"
												r.operationID = "orgs/create-invitation"
												r.pathPattern = "/orgs/{org}/invitations"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = OrgsCancelInvitationOperation
													r.summary = "Cancel an organization invitation"
													r.operationID = "orgs/cancel-invitation"
													r.pathPattern = "/orgs/{org}/invitations/{invitation_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/teams"

												if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = OrgsListInvitationTeamsOperation
														r.summary = "List organization invitation teams"
														r.operationID = "orgs/list-invitation-teams"
														r.pathPattern = "/orgs/{org}/invitations/{invitation_id}/teams"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									}

								case 's': // Prefix: "ssues"

									if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = IssuesListForOrgOperation
											r.summary = "List organization issues assigned to the authenticated user"
											r.operationID = "issues/list-for-org"
											r.pathPattern = "/orgs/{org}/issues"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'm': // Prefix: "m"

								if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "embers"

									if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = OrgsListMembersOperation
											r.summary = "List organization members"
											r.operationID = "orgs/list-members"
											r.pathPattern = "/orgs/{org}/members"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = OrgsRemoveMemberOperation
												r.summary = "Remove an organization member"
												r.operationID = "orgs/remove-member"
												r.pathPattern = "/orgs/{org}/members/{username}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = OrgsCheckMembershipForUserOperation
												r.summary = "Check organization membership for a user"
												r.operationID = "orgs/check-membership-for-user"
												r.pathPattern = "/orgs/{org}/members/{username}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									case 'h': // Prefix: "hips/"

										if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = OrgsRemoveMembershipForUserOperation
												r.summary = "Remove organization membership for a user"
												r.operationID = "orgs/remove-membership-for-user"
												r.pathPattern = "/orgs/{org}/memberships/{username}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = OrgsGetMembershipForUserOperation
												r.summary = "Get organization membership for a user"
												r.operationID = "orgs/get-membership-for-user"
												r.pathPattern = "/orgs/{org}/memberships/{username}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = OrgsSetMembershipForUserOperation
												r.summary = "Set organization membership for a user"
												r.operationID = "orgs/set-membership-for-user"
												r.pathPattern = "/orgs/{org}/memberships/{username}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								case 'i': // Prefix: "igrations"

									if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = MigrationsListForOrgOperation
											r.summary = "List organization migrations"
											r.operationID = "migrations/list-for-org"
											r.pathPattern = "/orgs/{org}/migrations"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = MigrationsStartForOrgOperation
											r.summary = "Start an organization migration"
											r.operationID = "migrations/start-for-org"
											r.pathPattern = "/orgs/{org}/migrations"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "migration_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = MigrationsGetStatusForOrgOperation
												r.summary = "Get an organization migration status"
												r.operationID = "migrations/get-status-for-org"
												r.pathPattern = "/orgs/{org}/migrations/{migration_id}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "archive"

												if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = MigrationsDeleteArchiveForOrgOperation
														r.summary = "Delete an organization migration archive"
														r.operationID = "migrations/delete-archive-for-org"
														r.pathPattern = "/orgs/{org}/migrations/{migration_id}/archive"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														r.name = MigrationsDownloadArchiveForOrgOperation
														r.summary = "Download an organization migration archive"
														r.operationID = "migrations/download-archive-for-org"
														r.pathPattern = "/orgs/{org}/migrations/{migration_id}/archive"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 'r': // Prefix: "repos"

												if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo_name"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/lock"

														if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = MigrationsUnlockRepoForOrgOperation
																r.summary = "Unlock an organization repository"
																r.operationID = "migrations/unlock-repo-for-org"
																r.pathPattern = "/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'i': // Prefix: "itories"

													if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = MigrationsListReposForOrgOperation
															r.summary = "List repositories in an organization migration"
															r.operationID = "migrations/list-repos-for-org"
															r.pathPattern = "/orgs/{org}/migrations/{migration_id}/repositories"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									}

								}

							case 'o': // Prefix: "outside_collaborators"

								if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = OrgsListOutsideCollaboratorsOperation
										r.summary = "List outside collaborators for an organization"
										r.operationID = "orgs/list-outside-collaborators"
										r.pathPattern = "/orgs/{org}/outside_collaborators"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = OrgsRemoveOutsideCollaboratorOperation
											r.summary = "Remove outside collaborator from an organization"
											r.operationID = "orgs/remove-outside-collaborator"
											r.pathPattern = "/orgs/{org}/outside_collaborators/{username}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = OrgsConvertMemberToOutsideCollaboratorOperation
											r.summary = "Convert an organization member to outside collaborator"
											r.operationID = "orgs/convert-member-to-outside-collaborator"
											r.pathPattern = "/orgs/{org}/outside_collaborators/{username}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							case 'p': // Prefix: "p"

								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"

									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = PackagesListPackagesForOrganizationOperation
											r.summary = "List packages for an organization"
											r.operationID = "packages/list-packages-for-organization"
											r.pathPattern = "/orgs/{org}/packages"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = PackagesDeletePackageForOrgOperation
													r.summary = "Delete a package for an organization"
													r.operationID = "packages/delete-package-for-org"
													r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = PackagesGetPackageForOrganizationOperation
													r.summary = "Get a package for an organization"
													r.operationID = "packages/get-package-for-organization"
													r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"

													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = PackagesRestorePackageForOrgOperation
															r.summary = "Restore a package for an organization"
															r.operationID = "packages/restore-package-for-org"
															r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}/restore"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												case 'v': // Prefix: "versions"

													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = PackagesGetAllPackageVersionsForPackageOwnedByOrgOperation
															r.summary = "Get all package versions for a package owned by an organization"
															r.operationID = "packages/get-all-package-versions-for-package-owned-by-org"
															r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}/versions"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = PackagesDeletePackageVersionForOrgOperation
																r.summary = "Delete package version for an organization"
																r.operationID = "packages/delete-package-version-for-org"
																r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
																r.args = args
																r.count = 4
																return r, true
															case "GET":
																r.name = PackagesGetPackageVersionForOrganizationOperation
																r.summary = "Get a package version for an organization"
																r.operationID = "packages/get-package-version-for-organization"
																r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"

															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "POST":
																	r.name = PackagesRestorePackageVersionForOrgOperation
																	r.summary = "Restore package version for an organization"
																	r.operationID = "packages/restore-package-version-for-org"
																	r.pathPattern = "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											}

										}

									}

								case 'r': // Prefix: "rojects"

									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ProjectsListForOrgOperation
											r.summary = "List organization projects"
											r.operationID = "projects/list-for-org"
											r.pathPattern = "/orgs/{org}/projects"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = ProjectsCreateForOrgOperation
											r.summary = "Create an organization project"
											r.operationID = "projects/create-for-org"
											r.pathPattern = "/orgs/{org}/projects"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'u': // Prefix: "ublic_members"

									if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = OrgsListPublicMembersOperation
											r.summary = "List public organization members"
											r.operationID = "orgs/list-public-members"
											r.pathPattern = "/orgs/{org}/public_members"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = OrgsRemovePublicMembershipForAuthenticatedUserOperation
												r.summary = "Remove public organization membership for the authenticated user"
												r.operationID = "orgs/remove-public-membership-for-authenticated-user"
												r.pathPattern = "/orgs/{org}/public_members/{username}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = OrgsCheckPublicMembershipForUserOperation
												r.summary = "Check public organization membership for a user"
												r.operationID = "orgs/check-public-membership-for-user"
												r.pathPattern = "/orgs/{org}/public_members/{username}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = OrgsSetPublicMembershipForAuthenticatedUserOperation
												r.summary = "Set public organization membership for the authenticated user"
												r.operationID = "orgs/set-public-membership-for-authenticated-user"
												r.pathPattern = "/orgs/{org}/public_members/{username}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'r': // Prefix: "repos"

								if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ReposListForOrgOperation
										r.summary = "List organization repositories"
										r.operationID = "repos/list-for-org"
										r.pathPattern = "/orgs/{org}/repos"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = ReposCreateInOrgOperation
										r.summary = "Create an organization repository"
										r.operationID = "repos/create-in-org"
										r.pathPattern = "/orgs/{org}/repos"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "se"

								if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cret-scanning/alerts"

									if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SecretScanningListAlertsForOrgOperation
											r.summary = "List secret scanning alerts by organization"
											r.operationID = "secret-scanning/list-alerts-for-org"
											r.pathPattern = "/orgs/{org}/secret-scanning/alerts"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "ttings/billing/"

									if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"

										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetGithubActionsBillingOrgOperation
												r.summary = "Get GitHub Actions billing for an organization"
												r.operationID = "billing/get-github-actions-billing-org"
												r.pathPattern = "/orgs/{org}/settings/billing/actions"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'p': // Prefix: "packages"

										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetGithubPackagesBillingOrgOperation
												r.summary = "Get GitHub Packages billing for an organization"
												r.operationID = "billing/get-github-packages-billing-org"
												r.pathPattern = "/orgs/{org}/settings/billing/packages"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "shared-storage"

										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetSharedStorageBillingOrgOperation
												r.summary = "Get shared storage billing for an organization"
												r.operationID = "billing/get-shared-storage-billing-org"
												r.pathPattern = "/orgs/{org}/settings/billing/shared-storage"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							case 't': // Prefix: "team"

								if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-sync/groups"

									if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = TeamsListIdpGroupsForOrgOperation
											r.summary = "List IdP groups for an organization"
											r.operationID = "teams/list-idp-groups-for-org"
											r.pathPattern = "/orgs/{org}/team-sync/groups"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = TeamsListOperation
											r.summary = "List teams"
											r.operationID = "teams/list"
											r.pathPattern = "/orgs/{org}/teams"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = TeamsCreateOperation
											r.summary = "Create a team"
											r.operationID = "teams/create"
											r.pathPattern = "/orgs/{org}/teams"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "team_slug"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = TeamsDeleteInOrgOperation
												r.summary = "Delete a team"
												r.operationID = "teams/delete-in-org"
												r.pathPattern = "/orgs/{org}/teams/{team_slug}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = TeamsGetByNameOperation
												r.summary = "Get a team by name"
												r.operationID = "teams/get-by-name"
												r.pathPattern = "/orgs/{org}/teams/{team_slug}"
												r.args = args
												r.count = 2
												return r, true
											case "PATCH":
												r.name = TeamsUpdateInOrgOperation
												r.summary = "Update a team"
												r.operationID = "teams/update-in-org"
												r.pathPattern = "/orgs/{org}/teams/{team_slug}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "discussions"

												if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = TeamsListDiscussionsInOrgOperation
														r.summary = "List discussions"
														r.operationID = "teams/list-discussions-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = TeamsCreateDiscussionInOrgOperation
														r.summary = "Create a discussion"
														r.operationID = "teams/create-discussion-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "discussion_number"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = TeamsDeleteDiscussionInOrgOperation
															r.summary = "Delete a discussion"
															r.operationID = "teams/delete-discussion-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = TeamsGetDiscussionInOrgOperation
															r.summary = "Get a discussion"
															r.operationID = "teams/get-discussion-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															r.name = TeamsUpdateDiscussionInOrgOperation
															r.summary = "Update a discussion"
															r.operationID = "teams/update-discussion-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "comments"

															if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = TeamsListDiscussionCommentsInOrgOperation
																	r.summary = "List discussion comments"
																	r.operationID = "teams/list-discussion-comments-in-org"
																	r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = TeamsCreateDiscussionCommentInOrgOperation
																	r.summary = "Create a discussion comment"
																	r.operationID = "teams/create-discussion-comment-in-org"
																	r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_number"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		r.name = TeamsDeleteDiscussionCommentInOrgOperation
																		r.summary = "Delete a discussion comment"
																		r.operationID = "teams/delete-discussion-comment-in-org"
																		r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "GET":
																		r.name = TeamsGetDiscussionCommentInOrgOperation
																		r.summary = "Get a discussion comment"
																		r.operationID = "teams/get-discussion-comment-in-org"
																		r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "PATCH":
																		r.name = TeamsUpdateDiscussionCommentInOrgOperation
																		r.summary = "Update a discussion comment"
																		r.operationID = "teams/update-discussion-comment-in-org"
																		r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/reactions"

																	if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			r.name = ReactionsListForTeamDiscussionCommentInOrgOperation
																			r.summary = "List reactions for a team discussion comment"
																			r.operationID = "reactions/list-for-team-discussion-comment-in-org"
																			r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
																			r.args = args
																			r.count = 4
																			return r, true
																		case "POST":
																			r.name = ReactionsCreateForTeamDiscussionCommentInOrgOperation
																			r.summary = "Create reaction for a team discussion comment"
																			r.operationID = "reactions/create-for-team-discussion-comment-in-org"
																			r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
																			r.args = args
																			r.count = 4
																			return r, true
																		default:
																			return
																		}
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/"

																		if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		// Param: "reaction_id"
																		// Leaf parameter, slashes are prohibited
																		idx := strings.IndexByte(elem, '/')
																		if idx >= 0 {
																			break
																		}
																		args[4] = elem
																		elem = ""

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "DELETE":
																				r.name = ReactionsDeleteForTeamDiscussionCommentOperation
																				r.summary = "Delete team discussion comment reaction"
																				r.operationID = "reactions/delete-for-team-discussion-comment"
																				r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
																				r.args = args
																				r.count = 5
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																}

															}

														case 'r': // Prefix: "reactions"

															if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = ReactionsListForTeamDiscussionInOrgOperation
																	r.summary = "List reactions for a team discussion"
																	r.operationID = "reactions/list-for-team-discussion-in-org"
																	r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = ReactionsCreateForTeamDiscussionInOrgOperation
																	r.summary = "Create reaction for a team discussion"
																	r.operationID = "reactions/create-for-team-discussion-in-org"
																	r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "DELETE":
																		r.name = ReactionsDeleteForTeamDiscussionOperation
																		r.summary = "Delete team discussion reaction"
																		r.operationID = "reactions/delete-for-team-discussion"
																		r.pathPattern = "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													}

												}

											case 'i': // Prefix: "invitations"

												if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = TeamsListPendingInvitationsInOrgOperation
														r.summary = "List pending team invitations"
														r.operationID = "teams/list-pending-invitations-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/invitations"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 'm': // Prefix: "members"

												if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = TeamsListMembersInOrgOperation
														r.summary = "List team members"
														r.operationID = "teams/list-members-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/members"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case 'h': // Prefix: "hips/"

													if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = TeamsRemoveMembershipForUserInOrgOperation
															r.summary = "Remove team membership for a user"
															r.operationID = "teams/remove-membership-for-user-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/memberships/{username}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = TeamsGetMembershipForUserInOrgOperation
															r.summary = "Get team membership for a user"
															r.operationID = "teams/get-membership-for-user-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/memberships/{username}"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = TeamsAddOrUpdateMembershipForUserInOrgOperation
															r.summary = "Add or update team membership for a user"
															r.operationID = "teams/add-or-update-membership-for-user-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/memberships/{username}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'p': // Prefix: "projects"

												if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = TeamsListProjectsInOrgOperation
														r.summary = "List team projects"
														r.operationID = "teams/list-projects-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/projects"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "project_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = TeamsRemoveProjectInOrgOperation
															r.summary = "Remove a project from a team"
															r.operationID = "teams/remove-project-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = TeamsCheckPermissionsForProjectInOrgOperation
															r.summary = "Check team permissions for a project"
															r.operationID = "teams/check-permissions-for-project-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = TeamsAddOrUpdateProjectPermissionsInOrgOperation
															r.summary = "Add or update team project permissions"
															r.operationID = "teams/add-or-update-project-permissions-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'r': // Prefix: "repos"

												if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = TeamsListReposInOrgOperation
														r.summary = "List team repositories"
														r.operationID = "teams/list-repos-in-org"
														r.pathPattern = "/orgs/{org}/teams/{team_slug}/repos"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "owner"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "repo"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = TeamsRemoveRepoInOrgOperation
																r.summary = "Remove a repository from a team"
																r.operationID = "teams/remove-repo-in-org"
																r.pathPattern = "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
																r.args = args
																r.count = 4
																return r, true
															case "GET":
																r.name = TeamsCheckPermissionsForRepoInOrgOperation
																r.summary = "Check team permissions for a repository"
																r.operationID = "teams/check-permissions-for-repo-in-org"
																r.pathPattern = "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
																r.args = args
																r.count = 4
																return r, true
															case "PUT":
																r.name = TeamsAddOrUpdateRepoPermissionsInOrgOperation
																r.summary = "Add or update team repository permissions"
																r.operationID = "teams/add-or-update-repo-permissions-in-org"
																r.pathPattern = "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}

													}

												}

											case 't': // Prefix: "team"

												if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '-': // Prefix: "-sync/group-mappings"

													if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = TeamsListIdpGroupsInOrgOperation
															r.summary = "List IdP groups for a team"
															r.operationID = "teams/list-idp-groups-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"
															r.args = args
															r.count = 2
															return r, true
														case "PATCH":
															r.name = TeamsCreateOrUpdateIdpGroupConnectionsInOrgOperation
															r.summary = "Create or update IdP group connections"
															r.operationID = "teams/create-or-update-idp-group-connections-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = TeamsListChildInOrgOperation
															r.summary = "List child teams"
															r.operationID = "teams/list-child-in-org"
															r.pathPattern = "/orgs/{org}/teams/{team_slug}/teams"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									}

								}

							}

						}

					}

				}

			case 'p': // Prefix: "projects/"

				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					origElem := elem
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						origElem := elem
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = ProjectsDeleteCardOperation
								r.summary = "Delete a project card"
								r.operationID = "projects/delete-card"
								r.pathPattern = "/projects/columns/cards/{card_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = ProjectsGetCardOperation
								r.summary = "Get a project card"
								r.operationID = "projects/get-card"
								r.pathPattern = "/projects/columns/cards/{card_id}"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = ProjectsUpdateCardOperation
								r.summary = "Update an existing project card"
								r.operationID = "projects/update-card"
								r.pathPattern = "/projects/columns/cards/{card_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"

							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ProjectsMoveCardOperation
									r.summary = "Move a project card"
									r.operationID = "projects/move-card"
									r.pathPattern = "/projects/columns/cards/{card_id}/moves"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

						elem = origElem
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = ProjectsDeleteColumnOperation
							r.summary = "Delete a project column"
							r.operationID = "projects/delete-column"
							r.pathPattern = "/projects/columns/{column_id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = ProjectsGetColumnOperation
							r.summary = "Get a project column"
							r.operationID = "projects/get-column"
							r.pathPattern = "/projects/columns/{column_id}"
							r.args = args
							r.count = 1
							return r, true
						case "PATCH":
							r.name = ProjectsUpdateColumnOperation
							r.summary = "Update an existing project column"
							r.operationID = "projects/update-column"
							r.pathPattern = "/projects/columns/{column_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "cards"

							if l := len("cards"); len(elem) >= l && elem[0:l] == "cards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ProjectsListCardsOperation
									r.summary = "List project cards"
									r.operationID = "projects/list-cards"
									r.pathPattern = "/projects/columns/{column_id}/cards"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 'm': // Prefix: "moves"

							if l := len("moves"); len(elem) >= l && elem[0:l] == "moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ProjectsMoveColumnOperation
									r.summary = "Move a project column"
									r.operationID = "projects/move-column"
									r.pathPattern = "/projects/columns/{column_id}/moves"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

					elem = origElem
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch method {
					case "DELETE":
						r.name = ProjectsDeleteOperation
						r.summary = "Delete a project"
						r.operationID = "projects/delete"
						r.pathPattern = "/projects/{project_id}"
						r.args = args
						r.count = 1
						return r, true
					case "GET":
						r.name = ProjectsGetOperation
						r.summary = "Get a project"
						r.operationID = "projects/get"
						r.pathPattern = "/projects/{project_id}"
						r.args = args
						r.count = 1
						return r, true
					case "PATCH":
						r.name = ProjectsUpdateOperation
						r.summary = "Update a project"
						r.operationID = "projects/update"
						r.pathPattern = "/projects/{project_id}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/col"

					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"

						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ProjectsListCollaboratorsOperation
								r.summary = "List project collaborators"
								r.operationID = "projects/list-collaborators"
								r.pathPattern = "/projects/{project_id}/collaborators"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = ProjectsRemoveCollaboratorOperation
									r.summary = "Remove user as a collaborator"
									r.operationID = "projects/remove-collaborator"
									r.pathPattern = "/projects/{project_id}/collaborators/{username}"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = ProjectsAddCollaboratorOperation
									r.summary = "Add project collaborator"
									r.operationID = "projects/add-collaborator"
									r.pathPattern = "/projects/{project_id}/collaborators/{username}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"

								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ProjectsGetPermissionForUserOperation
										r.summary = "Get project permission for a user"
										r.operationID = "projects/get-permission-for-user"
										r.pathPattern = "/projects/{project_id}/collaborators/{username}/permission"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'u': // Prefix: "umns"

						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = ProjectsListColumnsOperation
								r.summary = "List project columns"
								r.operationID = "projects/list-columns"
								r.pathPattern = "/projects/{project_id}/columns"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = ProjectsCreateColumnOperation
								r.summary = "Create a project column"
								r.operationID = "projects/create-column"
								r.pathPattern = "/projects/{project_id}/columns"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'r': // Prefix: "r"

				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"

					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = RateLimitGetOperation
							r.summary = "Get rate limit status for the authenticated user"
							r.operationID = "rate-limit/get"
							r.pathPattern = "/rate_limit"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'e': // Prefix: "e"

					if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"

						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "reaction_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = ReactionsDeleteLegacyOperation
								r.summary = "Delete a reaction (Legacy)"
								r.operationID = "reactions/delete-legacy"
								r.pathPattern = "/reactions/{reaction_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'p': // Prefix: "pos"

						if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = ReposDeleteOperation
										r.summary = "Delete a repository"
										r.operationID = "repos/delete"
										r.pathPattern = "/repos/{owner}/{repo}"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										r.name = ReposGetOperation
										r.summary = "Get a repository"
										r.operationID = "repos/get"
										r.pathPattern = "/repos/{owner}/{repo}"
										r.args = args
										r.count = 2
										return r, true
									case "PATCH":
										r.name = ReposUpdateOperation
										r.summary = "Update a repository"
										r.operationID = "repos/update"
										r.pathPattern = "/repos/{owner}/{repo}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "a"

										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "ctions/"

											if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "artifacts"

												if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsListArtifactsForRepoOperation
														r.summary = "List artifacts for a repository"
														r.operationID = "actions/list-artifacts-for-repo"
														r.pathPattern = "/repos/{owner}/{repo}/actions/artifacts"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "artifact_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = ActionsDeleteArtifactOperation
															r.summary = "Delete an artifact"
															r.operationID = "actions/delete-artifact"
															r.pathPattern = "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ActionsGetArtifactOperation
															r.summary = "Get an artifact"
															r.operationID = "actions/get-artifact"
															r.pathPattern = "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "archive_format"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ActionsDownloadArtifactOperation
																r.summary = "Download an artifact"
																r.operationID = "actions/download-artifact"
																r.pathPattern = "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}

													}

												}

											case 'j': // Prefix: "jobs/"

												if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "job_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsGetJobForWorkflowRunOperation
														r.summary = "Get a job for a workflow run"
														r.operationID = "actions/get-job-for-workflow-run"
														r.pathPattern = "/repos/{owner}/{repo}/actions/jobs/{job_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"

													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ActionsDownloadJobLogsForWorkflowRunOperation
															r.summary = "Download job logs for a workflow run"
															r.operationID = "actions/download-job-logs-for-workflow-run"
															r.pathPattern = "/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'p': // Prefix: "permissions"

												if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsGetGithubActionsPermissionsRepositoryOperation
														r.summary = "Get GitHub Actions permissions for a repository"
														r.operationID = "actions/get-github-actions-permissions-repository"
														r.pathPattern = "/repos/{owner}/{repo}/actions/permissions"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = ActionsSetGithubActionsPermissionsRepositoryOperation
														r.summary = "Set GitHub Actions permissions for a repository"
														r.operationID = "actions/set-github-actions-permissions-repository"
														r.pathPattern = "/repos/{owner}/{repo}/actions/permissions"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/selected-actions"

													if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ActionsGetAllowedActionsRepositoryOperation
															r.summary = "Get allowed actions for a repository"
															r.operationID = "actions/get-allowed-actions-repository"
															r.pathPattern = "/repos/{owner}/{repo}/actions/permissions/selected-actions"
															r.args = args
															r.count = 2
															return r, true
														case "PUT":
															r.name = ActionsSetAllowedActionsRepositoryOperation
															r.summary = "Set allowed actions for a repository"
															r.operationID = "actions/set-allowed-actions-repository"
															r.pathPattern = "/repos/{owner}/{repo}/actions/permissions/selected-actions"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											case 'r': // Prefix: "run"

												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'n': // Prefix: "ners"

													if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ActionsListSelfHostedRunnersForRepoOperation
															r.summary = "List self-hosted runners for a repository"
															r.operationID = "actions/list-self-hosted-runners-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/actions/runners"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'd': // Prefix: "downloads"
															origElem := elem
															if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = ActionsListRunnerApplicationsForRepoOperation
																	r.summary = "List runner applications for a repository"
																	r.operationID = "actions/list-runner-applications-for-repo"
																	r.pathPattern = "/repos/{owner}/{repo}/actions/runners/downloads"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}

															elem = origElem
														case 'r': // Prefix: "re"
															origElem := elem
															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'g': // Prefix: "gistration-token"

																if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = ActionsCreateRegistrationTokenForRepoOperation
																		r.summary = "Create a registration token for a repository"
																		r.operationID = "actions/create-registration-token-for-repo"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runners/registration-token"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}

															case 'm': // Prefix: "move-token"

																if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = ActionsCreateRemoveTokenForRepoOperation
																		r.summary = "Create a remove token for a repository"
																		r.operationID = "actions/create-remove-token-for-repo"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runners/remove-token"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}

															}

															elem = origElem
														}
														// Param: "runner_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = ActionsDeleteSelfHostedRunnerFromRepoOperation
																r.summary = "Delete a self-hosted runner from a repository"
																r.operationID = "actions/delete-self-hosted-runner-from-repo"
																r.pathPattern = "/repos/{owner}/{repo}/actions/runners/{runner_id}"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = ActionsGetSelfHostedRunnerForRepoOperation
																r.summary = "Get a self-hosted runner for a repository"
																r.operationID = "actions/get-self-hosted-runner-for-repo"
																r.pathPattern = "/repos/{owner}/{repo}/actions/runners/{runner_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ActionsListWorkflowRunsForRepoOperation
															r.summary = "List workflow runs for a repository"
															r.operationID = "actions/list-workflow-runs-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/actions/runs"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "run_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = ActionsDeleteWorkflowRunOperation
																r.summary = "Delete a workflow run"
																r.operationID = "actions/delete-workflow-run"
																r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = ActionsGetWorkflowRunOperation
																r.summary = "Get a workflow run"
																r.operationID = "actions/get-workflow-run"
																r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'a': // Prefix: "a"

																if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pprov"

																	if l := len("pprov"); len(elem) >= l && elem[0:l] == "pprov" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "als"

																		if l := len("als"); len(elem) >= l && elem[0:l] == "als" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "GET":
																				r.name = ActionsGetReviewsForRunOperation
																				r.summary = "Get the review history for a workflow run"
																				r.operationID = "actions/get-reviews-for-run"
																				r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	case 'e': // Prefix: "e"

																		if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "POST":
																				r.name = ActionsApproveWorkflowRunOperation
																				r.summary = "Approve a workflow run for a fork pull request"
																				r.operationID = "actions/approve-workflow-run"
																				r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/approve"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																case 'r': // Prefix: "rtifacts"

																	if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "GET":
																			r.name = ActionsListWorkflowRunArtifactsOperation
																			r.summary = "List workflow run artifacts"
																			r.operationID = "actions/list-workflow-run-artifacts"
																			r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																}

															case 'c': // Prefix: "cancel"

																if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = ActionsCancelWorkflowRunOperation
																		r.summary = "Cancel a workflow run"
																		r.operationID = "actions/cancel-workflow-run"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															case 'j': // Prefix: "jobs"

																if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "GET":
																		r.name = ActionsListJobsForWorkflowRunOperation
																		r.summary = "List jobs for a workflow run"
																		r.operationID = "actions/list-jobs-for-workflow-run"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															case 'l': // Prefix: "logs"

																if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "DELETE":
																		r.name = ActionsDeleteWorkflowRunLogsOperation
																		r.summary = "Delete workflow run logs"
																		r.operationID = "actions/delete-workflow-run-logs"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "GET":
																		r.name = ActionsDownloadWorkflowRunLogsOperation
																		r.summary = "Download workflow run logs"
																		r.operationID = "actions/download-workflow-run-logs"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															case 'p': // Prefix: "pending_deployments"

																if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = ActionsReviewPendingDeploymentsForRunOperation
																		r.summary = "Review pending deployments for a workflow run"
																		r.operationID = "actions/review-pending-deployments-for-run"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															case 'r': // Prefix: "re"

																if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'r': // Prefix: "run"

																	if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "POST":
																			r.name = ActionsReRunWorkflowOperation
																			r.summary = "Re-run a workflow"
																			r.operationID = "actions/re-run-workflow"
																			r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																case 't': // Prefix: "try"

																	if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "POST":
																			r.name = ActionsRetryWorkflowOperation
																			r.summary = "Retry a workflow"
																			r.operationID = "actions/retry-workflow"
																			r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/retry"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																}

															case 't': // Prefix: "timing"

																if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "GET":
																		r.name = ActionsGetWorkflowRunUsageOperation
																		r.summary = "Get workflow run usage"
																		r.operationID = "actions/get-workflow-run-usage"
																		r.pathPattern = "/repos/{owner}/{repo}/actions/runs/{run_id}/timing"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													}

												}

											case 's': // Prefix: "secrets"

												if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ActionsListRepoSecretsOperation
														r.summary = "List repository secrets"
														r.operationID = "actions/list-repo-secrets"
														r.pathPattern = "/repos/{owner}/{repo}/actions/secrets"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "public-key"
														origElem := elem
														if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ActionsGetRepoPublicKeyOperation
																r.summary = "Get a repository public key"
																r.operationID = "actions/get-repo-public-key"
																r.pathPattern = "/repos/{owner}/{repo}/actions/secrets/public-key"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

														elem = origElem
													}
													// Param: "secret_name"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ActionsDeleteRepoSecretOperation
															r.summary = "Delete a repository secret"
															r.operationID = "actions/delete-repo-secret"
															r.pathPattern = "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ActionsGetRepoSecretOperation
															r.summary = "Get a repository secret"
															r.operationID = "actions/get-repo-secret"
															r.pathPattern = "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = ActionsCreateOrUpdateRepoSecretOperation
															r.summary = "Create or update a repository secret"
															r.operationID = "actions/create-or-update-repo-secret"
															r.pathPattern = "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'w': // Prefix: "workflows"

												if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ActionsListRepoWorkflowsOperation
														r.summary = "List repository workflows"
														r.operationID = "actions/list-repo-workflows"
														r.pathPattern = "/repos/{owner}/{repo}/actions/workflows"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 's': // Prefix: "ssignees"

											if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = IssuesListAssigneesOperation
													r.summary = "List assignees"
													r.operationID = "issues/list-assignees"
													r.pathPattern = "/repos/{owner}/{repo}/assignees"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "assignee"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = IssuesCheckUserCanBeAssignedOperation
														r.summary = "Check if a user can be assigned"
														r.operationID = "issues/check-user-can-be-assigned"
														r.pathPattern = "/repos/{owner}/{repo}/assignees/{assignee}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 'u': // Prefix: "uto"

											if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "links"

												if l := len("links"); len(elem) >= l && elem[0:l] == "links" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ReposListAutolinksOperation
														r.summary = "List all autolinks of a repository"
														r.operationID = "repos/list-autolinks"
														r.pathPattern = "/repos/{owner}/{repo}/autolinks"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = ReposCreateAutolinkOperation
														r.summary = "Create an autolink reference for a repository"
														r.operationID = "repos/create-autolink"
														r.pathPattern = "/repos/{owner}/{repo}/autolinks"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "autolink_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ReposDeleteAutolinkOperation
															r.summary = "Delete an autolink reference from a repository"
															r.operationID = "repos/delete-autolink"
															r.pathPattern = "/repos/{owner}/{repo}/autolinks/{autolink_id}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ReposGetAutolinkOperation
															r.summary = "Get an autolink reference of a repository"
															r.operationID = "repos/get-autolink"
															r.pathPattern = "/repos/{owner}/{repo}/autolinks/{autolink_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'm': // Prefix: "mated-security-fixes"

												if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = ReposDisableAutomatedSecurityFixesOperation
														r.summary = "Disable automated security fixes"
														r.operationID = "repos/disable-automated-security-fixes"
														r.pathPattern = "/repos/{owner}/{repo}/automated-security-fixes"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = ReposEnableAutomatedSecurityFixesOperation
														r.summary = "Enable automated security fixes"
														r.operationID = "repos/enable-automated-security-fixes"
														r.pathPattern = "/repos/{owner}/{repo}/automated-security-fixes"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									case 'b': // Prefix: "branches"

										if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ReposListBranchesOperation
												r.summary = "List branches"
												r.operationID = "repos/list-branches"
												r.pathPattern = "/repos/{owner}/{repo}/branches"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "branch"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ReposGetBranchOperation
													r.summary = "Get a branch"
													r.operationID = "repos/get-branch"
													r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'p': // Prefix: "protection"

													if l := len("protection"); len(elem) >= l && elem[0:l] == "protection" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = ReposDeleteBranchProtectionOperation
															r.summary = "Delete branch protection"
															r.operationID = "repos/delete-branch-protection"
															r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ReposGetBranchProtectionOperation
															r.summary = "Get branch protection"
															r.operationID = "repos/get-branch-protection"
															r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = ReposUpdateBranchProtectionOperation
															r.summary = "Update branch protection"
															r.operationID = "repos/update-branch-protection"
															r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "enforce_admins"

															if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = ReposDeleteAdminBranchProtectionOperation
																	r.summary = "Delete admin branch protection"
																	r.operationID = "repos/delete-admin-branch-protection"
																	r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = ReposGetAdminBranchProtectionOperation
																	r.summary = "Get admin branch protection"
																	r.operationID = "repos/get-admin-branch-protection"
																	r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = ReposSetAdminBranchProtectionOperation
																	r.summary = "Set admin branch protection"
																	r.operationID = "repos/set-admin-branch-protection"
																	r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														case 'r': // Prefix: "re"

															if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'q': // Prefix: "quired_"

																if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'p': // Prefix: "pull_request_reviews"

																	if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "DELETE":
																			r.name = ReposDeletePullRequestReviewProtectionOperation
																			r.summary = "Delete pull request review protection"
																			r.operationID = "repos/delete-pull-request-review-protection"
																			r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
																			r.args = args
																			r.count = 3
																			return r, true
																		case "GET":
																			r.name = ReposGetPullRequestReviewProtectionOperation
																			r.summary = "Get pull request review protection"
																			r.operationID = "repos/get-pull-request-review-protection"
																			r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
																			r.args = args
																			r.count = 3
																			return r, true
																		case "PATCH":
																			r.name = ReposUpdatePullRequestReviewProtectionOperation
																			r.summary = "Update pull request review protection"
																			r.operationID = "repos/update-pull-request-review-protection"
																			r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																case 's': // Prefix: "s"

																	if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'i': // Prefix: "ignatures"

																		if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "DELETE":
																				r.name = ReposDeleteCommitSignatureProtectionOperation
																				r.summary = "Delete commit signature protection"
																				r.operationID = "repos/delete-commit-signature-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = ReposGetCommitSignatureProtectionOperation
																				r.summary = "Get commit signature protection"
																				r.operationID = "repos/get-commit-signature-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				r.name = ReposCreateCommitSignatureProtectionOperation
																				r.summary = "Create commit signature protection"
																				r.operationID = "repos/create-commit-signature-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	case 't': // Prefix: "tatus_checks"

																		if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			switch method {
																			case "DELETE":
																				r.name = ReposRemoveStatusCheckProtectionOperation
																				r.summary = "Remove status check protection"
																				r.operationID = "repos/remove-status-check-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = ReposGetStatusChecksProtectionOperation
																				r.summary = "Get status checks protection"
																				r.operationID = "repos/get-status-checks-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PATCH":
																				r.name = ReposUpdateStatusCheckProtectionOperation
																				r.summary = "Update status check protection"
																				r.operationID = "repos/update-status-check-protection"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}
																		switch elem[0] {
																		case '/': // Prefix: "/contexts"

																			if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch method {
																				case "DELETE":
																					r.name = ReposRemoveStatusCheckContextsOperation
																					r.summary = "Remove status check contexts"
																					r.operationID = "repos/remove-status-check-contexts"
																					r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "GET":
																					r.name = ReposGetAllStatusCheckContextsOperation
																					r.summary = "Get all status check contexts"
																					r.operationID = "repos/get-all-status-check-contexts"
																					r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "POST":
																					r.name = ReposAddStatusCheckContextsOperation
																					r.summary = "Add status check contexts"
																					r.operationID = "repos/add-status-check-contexts"
																					r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				case "PUT":
																					r.name = ReposSetStatusCheckContextsOperation
																					r.summary = "Set status check contexts"
																					r.operationID = "repos/set-status-check-contexts"
																					r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}

																		}

																	}

																}

															case 's': // Prefix: "strictions"

																if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		r.name = ReposDeleteAccessRestrictionsOperation
																		r.summary = "Delete access restrictions"
																		r.operationID = "repos/delete-access-restrictions"
																		r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "GET":
																		r.name = ReposGetAccessRestrictionsOperation
																		r.summary = "Get access restrictions"
																		r.operationID = "repos/get-access-restrictions"
																		r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'a': // Prefix: "apps"

																		if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "DELETE":
																				r.name = ReposRemoveAppAccessRestrictionsOperation
																				r.summary = "Remove app access restrictions"
																				r.operationID = "repos/remove-app-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = ReposGetAppsWithAccessToProtectedBranchOperation
																				r.summary = "Get apps with access to the protected branch"
																				r.operationID = "repos/get-apps-with-access-to-protected-branch"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				r.name = ReposAddAppAccessRestrictionsOperation
																				r.summary = "Add app access restrictions"
																				r.operationID = "repos/add-app-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				r.name = ReposSetAppAccessRestrictionsOperation
																				r.summary = "Set app access restrictions"
																				r.operationID = "repos/set-app-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	case 't': // Prefix: "teams"

																		if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "DELETE":
																				r.name = ReposRemoveTeamAccessRestrictionsOperation
																				r.summary = "Remove team access restrictions"
																				r.operationID = "repos/remove-team-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = ReposGetTeamsWithAccessToProtectedBranchOperation
																				r.summary = "Get teams with access to the protected branch"
																				r.operationID = "repos/get-teams-with-access-to-protected-branch"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				r.name = ReposAddTeamAccessRestrictionsOperation
																				r.summary = "Add team access restrictions"
																				r.operationID = "repos/add-team-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				r.name = ReposSetTeamAccessRestrictionsOperation
																				r.summary = "Set team access restrictions"
																				r.operationID = "repos/set-team-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	case 'u': // Prefix: "users"

																		if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "DELETE":
																				r.name = ReposRemoveUserAccessRestrictionsOperation
																				r.summary = "Remove user access restrictions"
																				r.operationID = "repos/remove-user-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "GET":
																				r.name = ReposGetUsersWithAccessToProtectedBranchOperation
																				r.summary = "Get users with access to the protected branch"
																				r.operationID = "repos/get-users-with-access-to-protected-branch"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				r.name = ReposAddUserAccessRestrictionsOperation
																				r.summary = "Add user access restrictions"
																				r.operationID = "repos/add-user-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "PUT":
																				r.name = ReposSetUserAccessRestrictionsOperation
																				r.summary = "Set user access restrictions"
																				r.operationID = "repos/set-user-access-restrictions"
																				r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																}

															}

														}

													}

												case 'r': // Prefix: "rename"

													if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = ReposRenameBranchOperation
															r.summary = "Rename a branch"
															r.operationID = "repos/rename-branch"
															r.pathPattern = "/repos/{owner}/{repo}/branches/{branch}/rename"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "heck-"

											if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'r': // Prefix: "runs/"

												if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "check_run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ChecksGetOperation
														r.summary = "Get a check run"
														r.operationID = "checks/get"
														r.pathPattern = "/repos/{owner}/{repo}/check-runs/{check_run_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/annotations"

													if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ChecksListAnnotationsOperation
															r.summary = "List check run annotations"
															r.operationID = "checks/list-annotations"
															r.pathPattern = "/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 's': // Prefix: "suites"

												if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = ChecksCreateSuiteOperation
														r.summary = "Create a check suite"
														r.operationID = "checks/create-suite"
														r.pathPattern = "/repos/{owner}/{repo}/check-suites"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "preferences"
														origElem := elem
														if l := len("preferences"); len(elem) >= l && elem[0:l] == "preferences" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "PATCH":
																r.name = ChecksSetSuitesPreferencesOperation
																r.summary = "Update repository preferences for check suites"
																r.operationID = "checks/set-suites-preferences"
																r.pathPattern = "/repos/{owner}/{repo}/check-suites/preferences"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

														elem = origElem
													}
													// Param: "check_suite_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ChecksGetSuiteOperation
															r.summary = "Get a check suite"
															r.operationID = "checks/get-suite"
															r.pathPattern = "/repos/{owner}/{repo}/check-suites/{check_suite_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'c': // Prefix: "check-runs"

															if l := len("check-runs"); len(elem) >= l && elem[0:l] == "check-runs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = ChecksListForSuiteOperation
																	r.summary = "List check runs in a check suite"
																	r.operationID = "checks/list-for-suite"
																	r.pathPattern = "/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														case 'r': // Prefix: "rerequest"

															if l := len("rerequest"); len(elem) >= l && elem[0:l] == "rerequest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "POST":
																	r.name = ChecksRerequestSuiteOperation
																	r.summary = "Rerequest a check suite"
																	r.operationID = "checks/rerequest-suite"
																	r.pathPattern = "/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											}

										case 'o': // Prefix: "o"

											if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "de-scanning/"

												if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "a"

													if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'l': // Prefix: "lerts"

														if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = CodeScanningListAlertsForRepoOperation
																r.summary = "List code scanning alerts for a repository"
																r.operationID = "code-scanning/list-alerts-for-repo"
																r.pathPattern = "/repos/{owner}/{repo}/code-scanning/alerts"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "alert_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = CodeScanningGetAlertOperation
																	r.summary = "Get a code scanning alert"
																	r.operationID = "code-scanning/get-alert"
																	r.pathPattern = "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PATCH":
																	r.name = CodeScanningUpdateAlertOperation
																	r.summary = "Update a code scanning alert"
																	r.operationID = "code-scanning/update-alert"
																	r.pathPattern = "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/instances"

																if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "GET":
																		r.name = CodeScanningListAlertInstancesOperation
																		r.summary = "List instances of a code scanning alert"
																		r.operationID = "code-scanning/list-alert-instances"
																		r.pathPattern = "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													case 'n': // Prefix: "nalyses"

														if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = CodeScanningListRecentAnalysesOperation
																r.summary = "List code scanning analyses for a repository"
																r.operationID = "code-scanning/list-recent-analyses"
																r.pathPattern = "/repos/{owner}/{repo}/code-scanning/analyses"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "analysis_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[2] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = CodeScanningDeleteAnalysisOperation
																	r.summary = "Delete a code scanning analysis from a repository"
																	r.operationID = "code-scanning/delete-analysis"
																	r.pathPattern = "/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = CodeScanningGetAnalysisOperation
																	r.summary = "Get a code scanning analysis for a repository"
																	r.operationID = "code-scanning/get-analysis"
																	r.pathPattern = "/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													}

												case 's': // Prefix: "sarifs"

													if l := len("sarifs"); len(elem) >= l && elem[0:l] == "sarifs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = CodeScanningUploadSarifOperation
															r.summary = "Upload an analysis as SARIF data"
															r.operationID = "code-scanning/upload-sarif"
															r.pathPattern = "/repos/{owner}/{repo}/code-scanning/sarifs"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "sarif_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = CodeScanningGetSarifOperation
																r.summary = "Get information about a SARIF upload"
																r.operationID = "code-scanning/get-sarif"
																r.pathPattern = "/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											case 'l': // Prefix: "llaborators"

												if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ReposListCollaboratorsOperation
														r.summary = "List repository collaborators"
														r.operationID = "repos/list-collaborators"
														r.pathPattern = "/repos/{owner}/{repo}/collaborators"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "username"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = ReposRemoveCollaboratorOperation
															r.summary = "Remove a repository collaborator"
															r.operationID = "repos/remove-collaborator"
															r.pathPattern = "/repos/{owner}/{repo}/collaborators/{username}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ReposCheckCollaboratorOperation
															r.summary = "Check if a user is a repository collaborator"
															r.operationID = "repos/check-collaborator"
															r.pathPattern = "/repos/{owner}/{repo}/collaborators/{username}"
															r.args = args
															r.count = 3
															return r, true
														case "PUT":
															r.name = ReposAddCollaboratorOperation
															r.summary = "Add a repository collaborator"
															r.operationID = "repos/add-collaborator"
															r.pathPattern = "/repos/{owner}/{repo}/collaborators/{username}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/permission"

														if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetCollaboratorPermissionLevelOperation
																r.summary = "Get repository permissions for a user"
																r.operationID = "repos/get-collaborator-permission-level"
																r.pathPattern = "/repos/{owner}/{repo}/collaborators/{username}/permission"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											case 'm': // Prefix: "m"

												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'm': // Prefix: "m"

													if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"

														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ReposListCommitCommentsForRepoOperation
																r.summary = "List commit comments for a repository"
																r.operationID = "repos/list-commit-comments-for-repo"
																r.pathPattern = "/repos/{owner}/{repo}/comments"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	r.name = ReposDeleteCommitCommentOperation
																	r.summary = "Delete a commit comment"
																	r.operationID = "repos/delete-commit-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = ReposGetCommitCommentOperation
																	r.summary = "Get a commit comment"
																	r.operationID = "repos/get-commit-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PATCH":
																	r.name = ReposUpdateCommitCommentOperation
																	r.summary = "Update a commit comment"
																	r.operationID = "repos/update-commit-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"

																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		r.name = ReactionsListForCommitCommentOperation
																		r.summary = "List reactions for a commit comment"
																		r.operationID = "reactions/list-for-commit-comment"
																		r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
																		r.args = args
																		r.count = 3
																		return r, true
																	case "POST":
																		r.name = ReactionsCreateForCommitCommentOperation
																		r.summary = "Create reaction for a commit comment"
																		r.operationID = "reactions/create-for-commit-comment"
																		r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "reaction_id"
																	// Leaf parameter, slashes are prohibited
																	idx := strings.IndexByte(elem, '/')
																	if idx >= 0 {
																		break
																	}
																	args[3] = elem
																	elem = ""

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "DELETE":
																			r.name = ReactionsDeleteForCommitCommentOperation
																			r.summary = "Delete a commit comment reaction"
																			r.operationID = "reactions/delete-for-commit-comment"
																			r.pathPattern = "/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
																			r.args = args
																			r.count = 4
																			return r, true
																		default:
																			return
																		}
																	}

																}

															}

														}

													case 'i': // Prefix: "its"

														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ReposListCommitsOperation
																r.summary = "List commits"
																r.operationID = "repos/list-commits"
																r.pathPattern = "/repos/{owner}/{repo}/commits"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "ref"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = ReposGetCommitOperation
																	r.summary = "Get a commit"
																	r.operationID = "repos/get-commit"
																	r.pathPattern = "/repos/{owner}/{repo}/commits/{ref}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case 'b': // Prefix: "branches-where-head"

																	if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "GET":
																			r.name = ReposListBranchesForHeadCommitOperation
																			r.summary = "List branches for HEAD commit"
																			r.operationID = "repos/list-branches-for-head-commit"
																			r.pathPattern = "/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																case 'c': // Prefix: "c"

																	if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'h': // Prefix: "heck-"

																		if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			break
																		}
																		switch elem[0] {
																		case 'r': // Prefix: "runs"

																			if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch method {
																				case "GET":
																					r.name = ChecksListForRefOperation
																					r.summary = "List check runs for a Git reference"
																					r.operationID = "checks/list-for-ref"
																					r.pathPattern = "/repos/{owner}/{repo}/commits/{ref}/check-runs"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}

																		case 's': // Prefix: "suites"

																			if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																				elem = elem[l:]
																			} else {
																				break
																			}

																			if len(elem) == 0 {
																				// Leaf node.
																				switch method {
																				case "GET":
																					r.name = ChecksListSuitesForRefOperation
																					r.summary = "List check suites for a Git reference"
																					r.operationID = "checks/list-suites-for-ref"
																					r.pathPattern = "/repos/{owner}/{repo}/commits/{ref}/check-suites"
																					r.args = args
																					r.count = 3
																					return r, true
																				default:
																					return
																				}
																			}

																		}

																	case 'o': // Prefix: "omments"

																		if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "GET":
																				r.name = ReposListCommentsForCommitOperation
																				r.summary = "List commit comments"
																				r.operationID = "repos/list-comments-for-commit"
																				r.pathPattern = "/repos/{owner}/{repo}/commits/{commit_sha}/comments"
																				r.args = args
																				r.count = 3
																				return r, true
																			case "POST":
																				r.name = ReposCreateCommitCommentOperation
																				r.summary = "Create a commit comment"
																				r.operationID = "repos/create-commit-comment"
																				r.pathPattern = "/repos/{owner}/{repo}/commits/{commit_sha}/comments"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																case 'p': // Prefix: "pulls"

																	if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "GET":
																			r.name = ReposListPullRequestsAssociatedWithCommitOperation
																			r.summary = "List pull requests associated with a commit"
																			r.operationID = "repos/list-pull-requests-associated-with-commit"
																			r.pathPattern = "/repos/{owner}/{repo}/commits/{commit_sha}/pulls"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}

																case 's': // Prefix: "status"

																	if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		switch method {
																		case "GET":
																			r.name = ReposGetCombinedStatusForRefOperation
																			r.summary = "Get the combined status for a specific reference"
																			r.operationID = "repos/get-combined-status-for-ref"
																			r.pathPattern = "/repos/{owner}/{repo}/commits/{ref}/status"
																			r.args = args
																			r.count = 3
																			return r, true
																		default:
																			return
																		}
																	}
																	switch elem[0] {
																	case 'e': // Prefix: "es"

																		if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "GET":
																				r.name = ReposListCommitStatusesForRefOperation
																				r.summary = "List commit statuses for a reference"
																				r.operationID = "repos/list-commit-statuses-for-ref"
																				r.pathPattern = "/repos/{owner}/{repo}/commits/{ref}/statuses"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																}

															}

														}

													case 'u': // Prefix: "unity/profile"

														if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetCommunityProfileMetricsOperation
																r.summary = "Get community profile metrics"
																r.operationID = "repos/get-community-profile-metrics"
																r.pathPattern = "/repos/{owner}/{repo}/community/profile"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												case 'p': // Prefix: "pare/"

													if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "basehead"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposCompareCommitsOperation
															r.summary = "Compare two commits"
															r.operationID = "repos/compare-commits"
															r.pathPattern = "/repos/{owner}/{repo}/compare/{basehead}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'n': // Prefix: "nt"

												if l := len("nt"); len(elem) >= l && elem[0:l] == "nt" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'e': // Prefix: "ent"

													if l := len("ent"); len(elem) >= l && elem[0:l] == "ent" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case '_': // Prefix: "_references/"

														if l := len("_references/"); len(elem) >= l && elem[0:l] == "_references/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "content_reference_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case '/': // Prefix: "/attachments"

															if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "POST":
																	r.name = AppsCreateContentAttachmentOperation
																	r.summary = "Create a content attachment"
																	r.operationID = "apps/create-content-attachment"
																	r.pathPattern = "/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													case 's': // Prefix: "s/"

														if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "path"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = ReposDeleteFileOperation
																r.summary = "Delete a file"
																r.operationID = "repos/delete-file"
																r.pathPattern = "/repos/{owner}/{repo}/contents/{path}"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																r.name = ReposCreateOrUpdateFileContentsOperation
																r.summary = "Create or update file contents"
																r.operationID = "repos/create-or-update-file-contents"
																r.pathPattern = "/repos/{owner}/{repo}/contents/{path}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'r': // Prefix: "ributors"

													if l := len("ributors"); len(elem) >= l && elem[0:l] == "ributors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposListContributorsOperation
															r.summary = "List repository contributors"
															r.operationID = "repos/list-contributors"
															r.pathPattern = "/repos/{owner}/{repo}/contributors"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									case 'd': // Prefix: "d"

										if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "eployments"

											if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ReposListDeploymentsOperation
													r.summary = "List deployments"
													r.operationID = "repos/list-deployments"
													r.pathPattern = "/repos/{owner}/{repo}/deployments"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = ReposCreateDeploymentOperation
													r.summary = "Create a deployment"
													r.operationID = "repos/create-deployment"
													r.pathPattern = "/repos/{owner}/{repo}/deployments"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "deployment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = ReposDeleteDeploymentOperation
														r.summary = "Delete a deployment"
														r.operationID = "repos/delete-deployment"
														r.pathPattern = "/repos/{owner}/{repo}/deployments/{deployment_id}"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = ReposGetDeploymentOperation
														r.summary = "Get a deployment"
														r.operationID = "repos/get-deployment"
														r.pathPattern = "/repos/{owner}/{repo}/deployments/{deployment_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/statuses"

													if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ReposListDeploymentStatusesOperation
															r.summary = "List deployment statuses"
															r.operationID = "repos/list-deployment-statuses"
															r.pathPattern = "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
															r.args = args
															r.count = 3
															return r, true
														case "POST":
															r.name = ReposCreateDeploymentStatusOperation
															r.summary = "Create a deployment status"
															r.operationID = "repos/create-deployment-status"
															r.pathPattern = "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "status_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetDeploymentStatusOperation
																r.summary = "Get a deployment status"
																r.operationID = "repos/get-deployment-status"
																r.pathPattern = "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										case 'i': // Prefix: "ispatches"

											if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = ReposCreateDispatchEventOperation
													r.summary = "Create a repository dispatch event"
													r.operationID = "repos/create-dispatch-event"
													r.pathPattern = "/repos/{owner}/{repo}/dispatches"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									case 'e': // Prefix: "e"

										if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'n': // Prefix: "nvironments/"

											if l := len("nvironments/"); len(elem) >= l && elem[0:l] == "nvironments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "environment_name"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = ReposDeleteAnEnvironmentOperation
													r.summary = "Delete an environment"
													r.operationID = "repos/delete-an-environment"
													r.pathPattern = "/repos/{owner}/{repo}/environments/{environment_name}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}

										case 'v': // Prefix: "vents"

											if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ActivityListRepoEventsOperation
													r.summary = "List repository events"
													r.operationID = "activity/list-repo-events"
													r.pathPattern = "/repos/{owner}/{repo}/events"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									case 'f': // Prefix: "forks"

										if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ReposListForksOperation
												r.summary = "List forks"
												r.operationID = "repos/list-forks"
												r.pathPattern = "/repos/{owner}/{repo}/forks"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												r.name = ReposCreateForkOperation
												r.summary = "Create a fork"
												r.operationID = "repos/create-fork"
												r.pathPattern = "/repos/{owner}/{repo}/forks"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									case 'g': // Prefix: "g"

										if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "enerate"

											if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = ReposCreateUsingTemplateOperation
													r.summary = "Create a repository using a template"
													r.operationID = "repos/create-using-template"
													r.pathPattern = "/repos/{template_owner}/{template_repo}/generate"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'i': // Prefix: "it/"

											if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "blobs"

												if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = GitCreateBlobOperation
														r.summary = "Create a blob"
														r.operationID = "git/create-blob"
														r.pathPattern = "/repos/{owner}/{repo}/git/blobs"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "file_sha"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = GitGetBlobOperation
															r.summary = "Get a blob"
															r.operationID = "git/get-blob"
															r.pathPattern = "/repos/{owner}/{repo}/git/blobs/{file_sha}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'c': // Prefix: "commits"

												if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = GitCreateCommitOperation
														r.summary = "Create a commit"
														r.operationID = "git/create-commit"
														r.pathPattern = "/repos/{owner}/{repo}/git/commits"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "commit_sha"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = GitGetCommitOperation
															r.summary = "Get a commit"
															r.operationID = "git/get-commit"
															r.pathPattern = "/repos/{owner}/{repo}/git/commits/{commit_sha}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'm': // Prefix: "matching-refs/"

												if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = GitListMatchingRefsOperation
														r.summary = "List matching references"
														r.operationID = "git/list-matching-refs"
														r.pathPattern = "/repos/{owner}/{repo}/git/matching-refs/{ref}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											case 'r': // Prefix: "ref"

												if l := len("ref"); len(elem) >= l && elem[0:l] == "ref" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ref"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = GitGetRefOperation
															r.summary = "Get a reference"
															r.operationID = "git/get-ref"
															r.pathPattern = "/repos/{owner}/{repo}/git/ref/{ref}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												case 's': // Prefix: "s"

													if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = GitCreateRefOperation
															r.summary = "Create a reference"
															r.operationID = "git/create-ref"
															r.pathPattern = "/repos/{owner}/{repo}/git/refs"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = GitDeleteRefOperation
																r.summary = "Delete a reference"
																r.operationID = "git/delete-ref"
																r.pathPattern = "/repos/{owner}/{repo}/git/refs/{ref}"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																r.name = GitUpdateRefOperation
																r.summary = "Update a reference"
																r.operationID = "git/update-ref"
																r.pathPattern = "/repos/{owner}/{repo}/git/refs/{ref}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											case 't': // Prefix: "t"

												if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "ags"

													if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = GitCreateTagOperation
															r.summary = "Create a tag object"
															r.operationID = "git/create-tag"
															r.pathPattern = "/repos/{owner}/{repo}/git/tags"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tag_sha"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = GitGetTagOperation
																r.summary = "Get a tag"
																r.operationID = "git/get-tag"
																r.pathPattern = "/repos/{owner}/{repo}/git/tags/{tag_sha}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'r': // Prefix: "rees"

													if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = GitCreateTreeOperation
															r.summary = "Create a tree"
															r.operationID = "git/create-tree"
															r.pathPattern = "/repos/{owner}/{repo}/git/trees"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "tree_sha"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = GitGetTreeOperation
																r.summary = "Get a tree"
																r.operationID = "git/get-tree"
																r.pathPattern = "/repos/{owner}/{repo}/git/trees/{tree_sha}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										}

									case 'h': // Prefix: "hooks"

										if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ReposListWebhooksOperation
												r.summary = "List repository webhooks"
												r.operationID = "repos/list-webhooks"
												r.pathPattern = "/repos/{owner}/{repo}/hooks"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												r.name = ReposCreateWebhookOperation
												r.summary = "Create a repository webhook"
												r.operationID = "repos/create-webhook"
												r.pathPattern = "/repos/{owner}/{repo}/hooks"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "hook_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = ReposDeleteWebhookOperation
													r.summary = "Delete a repository webhook"
													r.operationID = "repos/delete-webhook"
													r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = ReposGetWebhookOperation
													r.summary = "Get a repository webhook"
													r.operationID = "repos/get-webhook"
													r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}"
													r.args = args
													r.count = 3
													return r, true
												case "PATCH":
													r.name = ReposUpdateWebhookOperation
													r.summary = "Update a repository webhook"
													r.operationID = "repos/update-webhook"
													r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"

													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetWebhookConfigForRepoOperation
															r.summary = "Get a webhook configuration for a repository"
															r.operationID = "repos/get-webhook-config-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/config"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															r.name = ReposUpdateWebhookConfigForRepoOperation
															r.summary = "Update a webhook configuration for a repository"
															r.operationID = "repos/update-webhook-config-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/config"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												case 'd': // Prefix: "deliveries"

													if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ReposListWebhookDeliveriesOperation
															r.summary = "List deliveries for a repository webhook"
															r.operationID = "repos/list-webhook-deliveries"
															r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "delivery_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ReposGetWebhookDeliveryOperation
																r.summary = "Get a delivery for a repository webhook"
																r.operationID = "repos/get-webhook-delivery"
																r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/attempts"

															if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "POST":
																	r.name = ReposRedeliverWebhookDeliveryOperation
																	r.summary = "Redeliver a delivery for a repository webhook"
																	r.operationID = "repos/redeliver-webhook-delivery"
																	r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}

														}

													}

												case 'p': // Prefix: "pings"

													if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = ReposPingWebhookOperation
															r.summary = "Ping a repository webhook"
															r.operationID = "repos/ping-webhook"
															r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/pings"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												case 't': // Prefix: "tests"

													if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = ReposTestPushWebhookOperation
															r.summary = "Test the push repository webhook"
															r.operationID = "repos/test-push-webhook"
															r.pathPattern = "/repos/{owner}/{repo}/hooks/{hook_id}/tests"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									case 'i': // Prefix: "i"

										if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'm': // Prefix: "mport"

											if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = MigrationsCancelImportOperation
													r.summary = "Cancel an import"
													r.operationID = "migrations/cancel-import"
													r.pathPattern = "/repos/{owner}/{repo}/import"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = MigrationsGetImportStatusOperation
													r.summary = "Get an import status"
													r.operationID = "migrations/get-import-status"
													r.pathPattern = "/repos/{owner}/{repo}/import"
													r.args = args
													r.count = 2
													return r, true
												case "PATCH":
													r.name = MigrationsUpdateImportOperation
													r.summary = "Update an import"
													r.operationID = "migrations/update-import"
													r.pathPattern = "/repos/{owner}/{repo}/import"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = MigrationsStartImportOperation
													r.summary = "Start an import"
													r.operationID = "migrations/start-import"
													r.pathPattern = "/repos/{owner}/{repo}/import"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "authors"

													if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = MigrationsGetCommitAuthorsOperation
															r.summary = "Get commit authors"
															r.operationID = "migrations/get-commit-authors"
															r.pathPattern = "/repos/{owner}/{repo}/import/authors"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "author_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "PATCH":
																r.name = MigrationsMapCommitAuthorOperation
																r.summary = "Map a commit author"
																r.operationID = "migrations/map-commit-author"
																r.pathPattern = "/repos/{owner}/{repo}/import/authors/{author_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'l': // Prefix: "l"

													if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "arge_files"

														if l := len("arge_files"); len(elem) >= l && elem[0:l] == "arge_files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = MigrationsGetLargeFilesOperation
																r.summary = "Get large files"
																r.operationID = "migrations/get-large-files"
																r.pathPattern = "/repos/{owner}/{repo}/import/large_files"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'f': // Prefix: "fs"

														if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "PATCH":
																r.name = MigrationsSetLfsPreferenceOperation
																r.summary = "Update Git LFS preference"
																r.operationID = "migrations/set-lfs-preference"
																r.pathPattern = "/repos/{owner}/{repo}/import/lfs"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										case 'n': // Prefix: "n"

											if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "teraction-limits"

												if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = InteractionsRemoveRestrictionsForRepoOperation
														r.summary = "Remove interaction restrictions for a repository"
														r.operationID = "interactions/remove-restrictions-for-repo"
														r.pathPattern = "/repos/{owner}/{repo}/interaction-limits"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = InteractionsSetRestrictionsForRepoOperation
														r.summary = "Set interaction restrictions for a repository"
														r.operationID = "interactions/set-restrictions-for-repo"
														r.pathPattern = "/repos/{owner}/{repo}/interaction-limits"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 'v': // Prefix: "vitations"

												if l := len("vitations"); len(elem) >= l && elem[0:l] == "vitations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = ReposListInvitationsOperation
														r.summary = "List repository invitations"
														r.operationID = "repos/list-invitations"
														r.pathPattern = "/repos/{owner}/{repo}/invitations"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "invitation_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ReposDeleteInvitationOperation
															r.summary = "Delete a repository invitation"
															r.operationID = "repos/delete-invitation"
															r.pathPattern = "/repos/{owner}/{repo}/invitations/{invitation_id}"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															r.name = ReposUpdateInvitationOperation
															r.summary = "Update a repository invitation"
															r.operationID = "repos/update-invitation"
															r.pathPattern = "/repos/{owner}/{repo}/invitations/{invitation_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										case 's': // Prefix: "ssues"

											if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = IssuesListForRepoOperation
													r.summary = "List repository issues"
													r.operationID = "issues/list-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/issues"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = IssuesCreateOperation
													r.summary = "Create an issue"
													r.operationID = "issues/create"
													r.pathPattern = "/repos/{owner}/{repo}/issues"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													origElem := elem
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = IssuesListCommentsForRepoOperation
															r.summary = "List issue comments for a repository"
															r.operationID = "issues/list-comments-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/issues/comments"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = IssuesDeleteCommentOperation
																r.summary = "Delete an issue comment"
																r.operationID = "issues/delete-comment"
																r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = IssuesGetCommentOperation
																r.summary = "Get an issue comment"
																r.operationID = "issues/get-comment"
																r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																r.name = IssuesUpdateCommentOperation
																r.summary = "Update an issue comment"
																r.operationID = "issues/update-comment"
																r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"

															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = ReactionsListForIssueCommentOperation
																	r.summary = "List reactions for an issue comment"
																	r.operationID = "reactions/list-for-issue-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = ReactionsCreateForIssueCommentOperation
																	r.summary = "Create reaction for an issue comment"
																	r.operationID = "reactions/create-for-issue-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "DELETE":
																		r.name = ReactionsDeleteForIssueCommentOperation
																		r.summary = "Delete an issue comment reaction"
																		r.operationID = "reactions/delete-for-issue-comment"
																		r.pathPattern = "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													}

													elem = origElem
												case 'e': // Prefix: "events"
													origElem := elem
													if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = IssuesListEventsForRepoOperation
															r.summary = "List issue events for a repository"
															r.operationID = "issues/list-events-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/issues/events"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "event_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = IssuesGetEventOperation
																r.summary = "Get an issue event"
																r.operationID = "issues/get-event"
																r.pathPattern = "/repos/{owner}/{repo}/issues/events/{event_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

													elem = origElem
												}
												// Param: "issue_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = IssuesGetOperation
														r.summary = "Get an issue"
														r.operationID = "issues/get"
														r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = IssuesUpdateOperation
														r.summary = "Update an issue"
														r.operationID = "issues/update"
														r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assignees"

														if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "DELETE":
																r.name = IssuesRemoveAssigneesOperation
																r.summary = "Remove assignees from an issue"
																r.operationID = "issues/remove-assignees"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/assignees"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = IssuesAddAssigneesOperation
																r.summary = "Add assignees to an issue"
																r.operationID = "issues/add-assignees"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/assignees"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													case 'c': // Prefix: "comments"

														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = IssuesListCommentsOperation
																r.summary = "List issue comments"
																r.operationID = "issues/list-comments"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/comments"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = IssuesCreateCommentOperation
																r.summary = "Create an issue comment"
																r.operationID = "issues/create-comment"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/comments"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													case 'l': // Prefix: "l"

														if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "abels"

															if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "DELETE":
																	r.name = IssuesRemoveAllLabelsOperation
																	r.summary = "Remove all labels from an issue"
																	r.operationID = "issues/remove-all-labels"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/labels"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = IssuesListLabelsOnIssueOperation
																	r.summary = "List labels for an issue"
																	r.operationID = "issues/list-labels-on-issue"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/labels"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "name"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "DELETE":
																		r.name = IssuesRemoveLabelOperation
																		r.summary = "Remove a label from an issue"
																		r.operationID = "issues/remove-label"
																		r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}

															}

														case 'o': // Prefix: "ock"

															if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = IssuesUnlockOperation
																	r.summary = "Unlock an issue"
																	r.operationID = "issues/unlock"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/lock"
																	r.args = args
																	r.count = 3
																	return r, true
																case "PUT":
																	r.name = IssuesLockOperation
																	r.summary = "Lock an issue"
																	r.operationID = "issues/lock"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/lock"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													case 'r': // Prefix: "reactions"

														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = ReactionsListForIssueOperation
																r.summary = "List reactions for an issue"
																r.operationID = "reactions/list-for-issue"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = ReactionsCreateForIssueOperation
																r.summary = "Create reaction for an issue"
																r.operationID = "reactions/create-for-issue"
																r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "reaction_id"
															// Leaf parameter, slashes are prohibited
															idx := strings.IndexByte(elem, '/')
															if idx >= 0 {
																break
															}
															args[3] = elem
															elem = ""

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = ReactionsDeleteForIssueOperation
																	r.summary = "Delete an issue reaction"
																	r.operationID = "reactions/delete-for-issue"
																	r.pathPattern = "/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											}

										}

									case 'k': // Prefix: "keys"

										if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ReposListDeployKeysOperation
												r.summary = "List deploy keys"
												r.operationID = "repos/list-deploy-keys"
												r.pathPattern = "/repos/{owner}/{repo}/keys"
												r.args = args
												r.count = 2
												return r, true
											case "POST":
												r.name = ReposCreateDeployKeyOperation
												r.summary = "Create a deploy key"
												r.operationID = "repos/create-deploy-key"
												r.pathPattern = "/repos/{owner}/{repo}/keys"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "key_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = ReposDeleteDeployKeyOperation
													r.summary = "Delete a deploy key"
													r.operationID = "repos/delete-deploy-key"
													r.pathPattern = "/repos/{owner}/{repo}/keys/{key_id}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = ReposGetDeployKeyOperation
													r.summary = "Get a deploy key"
													r.operationID = "repos/get-deploy-key"
													r.pathPattern = "/repos/{owner}/{repo}/keys/{key_id}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}

										}

									case 'l': // Prefix: "l"

										if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"

											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bels"

												if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = IssuesListLabelsForRepoOperation
														r.summary = "List labels for a repository"
														r.operationID = "issues/list-labels-for-repo"
														r.pathPattern = "/repos/{owner}/{repo}/labels"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = IssuesCreateLabelOperation
														r.summary = "Create a label"
														r.operationID = "issues/create-label"
														r.pathPattern = "/repos/{owner}/{repo}/labels"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "name"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = IssuesDeleteLabelOperation
															r.summary = "Delete a label"
															r.operationID = "issues/delete-label"
															r.pathPattern = "/repos/{owner}/{repo}/labels/{name}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = IssuesGetLabelOperation
															r.summary = "Get a label"
															r.operationID = "issues/get-label"
															r.pathPattern = "/repos/{owner}/{repo}/labels/{name}"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															r.name = IssuesUpdateLabelOperation
															r.summary = "Update a label"
															r.operationID = "issues/update-label"
															r.pathPattern = "/repos/{owner}/{repo}/labels/{name}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											case 'n': // Prefix: "nguages"

												if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ReposListLanguagesOperation
														r.summary = "List repository languages"
														r.operationID = "repos/list-languages"
														r.pathPattern = "/repos/{owner}/{repo}/languages"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 'f': // Prefix: "fs"

											if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = ReposDisableLfsForRepoOperation
													r.summary = "Disable Git LFS for a repository"
													r.operationID = "repos/disable-lfs-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/lfs"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = ReposEnableLfsForRepoOperation
													r.summary = "Enable Git LFS for a repository"
													r.operationID = "repos/enable-lfs-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/lfs"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'i': // Prefix: "icense"

											if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = LicensesGetForRepoOperation
													r.summary = "Get the license for a repository"
													r.operationID = "licenses/get-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/license"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									case 'm': // Prefix: "m"

										if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "erge"

											if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '-': // Prefix: "-upstream"

												if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = ReposMergeUpstreamOperation
														r.summary = "Sync a fork branch with the upstream repository"
														r.operationID = "repos/merge-upstream"
														r.pathPattern = "/repos/{owner}/{repo}/merge-upstream"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 's': // Prefix: "s"

												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = ReposMergeOperation
														r.summary = "Merge a branch"
														r.operationID = "repos/merge"
														r.pathPattern = "/repos/{owner}/{repo}/merges"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 'i': // Prefix: "ilestones"

											if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = IssuesListMilestonesOperation
													r.summary = "List milestones"
													r.operationID = "issues/list-milestones"
													r.pathPattern = "/repos/{owner}/{repo}/milestones"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = IssuesCreateMilestoneOperation
													r.summary = "Create a milestone"
													r.operationID = "issues/create-milestone"
													r.pathPattern = "/repos/{owner}/{repo}/milestones"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "milestone_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = IssuesDeleteMilestoneOperation
														r.summary = "Delete a milestone"
														r.operationID = "issues/delete-milestone"
														r.pathPattern = "/repos/{owner}/{repo}/milestones/{milestone_number}"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = IssuesGetMilestoneOperation
														r.summary = "Get a milestone"
														r.operationID = "issues/get-milestone"
														r.pathPattern = "/repos/{owner}/{repo}/milestones/{milestone_number}"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = IssuesUpdateMilestoneOperation
														r.summary = "Update a milestone"
														r.operationID = "issues/update-milestone"
														r.pathPattern = "/repos/{owner}/{repo}/milestones/{milestone_number}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/labels"

													if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = IssuesListLabelsForMilestoneOperation
															r.summary = "List labels for issues in a milestone"
															r.operationID = "issues/list-labels-for-milestone"
															r.pathPattern = "/repos/{owner}/{repo}/milestones/{milestone_number}/labels"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									case 'n': // Prefix: "notifications"

										if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ActivityListRepoNotificationsForAuthenticatedUserOperation
												r.summary = "List repository notifications for the authenticated user"
												r.operationID = "activity/list-repo-notifications-for-authenticated-user"
												r.pathPattern = "/repos/{owner}/{repo}/notifications"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = ActivityMarkRepoNotificationsAsReadOperation
												r.summary = "Mark repository notifications as read"
												r.operationID = "activity/mark-repo-notifications-as-read"
												r.pathPattern = "/repos/{owner}/{repo}/notifications"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									case 'p': // Prefix: "p"

										if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ages"

											if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = ReposDeletePagesSiteOperation
													r.summary = "Delete a GitHub Pages site"
													r.operationID = "repos/delete-pages-site"
													r.pathPattern = "/repos/{owner}/{repo}/pages"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = ReposGetPagesOperation
													r.summary = "Get a GitHub Pages site"
													r.operationID = "repos/get-pages"
													r.pathPattern = "/repos/{owner}/{repo}/pages"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = ReposCreatePagesSiteOperation
													r.summary = "Create a GitHub Pages site"
													r.operationID = "repos/create-pages-site"
													r.pathPattern = "/repos/{owner}/{repo}/pages"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'b': // Prefix: "builds"

													if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = ReposListPagesBuildsOperation
															r.summary = "List GitHub Pages builds"
															r.operationID = "repos/list-pages-builds"
															r.pathPattern = "/repos/{owner}/{repo}/pages/builds"
															r.args = args
															r.count = 2
															return r, true
														case "POST":
															r.name = ReposRequestPagesBuildOperation
															r.summary = "Request a GitHub Pages build"
															r.operationID = "repos/request-pages-build"
															r.pathPattern = "/repos/{owner}/{repo}/pages/builds"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'l': // Prefix: "latest"
															origElem := elem
															if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = ReposGetLatestPagesBuildOperation
																	r.summary = "Get latest Pages build"
																	r.operationID = "repos/get-latest-pages-build"
																	r.pathPattern = "/repos/{owner}/{repo}/pages/builds/latest"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}

															elem = origElem
														}
														// Param: "build_id"
														// Leaf parameter, slashes are prohibited
														idx := strings.IndexByte(elem, '/')
														if idx >= 0 {
															break
														}
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetPagesBuildOperation
																r.summary = "Get GitHub Pages build"
																r.operationID = "repos/get-pages-build"
																r.pathPattern = "/repos/{owner}/{repo}/pages/builds/{build_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												case 'h': // Prefix: "health"

													if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetPagesHealthCheckOperation
															r.summary = "Get a DNS health check for GitHub Pages"
															r.operationID = "repos/get-pages-health-check"
															r.pathPattern = "/repos/{owner}/{repo}/pages/health"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											}

										case 'r': // Prefix: "rojects"

											if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ProjectsListForRepoOperation
													r.summary = "List repository projects"
													r.operationID = "projects/list-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/projects"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = ProjectsCreateForRepoOperation
													r.summary = "Create a repository project"
													r.operationID = "projects/create-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/projects"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'u': // Prefix: "ulls"

											if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = PullsListOperation
													r.summary = "List pull requests"
													r.operationID = "pulls/list"
													r.pathPattern = "/repos/{owner}/{repo}/pulls"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = PullsCreateOperation
													r.summary = "Create a pull request"
													r.operationID = "pulls/create"
													r.pathPattern = "/repos/{owner}/{repo}/pulls"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													origElem := elem
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = PullsListReviewCommentsForRepoOperation
															r.summary = "List review comments in a repository"
															r.operationID = "pulls/list-review-comments-for-repo"
															r.pathPattern = "/repos/{owner}/{repo}/pulls/comments"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = PullsDeleteReviewCommentOperation
																r.summary = "Delete a review comment for a pull request"
																r.operationID = "pulls/delete-review-comment"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															case "GET":
																r.name = PullsGetReviewCommentOperation
																r.summary = "Get a review comment for a pull request"
																r.operationID = "pulls/get-review-comment"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															case "PATCH":
																r.name = PullsUpdateReviewCommentOperation
																r.summary = "Update a review comment for a pull request"
																r.operationID = "pulls/update-review-comment"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"

															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = ReactionsListForPullRequestReviewCommentOperation
																	r.summary = "List reactions for a pull request review comment"
																	r.operationID = "reactions/list-for-pull-request-review-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = ReactionsCreateForPullRequestReviewCommentOperation
																	r.summary = "Create reaction for a pull request review comment"
																	r.operationID = "reactions/create-for-pull-request-review-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "reaction_id"
																// Leaf parameter, slashes are prohibited
																idx := strings.IndexByte(elem, '/')
																if idx >= 0 {
																	break
																}
																args[3] = elem
																elem = ""

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "DELETE":
																		r.name = ReactionsDeleteForPullRequestCommentOperation
																		r.summary = "Delete a pull request comment reaction"
																		r.operationID = "reactions/delete-for-pull-request-comment"
																		r.pathPattern = "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													}

													elem = origElem
												}
												// Param: "pull_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = PullsGetOperation
														r.summary = "Get a pull request"
														r.operationID = "pulls/get"
														r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = PullsUpdateOperation
														r.summary = "Update a pull request"
														r.operationID = "pulls/update"
														r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "comm"

														if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'e': // Prefix: "ents"

															if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = PullsListReviewCommentsOperation
																	r.summary = "List review comments on a pull request"
																	r.operationID = "pulls/list-review-comments"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/comments"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = PullsCreateReviewCommentOperation
																	r.summary = "Create a review comment for a pull request"
																	r.operationID = "pulls/create-review-comment"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/comments"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "comment_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	break
																}
																switch elem[0] {
																case '/': // Prefix: "/replies"

																	if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf node.
																		switch method {
																		case "POST":
																			r.name = PullsCreateReplyForReviewCommentOperation
																			r.summary = "Create a reply for a review comment"
																			r.operationID = "pulls/create-reply-for-review-comment"
																			r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
																			r.args = args
																			r.count = 4
																			return r, true
																		default:
																			return
																		}
																	}

																}

															}

														case 'i': // Prefix: "its"

															if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = PullsListCommitsOperation
																	r.summary = "List commits on a pull request"
																	r.operationID = "pulls/list-commits"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/commits"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														}

													case 'f': // Prefix: "files"

														if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = PullsListFilesOperation
																r.summary = "List pull requests files"
																r.operationID = "pulls/list-files"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/files"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													case 'm': // Prefix: "merge"

														if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = PullsCheckIfMergedOperation
																r.summary = "Check if a pull request has been merged"
																r.operationID = "pulls/check-if-merged"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/merge"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																r.name = PullsMergeOperation
																r.summary = "Merge a pull request"
																r.operationID = "pulls/merge"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/merge"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													case 'r': // Prefix: "re"

														if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'q': // Prefix: "quested_reviewers"

															if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "DELETE":
																	r.name = PullsRemoveRequestedReviewersOperation
																	r.summary = "Remove requested reviewers from a pull request"
																	r.operationID = "pulls/remove-requested-reviewers"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
																	r.args = args
																	r.count = 3
																	return r, true
																case "GET":
																	r.name = PullsListRequestedReviewersOperation
																	r.summary = "List requested reviewers for a pull request"
																	r.operationID = "pulls/list-requested-reviewers"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}

														case 'v': // Prefix: "views"

															if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = PullsListReviewsOperation
																	r.summary = "List reviews for a pull request"
																	r.operationID = "pulls/list-reviews"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
																	r.args = args
																	r.count = 3
																	return r, true
																case "POST":
																	r.name = PullsCreateReviewOperation
																	r.summary = "Create a review for a pull request"
																	r.operationID = "pulls/create-review"
																	r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/"

																if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																	elem = elem[l:]
																} else {
																	break
																}

																// Param: "review_id"
																// Match until "/"
																idx := strings.IndexByte(elem, '/')
																if idx < 0 {
																	idx = len(elem)
																}
																args[3] = elem[:idx]
																elem = elem[idx:]

																if len(elem) == 0 {
																	switch method {
																	case "DELETE":
																		r.name = PullsDeletePendingReviewOperation
																		r.summary = "Delete a pending review for a pull request"
																		r.operationID = "pulls/delete-pending-review"
																		r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "GET":
																		r.name = PullsGetReviewOperation
																		r.summary = "Get a review for a pull request"
																		r.operationID = "pulls/get-review"
																		r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	case "PUT":
																		r.name = PullsUpdateReviewOperation
																		r.summary = "Update a review for a pull request"
																		r.operationID = "pulls/update-review"
																		r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
																		r.args = args
																		r.count = 4
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case 'c': // Prefix: "comments"

																		if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "GET":
																				r.name = PullsListCommentsForReviewOperation
																				r.summary = "List comments for a pull request review"
																				r.operationID = "pulls/list-comments-for-review"
																				r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}

																	case 'd': // Prefix: "dismissals"

																		if l := len("dismissals"); len(elem) >= l && elem[0:l] == "dismissals" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "PUT":
																				r.name = PullsDismissReviewOperation
																				r.summary = "Dismiss a review for a pull request"
																				r.operationID = "pulls/dismiss-review"
																				r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}

																	case 'e': // Prefix: "events"

																		if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "POST":
																				r.name = PullsSubmitReviewOperation
																				r.summary = "Submit a review for a pull request"
																				r.operationID = "pulls/submit-review"
																				r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
																				r.args = args
																				r.count = 4
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																}

															}

														}

													case 'u': // Prefix: "update-branch"

														if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "PUT":
																r.name = PullsUpdateBranchOperation
																r.summary = "Update a pull request branch"
																r.operationID = "pulls/update-branch"
																r.pathPattern = "/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										}

									case 'r': // Prefix: "re"

										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "adme"

											if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ReposGetReadmeOperation
													r.summary = "Get a repository README"
													r.operationID = "repos/get-readme"
													r.pathPattern = "/repos/{owner}/{repo}/readme"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "dir"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ReposGetReadmeInDirectoryOperation
														r.summary = "Get a repository README for a directory"
														r.operationID = "repos/get-readme-in-directory"
														r.pathPattern = "/repos/{owner}/{repo}/readme/{dir}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 'l': // Prefix: "leases"

											if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = ReposListReleasesOperation
													r.summary = "List releases"
													r.operationID = "repos/list-releases"
													r.pathPattern = "/repos/{owner}/{repo}/releases"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = ReposCreateReleaseOperation
													r.summary = "Create a release"
													r.operationID = "repos/create-release"
													r.pathPattern = "/repos/{owner}/{repo}/releases"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "assets/"
													origElem := elem
													if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "asset_id"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "DELETE":
															r.name = ReposDeleteReleaseAssetOperation
															r.summary = "Delete a release asset"
															r.operationID = "repos/delete-release-asset"
															r.pathPattern = "/repos/{owner}/{repo}/releases/assets/{asset_id}"
															r.args = args
															r.count = 3
															return r, true
														case "GET":
															r.name = ReposGetReleaseAssetOperation
															r.summary = "Get a release asset"
															r.operationID = "repos/get-release-asset"
															r.pathPattern = "/repos/{owner}/{repo}/releases/assets/{asset_id}"
															r.args = args
															r.count = 3
															return r, true
														case "PATCH":
															r.name = ReposUpdateReleaseAssetOperation
															r.summary = "Update a release asset"
															r.operationID = "repos/update-release-asset"
															r.pathPattern = "/repos/{owner}/{repo}/releases/assets/{asset_id}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

													elem = origElem
												case 'l': // Prefix: "latest"
													origElem := elem
													if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetLatestReleaseOperation
															r.summary = "Get the latest release"
															r.operationID = "repos/get-latest-release"
															r.pathPattern = "/repos/{owner}/{repo}/releases/latest"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

													elem = origElem
												case 't': // Prefix: "tags/"
													origElem := elem
													if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "tag"
													// Leaf parameter, slashes are prohibited
													idx := strings.IndexByte(elem, '/')
													if idx >= 0 {
														break
													}
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetReleaseByTagOperation
															r.summary = "Get a release by tag name"
															r.operationID = "repos/get-release-by-tag"
															r.pathPattern = "/repos/{owner}/{repo}/releases/tags/{tag}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

													elem = origElem
												}
												// Param: "release_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = ReposDeleteReleaseOperation
														r.summary = "Delete a release"
														r.operationID = "repos/delete-release"
														r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = ReposGetReleaseOperation
														r.summary = "Get a release"
														r.operationID = "repos/get-release"
														r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = ReposUpdateReleaseOperation
														r.summary = "Update a release"
														r.operationID = "repos/update-release"
														r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "assets"

														if l := len("assets"); len(elem) >= l && elem[0:l] == "assets" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposListReleaseAssetsOperation
																r.summary = "List release assets"
																r.operationID = "repos/list-release-assets"
																r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}/assets"
																r.args = args
																r.count = 3
																return r, true
															case "POST":
																r.name = ReposUploadReleaseAssetOperation
																r.summary = "Upload a release asset"
																r.operationID = "repos/upload-release-asset"
																r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}/assets"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													case 'r': // Prefix: "reactions"

														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "POST":
																r.name = ReactionsCreateForReleaseOperation
																r.summary = "Create reaction for a release"
																r.operationID = "reactions/create-for-release"
																r.pathPattern = "/repos/{owner}/{repo}/releases/{release_id}/reactions"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "ecret-scanning/alerts"

											if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = SecretScanningListAlertsForRepoOperation
													r.summary = "List secret scanning alerts for a repository"
													r.operationID = "secret-scanning/list-alerts-for-repo"
													r.pathPattern = "/repos/{owner}/{repo}/secret-scanning/alerts"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "alert_number"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = SecretScanningGetAlertOperation
														r.summary = "Get a secret scanning alert"
														r.operationID = "secret-scanning/get-alert"
														r.pathPattern = "/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
														r.args = args
														r.count = 3
														return r, true
													case "PATCH":
														r.name = SecretScanningUpdateAlertOperation
														r.summary = "Update a secret scanning alert"
														r.operationID = "secret-scanning/update-alert"
														r.pathPattern = "/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 't': // Prefix: "tat"

											if l := len("tat"); len(elem) >= l && elem[0:l] == "tat" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 's': // Prefix: "s/"

												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "co"

													if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "de_frequency"

														if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetCodeFrequencyStatsOperation
																r.summary = "Get the weekly commit activity"
																r.operationID = "repos/get-code-frequency-stats"
																r.pathPattern = "/repos/{owner}/{repo}/stats/code_frequency"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'm': // Prefix: "mmit_activity"

														if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetCommitActivityStatsOperation
																r.summary = "Get the last year of commit activity"
																r.operationID = "repos/get-commit-activity-stats"
																r.pathPattern = "/repos/{owner}/{repo}/stats/commit_activity"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'n': // Prefix: "ntributors"

														if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetContributorsStatsOperation
																r.summary = "Get all contributor commit activity"
																r.operationID = "repos/get-contributors-stats"
																r.pathPattern = "/repos/{owner}/{repo}/stats/contributors"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												case 'p': // Prefix: "p"

													if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'a': // Prefix: "articipation"

														if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetParticipationStatsOperation
																r.summary = "Get the weekly commit count"
																r.operationID = "repos/get-participation-stats"
																r.pathPattern = "/repos/{owner}/{repo}/stats/participation"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'u': // Prefix: "unch_card"

														if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetPunchCardStatsOperation
																r.summary = "Get the hourly commit count for each day"
																r.operationID = "repos/get-punch-card-stats"
																r.pathPattern = "/repos/{owner}/{repo}/stats/punch_card"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												}

											case 'u': // Prefix: "uses/"

												if l := len("uses/"); len(elem) >= l && elem[0:l] == "uses/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sha"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = ReposCreateCommitStatusOperation
														r.summary = "Create a commit status"
														r.operationID = "repos/create-commit-status"
														r.pathPattern = "/repos/{owner}/{repo}/statuses/{sha}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 'u': // Prefix: "ubscri"

											if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'b': // Prefix: "bers"

												if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ActivityListWatchersForRepoOperation
														r.summary = "List watchers"
														r.operationID = "activity/list-watchers-for-repo"
														r.pathPattern = "/repos/{owner}/{repo}/subscribers"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 'p': // Prefix: "ption"

												if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = ActivityDeleteRepoSubscriptionOperation
														r.summary = "Delete a repository subscription"
														r.operationID = "activity/delete-repo-subscription"
														r.pathPattern = "/repos/{owner}/{repo}/subscription"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														r.name = ActivityGetRepoSubscriptionOperation
														r.summary = "Get a repository subscription"
														r.operationID = "activity/get-repo-subscription"
														r.pathPattern = "/repos/{owner}/{repo}/subscription"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														r.name = ActivitySetRepoSubscriptionOperation
														r.summary = "Set a repository subscription"
														r.operationID = "activity/set-repo-subscription"
														r.pathPattern = "/repos/{owner}/{repo}/subscription"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									case 't': // Prefix: "t"

										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "a"

											if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'g': // Prefix: "gs"

												if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ReposListTagsOperation
														r.summary = "List repository tags"
														r.operationID = "repos/list-tags"
														r.pathPattern = "/repos/{owner}/{repo}/tags"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											case 'r': // Prefix: "rball/"

												if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "ref"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ReposDownloadTarballArchiveOperation
														r.summary = "Download a repository archive (tar)"
														r.operationID = "repos/download-tarball-archive"
														r.pathPattern = "/repos/{owner}/{repo}/tarball/{ref}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 'e': // Prefix: "eams"

											if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ReposListTeamsOperation
													r.summary = "List repository teams"
													r.operationID = "repos/list-teams"
													r.pathPattern = "/repos/{owner}/{repo}/teams"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'o': // Prefix: "opics"

											if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ReposGetAllTopicsOperation
													r.summary = "Get all repository topics"
													r.operationID = "repos/get-all-topics"
													r.pathPattern = "/repos/{owner}/{repo}/topics"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = ReposReplaceAllTopicsOperation
													r.summary = "Replace all repository topics"
													r.operationID = "repos/replace-all-topics"
													r.pathPattern = "/repos/{owner}/{repo}/topics"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'r': // Prefix: "ra"

											if l := len("ra"); len(elem) >= l && elem[0:l] == "ra" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "ffic/"

												if l := len("ffic/"); len(elem) >= l && elem[0:l] == "ffic/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "clones"

													if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetClonesOperation
															r.summary = "Get repository clones"
															r.operationID = "repos/get-clones"
															r.pathPattern = "/repos/{owner}/{repo}/traffic/clones"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												case 'p': // Prefix: "popular/"

													if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'p': // Prefix: "paths"

														if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetTopPathsOperation
																r.summary = "Get top referral paths"
																r.operationID = "repos/get-top-paths"
																r.pathPattern = "/repos/{owner}/{repo}/traffic/popular/paths"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'r': // Prefix: "referrers"

														if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = ReposGetTopReferrersOperation
																r.summary = "Get top referral sources"
																r.operationID = "repos/get-top-referrers"
																r.pathPattern = "/repos/{owner}/{repo}/traffic/popular/referrers"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												case 'v': // Prefix: "views"

													if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = ReposGetViewsOperation
															r.summary = "Get page views"
															r.operationID = "repos/get-views"
															r.pathPattern = "/repos/{owner}/{repo}/traffic/views"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											case 'n': // Prefix: "nsfer"

												if l := len("nsfer"); len(elem) >= l && elem[0:l] == "nsfer" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = ReposTransferOperation
														r.summary = "Transfer a repository"
														r.operationID = "repos/transfer"
														r.pathPattern = "/repos/{owner}/{repo}/transfer"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									case 'v': // Prefix: "vulnerability-alerts"

										if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = ReposDisableVulnerabilityAlertsOperation
												r.summary = "Disable vulnerability alerts"
												r.operationID = "repos/disable-vulnerability-alerts"
												r.pathPattern = "/repos/{owner}/{repo}/vulnerability-alerts"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = ReposCheckVulnerabilityAlertsOperation
												r.summary = "Check if vulnerability alerts are enabled for a repository"
												r.operationID = "repos/check-vulnerability-alerts"
												r.pathPattern = "/repos/{owner}/{repo}/vulnerability-alerts"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = ReposEnableVulnerabilityAlertsOperation
												r.summary = "Enable vulnerability alerts"
												r.operationID = "repos/enable-vulnerability-alerts"
												r.pathPattern = "/repos/{owner}/{repo}/vulnerability-alerts"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									case 'z': // Prefix: "zipball/"

										if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ReposDownloadZipballArchiveOperation
												r.summary = "Download a repository archive (zip)"
												r.operationID = "repos/download-zipball-archive"
												r.pathPattern = "/repos/{owner}/{repo}/zipball/{ref}"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 'i': // Prefix: "itories"

							if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ReposListPublicOperation
									r.summary = "List public repositories"
									r.operationID = "repos/list-public"
									r.pathPattern = "/repositories"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/environments/"

									if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/secrets"

										if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ActionsListEnvironmentSecretsOperation
												r.summary = "List environment secrets"
												r.operationID = "actions/list-environment-secrets"
												r.pathPattern = "/repositories/{repository_id}/environments/{environment_name}/secrets"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'p': // Prefix: "public-key"
												origElem := elem
												if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = ActionsGetEnvironmentPublicKeyOperation
														r.summary = "Get an environment public key"
														r.operationID = "actions/get-environment-public-key"
														r.pathPattern = "/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}
											// Param: "secret_name"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = ActionsDeleteEnvironmentSecretOperation
													r.summary = "Delete an environment secret"
													r.operationID = "actions/delete-environment-secret"
													r.pathPattern = "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = ActionsGetEnvironmentSecretOperation
													r.summary = "Get an environment secret"
													r.operationID = "actions/get-environment-secret"
													r.pathPattern = "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
													r.args = args
													r.count = 3
													return r, true
												case "PUT":
													r.name = ActionsCreateOrUpdateEnvironmentSecretOperation
													r.summary = "Create or update an environment secret"
													r.operationID = "actions/create-or-update-environment-secret"
													r.pathPattern = "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						}

					}

				}

			case 's': // Prefix: "s"

				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/"

					if l := len("cim/v2/"); len(elem) >= l && elem[0:l] == "cim/v2/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "enterprises/"

						if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "enterprise"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'G': // Prefix: "Groups"

								if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = EnterpriseAdminListProvisionedGroupsEnterpriseOperation
										r.summary = "List provisioned SCIM groups for an enterprise"
										r.operationID = "enterprise-admin/list-provisioned-groups-enterprise"
										r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = EnterpriseAdminProvisionAndInviteEnterpriseGroupOperation
										r.summary = "Provision a SCIM enterprise group and invite users"
										r.operationID = "enterprise-admin/provision-and-invite-enterprise-group"
										r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_group_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = EnterpriseAdminDeleteScimGroupFromEnterpriseOperation
											r.summary = "Delete a SCIM group from an enterprise"
											r.operationID = "enterprise-admin/delete-scim-group-from-enterprise"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = EnterpriseAdminGetProvisioningInformationForEnterpriseGroupOperation
											r.summary = "Get SCIM provisioning information for an enterprise group"
											r.operationID = "enterprise-admin/get-provisioning-information-for-enterprise-group"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											r.name = EnterpriseAdminUpdateAttributeForEnterpriseGroupOperation
											r.summary = "Update an attribute for a SCIM enterprise group"
											r.operationID = "enterprise-admin/update-attribute-for-enterprise-group"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = EnterpriseAdminSetInformationForProvisionedEnterpriseGroupOperation
											r.summary = "Set SCIM information for a provisioned enterprise group"
											r.operationID = "enterprise-admin/set-information-for-provisioned-enterprise-group"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							case 'U': // Prefix: "Users"

								if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = EnterpriseAdminListProvisionedIdentitiesEnterpriseOperation
										r.summary = "List SCIM provisioned identities for an enterprise"
										r.operationID = "enterprise-admin/list-provisioned-identities-enterprise"
										r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = EnterpriseAdminProvisionAndInviteEnterpriseUserOperation
										r.summary = "Provision and invite a SCIM enterprise user"
										r.operationID = "enterprise-admin/provision-and-invite-enterprise-user"
										r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "scim_user_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = EnterpriseAdminDeleteUserFromEnterpriseOperation
											r.summary = "Delete a SCIM user from an enterprise"
											r.operationID = "enterprise-admin/delete-user-from-enterprise"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = EnterpriseAdminGetProvisioningInformationForEnterpriseUserOperation
											r.summary = "Get SCIM provisioning information for an enterprise user"
											r.operationID = "enterprise-admin/get-provisioning-information-for-enterprise-user"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PATCH":
											r.name = EnterpriseAdminUpdateAttributeForEnterpriseUserOperation
											r.summary = "Update an attribute for a SCIM enterprise user"
											r.operationID = "enterprise-admin/update-attribute-for-enterprise-user"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = EnterpriseAdminSetInformationForProvisionedEnterpriseUserOperation
											r.summary = "Set SCIM information for a provisioned enterprise user"
											r.operationID = "enterprise-admin/set-information-for-provisioned-enterprise-user"
											r.pathPattern = "/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'o': // Prefix: "organizations/"

						if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/Users/"

							if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = ScimDeleteUserFromOrgOperation
									r.summary = "Delete a SCIM user from an organization"
									r.operationID = "scim/delete-user-from-org"
									r.pathPattern = "/scim/v2/organizations/{org}/Users/{scim_user_id}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'e': // Prefix: "earch/"

					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "co"

						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "de"

							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = SearchCodeOperation
									r.summary = "Search code"
									r.operationID = "search/code"
									r.pathPattern = "/search/code"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'm': // Prefix: "mmits"

							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = SearchCommitsOperation
									r.summary = "Search commits"
									r.operationID = "search/commits"
									r.pathPattern = "/search/commits"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'i': // Prefix: "issues"

						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = SearchIssuesAndPullRequestsOperation
								r.summary = "Search issues and pull requests"
								r.operationID = "search/issues-and-pull-requests"
								r.pathPattern = "/search/issues"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "labels"

						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = SearchLabelsOperation
								r.summary = "Search labels"
								r.operationID = "search/labels"
								r.pathPattern = "/search/labels"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "repositories"

						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = SearchReposOperation
								r.summary = "Search repositories"
								r.operationID = "search/repos"
								r.pathPattern = "/search/repositories"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "topics"

						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = SearchTopicsOperation
								r.summary = "Search topics"
								r.operationID = "search/topics"
								r.pathPattern = "/search/topics"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "users"

						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = SearchUsersOperation
								r.summary = "Search users"
								r.operationID = "search/users"
								r.pathPattern = "/search/users"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 't': // Prefix: "teams/"

				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch method {
					case "DELETE":
						r.name = TeamsDeleteLegacyOperation
						r.summary = "Delete a team (Legacy)"
						r.operationID = "teams/delete-legacy"
						r.pathPattern = "/teams/{team_id}"
						r.args = args
						r.count = 1
						return r, true
					case "GET":
						r.name = TeamsGetLegacyOperation
						r.summary = "Get a team (Legacy)"
						r.operationID = "teams/get-legacy"
						r.pathPattern = "/teams/{team_id}"
						r.args = args
						r.count = 1
						return r, true
					case "PATCH":
						r.name = TeamsUpdateLegacyOperation
						r.summary = "Update a team (Legacy)"
						r.operationID = "teams/update-legacy"
						r.pathPattern = "/teams/{team_id}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"

						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = TeamsListDiscussionsLegacyOperation
								r.summary = "List discussions (Legacy)"
								r.operationID = "teams/list-discussions-legacy"
								r.pathPattern = "/teams/{team_id}/discussions"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = TeamsCreateDiscussionLegacyOperation
								r.summary = "Create a discussion (Legacy)"
								r.operationID = "teams/create-discussion-legacy"
								r.pathPattern = "/teams/{team_id}/discussions"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = TeamsDeleteDiscussionLegacyOperation
									r.summary = "Delete a discussion (Legacy)"
									r.operationID = "teams/delete-discussion-legacy"
									r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									r.name = TeamsGetDiscussionLegacyOperation
									r.summary = "Get a discussion (Legacy)"
									r.operationID = "teams/get-discussion-legacy"
									r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}"
									r.args = args
									r.count = 2
									return r, true
								case "PATCH":
									r.name = TeamsUpdateDiscussionLegacyOperation
									r.summary = "Update a discussion (Legacy)"
									r.operationID = "teams/update-discussion-legacy"
									r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"

									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = TeamsListDiscussionCommentsLegacyOperation
											r.summary = "List discussion comments (Legacy)"
											r.operationID = "teams/list-discussion-comments-legacy"
											r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments"
											r.args = args
											r.count = 2
											return r, true
										case "POST":
											r.name = TeamsCreateDiscussionCommentLegacyOperation
											r.summary = "Create a discussion comment (Legacy)"
											r.operationID = "teams/create-discussion-comment-legacy"
											r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = TeamsDeleteDiscussionCommentLegacyOperation
												r.summary = "Delete a discussion comment (Legacy)"
												r.operationID = "teams/delete-discussion-comment-legacy"
												r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
												r.args = args
												r.count = 3
												return r, true
											case "GET":
												r.name = TeamsGetDiscussionCommentLegacyOperation
												r.summary = "Get a discussion comment (Legacy)"
												r.operationID = "teams/get-discussion-comment-legacy"
												r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
												r.args = args
												r.count = 3
												return r, true
											case "PATCH":
												r.name = TeamsUpdateDiscussionCommentLegacyOperation
												r.summary = "Update a discussion comment (Legacy)"
												r.operationID = "teams/update-discussion-comment-legacy"
												r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"

											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ReactionsListForTeamDiscussionCommentLegacyOperation
													r.summary = "List reactions for a team discussion comment (Legacy)"
													r.operationID = "reactions/list-for-team-discussion-comment-legacy"
													r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
													r.args = args
													r.count = 3
													return r, true
												case "POST":
													r.name = ReactionsCreateForTeamDiscussionCommentLegacyOperation
													r.summary = "Create reaction for a team discussion comment (Legacy)"
													r.operationID = "reactions/create-for-team-discussion-comment-legacy"
													r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}

										}

									}

								case 'r': // Prefix: "reactions"

									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ReactionsListForTeamDiscussionLegacyOperation
											r.summary = "List reactions for a team discussion (Legacy)"
											r.operationID = "reactions/list-for-team-discussion-legacy"
											r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/reactions"
											r.args = args
											r.count = 2
											return r, true
										case "POST":
											r.name = ReactionsCreateForTeamDiscussionLegacyOperation
											r.summary = "Create reaction for a team discussion (Legacy)"
											r.operationID = "reactions/create-for-team-discussion-legacy"
											r.pathPattern = "/teams/{team_id}/discussions/{discussion_number}/reactions"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'i': // Prefix: "invitations"

						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TeamsListPendingInvitationsLegacyOperation
								r.summary = "List pending team invitations (Legacy)"
								r.operationID = "teams/list-pending-invitations-legacy"
								r.pathPattern = "/teams/{team_id}/invitations"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'm': // Prefix: "members"

						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = TeamsListMembersLegacyOperation
								r.summary = "List team members (Legacy)"
								r.operationID = "teams/list-members-legacy"
								r.pathPattern = "/teams/{team_id}/members"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = TeamsRemoveMemberLegacyOperation
									r.summary = "Remove team member (Legacy)"
									r.operationID = "teams/remove-member-legacy"
									r.pathPattern = "/teams/{team_id}/members/{username}"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									r.name = TeamsGetMemberLegacyOperation
									r.summary = "Get team member (Legacy)"
									r.operationID = "teams/get-member-legacy"
									r.pathPattern = "/teams/{team_id}/members/{username}"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = TeamsAddMemberLegacyOperation
									r.summary = "Add team member (Legacy)"
									r.operationID = "teams/add-member-legacy"
									r.pathPattern = "/teams/{team_id}/members/{username}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						case 'h': // Prefix: "hips/"

							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = TeamsRemoveMembershipForUserLegacyOperation
									r.summary = "Remove team membership for a user (Legacy)"
									r.operationID = "teams/remove-membership-for-user-legacy"
									r.pathPattern = "/teams/{team_id}/memberships/{username}"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									r.name = TeamsGetMembershipForUserLegacyOperation
									r.summary = "Get team membership for a user (Legacy)"
									r.operationID = "teams/get-membership-for-user-legacy"
									r.pathPattern = "/teams/{team_id}/memberships/{username}"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = TeamsAddOrUpdateMembershipForUserLegacyOperation
									r.summary = "Add or update team membership for a user (Legacy)"
									r.operationID = "teams/add-or-update-membership-for-user-legacy"
									r.pathPattern = "/teams/{team_id}/memberships/{username}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					case 'p': // Prefix: "projects"

						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = TeamsListProjectsLegacyOperation
								r.summary = "List team projects (Legacy)"
								r.operationID = "teams/list-projects-legacy"
								r.pathPattern = "/teams/{team_id}/projects"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = TeamsRemoveProjectLegacyOperation
									r.summary = "Remove a project from a team (Legacy)"
									r.operationID = "teams/remove-project-legacy"
									r.pathPattern = "/teams/{team_id}/projects/{project_id}"
									r.args = args
									r.count = 2
									return r, true
								case "GET":
									r.name = TeamsCheckPermissionsForProjectLegacyOperation
									r.summary = "Check team permissions for a project (Legacy)"
									r.operationID = "teams/check-permissions-for-project-legacy"
									r.pathPattern = "/teams/{team_id}/projects/{project_id}"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = TeamsAddOrUpdateProjectPermissionsLegacyOperation
									r.summary = "Add or update team project permissions (Legacy)"
									r.operationID = "teams/add-or-update-project-permissions-legacy"
									r.pathPattern = "/teams/{team_id}/projects/{project_id}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					case 'r': // Prefix: "repos"

						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = TeamsListReposLegacyOperation
								r.summary = "List team repositories (Legacy)"
								r.operationID = "teams/list-repos-legacy"
								r.pathPattern = "/teams/{team_id}/repos"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = TeamsRemoveRepoLegacyOperation
										r.summary = "Remove a repository from a team (Legacy)"
										r.operationID = "teams/remove-repo-legacy"
										r.pathPattern = "/teams/{team_id}/repos/{owner}/{repo}"
										r.args = args
										r.count = 3
										return r, true
									case "GET":
										r.name = TeamsCheckPermissionsForRepoLegacyOperation
										r.summary = "Check team permissions for a repository (Legacy)"
										r.operationID = "teams/check-permissions-for-repo-legacy"
										r.pathPattern = "/teams/{team_id}/repos/{owner}/{repo}"
										r.args = args
										r.count = 3
										return r, true
									case "PUT":
										r.name = TeamsAddOrUpdateRepoPermissionsLegacyOperation
										r.summary = "Add or update team repository permissions (Legacy)"
										r.operationID = "teams/add-or-update-repo-permissions-legacy"
										r.pathPattern = "/teams/{team_id}/repos/{owner}/{repo}"
										r.args = args
										r.count = 3
										return r, true
									default:
										return
									}
								}

							}

						}

					case 't': // Prefix: "team"

						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"

							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TeamsListIdpGroupsForLegacyOperation
									r.summary = "List IdP groups for a team (Legacy)"
									r.operationID = "teams/list-idp-groups-for-legacy"
									r.pathPattern = "/teams/{team_id}/team-sync/group-mappings"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = TeamsCreateOrUpdateIdpGroupConnectionsLegacyOperation
									r.summary = "Create or update IdP group connections (Legacy)"
									r.operationID = "teams/create-or-update-idp-group-connections-legacy"
									r.pathPattern = "/teams/{team_id}/team-sync/group-mappings"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TeamsListChildLegacyOperation
									r.summary = "List child teams (Legacy)"
									r.operationID = "teams/list-child-legacy"
									r.pathPattern = "/teams/{team_id}/teams"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'u': // Prefix: "user"

				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = UsersGetAuthenticatedOperation
						r.summary = "Get the authenticated user"
						r.operationID = "users/get-authenticated"
						r.pathPattern = "/user"
						r.args = args
						r.count = 0
						return r, true
					case "PATCH":
						r.name = UsersUpdateAuthenticatedOperation
						r.summary = "Update the authenticated user"
						r.operationID = "users/update-authenticated"
						r.pathPattern = "/user"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"

						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = UsersListBlockedByAuthenticatedOperation
								r.summary = "List users blocked by the authenticated user"
								r.operationID = "users/list-blocked-by-authenticated"
								r.pathPattern = "/user/blocks"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = UsersUnblockOperation
									r.summary = "Unblock a user"
									r.operationID = "users/unblock"
									r.pathPattern = "/user/blocks/{username}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = UsersCheckBlockedOperation
									r.summary = "Check if a user is blocked by the authenticated user"
									r.operationID = "users/check-blocked"
									r.pathPattern = "/user/blocks/{username}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = UsersBlockOperation
									r.summary = "Block a user"
									r.operationID = "users/block"
									r.pathPattern = "/user/blocks/{username}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'e': // Prefix: "email"

						if l := len("email"); len(elem) >= l && elem[0:l] == "email" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/visibility"

							if l := len("/visibility"); len(elem) >= l && elem[0:l] == "/visibility" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "PATCH":
									r.name = UsersSetPrimaryEmailVisibilityForAuthenticatedOperation
									r.summary = "Set primary email visibility for the authenticated user"
									r.operationID = "users/set-primary-email-visibility-for-authenticated"
									r.pathPattern = "/user/email/visibility"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = UsersDeleteEmailForAuthenticatedOperation
									r.summary = "Delete an email address for the authenticated user"
									r.operationID = "users/delete-email-for-authenticated"
									r.pathPattern = "/user/emails"
									r.args = args
									r.count = 0
									return r, true
								case "GET":
									r.name = UsersListEmailsForAuthenticatedOperation
									r.summary = "List email addresses for the authenticated user"
									r.operationID = "users/list-emails-for-authenticated"
									r.pathPattern = "/user/emails"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = UsersAddEmailForAuthenticatedOperation
									r.summary = "Add an email address for the authenticated user"
									r.operationID = "users/add-email-for-authenticated"
									r.pathPattern = "/user/emails"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'f': // Prefix: "follow"

						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"

							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = UsersListFollowersForAuthenticatedUserOperation
									r.summary = "List followers of the authenticated user"
									r.operationID = "users/list-followers-for-authenticated-user"
									r.pathPattern = "/user/followers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'i': // Prefix: "ing"

							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = UsersListFollowedByAuthenticatedOperation
									r.summary = "List the people the authenticated user follows"
									r.operationID = "users/list-followed-by-authenticated"
									r.pathPattern = "/user/following"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = UsersUnfollowOperation
										r.summary = "Unfollow a user"
										r.operationID = "users/unfollow"
										r.pathPattern = "/user/following/{username}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = UsersCheckPersonIsFollowedByAuthenticatedOperation
										r.summary = "Check if a person is followed by the authenticated user"
										r.operationID = "users/check-person-is-followed-by-authenticated"
										r.pathPattern = "/user/following/{username}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UsersFollowOperation
										r.summary = "Follow a user"
										r.operationID = "users/follow"
										r.pathPattern = "/user/following/{username}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'g': // Prefix: "gpg_keys"

						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = UsersListGpgKeysForAuthenticatedOperation
								r.summary = "List GPG keys for the authenticated user"
								r.operationID = "users/list-gpg-keys-for-authenticated"
								r.pathPattern = "/user/gpg_keys"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = UsersCreateGpgKeyForAuthenticatedOperation
								r.summary = "Create a GPG key for the authenticated user"
								r.operationID = "users/create-gpg-key-for-authenticated"
								r.pathPattern = "/user/gpg_keys"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = UsersDeleteGpgKeyForAuthenticatedOperation
									r.summary = "Delete a GPG key for the authenticated user"
									r.operationID = "users/delete-gpg-key-for-authenticated"
									r.pathPattern = "/user/gpg_keys/{gpg_key_id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = UsersGetGpgKeyForAuthenticatedOperation
									r.summary = "Get a GPG key for the authenticated user"
									r.operationID = "users/get-gpg-key-for-authenticated"
									r.pathPattern = "/user/gpg_keys/{gpg_key_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'i': // Prefix: "i"

						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'n': // Prefix: "n"

							if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "stallations/"

								if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "installation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/repositories"

									if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = AppsListInstallationReposForAuthenticatedUserOperation
											r.summary = "List repositories accessible to the user access token"
											r.operationID = "apps/list-installation-repos-for-authenticated-user"
											r.pathPattern = "/user/installations/{installation_id}/repositories"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = AppsRemoveRepoFromInstallationOperation
												r.summary = "Remove a repository from an app installation"
												r.operationID = "apps/remove-repo-from-installation"
												r.pathPattern = "/user/installations/{installation_id}/repositories/{repository_id}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = AppsAddRepoToInstallationOperation
												r.summary = "Add a repository to an app installation"
												r.operationID = "apps/add-repo-to-installation"
												r.pathPattern = "/user/installations/{installation_id}/repositories/{repository_id}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								}

							case 't': // Prefix: "teraction-limits"

								if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = InteractionsRemoveRestrictionsForAuthenticatedUserOperation
										r.summary = "Remove interaction restrictions from your public repositories"
										r.operationID = "interactions/remove-restrictions-for-authenticated-user"
										r.pathPattern = "/user/interaction-limits"
										r.args = args
										r.count = 0
										return r, true
									case "PUT":
										r.name = InteractionsSetRestrictionsForAuthenticatedUserOperation
										r.summary = "Set interaction restrictions for your public repositories"
										r.operationID = "interactions/set-restrictions-for-authenticated-user"
										r.pathPattern = "/user/interaction-limits"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 's': // Prefix: "ssues"

							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = IssuesListForAuthenticatedUserOperation
									r.summary = "List user account issues assigned to the authenticated user"
									r.operationID = "issues/list-for-authenticated-user"
									r.pathPattern = "/user/issues"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'k': // Prefix: "keys"

						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = UsersListPublicSSHKeysForAuthenticatedOperation
								r.summary = "List public SSH keys for the authenticated user"
								r.operationID = "users/list-public-ssh-keys-for-authenticated"
								r.pathPattern = "/user/keys"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = UsersCreatePublicSSHKeyForAuthenticatedOperation
								r.summary = "Create a public SSH key for the authenticated user"
								r.operationID = "users/create-public-ssh-key-for-authenticated"
								r.pathPattern = "/user/keys"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = UsersDeletePublicSSHKeyForAuthenticatedOperation
									r.summary = "Delete a public SSH key for the authenticated user"
									r.operationID = "users/delete-public-ssh-key-for-authenticated"
									r.pathPattern = "/user/keys/{key_id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = UsersGetPublicSSHKeyForAuthenticatedOperation
									r.summary = "Get a public SSH key for the authenticated user"
									r.operationID = "users/get-public-ssh-key-for-authenticated"
									r.pathPattern = "/user/keys/{key_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'm': // Prefix: "m"

						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"

							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = AppsListSubscriptionsForAuthenticatedUserOperation
									r.summary = "List subscriptions for the authenticated user"
									r.operationID = "apps/list-subscriptions-for-authenticated-user"
									r.pathPattern = "/user/marketplace_purchases"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"

								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = AppsListSubscriptionsForAuthenticatedUserStubbedOperation
										r.summary = "List subscriptions for the authenticated user (stubbed)"
										r.operationID = "apps/list-subscriptions-for-authenticated-user-stubbed"
										r.pathPattern = "/user/marketplace_purchases/stubbed"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'e': // Prefix: "emberships/orgs"

							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = OrgsListMembershipsForAuthenticatedUserOperation
									r.summary = "List organization memberships for the authenticated user"
									r.operationID = "orgs/list-memberships-for-authenticated-user"
									r.pathPattern = "/user/memberships/orgs"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = OrgsGetMembershipForAuthenticatedUserOperation
										r.summary = "Get an organization membership for the authenticated user"
										r.operationID = "orgs/get-membership-for-authenticated-user"
										r.pathPattern = "/user/memberships/orgs/{org}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = OrgsUpdateMembershipForAuthenticatedUserOperation
										r.summary = "Update an organization membership for the authenticated user"
										r.operationID = "orgs/update-membership-for-authenticated-user"
										r.pathPattern = "/user/memberships/orgs/{org}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'i': // Prefix: "igrations"

							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = MigrationsListForAuthenticatedUserOperation
									r.summary = "List user migrations"
									r.operationID = "migrations/list-for-authenticated-user"
									r.pathPattern = "/user/migrations"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = MigrationsStartForAuthenticatedUserOperation
									r.summary = "Start a user migration"
									r.operationID = "migrations/start-for-authenticated-user"
									r.pathPattern = "/user/migrations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = MigrationsGetStatusForAuthenticatedUserOperation
										r.summary = "Get a user migration status"
										r.operationID = "migrations/get-status-for-authenticated-user"
										r.pathPattern = "/user/migrations/{migration_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"

										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = MigrationsDeleteArchiveForAuthenticatedUserOperation
												r.summary = "Delete a user migration archive"
												r.operationID = "migrations/delete-archive-for-authenticated-user"
												r.pathPattern = "/user/migrations/{migration_id}/archive"
												r.args = args
												r.count = 1
												return r, true
											case "GET":
												r.name = MigrationsGetArchiveForAuthenticatedUserOperation
												r.summary = "Download a user migration archive"
												r.operationID = "migrations/get-archive-for-authenticated-user"
												r.pathPattern = "/user/migrations/{migration_id}/archive"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'r': // Prefix: "repos"

										if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "repo_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/lock"

												if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = MigrationsUnlockRepoForAuthenticatedUserOperation
														r.summary = "Unlock a user repository"
														r.operationID = "migrations/unlock-repo-for-authenticated-user"
														r.pathPattern = "/user/migrations/{migration_id}/repos/{repo_name}/lock"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 'i': // Prefix: "itories"

											if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = MigrationsListReposForUserOperation
													r.summary = "List repositories for a user migration"
													r.operationID = "migrations/list-repos-for-user"
													r.pathPattern = "/user/migrations/{migration_id}/repositories"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						}

					case 'o': // Prefix: "orgs"

						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = OrgsListForAuthenticatedUserOperation
								r.summary = "List organizations for the authenticated user"
								r.operationID = "orgs/list-for-authenticated-user"
								r.pathPattern = "/user/orgs"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'p': // Prefix: "p"

						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"

							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = PackagesListPackagesForAuthenticatedUserOperation
									r.summary = "List packages for the authenticated user's namespace"
									r.operationID = "packages/list-packages-for-authenticated-user"
									r.pathPattern = "/user/packages"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = PackagesDeletePackageForAuthenticatedUserOperation
											r.summary = "Delete a package for the authenticated user"
											r.operationID = "packages/delete-package-for-authenticated-user"
											r.pathPattern = "/user/packages/{package_type}/{package_name}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = PackagesGetPackageForAuthenticatedUserOperation
											r.summary = "Get a package for the authenticated user"
											r.operationID = "packages/get-package-for-authenticated-user"
											r.pathPattern = "/user/packages/{package_type}/{package_name}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "restore"

											if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = PackagesRestorePackageForAuthenticatedUserOperation
													r.summary = "Restore a package for the authenticated user"
													r.operationID = "packages/restore-package-for-authenticated-user"
													r.pathPattern = "/user/packages/{package_type}/{package_name}/restore"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'v': // Prefix: "versions"

											if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOperation
													r.summary = "Get all package versions for a package owned by the authenticated user"
													r.operationID = "packages/get-all-package-versions-for-package-owned-by-authenticated-user"
													r.pathPattern = "/user/packages/{package_type}/{package_name}/versions"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = PackagesDeletePackageVersionForAuthenticatedUserOperation
														r.summary = "Delete a package version for the authenticated user"
														r.operationID = "packages/delete-package-version-for-authenticated-user"
														r.pathPattern = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														r.name = PackagesGetPackageVersionForAuthenticatedUserOperation
														r.summary = "Get a package version for the authenticated user"
														r.operationID = "packages/get-package-version-for-authenticated-user"
														r.pathPattern = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/restore"

													if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = PackagesRestorePackageVersionForAuthenticatedUserOperation
															r.summary = "Restore a package version for the authenticated user"
															r.operationID = "packages/restore-package-version-for-authenticated-user"
															r.pathPattern = "/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									}

								}

							}

						case 'r': // Prefix: "rojects"

							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = ProjectsCreateForAuthenticatedUserOperation
									r.summary = "Create a user project"
									r.operationID = "projects/create-for-authenticated-user"
									r.pathPattern = "/user/projects"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'u': // Prefix: "ublic_emails"

							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = UsersListPublicEmailsForAuthenticatedOperation
									r.summary = "List public email addresses for the authenticated user"
									r.operationID = "users/list-public-emails-for-authenticated"
									r.pathPattern = "/user/public_emails"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'r': // Prefix: "repos"

						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ReposListForAuthenticatedUserOperation
								r.summary = "List repositories for the authenticated user"
								r.operationID = "repos/list-for-authenticated-user"
								r.pathPattern = "/user/repos"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = ReposCreateForAuthenticatedUserOperation
								r.summary = "Create a repository for the authenticated user"
								r.operationID = "repos/create-for-authenticated-user"
								r.pathPattern = "/user/repos"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"

							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ReposListInvitationsForAuthenticatedUserOperation
									r.summary = "List repository invitations for the authenticated user"
									r.operationID = "repos/list-invitations-for-authenticated-user"
									r.pathPattern = "/user/repository_invitations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = ReposDeclineInvitationOperation
										r.summary = "Decline a repository invitation"
										r.operationID = "repos/decline-invitation"
										r.pathPattern = "/user/repository_invitations/{invitation_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = ReposAcceptInvitationOperation
										r.summary = "Accept a repository invitation"
										r.operationID = "repos/accept-invitation"
										r.pathPattern = "/user/repository_invitations/{invitation_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"

							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ActivityListReposStarredByAuthenticatedUserOperation
									r.summary = "List repositories starred by the authenticated user"
									r.operationID = "activity/list-repos-starred-by-authenticated-user"
									r.pathPattern = "/user/starred"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = ActivityUnstarRepoForAuthenticatedUserOperation
											r.summary = "Unstar a repository for the authenticated user"
											r.operationID = "activity/unstar-repo-for-authenticated-user"
											r.pathPattern = "/user/starred/{owner}/{repo}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = ActivityCheckRepoIsStarredByAuthenticatedUserOperation
											r.summary = "Check if a repository is starred by the authenticated user"
											r.operationID = "activity/check-repo-is-starred-by-authenticated-user"
											r.pathPattern = "/user/starred/{owner}/{repo}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = ActivityStarRepoForAuthenticatedUserOperation
											r.summary = "Star a repository for the authenticated user"
											r.operationID = "activity/star-repo-for-authenticated-user"
											r.pathPattern = "/user/starred/{owner}/{repo}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'u': // Prefix: "ubscriptions"

							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ActivityListWatchedReposForAuthenticatedUserOperation
									r.summary = "List repositories watched by the authenticated user"
									r.operationID = "activity/list-watched-repos-for-authenticated-user"
									r.pathPattern = "/user/subscriptions"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 't': // Prefix: "teams"

						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TeamsListForAuthenticatedUserOperation
								r.summary = "List teams for the authenticated user"
								r.operationID = "teams/list-for-authenticated-user"
								r.pathPattern = "/user/teams"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 's': // Prefix: "s"

					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = UsersListOperation
							r.summary = "List users"
							r.operationID = "users/list"
							r.pathPattern = "/users"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = UsersGetByUsernameOperation
								r.summary = "Get a user"
								r.operationID = "users/get-by-username"
								r.pathPattern = "/users/{username}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "events"

								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ActivityListEventsForAuthenticatedUserOperation
										r.summary = "List events for the authenticated user"
										r.operationID = "activity/list-events-for-authenticated-user"
										r.pathPattern = "/users/{username}/events"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"

										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ActivityListOrgEventsForAuthenticatedUserOperation
												r.summary = "List organization events for the authenticated user"
												r.operationID = "activity/list-org-events-for-authenticated-user"
												r.pathPattern = "/users/{username}/events/orgs/{org}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									case 'p': // Prefix: "public"

										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ActivityListPublicEventsForUserOperation
												r.summary = "List public events for a user"
												r.operationID = "activity/list-public-events-for-user"
												r.pathPattern = "/users/{username}/events/public"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'f': // Prefix: "follow"

								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"

									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = UsersListFollowersForUserOperation
											r.summary = "List followers of a user"
											r.operationID = "users/list-followers-for-user"
											r.pathPattern = "/users/{username}/followers"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'i': // Prefix: "ing"

									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = UsersListFollowingForUserOperation
											r.summary = "List the people a user follows"
											r.operationID = "users/list-following-for-user"
											r.pathPattern = "/users/{username}/following"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = UsersCheckFollowingForUserOperation
												r.summary = "Check if a user follows another user"
												r.operationID = "users/check-following-for-user"
												r.pathPattern = "/users/{username}/following/{target_user}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'g': // Prefix: "g"

								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"

									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GistsListForUserOperation
											r.summary = "List gists for a user"
											r.operationID = "gists/list-for-user"
											r.pathPattern = "/users/{username}/gists"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "pg_keys"

									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = UsersListGpgKeysForUserOperation
											r.summary = "List GPG keys for a user"
											r.operationID = "users/list-gpg-keys-for-user"
											r.pathPattern = "/users/{username}/gpg_keys"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'h': // Prefix: "hovercard"

								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = UsersGetContextForUserOperation
										r.summary = "Get contextual information for a user"
										r.operationID = "users/get-context-for-user"
										r.pathPattern = "/users/{username}/hovercard"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'k': // Prefix: "keys"

								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = UsersListPublicKeysForUserOperation
										r.summary = "List public keys for a user"
										r.operationID = "users/list-public-keys-for-user"
										r.pathPattern = "/users/{username}/keys"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'o': // Prefix: "orgs"

								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = OrgsListForUserOperation
										r.summary = "List organizations for a user"
										r.operationID = "orgs/list-for-user"
										r.pathPattern = "/users/{username}/orgs"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "p"

								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"

									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = PackagesListPackagesForUserOperation
											r.summary = "List packages for a user"
											r.operationID = "packages/list-packages-for-user"
											r.pathPattern = "/users/{username}/packages"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = PackagesDeletePackageForUserOperation
													r.summary = "Delete a package for a user"
													r.operationID = "packages/delete-package-for-user"
													r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													r.name = PackagesGetPackageForUserOperation
													r.summary = "Get a package for a user"
													r.operationID = "packages/get-package-for-user"
													r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'r': // Prefix: "restore"

													if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = PackagesRestorePackageForUserOperation
															r.summary = "Restore a package for a user"
															r.operationID = "packages/restore-package-for-user"
															r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}/restore"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}

												case 'v': // Prefix: "versions"

													if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "GET":
															r.name = PackagesGetAllPackageVersionsForPackageOwnedByUserOperation
															r.summary = "Get all package versions for a package owned by a user"
															r.operationID = "packages/get-all-package-versions-for-package-owned-by-user"
															r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}/versions"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "package_version_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[3] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																r.name = PackagesDeletePackageVersionForUserOperation
																r.summary = "Delete package version for a user"
																r.operationID = "packages/delete-package-version-for-user"
																r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
																r.args = args
																r.count = 4
																return r, true
															case "GET":
																r.name = PackagesGetPackageVersionForUserOperation
																r.summary = "Get a package version for a user"
																r.operationID = "packages/get-package-version-for-user"
																r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
																r.args = args
																r.count = 4
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/restore"

															if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "POST":
																	r.name = PackagesRestorePackageVersionForUserOperation
																	r.summary = "Restore package version for a user"
																	r.operationID = "packages/restore-package-version-for-user"
																	r.pathPattern = "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
																	r.args = args
																	r.count = 4
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											}

										}

									}

								case 'r': // Prefix: "rojects"

									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ProjectsListForUserOperation
											r.summary = "List user projects"
											r.operationID = "projects/list-for-user"
											r.pathPattern = "/users/{username}/projects"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'r': // Prefix: "re"

								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"

									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = ActivityListReceivedEventsForUserOperation
											r.summary = "List events received by the authenticated user"
											r.operationID = "activity/list-received-events-for-user"
											r.pathPattern = "/users/{username}/received_events"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/public"

										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ActivityListReceivedPublicEventsForUserOperation
												r.summary = "List public events received by a user"
												r.operationID = "activity/list-received-public-events-for-user"
												r.pathPattern = "/users/{username}/received_events/public"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case 'p': // Prefix: "pos"

									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ReposListForUserOperation
											r.summary = "List repositories for a user"
											r.operationID = "repos/list-for-user"
											r.pathPattern = "/users/{username}/repos"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"

									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"

										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetGithubActionsBillingUserOperation
												r.summary = "Get GitHub Actions billing for a user"
												r.operationID = "billing/get-github-actions-billing-user"
												r.pathPattern = "/users/{username}/settings/billing/actions"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'p': // Prefix: "packages"

										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetGithubPackagesBillingUserOperation
												r.summary = "Get GitHub Packages billing for a user"
												r.operationID = "billing/get-github-packages-billing-user"
												r.pathPattern = "/users/{username}/settings/billing/packages"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "shared-storage"

										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = BillingGetSharedStorageBillingUserOperation
												r.summary = "Get shared storage billing for a user"
												r.operationID = "billing/get-shared-storage-billing-user"
												r.pathPattern = "/users/{username}/settings/billing/shared-storage"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case 'u': // Prefix: "ubscriptions"

									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ActivityListReposWatchedByUserOperation
											r.summary = "List repositories watched by a user"
											r.operationID = "activity/list-repos-watched-by-user"
											r.pathPattern = "/users/{username}/subscriptions"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				}

			case 'z': // Prefix: "zen"

				if l := len("zen"); len(elem) >= l && elem[0:l] == "zen" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = MetaGetZenOperation
						r.summary = "Get the Zen of GitHub"
						r.operationID = "meta/get-zen"
						r.pathPattern = "/zen"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			}

		}
	}
	return r, false
}
