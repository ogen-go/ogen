// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/metric/nonrecording"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.MeterConfig{}
	_ = syncint64.Counter(nil)
	_ = nonrecording.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

func (s *Server) notFound(w http.ResponseWriter, r *http.Request) {
	s.cfg.NotFound(w, r)
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [5]string{}
	// Static code generated router with unwrapped path search.
	switch r.Method {
	case "DELETE":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsDeleteOrgSecretRequest([2]string{
					args[0],
					args[1],
				}, w, r)

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsDeleteAuthorizationRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsDeleteInstallationRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/installations/"
						if l := len("/installations/"); len(elem) >= l && elem[0:l] == "/installations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleAppsDeleteInstallationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/suspended"
							if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsUnsuspendInstallation
								s.handleAppsUnsuspendInstallationRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants/"
							if l := len("grants/"); len(elem) >= l && elem[0:l] == "grants/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsDeleteGrant
								s.handleOAuthAuthorizationsDeleteGrantRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsDeleteTokenRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"
								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsDeleteAuthorization
									s.handleAppsDeleteAuthorizationRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 't': // Prefix: "token"
								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsDeleteToken
									s.handleAppsDeleteTokenRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsDeleteAuthorization
						s.handleOAuthAuthorizationsDeleteAuthorizationRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/"
					if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'p': // Prefix: "permissions/organizations/"
						if l := len("permissions/organizations/"); len(elem) >= l && elem[0:l] == "permissions/organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
							s.handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'r': // Prefix: "runner"
						if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '-': // Prefix: "-groups/"
							if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'o': // Prefix: "organizations/"
									if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
										s.handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'r': // Prefix: "runners/"
									if l := len("runners/"); len(elem) >= l && elem[0:l] == "runners/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
										s.handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						case 's': // Prefix: "s/"
							if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
								s.handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleGistsDeleteRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleGistsUnstarRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "comments/"
						if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "comment_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GistsDeleteComment
							s.handleGistsDeleteCommentRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 's': // Prefix: "star"
						if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: GistsUnstar
							s.handleGistsUnstarRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'i': // Prefix: "installation/token"
				if l := len("installation/token"); len(elem) >= l && elem[0:l] == "installation/token" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: AppsRevokeInstallationAccessToken
					s.handleAppsRevokeInstallationAccessTokenRequest([0]string{}, w, r)

					return
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/subscription"
					if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ActivityDeleteThreadSubscription
						s.handleActivityDeleteThreadSubscriptionRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleInteractionsRemoveRestrictionsForOrgRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActionsDeleteSelfHostedRunnerFromOrgRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions/repositories/"
							if l := len("permissions/repositories/"); len(elem) >= l && elem[0:l] == "permissions/repositories/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActionsDisableSelectedRepositoryGithubActionsOrganization
								s.handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'r': // Prefix: "runner"
							if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '-': // Prefix: "-groups/"
								if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_group_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/r"
									if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'e': // Prefix: "epositories/"
										if l := len("epositories/"); len(elem) >= l && elem[0:l] == "epositories/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
											s.handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'u': // Prefix: "unners/"
										if l := len("unners/"); len(elem) >= l && elem[0:l] == "unners/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "runner_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsRemoveSelfHostedRunnerFromGroupForOrg
											s.handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 's': // Prefix: "s/"
								if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsDeleteSelfHostedRunnerFromOrg
									s.handleActionsDeleteSelfHostedRunnerFromOrgRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 's': // Prefix: "secrets/"
							if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleActionsDeleteOrgSecretRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories/"
								if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsRemoveSelectedRepoFromOrgSecret
									s.handleActionsRemoveSelectedRepoFromOrgSecretRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						}
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsUnblockUser
							s.handleOrgsUnblockUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'c': // Prefix: "credential-authorizations/"
						if l := len("credential-authorizations/"); len(elem) >= l && elem[0:l] == "credential-authorizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "credential_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsRemoveSamlSSOAuthorization
							s.handleOrgsRemoveSamlSSOAuthorizationRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'h': // Prefix: "hooks/"
						if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "hook_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsDeleteWebhook
							s.handleOrgsDeleteWebhookRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'i': // Prefix: "in"
						if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOrgsCancelInvitationRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case 't': // Prefix: "teraction-limits"
							if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsRemoveRestrictionsForOrg
								s.handleInteractionsRemoveRestrictionsForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'v': // Prefix: "vitations/"
							if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "invitation_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsCancelInvitation
								s.handleOrgsCancelInvitationRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOrgsRemoveMemberRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'e': // Prefix: "embers"
							if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsRemoveMembershipForUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsRemoveMember
									s.handleOrgsRemoveMemberRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'h': // Prefix: "hips/"
								if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsRemoveMembershipForUser
									s.handleOrgsRemoveMembershipForUserRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'i': // Prefix: "igrations/"
							if l := len("igrations/"); len(elem) >= l && elem[0:l] == "igrations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "migration_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleMigrationsUnlockRepoForOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'a': // Prefix: "archive"
									if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsDeleteArchiveForOrg
										s.handleMigrationsDeleteArchiveForOrgRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'r': // Prefix: "repos/"
									if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/lock"
										if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsUnlockRepoForOrg
											s.handleMigrationsUnlockRepoForOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						}
					case 'o': // Prefix: "outside_collaborators/"
						if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsRemoveOutsideCollaborator
							s.handleOrgsRemoveOutsideCollaboratorRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handlePackagesDeletePackageForOrgRequest([3]string{
								args[0],
								args[1],
								args[2],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handlePackagesDeletePackageForOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/versions/"
									if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_version_id"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: PackagesDeletePackageVersionForOrg
										s.handlePackagesDeletePackageVersionForOrgRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
								}
							}
						case 'u': // Prefix: "ublic_members/"
							if l := len("ublic_members/"); len(elem) >= l && elem[0:l] == "ublic_members/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsRemovePublicMembershipForAuthenticatedUser
								s.handleOrgsRemovePublicMembershipForAuthenticatedUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleTeamsDeleteInOrgRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsRemoveMembershipForUserInOrgRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'd': // Prefix: "discussions/"
								if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "discussion_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsDeleteDiscussionInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReactionsDeleteForTeamDiscussionCommentRequest([5]string{
											args[0],
											args[1],
											args[2],
											args[3],
											args[4],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'c': // Prefix: "comments/"
										if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleTeamsDeleteDiscussionCommentInOrgRequest([4]string{
												args[0],
												args[1],
												args[2],
												args[3],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions/"
											if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "reaction_id"
											// Leaf parameter
											args[4] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReactionsDeleteForTeamDiscussionComment
												s.handleReactionsDeleteForTeamDiscussionCommentRequest([5]string{
													args[0],
													args[1],
													args[2],
													args[3],
													args[4],
												}, w, r)

												return
											}
										}
									case 'r': // Prefix: "reactions/"
										if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "reaction_id"
										// Leaf parameter
										args[3] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReactionsDeleteForTeamDiscussion
											s.handleReactionsDeleteForTeamDiscussionRequest([4]string{
												args[0],
												args[1],
												args[2],
												args[3],
											}, w, r)

											return
										}
									}
								}
							case 'm': // Prefix: "memberships/"
								if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveMembershipForUserInOrg
									s.handleTeamsRemoveMembershipForUserInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							case 'p': // Prefix: "projects/"
								if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveProjectInOrg
									s.handleTeamsRemoveProjectInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsRemoveRepoInOrg
										s.handleTeamsRemoveRepoInOrgRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsDeleteColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsDeleteCard
							s.handleProjectsDeleteCardRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsDeleteColumn
						s.handleProjectsDeleteColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleProjectsDeleteRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/collaborators/"
					if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsRemoveCollaborator
						s.handleProjectsRemoveCollaboratorRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
				}
			case 'r': // Prefix: "re"
				if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleReactionsDeleteLegacyRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'a': // Prefix: "actions/"
					if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "reaction_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ReactionsDeleteLegacy
						s.handleReactionsDeleteLegacyRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				case 'p': // Prefix: "pos"
					if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActionsDeleteEnvironmentSecretRequest([3]string{
							args[0],
							args[1],
							args[2],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleReposDeleteRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActivityDeleteRepoSubscriptionRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'a': // Prefix: "a"
									if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposDeleteAutolinkRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'c': // Prefix: "ctions/"
										if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsDeleteRepoSecretRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'a': // Prefix: "artifacts/"
											if l := len("artifacts/"); len(elem) >= l && elem[0:l] == "artifacts/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "artifact_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsDeleteArtifact
												s.handleActionsDeleteArtifactRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'r': // Prefix: "run"
											if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsDeleteWorkflowRunRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'n': // Prefix: "ners/"
												if l := len("ners/"); len(elem) >= l && elem[0:l] == "ners/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsDeleteSelfHostedRunnerFromRepo
													s.handleActionsDeleteSelfHostedRunnerFromRepoRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 's': // Prefix: "s/"
												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													s.handleActionsDeleteWorkflowRunRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"
													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsDeleteWorkflowRunLogs
														s.handleActionsDeleteWorkflowRunLogsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											}
										case 's': // Prefix: "secrets/"
											if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "secret_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsDeleteRepoSecret
												s.handleActionsDeleteRepoSecretRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 'u': // Prefix: "uto"
										if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposDisableAutomatedSecurityFixesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'l': // Prefix: "links/"
											if l := len("links/"); len(elem) >= l && elem[0:l] == "links/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "autolink_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteAutolink
												s.handleReposDeleteAutolinkRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'm': // Prefix: "mated-security-fixes"
											if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposDisableAutomatedSecurityFixes
												s.handleReposDisableAutomatedSecurityFixesRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								case 'b': // Prefix: "branches/"
									if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "branch"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/protection"
										if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposDeleteBranchProtectionRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposDeleteAdminBranchProtectionRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'e': // Prefix: "enforce_admins"
												if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposDeleteAdminBranchProtection
													s.handleReposDeleteAdminBranchProtectionRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposDeleteCommitSignatureProtectionRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'q': // Prefix: "quired_"
													if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposDeletePullRequestReviewProtectionRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'p': // Prefix: "pull_request_reviews"
														if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposDeletePullRequestReviewProtection
															s.handleReposDeletePullRequestReviewProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													case 's': // Prefix: "s"
														if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposRemoveStatusCheckContextsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case 'i': // Prefix: "ignatures"
															if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposDeleteCommitSignatureProtection
																s.handleReposDeleteCommitSignatureProtectionRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 't': // Prefix: "tatus_checks"
															if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposRemoveStatusCheckProtectionRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/contexts"
																if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposRemoveStatusCheckContexts
																	s.handleReposRemoveStatusCheckContextsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															}
														}
													}
												case 's': // Prefix: "strictions"
													if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposDeleteAccessRestrictionsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposRemoveTeamAccessRestrictionsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case 'a': // Prefix: "apps"
															if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveAppAccessRestrictions
																s.handleReposRemoveAppAccessRestrictionsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 't': // Prefix: "teams"
															if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveTeamAccessRestrictions
																s.handleReposRemoveTeamAccessRestrictionsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 'u': // Prefix: "users"
															if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveUserAccessRestrictions
																s.handleReposRemoveUserAccessRestrictionsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														}
													}
												}
											}
										}
									}
								case 'c': // Prefix: "co"
									if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReactionsDeleteForCommitCommentRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'd': // Prefix: "de-scanning/analyses/"
										if l := len("de-scanning/analyses/"); len(elem) >= l && elem[0:l] == "de-scanning/analyses/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "analysis_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: CodeScanningDeleteAnalysis
											s.handleCodeScanningDeleteAnalysisRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'l': // Prefix: "llaborators/"
										if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposRemoveCollaborator
											s.handleReposRemoveCollaboratorRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'm': // Prefix: "mments/"
										if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleReposDeleteCommitCommentRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions/"
											if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "reaction_id"
											// Leaf parameter
											args[3] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReactionsDeleteForCommitComment
												s.handleReactionsDeleteForCommitCommentRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, w, r)

												return
											}
										}
									case 'n': // Prefix: "ntents/"
										if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "path"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposDeleteFile
											s.handleReposDeleteFileRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								case 'd': // Prefix: "deployments/"
									if l := len("deployments/"); len(elem) >= l && elem[0:l] == "deployments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "deployment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteDeployment
										s.handleReposDeleteDeploymentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'e': // Prefix: "environments/"
									if l := len("environments/"); len(elem) >= l && elem[0:l] == "environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteAnEnvironment
										s.handleReposDeleteAnEnvironmentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'g': // Prefix: "git/refs/"
									if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "ref"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: GitDeleteRef
										s.handleGitDeleteRefRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'h': // Prefix: "hooks/"
									if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteWebhook
										s.handleReposDeleteWebhookRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'i': // Prefix: "i"
									if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleIssuesDeleteCommentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'm': // Prefix: "mport"
										if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsCancelImport
											s.handleMigrationsCancelImportRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'n': // Prefix: "n"
										if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposDeleteInvitationRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 't': // Prefix: "teraction-limits"
											if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: InteractionsRemoveRestrictionsForRepo
												s.handleInteractionsRemoveRestrictionsForRepoRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'v': // Prefix: "vitations/"
											if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteInvitation
												s.handleReposDeleteInvitationRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 's': // Prefix: "ssues/"
										if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleIssuesRemoveAllLabelsRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleIssuesDeleteCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/reactions/"
												if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForIssueComment
													s.handleReactionsDeleteForIssueCommentRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
										// Param: "issue_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleIssuesRemoveAssigneesRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "assignees"
												if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: IssuesRemoveAssignees
													s.handleIssuesRemoveAssigneesRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'l': // Prefix: "l"
												if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesUnlockRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'a': // Prefix: "abels"
													if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleIssuesRemoveAllLabelsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "name"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: IssuesRemoveLabel
															s.handleIssuesRemoveLabelRequest([4]string{
																args[0],
																args[1],
																args[2],
																args[3],
															}, w, r)

															return
														}
													}
												case 'o': // Prefix: "ock"
													if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesUnlock
														s.handleIssuesUnlockRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											case 'r': // Prefix: "reactions/"
												if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForIssue
													s.handleReactionsDeleteForIssueRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
									}
								case 'k': // Prefix: "keys/"
									if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "key_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteDeployKey
										s.handleReposDeleteDeployKeyRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'l': // Prefix: "l"
									if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposDisableLfsForRepoRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "abels/"
										if l := len("abels/"); len(elem) >= l && elem[0:l] == "abels/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: IssuesDeleteLabel
											s.handleIssuesDeleteLabelRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'f': // Prefix: "fs"
										if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposDisableLfsForRepo
											s.handleReposDisableLfsForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								case 'm': // Prefix: "milestones/"
									if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "milestone_number"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesDeleteMilestone
										s.handleIssuesDeleteMilestoneRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposDeletePagesSiteRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "ages"
										if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposDeletePagesSite
											s.handleReposDeletePagesSiteRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'u': // Prefix: "ulls/"
										if l := len("ulls/"); len(elem) >= l && elem[0:l] == "ulls/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handlePullsDeleteReviewCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/reactions/"
												if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForPullRequestComment
													s.handleReactionsDeleteForPullRequestCommentRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
										// Param: "pull_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/re"
											if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePullsRemoveRequestedReviewersRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'q': // Prefix: "quested_reviewers"
												if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: PullsRemoveRequestedReviewers
													s.handlePullsRemoveRequestedReviewersRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'v': // Prefix: "views/"
												if l := len("views/"); len(elem) >= l && elem[0:l] == "views/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "review_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: PullsDeletePendingReview
													s.handlePullsDeletePendingReviewRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
									}
								case 'r': // Prefix: "releases/"
									if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "assets/"
										if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "asset_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposDeleteReleaseAsset
											s.handleReposDeleteReleaseAssetRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
									// Param: "release_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteRelease
										s.handleReposDeleteReleaseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 's': // Prefix: "subscription"
									if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityDeleteRepoSubscription
										s.handleActivityDeleteRepoSubscriptionRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'v': // Prefix: "vulnerability-alerts"
									if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposDisableVulnerabilityAlerts
										s.handleReposDisableVulnerabilityAlertsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						}
					case 'i': // Prefix: "itories/"
						if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repository_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/environments/"
							if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "environment_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/secrets/"
								if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "secret_name"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsDeleteEnvironmentSecret
									s.handleActionsDeleteEnvironmentSecretRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/"
				if l := len("scim/v2/"); len(elem) >= l && elem[0:l] == "scim/v2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleScimDeleteUserFromOrgRequest([2]string{
						args[0],
						args[1],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'e': // Prefix: "enterprises/"
					if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups/"
							if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_group_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteScimGroupFromEnterprise
								s.handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'U': // Prefix: "Users/"
							if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteUserFromEnterprise
								s.handleEnterpriseAdminDeleteUserFromEnterpriseRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				case 'o': // Prefix: "organizations/"
					if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/Users/"
						if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ScimDeleteUserFromOrg
							s.handleScimDeleteUserFromOrgRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleTeamsDeleteLegacyRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleTeamsRemoveMemberLegacyRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions/"
						if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleTeamsDeleteDiscussionLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/comments/"
							if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "comment_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsDeleteDiscussionCommentLegacy
								s.handleTeamsDeleteDiscussionCommentLegacyRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsRemoveMembershipForUserLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveMemberLegacy
								s.handleTeamsRemoveMemberLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveMembershipForUserLegacy
								s.handleTeamsRemoveMembershipForUserLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 'p': // Prefix: "projects/"
						if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: TeamsRemoveProjectLegacy
							s.handleTeamsRemoveProjectLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'r': // Prefix: "repos/"
						if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveRepoLegacy
								s.handleTeamsRemoveRepoLegacyRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handlePackagesDeletePackageForUserRequest([3]string{
						args[0],
						args[1],
						args[2],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsRemoveRepoFromInstallationRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnblock
							s.handleUsersUnblockRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersDeleteEmailForAuthenticated
							s.handleUsersDeleteEmailForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'f': // Prefix: "following/"
						if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnfollow
							s.handleUsersUnfollowRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'g': // Prefix: "gpg_keys/"
						if l := len("gpg_keys/"); len(elem) >= l && elem[0:l] == "gpg_keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "gpg_key_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeleteGpgKeyForAuthenticated
							s.handleUsersDeleteGpgKeyForAuthenticatedRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'i': // Prefix: "in"
						if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 's': // Prefix: "stallations/"
							if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories/"
								if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsRemoveRepoFromInstallation
									s.handleAppsRemoveRepoFromInstallationRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 't': // Prefix: "teraction-limits"
							if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsRemoveRestrictionsForAuthenticatedUser
								s.handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						}
					case 'k': // Prefix: "keys/"
						if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "key_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeletePublicSSHKeyForAuthenticated
							s.handleUsersDeletePublicSSHKeyForAuthenticatedRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'm': // Prefix: "migrations/"
						if l := len("migrations/"); len(elem) >= l && elem[0:l] == "migrations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "migration_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleMigrationsUnlockRepoForAuthenticatedUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'a': // Prefix: "archive"
								if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: MigrationsDeleteArchiveForAuthenticatedUser
									s.handleMigrationsDeleteArchiveForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/lock"
									if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsUnlockRepoForAuthenticatedUser
										s.handleMigrationsUnlockRepoForAuthenticatedUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						}
					case 'p': // Prefix: "packages/"
						if l := len("packages/"); len(elem) >= l && elem[0:l] == "packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handlePackagesDeletePackageForAuthenticatedUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/versions/"
								if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_version_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PackagesDeletePackageVersionForAuthenticatedUser
									s.handlePackagesDeletePackageVersionForAuthenticatedUserRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposDeclineInvitation
							s.handleReposDeclineInvitationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 's': // Prefix: "starred/"
						if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActivityUnstarRepoForAuthenticatedUser
								s.handleActivityUnstarRepoForAuthenticatedUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/packages/"
						if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handlePackagesDeletePackageForUserRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/versions/"
								if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_version_id"
								// Leaf parameter
								args[3] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PackagesDeletePackageVersionForUser
									s.handlePackagesDeletePackageVersionForUserRequest([4]string{
										args[0],
										args[1],
										args[2],
										args[3],
									}, w, r)

									return
								}
							}
						}
					}
				}
			}
		}
	case "GET":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleMetaRootRequest([0]string{}, w, r)

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsGetAuthorizationRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsGetAuthenticatedRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/"
						if l := len("/hook/"); len(elem) >= l && elem[0:l] == "/hook/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsGetWebhookDeliveryRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'c': // Prefix: "config"
							if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsGetWebhookConfigForApp
								s.handleAppsGetWebhookConfigForAppRequest([0]string{}, w, r)

								return
							}
						case 'd': // Prefix: "deliveries"
							if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListWebhookDeliveriesRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "delivery_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsGetWebhookDelivery
									s.handleAppsGetWebhookDeliveryRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 'l': // Prefix: "lications/grants"
						if l := len("lications/grants"); len(elem) >= l && elem[0:l] == "lications/grants" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOAuthAuthorizationsListGrantsRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsGetGrant
								s.handleOAuthAuthorizationsGetGrantRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 's': // Prefix: "s/"
						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetBySlug
							s.handleAppsGetBySlugRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleOAuthAuthorizationsListAuthorizationsRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "authorization_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OAuthAuthorizationsGetAuthorization
							s.handleOAuthAuthorizationsGetAuthorizationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'c': // Prefix: "codes_of_conduct"
				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleCodesOfConductGetAllCodesOfConductRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: CodesOfConductGetConductCode
						s.handleCodesOfConductGetConductCodeRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleBillingGetGithubActionsBillingGheRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"
					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: EmojisGet
						s.handleEmojisGetRequest([0]string{}, w, r)

						return
					}
				case 'n': // Prefix: "nterprises/"
					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminGetAuditLogRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"
											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise
												s.handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
													args[0],
												}, w, r)

												return
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminGetAllowedActionsEnterprise
												s.handleEnterpriseAdminGetAllowedActionsEnterpriseRequest([1]string{
													args[0],
												}, w, r)

												return
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"
													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise
														s.handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												case 'r': // Prefix: "runners"
													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise
														s.handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: EnterpriseAdminListRunnerApplicationsForEnterprise
													s.handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest([1]string{
														args[0],
													}, w, r)

													return
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminGetSelfHostedRunnerForEnterprise
												s.handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetAuditLog
									s.handleEnterpriseAdminGetAuditLogRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 's': // Prefix: "settings/billing/"
							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleBillingGetGithubPackagesBillingGheRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"
								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetGithubActionsBillingGhe
									s.handleBillingGetGithubActionsBillingGheRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'p': // Prefix: "packages"
								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetGithubPackagesBillingGhe
									s.handleBillingGetGithubPackagesBillingGheRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 's': // Prefix: "shared-storage"
								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetSharedStorageBillingGhe
									s.handleBillingGetSharedStorageBillingGheRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					}
				case 'v': // Prefix: "vents"
					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ActivityListPublicEvents
						s.handleActivityListPublicEventsRequest([0]string{}, w, r)

						return
					}
				}
			case 'f': // Prefix: "feeds"
				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: ActivityGetFeeds
					s.handleActivityGetFeedsRequest([0]string{}, w, r)

					return
				}
			case 'g': // Prefix: "gi"
				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleGitignoreGetAllTemplatesRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 's': // Prefix: "sts"
					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleGistsListRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListPublic
								s.handleGistsListPublicRequest([0]string{}, w, r)

								return
							}
						case 's': // Prefix: "starred"
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListStarred
								s.handleGistsListStarredRequest([0]string{}, w, r)

								return
							}
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleGistsGetRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleGistsGetCommentRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleGistsListCommitsRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"
									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleGistsListCommentsRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GistsGetComment
											s.handleGistsGetCommentRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								case 'i': // Prefix: "its"
									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsListCommits
										s.handleGistsListCommitsRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							case 'f': // Prefix: "forks"
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsListForks
									s.handleGistsListForksRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 's': // Prefix: "star"
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsCheckIsStarred
									s.handleGistsCheckIsStarredRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
							// Param: "sha"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: GistsGetRevision
								s.handleGistsGetRevisionRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				case 't': // Prefix: "tignore/templates"
					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleGitignoreGetAllTemplatesRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GitignoreGetTemplate
							s.handleGitignoreGetTemplateRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleIssuesListRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/repositories"
					if l := len("nstallation/repositories"); len(elem) >= l && elem[0:l] == "nstallation/repositories" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: AppsListReposAccessibleToInstallation
						s.handleAppsListReposAccessibleToInstallationRequest([0]string{}, w, r)

						return
					}
				case 's': // Prefix: "ssues"
					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: IssuesList
						s.handleIssuesListRequest([0]string{}, w, r)

						return
					}
				}
			case 'l': // Prefix: "licenses"
				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleLicensesGetAllCommonlyUsedRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: LicensesGet
						s.handleLicensesGetRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'm': // Prefix: "m"
				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleMetaGetRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'a': // Prefix: "arketplace_listing/"
					if l := len("arketplace_listing/"); len(elem) >= l && elem[0:l] == "arketplace_listing/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsGetSubscriptionPlanForAccountStubbedRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'a': // Prefix: "accounts/"
						if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "account_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetSubscriptionPlanForAccount
							s.handleAppsGetSubscriptionPlanForAccountRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'p': // Prefix: "plans"
						if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsListPlansRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "plan_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/accounts"
								if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListAccountsForPlan
									s.handleAppsListAccountsForPlanRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 's': // Prefix: "stubbed/"
						if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsListAccountsForPlanStubbedRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"
							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: AppsGetSubscriptionPlanForAccountStubbed
								s.handleAppsGetSubscriptionPlanForAccountStubbedRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'p': // Prefix: "plans"
							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListPlansStubbedRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"
									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsListAccountsForPlanStubbed
										s.handleAppsListAccountsForPlanStubbedRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eta"
					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: MetaGet
						s.handleMetaGetRequest([0]string{}, w, r)

						return
					}
				}
			case 'n': // Prefix: "n"
				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActivityListPublicEventsForRepoNetworkRequest([2]string{
						args[0],
						args[1],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"
					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"
							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListPublicEventsForRepoNetwork
								s.handleActivityListPublicEventsForRepoNetworkRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				case 'o': // Prefix: "otifications"
					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActivityListNotificationsForAuthenticatedUserRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"
						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleActivityGetThreadRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"
							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityGetThreadSubscriptionForAuthenticatedUser
								s.handleActivityGetThreadSubscriptionForAuthenticatedUserRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
				}
			case 'o': // Prefix: "org"
				if l := len("org"); len(elem) >= l && elem[0:l] == "org" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOrgsListRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'a': // Prefix: "anizations"
					if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OrgsList
						s.handleOrgsListRequest([0]string{}, w, r)

						return
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleOrgsGetRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActivityListPublicOrgEventsRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsGetAuditLogRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsGetOrgPublicKeyRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsGetGithubActionsPermissionsOrganizationRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
												s.handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
													args[0],
												}, w, r)

												return
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetAllowedActionsOrganization
												s.handleActionsGetAllowedActionsOrganizationRequest([1]string{
													args[0],
												}, w, r)

												return
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsGetSelfHostedRunnerGroupForOrgRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsListSelfHostedRunnerGroupsForOrgRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleActionsGetSelfHostedRunnerGroupForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/r"
												if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsListSelfHostedRunnersInGroupForOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'e': // Prefix: "epositories"
													if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
														s.handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												case 'u': // Prefix: "unners"
													if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListSelfHostedRunnersInGroupForOrg
														s.handleActionsListSelfHostedRunnersInGroupForOrgRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsListSelfHostedRunnersForOrgRequest([1]string{
												args[0],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsListRunnerApplicationsForOrg
													s.handleActionsListRunnerApplicationsForOrgRequest([1]string{
														args[0],
													}, w, r)

													return
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsGetSelfHostedRunnerForOrg
												s.handleActionsGetSelfHostedRunnerForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								case 's': // Prefix: "secrets"
									if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsListOrgSecretsRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsGetOrgSecretRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetOrgPublicKey
												s.handleActionsGetOrgPublicKeyRequest([1]string{
													args[0],
												}, w, r)

												return
											}
										}
										// Param: "secret_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleActionsGetOrgSecretRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/repositories"
											if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListSelectedReposForOrgSecret
												s.handleActionsListSelectedReposForOrgSecretRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsGetAuditLog
									s.handleOrgsGetAuditLogRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 'b': // Prefix: "blocks"
							if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsListBlockedUsersRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsCheckBlockedUser
									s.handleOrgsCheckBlockedUserRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'c': // Prefix: "credential-authorizations"
							if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListSamlSSOAuthorizations
								s.handleOrgsListSamlSSOAuthorizationsRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'e': // Prefix: "events"
							if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListPublicOrgEvents
								s.handleActivityListPublicOrgEventsRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'f': // Prefix: "failed_invitations"
							if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListFailedInvitations
								s.handleOrgsListFailedInvitationsRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsListWebhooksRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleOrgsGetWebhookRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleOrgsGetWebhookDeliveryRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsGetWebhookConfigForOrg
											s.handleOrgsGetWebhookConfigForOrgRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'd': // Prefix: "deliveries"
										if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleOrgsListWebhookDeliveriesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "delivery_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: OrgsGetWebhookDelivery
												s.handleOrgsGetWebhookDeliveryRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsListInvitationTeamsRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'n': // Prefix: "nvitations"
								if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListPendingInvitationsRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "invitation_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/teams"
										if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsListInvitationTeams
											s.handleOrgsListInvitationTeamsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								}
							case 's': // Prefix: "ssues"
								if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: IssuesListForOrg
									s.handleIssuesListForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsCheckMembershipForUserRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'e': // Prefix: "embers"
								if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListMembersRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsCheckMembershipForUser
										s.handleOrgsCheckMembershipForUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'h': // Prefix: "hips/"
									if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsGetMembershipForUser
										s.handleOrgsGetMembershipForUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							case 'i': // Prefix: "igrations"
								if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleMigrationsListForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "migration_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleMigrationsGetStatusForOrgRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleMigrationsListReposForOrgRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsDownloadArchiveForOrg
												s.handleMigrationsDownloadArchiveForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsListReposForOrg
												s.handleMigrationsListReposForOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								}
							}
						case 'o': // Prefix: "outside_collaborators"
							if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListOutsideCollaborators
								s.handleOrgsListOutsideCollaboratorsRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages"
								if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handlePackagesListPackagesForOrganizationRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handlePackagesGetPackageForOrganizationRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/versions"
											if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: PackagesGetPackageVersionForOrganization
													s.handlePackagesGetPackageVersionForOrganizationRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsListForOrg
									s.handleProjectsListForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'u': // Prefix: "ublic_members"
								if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsListPublicMembersRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsCheckPublicMembershipForUser
										s.handleOrgsCheckPublicMembershipForUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposListForOrg
								s.handleReposListForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 's': // Prefix: "se"
							if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleSecretScanningListAlertsForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "cret-scanning/alerts"
								if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: SecretScanningListAlertsForOrg
									s.handleSecretScanningListAlertsForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 't': // Prefix: "ttings/billing/"
								if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleBillingGetGithubPackagesBillingOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"
									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubActionsBillingOrg
										s.handleBillingGetGithubActionsBillingOrgRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								case 'p': // Prefix: "packages"
									if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubPackagesBillingOrg
										s.handleBillingGetGithubPackagesBillingOrgRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								case 's': // Prefix: "shared-storage"
									if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetSharedStorageBillingOrg
										s.handleBillingGetSharedStorageBillingOrgRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							}
						case 't': // Prefix: "team"
							if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsListIdpGroupsForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '-': // Prefix: "-sync/groups"
								if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsListIdpGroupsForOrg
									s.handleTeamsListIdpGroupsForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleTeamsListRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "team_slug"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handleTeamsGetByNameRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleTeamsCheckPermissionsForProjectInOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'd': // Prefix: "discussions"
											if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListDiscussionsInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "discussion_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													s.handleTeamsGetDiscussionInOrgRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReactionsListForTeamDiscussionInOrgRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleTeamsListDiscussionCommentsInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handleTeamsGetDiscussionCommentInOrgRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReactionsListForTeamDiscussionCommentInOrg
																	s.handleReactionsListForTeamDiscussionCommentInOrgRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)

																	return
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForTeamDiscussionInOrg
															s.handleReactionsListForTeamDiscussionInOrgRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													}
												}
											}
										case 'i': // Prefix: "invitations"
											if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: TeamsListPendingInvitationsInOrg
												s.handleTeamsListPendingInvitationsInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'm': // Prefix: "members"
											if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListMembersInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'h': // Prefix: "hips/"
												if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsGetMembershipForUserInOrg
													s.handleTeamsGetMembershipForUserInOrgRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'p': // Prefix: "projects"
											if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListProjectsInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "project_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsCheckPermissionsForProjectInOrg
													s.handleTeamsCheckPermissionsForProjectInOrgRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListReposInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "owner"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: TeamsCheckPermissionsForRepoInOrg
														s.handleTeamsCheckPermissionsForRepoInOrgRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										case 't': // Prefix: "team"
											if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsListIdpGroupsInOrgRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '-': // Prefix: "-sync/group-mappings"
												if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: TeamsListIdpGroupsInOrg
													s.handleTeamsListIdpGroupsInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: TeamsListChildInOrg
													s.handleTeamsListChildInOrgRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsGetColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsGetCard
							s.handleProjectsGetCardRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleProjectsGetColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/cards"
						if l := len("/cards"); len(elem) >= l && elem[0:l] == "/cards" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsListCards
							s.handleProjectsListCardsRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleProjectsGetRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/col"
					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsListColumnsRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"
						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleProjectsListCollaboratorsRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"
								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsGetPermissionForUser
									s.handleProjectsGetPermissionForUserRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						}
					case 'u': // Prefix: "umns"
						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsListColumns
							s.handleProjectsListColumnsRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'r': // Prefix: "r"
				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleRateLimitGetRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"
					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: RateLimitGet
						s.handleRateLimitGetRequest([0]string{}, w, r)

						return
					}
				case 'e': // Prefix: "epos"
					if l := len("epos"); len(elem) >= l && elem[0:l] == "epos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleActionsGetEnvironmentPublicKeyRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleReposGetRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActivityGetRepoSubscriptionRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'a': // Prefix: "a"
									if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleIssuesCheckUserCanBeAssignedRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'c': // Prefix: "ctions/"
										if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsDownloadJobLogsForWorkflowRunRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'a': // Prefix: "artifacts"
											if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListArtifactsForRepoRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "artifact_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													s.handleActionsGetArtifactRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "archive_format"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsDownloadArtifact
														s.handleActionsDownloadArtifactRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										case 'j': // Prefix: "jobs/"
											if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "job_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleActionsGetJobForWorkflowRunRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/logs"
												if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsDownloadJobLogsForWorkflowRun
													s.handleActionsDownloadJobLogsForWorkflowRunRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'p': // Prefix: "permissions"
											if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsGetGithubActionsPermissionsRepositoryRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/selected-actions"
												if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsGetAllowedActionsRepository
													s.handleActionsGetAllowedActionsRepositoryRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										case 'r': // Prefix: "run"
											if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsGetSelfHostedRunnerForRepoRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'n': // Prefix: "ners"
												if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsListSelfHostedRunnersForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "downloads"
														if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsListRunnerApplicationsForRepo
															s.handleActionsListRunnerApplicationsForRepoRequest([2]string{
																args[0],
																args[1],
															}, w, r)

															return
														}
													}
													// Param: "runner_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsGetSelfHostedRunnerForRepo
														s.handleActionsGetSelfHostedRunnerForRepoRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsListWorkflowRunsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "run_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleActionsGetWorkflowRunRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleActionsGetReviewsForRunRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case 'a': // Prefix: "a"
															if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleActionsListWorkflowRunArtifactsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
															switch elem[0] {
															case 'p': // Prefix: "pprovals"
																if l := len("pprovals"); len(elem) >= l && elem[0:l] == "pprovals" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsGetReviewsForRun
																	s.handleActionsGetReviewsForRunRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 'r': // Prefix: "rtifacts"
																if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsListWorkflowRunArtifacts
																	s.handleActionsListWorkflowRunArtifactsRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															}
														case 'j': // Prefix: "jobs"
															if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsListJobsForWorkflowRun
																s.handleActionsListJobsForWorkflowRunRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 'l': // Prefix: "logs"
															if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsDownloadWorkflowRunLogs
																s.handleActionsDownloadWorkflowRunLogsRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 't': // Prefix: "timing"
															if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsGetWorkflowRunUsage
																s.handleActionsGetWorkflowRunUsageRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														}
													}
												}
											}
										case 's': // Prefix: "secrets"
											if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsListRepoSecretsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleActionsGetRepoSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'p': // Prefix: "public-key"
													if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsGetRepoPublicKey
														s.handleActionsGetRepoPublicKeyRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												}
												// Param: "secret_name"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsGetRepoSecret
													s.handleActionsGetRepoSecretRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'w': // Prefix: "workflows"
											if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListRepoWorkflows
												s.handleActionsListRepoWorkflowsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									case 's': // Prefix: "ssignees"
										if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleIssuesListAssigneesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "assignee"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: IssuesCheckUserCanBeAssigned
												s.handleIssuesCheckUserCanBeAssignedRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 'u': // Prefix: "utolinks"
										if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposListAutolinksRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "autolink_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposGetAutolink
												s.handleReposGetAutolinkRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								case 'b': // Prefix: "branches"
									if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposListBranchesRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "branch"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleReposGetBranchRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/protection"
											if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetBranchProtectionRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposGetAdminBranchProtectionRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'e': // Prefix: "enforce_admins"
													if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetAdminBranchProtection
														s.handleReposGetAdminBranchProtectionRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												case 'r': // Prefix: "re"
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetAllStatusCheckContextsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'q': // Prefix: "quired_"
														if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposGetPullRequestReviewProtectionRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case 'p': // Prefix: "pull_request_reviews"
															if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposGetPullRequestReviewProtection
																s.handleReposGetPullRequestReviewProtectionRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														case 's': // Prefix: "s"
															if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposGetCommitSignatureProtectionRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
															switch elem[0] {
															case 'i': // Prefix: "ignatures"
																if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetCommitSignatureProtection
																	s.handleReposGetCommitSignatureProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 't': // Prefix: "tatus_checks"
																if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposGetStatusChecksProtectionRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/contexts"
																	if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposGetAllStatusCheckContexts
																		s.handleReposGetAllStatusCheckContextsRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)

																		return
																	}
																}
															}
														}
													case 's': // Prefix: "strictions"
														if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handleReposGetAccessRestrictionsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposGetTeamsWithAccessToProtectedBranchRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
															switch elem[0] {
															case 'a': // Prefix: "apps"
																if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetAppsWithAccessToProtectedBranch
																	s.handleReposGetAppsWithAccessToProtectedBranchRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 't': // Prefix: "teams"
																if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetTeamsWithAccessToProtectedBranch
																	s.handleReposGetTeamsWithAccessToProtectedBranchRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 'u': // Prefix: "users"
																if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetUsersWithAccessToProtectedBranch
																	s.handleReposGetUsersWithAccessToProtectedBranchRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															}
														}
													}
												}
											}
										}
									}
								case 'c': // Prefix: "c"
									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleChecksListForRefRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'h': // Prefix: "heck-"
										if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleChecksGetSuiteRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'r': // Prefix: "runs/"
											if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "check_run_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleChecksGetRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/annotations"
												if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ChecksListAnnotations
													s.handleChecksListAnnotationsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 's': // Prefix: "suites/"
											if l := len("suites/"); len(elem) >= l && elem[0:l] == "suites/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "check_suite_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleChecksGetSuiteRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/check-runs"
												if l := len("/check-runs"); len(elem) >= l && elem[0:l] == "/check-runs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ChecksListForSuite
													s.handleChecksListForSuiteRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										}
									case 'o': // Prefix: "o"
										if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleCodeScanningGetAlertRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'd': // Prefix: "de-scanning/"
											if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleCodeScanningGetSarifRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "a"
												if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleCodeScanningGetAnalysisRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'l': // Prefix: "lerts"
													if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleCodeScanningListAlertsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "alert_number"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleCodeScanningGetAlertRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/instances"
															if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: CodeScanningListAlertInstances
																s.handleCodeScanningListAlertInstancesRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														}
													}
												case 'n': // Prefix: "nalyses"
													if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleCodeScanningListRecentAnalysesRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "analysis_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: CodeScanningGetAnalysis
															s.handleCodeScanningGetAnalysisRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													}
												}
											case 's': // Prefix: "sarifs/"
												if l := len("sarifs/"); len(elem) >= l && elem[0:l] == "sarifs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sarif_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: CodeScanningGetSarif
													s.handleCodeScanningGetSarifRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'l': // Prefix: "llaborators"
											if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListCollaboratorsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													s.handleReposCheckCollaboratorRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/permission"
													if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetCollaboratorPermissionLevel
														s.handleReposGetCollaboratorPermissionLevelRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											}
										case 'm': // Prefix: "m"
											if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposCompareCommitsRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'm': // Prefix: "m"
												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReactionsListForCommitCommentRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'e': // Prefix: "ents"
													if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposListCommitCommentsForRepoRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleReposGetCommitCommentRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReactionsListForCommitComment
																s.handleReactionsListForCommitCommentRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
														}
													}
												case 'i': // Prefix: "its"
													if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposListCommitsRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															s.handleReposGetCommitRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																s.handleReposGetCombinedStatusForRefRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, w, r)

																return
															}
															switch elem[0] {
															case 'b': // Prefix: "branches-where-head"
																if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposListBranchesForHeadCommit
																	s.handleReposListBranchesForHeadCommitRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 'c': // Prefix: "c"
																if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposListCommentsForCommitRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
																switch elem[0] {
																case 'h': // Prefix: "heck-"
																	if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		s.handleChecksListSuitesForRefRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)

																		return
																	}
																	switch elem[0] {
																	case 'r': // Prefix: "runs"
																		if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ChecksListForRef
																			s.handleChecksListForRefRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)

																			return
																		}
																	case 's': // Prefix: "suites"
																		if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ChecksListSuitesForRef
																			s.handleChecksListSuitesForRefRequest([3]string{
																				args[0],
																				args[1],
																				args[2],
																			}, w, r)

																			return
																		}
																	}
																case 'o': // Prefix: "omments"
																	if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposListCommentsForCommit
																		s.handleReposListCommentsForCommitRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)

																		return
																	}
																}
															case 'p': // Prefix: "pulls"
																if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposListPullRequestsAssociatedWithCommit
																	s.handleReposListPullRequestsAssociatedWithCommitRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
															case 's': // Prefix: "status"
																if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	s.handleReposGetCombinedStatusForRefRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, w, r)

																	return
																}
																switch elem[0] {
																case 'e': // Prefix: "es"
																	if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposListCommitStatusesForRef
																		s.handleReposListCommitStatusesForRefRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, w, r)

																		return
																	}
																}
															}
														}
													}
												case 'u': // Prefix: "unity/profile"
													if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetCommunityProfileMetrics
														s.handleReposGetCommunityProfileMetricsRequest([2]string{
															args[0],
															args[1],
														}, w, r)

														return
													}
												}
											case 'p': // Prefix: "pare/"
												if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "basehead"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposCompareCommits
													s.handleReposCompareCommitsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'n': // Prefix: "ntributors"
											if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListContributors
												s.handleReposListContributorsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								case 'd': // Prefix: "deployments"
									if l := len("deployments"); len(elem) >= l && elem[0:l] == "deployments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposListDeploymentsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "deployment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleReposGetDeploymentRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/statuses"
											if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposListDeploymentStatusesRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "status_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetDeploymentStatus
													s.handleReposGetDeploymentStatusRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
											}
										}
									}
								case 'e': // Prefix: "events"
									if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListRepoEvents
										s.handleActivityListRepoEventsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'f': // Prefix: "forks"
									if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposListForks
										s.handleReposListForksRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'g': // Prefix: "git/"
									if l := len("git/"); len(elem) >= l && elem[0:l] == "git/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleGitGetCommitRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'b': // Prefix: "blobs/"
										if l := len("blobs/"); len(elem) >= l && elem[0:l] == "blobs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "file_sha"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetBlob
											s.handleGitGetBlobRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'c': // Prefix: "commits/"
										if l := len("commits/"); len(elem) >= l && elem[0:l] == "commits/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commit_sha"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetCommit
											s.handleGitGetCommitRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'm': // Prefix: "matching-refs/"
										if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitListMatchingRefs
											s.handleGitListMatchingRefsRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'r': // Prefix: "ref/"
										if l := len("ref/"); len(elem) >= l && elem[0:l] == "ref/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetRef
											s.handleGitGetRefRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 't': // Prefix: "t"
										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleGitGetTreeRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'a': // Prefix: "ags/"
											if l := len("ags/"); len(elem) >= l && elem[0:l] == "ags/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "tag_sha"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GitGetTag
												s.handleGitGetTagRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'r': // Prefix: "rees/"
											if l := len("rees/"); len(elem) >= l && elem[0:l] == "rees/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "tree_sha"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GitGetTree
												s.handleGitGetTreeRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								case 'h': // Prefix: "hooks"
									if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposListWebhooksRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "hook_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleReposGetWebhookRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetWebhookDeliveryRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'c': // Prefix: "config"
												if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetWebhookConfigForRepo
													s.handleReposGetWebhookConfigForRepoRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'd': // Prefix: "deliveries"
												if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListWebhookDeliveriesRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "delivery_id"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetWebhookDelivery
														s.handleReposGetWebhookDeliveryRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										}
									}
								case 'i': // Prefix: "i"
									if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleMigrationsGetCommitAuthorsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'm': // Prefix: "mport"
										if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleMigrationsGetImportStatusRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleMigrationsGetLargeFilesRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "authors"
												if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsGetCommitAuthors
													s.handleMigrationsGetCommitAuthorsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 'l': // Prefix: "large_files"
												if l := len("large_files"); len(elem) >= l && elem[0:l] == "large_files" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsGetLargeFiles
													s.handleMigrationsGetLargeFilesRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										}
									case 'n': // Prefix: "nvitations"
										if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposListInvitations
											s.handleReposListInvitationsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 's': // Prefix: "ssues"
										if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleIssuesListForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "comments"
												if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesListCommentsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handleIssuesGetCommentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForIssueComment
															s.handleReactionsListForIssueCommentRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													}
												}
											case 'e': // Prefix: "events"
												if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesListEventsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "event_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: IssuesGetEvent
														s.handleIssuesGetEventRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											}
											// Param: "issue_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleIssuesGetRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleIssuesListLabelsOnIssueRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesListComments
														s.handleIssuesListCommentsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												case 'l': // Prefix: "labels"
													if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesListLabelsOnIssue
														s.handleIssuesListLabelsOnIssueRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												case 'r': // Prefix: "reactions"
													if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsListForIssue
														s.handleReactionsListForIssueRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											}
										}
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposListDeployKeysRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "key_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposGetDeployKey
											s.handleReposGetDeployKeyRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								case 'l': // Prefix: "l"
									if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleLicensesGetForRepoRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposListLanguagesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'b': // Prefix: "bels"
											if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleIssuesListLabelsForRepoRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "name"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: IssuesGetLabel
													s.handleIssuesGetLabelRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 'n': // Prefix: "nguages"
											if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListLanguages
												s.handleReposListLanguagesRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									case 'i': // Prefix: "icense"
										if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: LicensesGetForRepo
											s.handleLicensesGetForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								case 'm': // Prefix: "milestones"
									if l := len("milestones"); len(elem) >= l && elem[0:l] == "milestones" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleIssuesListMilestonesRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "milestone_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleIssuesGetMilestoneRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/labels"
											if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: IssuesListLabelsForMilestone
												s.handleIssuesListLabelsForMilestoneRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								case 'n': // Prefix: "notifications"
									if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListRepoNotificationsForAuthenticatedUser
										s.handleActivityListRepoNotificationsForAuthenticatedUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePullsCheckIfMergedRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "ages"
										if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposGetPagesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetPagesHealthCheckRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'b': // Prefix: "builds"
												if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handleReposListPagesBuildsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handleReposGetPagesBuildRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'l': // Prefix: "latest"
														if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetLatestPagesBuild
															s.handleReposGetLatestPagesBuildRequest([2]string{
																args[0],
																args[1],
															}, w, r)

															return
														}
													}
													// Param: "build_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetPagesBuild
														s.handleReposGetPagesBuildRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												}
											case 'h': // Prefix: "health"
												if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetPagesHealthCheck
													s.handleReposGetPagesHealthCheckRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										}
									case 'r': // Prefix: "rojects"
										if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ProjectsListForRepo
											s.handleProjectsListForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'u': // Prefix: "ulls"
										if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handlePullsListRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "comments"
												if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePullsListReviewCommentsForRepoRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														s.handlePullsGetReviewCommentRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForPullRequestReviewComment
															s.handleReactionsListForPullRequestReviewCommentRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													}
												}
											}
											// Param: "pull_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handlePullsGetRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePullsGetReviewRequest([4]string{
														args[0],
														args[1],
														args[2],
														args[3],
													}, w, r)

													return
												}
												switch elem[0] {
												case 'c': // Prefix: "comm"
													if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handlePullsListReviewCommentsRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"
														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListReviewComments
															s.handlePullsListReviewCommentsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													case 'i': // Prefix: "its"
														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListCommits
															s.handlePullsListCommitsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													}
												case 'f': // Prefix: "files"
													if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsListFiles
														s.handlePullsListFilesRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												case 'm': // Prefix: "merge"
													if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsCheckIfMerged
														s.handlePullsCheckIfMergedRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
												case 'r': // Prefix: "re"
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														s.handlePullsListRequestedReviewersRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, w, r)

														return
													}
													switch elem[0] {
													case 'q': // Prefix: "quested_reviewers"
														if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListRequestedReviewers
															s.handlePullsListRequestedReviewersRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
													case 'v': // Prefix: "views"
														if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															s.handlePullsListReviewsRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, w, r)

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "review_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																s.handlePullsGetReviewRequest([4]string{
																	args[0],
																	args[1],
																	args[2],
																	args[3],
																}, w, r)

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/comments"
																if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: PullsListCommentsForReview
																	s.handlePullsListCommentsForReviewRequest([4]string{
																		args[0],
																		args[1],
																		args[2],
																		args[3],
																	}, w, r)

																	return
																}
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "re"
									if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposGetReadmeRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "adme"
										if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposGetReadmeRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "dir"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposGetReadmeInDirectory
												s.handleReposGetReadmeInDirectoryRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 'l': // Prefix: "leases"
										if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposListReleasesRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetReleaseRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "assets/"
												if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "asset_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetReleaseAsset
													s.handleReposGetReleaseAssetRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'l': // Prefix: "latest"
												if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetLatestRelease
													s.handleReposGetLatestReleaseRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 't': // Prefix: "tags/"
												if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tag"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetReleaseByTag
													s.handleReposGetReleaseByTagRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
											// Param: "release_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handleReposGetReleaseRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/assets"
												if l := len("/assets"); len(elem) >= l && elem[0:l] == "/assets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposListReleaseAssets
													s.handleReposListReleaseAssetsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposGetCodeFrequencyStatsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'e': // Prefix: "ecret-scanning/alerts"
										if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleSecretScanningListAlertsForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "alert_number"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: SecretScanningGetAlert
												s.handleSecretScanningGetAlertRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 't': // Prefix: "tats/"
										if l := len("tats/"); len(elem) >= l && elem[0:l] == "tats/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposGetParticipationStatsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'c': // Prefix: "co"
											if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetCommitActivityStatsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'd': // Prefix: "de_frequency"
												if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetCodeFrequencyStats
													s.handleReposGetCodeFrequencyStatsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 'm': // Prefix: "mmit_activity"
												if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetCommitActivityStats
													s.handleReposGetCommitActivityStatsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 'n': // Prefix: "ntributors"
												if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetContributorsStats
													s.handleReposGetContributorsStatsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										case 'p': // Prefix: "p"
											if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetPunchCardStatsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "articipation"
												if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetParticipationStats
													s.handleReposGetParticipationStatsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 'u': // Prefix: "unch_card"
												if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetPunchCardStats
													s.handleReposGetPunchCardStatsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										}
									case 'u': // Prefix: "ubscri"
										if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActivityListWatchersForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'b': // Prefix: "bers"
											if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListWatchersForRepo
												s.handleActivityListWatchersForRepoRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'p': // Prefix: "ption"
											if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityGetRepoSubscription
												s.handleActivityGetRepoSubscriptionRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposGetAllTopicsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposListTagsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'g': // Prefix: "gs"
											if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListTags
												s.handleReposListTagsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'r': // Prefix: "rball/"
											if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "ref"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDownloadTarballArchive
												s.handleReposDownloadTarballArchiveRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 'e': // Prefix: "eams"
										if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposListTeams
											s.handleReposListTeamsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'o': // Prefix: "opics"
										if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposGetAllTopics
											s.handleReposGetAllTopicsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'r': // Prefix: "raffic/"
										if l := len("raffic/"); len(elem) >= l && elem[0:l] == "raffic/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposGetTopPathsRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'c': // Prefix: "clones"
											if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposGetClones
												s.handleReposGetClonesRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										case 'p': // Prefix: "popular/"
											if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposGetTopReferrersRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'p': // Prefix: "paths"
												if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetTopPaths
													s.handleReposGetTopPathsRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											case 'r': // Prefix: "referrers"
												if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetTopReferrers
													s.handleReposGetTopReferrersRequest([2]string{
														args[0],
														args[1],
													}, w, r)

													return
												}
											}
										case 'v': // Prefix: "views"
											if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposGetViews
												s.handleReposGetViewsRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									}
								case 'v': // Prefix: "vulnerability-alerts"
									if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposCheckVulnerabilityAlerts
										s.handleReposCheckVulnerabilityAlertsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'z': // Prefix: "zipball/"
									if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "ref"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDownloadZipballArchive
										s.handleReposDownloadZipballArchiveRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						}
					case 'i': // Prefix: "itories"
						if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleReposListPublicRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/environments/"
								if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "environment_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/secrets"
									if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsListEnvironmentSecretsRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsGetEnvironmentSecretRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetEnvironmentPublicKey
												s.handleActionsGetEnvironmentPublicKeyRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
										// Param: "secret_name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsGetEnvironmentSecret
											s.handleActionsGetEnvironmentSecretRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleSearchCodeRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/enterprises/"
					if l := len("cim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "cim/v2/enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups"
							if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_group_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseGroup
									s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'U': // Prefix: "Users"
							if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_user_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseUser
									s.handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						}
					}
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleSearchIssuesAndPullRequestsRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "co"
						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleSearchCommitsRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'd': // Prefix: "de"
							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCode
								s.handleSearchCodeRequest([0]string{}, w, r)

								return
							}
						case 'm': // Prefix: "mmits"
							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCommits
								s.handleSearchCommitsRequest([0]string{}, w, r)

								return
							}
						}
					case 'i': // Prefix: "issues"
						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchIssuesAndPullRequests
							s.handleSearchIssuesAndPullRequestsRequest([0]string{}, w, r)

							return
						}
					case 'l': // Prefix: "labels"
						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchLabels
							s.handleSearchLabelsRequest([0]string{}, w, r)

							return
						}
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchRepos
							s.handleSearchReposRequest([0]string{}, w, r)

							return
						}
					case 't': // Prefix: "topics"
						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchTopics
							s.handleSearchTopicsRequest([0]string{}, w, r)

							return
						}
					case 'u': // Prefix: "users"
						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchUsers
							s.handleSearchUsersRequest([0]string{}, w, r)

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleTeamsGetLegacyRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleTeamsCheckPermissionsForProjectLegacyRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"
						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsListDiscussionsLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleTeamsGetDiscussionLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReactionsListForTeamDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"
									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleTeamsListDiscussionCommentsLegacyRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handleTeamsGetDiscussionCommentLegacyRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsListForTeamDiscussionCommentLegacy
												s.handleReactionsListForTeamDiscussionCommentLegacyRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								case 'r': // Prefix: "reactions"
									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReactionsListForTeamDiscussionLegacy
										s.handleReactionsListForTeamDiscussionLegacyRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsListPendingInvitationsLegacy
							s.handleTeamsListPendingInvitationsLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsListMembersLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsGetMemberLegacy
								s.handleTeamsGetMemberLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsGetMembershipForUserLegacy
								s.handleTeamsGetMembershipForUserLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 'p': // Prefix: "projects"
						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsListProjectsLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsCheckPermissionsForProjectLegacy
								s.handleTeamsCheckPermissionsForProjectLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsListReposLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsCheckPermissionsForRepoLegacy
									s.handleTeamsCheckPermissionsForRepoLegacyRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						}
					case 't': // Prefix: "team"
						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsListIdpGroupsForLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"
							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsListIdpGroupsForLegacy
								s.handleTeamsListIdpGroupsForLegacyRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsListChildLegacy
								s.handleTeamsListChildLegacyRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleUsersGetAuthenticatedRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsListInstallationReposForAuthenticatedUserRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"
						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListBlockedByAuthenticatedRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersCheckBlocked
								s.handleUsersCheckBlockedRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersListEmailsForAuthenticated
							s.handleUsersListEmailsForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'f': // Prefix: "follow"
						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListFollowersForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"
							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListFollowersForAuthenticatedUser
								s.handleUsersListFollowersForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						case 'i': // Prefix: "ing"
							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleUsersListFollowedByAuthenticatedRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: UsersCheckPersonIsFollowedByAuthenticated
									s.handleUsersCheckPersonIsFollowedByAuthenticatedRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListGpgKeysForAuthenticatedRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetGpgKeyForAuthenticated
								s.handleUsersGetGpgKeyForAuthenticatedRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 'i': // Prefix: "i"
						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleIssuesListForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'n': // Prefix: "nstallations/"
							if l := len("nstallations/"); len(elem) >= l && elem[0:l] == "nstallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories"
								if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListInstallationReposForAuthenticatedUser
									s.handleAppsListInstallationReposForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 's': // Prefix: "ssues"
							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: IssuesListForAuthenticatedUser
								s.handleIssuesListForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListPublicSSHKeysForAuthenticatedRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetPublicSSHKeyForAuthenticated
								s.handleUsersGetPublicSSHKeyForAuthenticatedRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleMigrationsGetArchiveForAuthenticatedUserRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"
							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsListSubscriptionsForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"
								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListSubscriptionsForAuthenticatedUserStubbed
									s.handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest([0]string{}, w, r)

									return
								}
							}
						case 'e': // Prefix: "emberships/orgs"
							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleOrgsListMembershipsForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsGetMembershipForAuthenticatedUser
									s.handleOrgsGetMembershipForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 'i': // Prefix: "igrations"
							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleMigrationsListForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleMigrationsGetStatusForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleMigrationsListReposForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"
										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsGetArchiveForAuthenticatedUser
											s.handleMigrationsGetArchiveForAuthenticatedUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									case 'r': // Prefix: "repositories"
										if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsListReposForUser
											s.handleMigrationsListReposForUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									}
								}
							}
						}
					case 'o': // Prefix: "orgs"
						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: OrgsListForAuthenticatedUser
							s.handleOrgsListForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleUsersListPublicEmailsForAuthenticatedRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"
							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handlePackagesListPackagesForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										s.handlePackagesGetPackageForAuthenticatedUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/versions"
										if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_version_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: PackagesGetPackageVersionForAuthenticatedUser
												s.handlePackagesGetPackageVersionForAuthenticatedUserRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								}
							}
						case 'u': // Prefix: "ublic_emails"
							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListPublicEmailsForAuthenticated
								s.handleUsersListPublicEmailsForAuthenticatedRequest([0]string{}, w, r)

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleReposListForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"
							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposListInvitationsForAuthenticatedUser
								s.handleReposListInvitationsForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						}
					case 's': // Prefix: "s"
						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActivityListWatchedReposForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"
							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActivityListReposStarredByAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActivityCheckRepoIsStarredByAuthenticatedUser
										s.handleActivityCheckRepoIsStarredByAuthenticatedUserRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						case 'u': // Prefix: "ubscriptions"
							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListWatchedReposForAuthenticatedUser
								s.handleActivityListWatchedReposForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsListForAuthenticatedUser
							s.handleTeamsListForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
					}
				case 's': // Prefix: "s"
					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleUsersListRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleUsersGetByUsernameRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActivityListReceivedEventsForUserRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'e': // Prefix: "events"
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActivityListEventsForAuthenticatedUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActivityListPublicEventsForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"
										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActivityListOrgEventsForAuthenticatedUser
											s.handleActivityListOrgEventsForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'p': // Prefix: "public"
										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityListPublicEventsForUser
											s.handleActivityListPublicEventsForUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									}
								}
							case 'f': // Prefix: "follow"
								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleUsersListFollowersForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"
									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersListFollowersForUser
										s.handleUsersListFollowersForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								case 'i': // Prefix: "ing"
									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleUsersListFollowingForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: UsersCheckFollowingForUser
											s.handleUsersCheckFollowingForUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								}
							case 'g': // Prefix: "g"
								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleUsersListGpgKeysForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"
									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsListForUser
										s.handleGistsListForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								case 'p': // Prefix: "pg_keys"
									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersListGpgKeysForUser
										s.handleUsersListGpgKeysForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							case 'h': // Prefix: "hovercard"
								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: UsersGetContextForUser
									s.handleUsersGetContextForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'k': // Prefix: "keys"
								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: UsersListPublicKeysForUser
									s.handleUsersListPublicKeysForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'o': // Prefix: "orgs"
								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsListForUser
									s.handleOrgsListForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'p': // Prefix: "p"
								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleProjectsListForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"
									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePackagesListPackagesForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												s.handlePackagesGetPackageForUserRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/versions"
												if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													s.handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: PackagesGetPackageVersionForUser
														s.handlePackagesGetPackageVersionForUserRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										}
									}
								case 'r': // Prefix: "rojects"
									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ProjectsListForUser
										s.handleProjectsListForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposListForUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"
									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActivityListReceivedEventsForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/public"
										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityListReceivedPublicEventsForUser
											s.handleActivityListReceivedPublicEventsForUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									}
								case 'p': // Prefix: "pos"
									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposListForUser
										s.handleReposListForUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleBillingGetGithubActionsBillingUserRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"
									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleBillingGetGithubPackagesBillingUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"
										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubActionsBillingUser
											s.handleBillingGetGithubActionsBillingUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									case 'p': // Prefix: "packages"
										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubPackagesBillingUser
											s.handleBillingGetGithubPackagesBillingUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									case 's': // Prefix: "shared-storage"
										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetSharedStorageBillingUser
											s.handleBillingGetSharedStorageBillingUserRequest([1]string{
												args[0],
											}, w, r)

											return
										}
									}
								case 'u': // Prefix: "ubscriptions"
									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListReposWatchedByUser
										s.handleActivityListReposWatchedByUserRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							}
						}
					}
				}
			}
		}
	case "PATCH":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActivityMarkThreadAsReadRequest([1]string{
					args[0],
				}, w, r)

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsUpdateAuthorizationRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsUpdateWebhookConfigForAppRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/config"
						if l := len("/hook/config"); len(elem) >= l && elem[0:l] == "/hook/config" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: AppsUpdateWebhookConfigForApp
							s.handleAppsUpdateWebhookConfigForAppRequest([0]string{}, w, r)

							return
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/token"
							if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsResetToken
								s.handleAppsResetTokenRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsUpdateAuthorization
						s.handleOAuthAuthorizationsUpdateAuthorizationRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/runner-groups/"
					if l := len("/actions/runner-groups/"); len(elem) >= l && elem[0:l] == "/actions/runner-groups/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "runner_group_id"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise
						s.handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/comments/"
					if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "comment_id"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: GistsUpdateComment
						s.handleGistsUpdateCommentRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ActivityMarkThreadAsRead
					s.handleActivityMarkThreadAsReadRequest([1]string{
						args[0],
					}, w, r)

					return
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleOrgsUpdateWebhookRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/runner-groups/"
						if l := len("actions/runner-groups/"); len(elem) >= l && elem[0:l] == "actions/runner-groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "runner_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ActionsUpdateSelfHostedRunnerGroupForOrg
							s.handleActionsUpdateSelfHostedRunnerGroupForOrgRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'h': // Prefix: "hooks/"
						if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "hook_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleOrgsUpdateWebhookRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/config"
							if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsUpdateWebhookConfigForOrg
								s.handleOrgsUpdateWebhookConfigForOrgRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleTeamsUpdateInOrgRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsUpdateDiscussionCommentInOrgRequest([4]string{
									args[0],
									args[1],
									args[2],
									args[3],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'd': // Prefix: "discussions/"
								if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "discussion_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									s.handleTeamsUpdateDiscussionInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/comments/"
									if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsUpdateDiscussionCommentInOrg
										s.handleTeamsUpdateDiscussionCommentInOrgRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
								}
							case 't': // Prefix: "team-sync/group-mappings"
								if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsInOrg
									s.handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsUpdateColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsUpdateCard
							s.handleProjectsUpdateCardRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsUpdateColumn
						s.handleProjectsUpdateColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
				// Param: "project_id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ProjectsUpdate
					s.handleProjectsUpdateRequest([1]string{
						args[0],
					}, w, r)

					return
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repo"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[1] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleReposUpdateRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleGitUpdateRefRequest([3]string{
								args[0],
								args[1],
								args[2],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'b': // Prefix: "branches/"
							if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "branch"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/protection/required_"
								if l := len("/protection/required_"); len(elem) >= l && elem[0:l] == "/protection/required_" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposUpdateStatusCheckProtectionRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'p': // Prefix: "pull_request_reviews"
									if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposUpdatePullRequestReviewProtection
										s.handleReposUpdatePullRequestReviewProtectionRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 's': // Prefix: "status_checks"
									if l := len("status_checks"); len(elem) >= l && elem[0:l] == "status_checks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposUpdateStatusCheckProtection
										s.handleReposUpdateStatusCheckProtectionRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleCodeScanningUpdateAlertRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'h': // Prefix: "heck-suites/preferences"
								if l := len("heck-suites/preferences"); len(elem) >= l && elem[0:l] == "heck-suites/preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ChecksSetSuitesPreferences
									s.handleChecksSetSuitesPreferencesRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'o': // Prefix: "o"
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposUpdateCommitCommentRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'd': // Prefix: "de-scanning/alerts/"
									if l := len("de-scanning/alerts/"); len(elem) >= l && elem[0:l] == "de-scanning/alerts/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "alert_number"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: CodeScanningUpdateAlert
										s.handleCodeScanningUpdateAlertRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'm': // Prefix: "mments/"
									if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposUpdateCommitComment
										s.handleReposUpdateCommitCommentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						case 'g': // Prefix: "git/refs/"
							if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "ref"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: GitUpdateRef
								s.handleGitUpdateRefRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 'h': // Prefix: "hooks/"
							if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleReposUpdateWebhookRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/config"
								if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposUpdateWebhookConfigForRepo
									s.handleReposUpdateWebhookConfigForRepoRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleMigrationsMapCommitAuthorRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'm': // Prefix: "mport"
								if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleMigrationsUpdateImportRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleMigrationsSetLfsPreferenceRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "authors/"
										if l := len("authors/"); len(elem) >= l && elem[0:l] == "authors/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "author_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: MigrationsMapCommitAuthor
											s.handleMigrationsMapCommitAuthorRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'l': // Prefix: "lfs"
										if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsSetLfsPreference
											s.handleMigrationsSetLfsPreferenceRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								}
							case 'n': // Prefix: "nvitations/"
								if l := len("nvitations/"); len(elem) >= l && elem[0:l] == "nvitations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ReposUpdateInvitation
									s.handleReposUpdateInvitationRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							case 's': // Prefix: "ssues/"
								if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments/"
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesUpdateComment
										s.handleIssuesUpdateCommentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
								// Param: "issue_number"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: IssuesUpdate
									s.handleIssuesUpdateRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
						case 'l': // Prefix: "labels/"
							if l := len("labels/"); len(elem) >= l && elem[0:l] == "labels/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: IssuesUpdateLabel
								s.handleIssuesUpdateLabelRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 'm': // Prefix: "milestones/"
							if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "milestone_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: IssuesUpdateMilestone
								s.handleIssuesUpdateMilestoneRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 'p': // Prefix: "pulls/"
							if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comments/"
								if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "comment_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PullsUpdateReviewComment
									s.handlePullsUpdateReviewCommentRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
							// Param: "pull_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: PullsUpdate
								s.handlePullsUpdateRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 'r': // Prefix: "releases/"
							if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "assets/"
								if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "asset_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ReposUpdateReleaseAsset
									s.handleReposUpdateReleaseAssetRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							}
							// Param: "release_id"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ReposUpdateRelease
								s.handleReposUpdateReleaseRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 's': // Prefix: "secret-scanning/alerts/"
							if l := len("secret-scanning/alerts/"); len(elem) >= l && elem[0:l] == "secret-scanning/alerts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "alert_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: SecretScanningUpdateAlert
								s.handleSecretScanningUpdateAlertRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups/"
						if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseGroup
							s.handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'U': // Prefix: "Users/"
						if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseUser
							s.handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					s.handleTeamsUpdateLegacyRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleTeamsUpdateDiscussionCommentLegacyRequest([3]string{
							args[0],
							args[1],
							args[2],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions/"
						if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							s.handleTeamsUpdateDiscussionLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/comments/"
							if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "comment_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsUpdateDiscussionCommentLegacy
								s.handleTeamsUpdateDiscussionCommentLegacyRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					case 't': // Prefix: "team-sync/group-mappings"
						if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsLegacy
							s.handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleUsersUpdateAuthenticatedRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleReposAcceptInvitationRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'e': // Prefix: "email/visibility"
						if l := len("email/visibility"); len(elem) >= l && elem[0:l] == "email/visibility" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersSetPrimaryEmailVisibilityForAuthenticated
							s.handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'm': // Prefix: "memberships/orgs/"
						if l := len("memberships/orgs/"); len(elem) >= l && elem[0:l] == "memberships/orgs/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsUpdateMembershipForAuthenticatedUser
							s.handleOrgsUpdateMembershipForAuthenticatedUserRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposAcceptInvitation
							s.handleReposAcceptInvitationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			}
		}
	case "POST":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsCreateRegistrationTokenForOrgRequest([1]string{
					args[0],
				}, w, r)

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsCreateAuthorizationRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleAppsCreateInstallationAccessTokenRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsRedeliverWebhookDeliveryRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/deliveries/"
							if l := len("hook/deliveries/"); len(elem) >= l && elem[0:l] == "hook/deliveries/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "delivery_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/attempts"
								if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsRedeliverWebhookDelivery
									s.handleAppsRedeliverWebhookDeliveryRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						case 'i': // Prefix: "installations/"
							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/access_tokens"
								if l := len("/access_tokens"); len(elem) >= l && elem[0:l] == "/access_tokens" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsCreateInstallationAccessToken
									s.handleAppsCreateInstallationAccessTokenRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/token"
							if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleAppsCheckTokenRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/scoped"
								if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsScopeToken
									s.handleAppsScopeTokenRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsCreateAuthorization
						s.handleOAuthAuthorizationsCreateAuthorizationRequest([0]string{}, w, r)

						return
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/runner"
					if l := len("/actions/runner"); len(elem) >= l && elem[0:l] == "/actions/runner" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '-': // Prefix: "-groups"
						if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
							s.handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 's': // Prefix: "s/re"
						if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'g': // Prefix: "gistration-token"
							if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminCreateRegistrationTokenForEnterprise
								s.handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'm': // Prefix: "move-token"
							if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminCreateRemoveTokenForEnterprise
								s.handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
				}
			case 'g': // Prefix: "gists"
				if l := len("gists"); len(elem) >= l && elem[0:l] == "gists" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleGistsCreateRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "gist_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleGistsForkRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'c': // Prefix: "comments"
							if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsCreateComment
								s.handleGistsCreateCommentRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 'f': // Prefix: "forks"
							if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsFork
								s.handleGistsForkRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleMigrationsStartForOrgRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/runner"
						if l := len("actions/runner"); len(elem) >= l && elem[0:l] == "actions/runner" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '-': // Prefix: "-groups"
							if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActionsCreateSelfHostedRunnerGroupForOrg
								s.handleActionsCreateSelfHostedRunnerGroupForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						case 's': // Prefix: "s/re"
							if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsCreateRemoveTokenForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'g': // Prefix: "gistration-token"
								if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActionsCreateRegistrationTokenForOrg
									s.handleActionsCreateRegistrationTokenForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							case 'm': // Prefix: "move-token"
								if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActionsCreateRemoveTokenForOrg
									s.handleActionsCreateRemoveTokenForOrgRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 'h': // Prefix: "hooks"
						if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleOrgsCreateWebhookRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleOrgsRedeliverWebhookDeliveryRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'd': // Prefix: "deliveries/"
									if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"
										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsRedeliverWebhookDelivery
											s.handleOrgsRedeliverWebhookDeliveryRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								case 'p': // Prefix: "pings"
									if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: OrgsPingWebhook
										s.handleOrgsPingWebhookRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: OrgsCreateInvitation
							s.handleOrgsCreateInvitationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'm': // Prefix: "migrations"
						if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: MigrationsStartForOrg
							s.handleMigrationsStartForOrgRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleProjectsCreateForOrgRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePackagesRestorePackageVersionForOrgRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'r': // Prefix: "restore"
										if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageForOrg
											s.handlePackagesRestorePackageForOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'v': // Prefix: "versions/"
										if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_version_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"
											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PackagesRestorePackageVersionForOrg
												s.handlePackagesRestorePackageVersionForOrgRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, w, r)

												return
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsCreateForOrg
								s.handleProjectsCreateForOrgRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ReposCreateInOrg
							s.handleReposCreateInOrgRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsCreateRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "team_slug"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/discussions"
								if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleTeamsCreateDiscussionInOrgRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "discussion_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReactionsCreateForTeamDiscussionInOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'c': // Prefix: "comments"
											if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleTeamsCreateDiscussionCommentInOrgRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/reactions"
													if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsCreateForTeamDiscussionCommentInOrg
														s.handleReactionsCreateForTeamDiscussionCommentInOrgRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										case 'r': // Prefix: "reactions"
											if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForTeamDiscussionInOrg
												s.handleReactionsCreateForTeamDiscussionInOrgRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleProjectsMoveColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"
							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsMoveCard
								s.handleProjectsMoveCardRequest([1]string{
									args[0],
								}, w, r)

								return
							}
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/moves"
						if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsMoveColumn
							s.handleProjectsMoveColumnRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/columns"
					if l := len("/columns"); len(elem) >= l && elem[0:l] == "/columns" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ProjectsCreateColumn
						s.handleProjectsCreateColumnRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repo"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[1] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleAppsCreateContentAttachmentRequest([3]string{
								args[0],
								args[1],
								args[2],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposCreateAutolinkRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/run"
								if l := len("ctions/run"); len(elem) >= l && elem[0:l] == "ctions/run" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsCreateRegistrationTokenForRepoRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'n': // Prefix: "ners/re"
									if l := len("ners/re"); len(elem) >= l && elem[0:l] == "ners/re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsCreateRemoveTokenForRepoRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'g': // Prefix: "gistration-token"
										if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActionsCreateRegistrationTokenForRepo
											s.handleActionsCreateRegistrationTokenForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'm': // Prefix: "move-token"
										if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActionsCreateRemoveTokenForRepo
											s.handleActionsCreateRemoveTokenForRepoRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								case 's': // Prefix: "s/"
									if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "run_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsCancelWorkflowRunRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'a': // Prefix: "approve"
											if l := len("approve"); len(elem) >= l && elem[0:l] == "approve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsApproveWorkflowRun
												s.handleActionsApproveWorkflowRunRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'c': // Prefix: "cancel"
											if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsCancelWorkflowRun
												s.handleActionsCancelWorkflowRunRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'p': // Prefix: "pending_deployments"
											if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsReviewPendingDeploymentsForRun
												s.handleActionsReviewPendingDeploymentsForRunRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 'r': // Prefix: "re"
											if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleActionsRetryWorkflowRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'r': // Prefix: "run"
												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsReRunWorkflow
													s.handleActionsReRunWorkflowRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 't': // Prefix: "try"
												if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsRetryWorkflow
													s.handleActionsRetryWorkflowRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										}
									}
								}
							case 'u': // Prefix: "utolinks"
								if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateAutolink
									s.handleReposCreateAutolinkRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'b': // Prefix: "branches/"
							if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "branch"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposRenameBranchRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'p': // Prefix: "protection/"
									if l := len("protection/"); len(elem) >= l && elem[0:l] == "protection/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposSetAdminBranchProtectionRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'e': // Prefix: "enforce_admins"
										if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposSetAdminBranchProtection
											s.handleReposSetAdminBranchProtectionRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'r': // Prefix: "re"
										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposAddStatusCheckContextsRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'q': // Prefix: "quired_s"
											if l := len("quired_s"); len(elem) >= l && elem[0:l] == "quired_s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposCreateCommitSignatureProtectionRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'i': // Prefix: "ignatures"
												if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposCreateCommitSignatureProtection
													s.handleReposCreateCommitSignatureProtectionRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 't': // Prefix: "tatus_checks/contexts"
												if l := len("tatus_checks/contexts"); len(elem) >= l && elem[0:l] == "tatus_checks/contexts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddStatusCheckContexts
													s.handleReposAddStatusCheckContextsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										case 's': // Prefix: "strictions/"
											if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposAddTeamAccessRestrictionsRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "apps"
												if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddAppAccessRestrictions
													s.handleReposAddAppAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 't': // Prefix: "teams"
												if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddTeamAccessRestrictions
													s.handleReposAddTeamAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'u': // Prefix: "users"
												if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddUserAccessRestrictions
													s.handleReposAddUserAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										}
									}
								case 'r': // Prefix: "rename"
									if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposRenameBranch
										s.handleReposRenameBranchRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleChecksCreateSuiteRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'h': // Prefix: "heck-suites"
								if l := len("heck-suites"); len(elem) >= l && elem[0:l] == "heck-suites" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleChecksCreateSuiteRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "check_suite_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/rerequest"
										if l := len("/rerequest"); len(elem) >= l && elem[0:l] == "/rerequest" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ChecksRerequestSuite
											s.handleChecksRerequestSuiteRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 'o': // Prefix: "o"
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleCodeScanningUploadSarifRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'd': // Prefix: "de-scanning/sarifs"
									if l := len("de-scanning/sarifs"); len(elem) >= l && elem[0:l] == "de-scanning/sarifs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: CodeScanningUploadSarif
										s.handleCodeScanningUploadSarifRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'm': // Prefix: "mm"
									if l := len("mm"); len(elem) >= l && elem[0:l] == "mm" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposCreateCommitCommentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'e': // Prefix: "ents/"
										if l := len("ents/"); len(elem) >= l && elem[0:l] == "ents/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForCommitComment
												s.handleReactionsCreateForCommitCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									case 'i': // Prefix: "its/"
										if l := len("its/"); len(elem) >= l && elem[0:l] == "its/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commit_sha"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/comments"
											if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposCreateCommitComment
												s.handleReposCreateCommitCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								case 'n': // Prefix: "ntent_references/"
									if l := len("ntent_references/"); len(elem) >= l && elem[0:l] == "ntent_references/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "content_reference_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/attachments"
										if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: AppsCreateContentAttachment
											s.handleAppsCreateContentAttachmentRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						case 'd': // Prefix: "d"
							if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposCreateDispatchEventRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'e': // Prefix: "eployments"
								if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposCreateDeploymentRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "deployment_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/statuses"
										if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposCreateDeploymentStatus
											s.handleReposCreateDeploymentStatusRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 'i': // Prefix: "ispatches"
								if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateDispatchEvent
									s.handleReposCreateDispatchEventRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'f': // Prefix: "forks"
							if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposCreateFork
								s.handleReposCreateForkRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'g': // Prefix: "g"
							if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposCreateUsingTemplateRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'e': // Prefix: "enerate"
								if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateUsingTemplate
									s.handleReposCreateUsingTemplateRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'i': // Prefix: "it/"
								if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleGitCreateCommitRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'b': // Prefix: "blobs"
									if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateBlob
										s.handleGitCreateBlobRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'c': // Prefix: "commits"
									if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateCommit
										s.handleGitCreateCommitRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'r': // Prefix: "refs"
									if l := len("refs"); len(elem) >= l && elem[0:l] == "refs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateRef
										s.handleGitCreateRefRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleGitCreateTreeRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "ags"
										if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GitCreateTag
											s.handleGitCreateTagRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'r': // Prefix: "rees"
										if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GitCreateTree
											s.handleGitCreateTreeRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								}
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposCreateWebhookRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposRedeliverWebhookDeliveryRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'd': // Prefix: "deliveries/"
										if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "delivery_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/attempts"
											if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposRedeliverWebhookDelivery
												s.handleReposRedeliverWebhookDeliveryRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, w, r)

												return
											}
										}
									case 'p': // Prefix: "pings"
										if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposPingWebhook
											s.handleReposPingWebhookRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 't': // Prefix: "tests"
										if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposTestPushWebhook
											s.handleReposTestPushWebhookRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						case 'i': // Prefix: "issues"
							if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleIssuesCreateRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments/"
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/reactions"
										if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForIssueComment
											s.handleReactionsCreateForIssueCommentRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
								// Param: "issue_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleIssuesCreateCommentRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'a': // Prefix: "assignees"
										if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesAddAssignees
											s.handleIssuesAddAssigneesRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'c': // Prefix: "comments"
										if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesCreateComment
											s.handleIssuesCreateCommentRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'r': // Prefix: "reactions"
										if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForIssue
											s.handleReactionsCreateForIssueRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						case 'k': // Prefix: "keys"
							if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposCreateDeployKey
								s.handleReposCreateDeployKeyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'l': // Prefix: "labels"
							if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: IssuesCreateLabel
								s.handleIssuesCreateLabelRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposMergeRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'e': // Prefix: "erge"
								if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposMergeUpstreamRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '-': // Prefix: "-upstream"
									if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposMergeUpstream
										s.handleReposMergeUpstreamRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposMerge
										s.handleReposMergeRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							case 'i': // Prefix: "ilestones"
								if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: IssuesCreateMilestone
									s.handleIssuesCreateMilestoneRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handlePullsCreateRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'a': // Prefix: "ages"
								if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposCreatePagesSiteRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/builds"
									if l := len("/builds"); len(elem) >= l && elem[0:l] == "/builds" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposRequestPagesBuild
										s.handleReposRequestPagesBuildRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsCreateForRepo
									s.handleProjectsCreateForRepoRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'u': // Prefix: "ulls"
								if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handlePullsCreateRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "comments/"
										if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForPullRequestReviewComment
												s.handleReactionsCreateForPullRequestReviewCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
									// Param: "pull_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handlePullsCreateReviewRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'c': // Prefix: "comments"
											if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePullsCreateReviewCommentRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/replies"
													if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsCreateReplyForReviewComment
														s.handlePullsCreateReplyForReviewCommentRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										case 'r': // Prefix: "reviews"
											if l := len("reviews"); len(elem) >= l && elem[0:l] == "reviews" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handlePullsCreateReviewRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "review_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/events"
													if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsSubmitReview
														s.handlePullsSubmitReviewRequest([4]string{
															args[0],
															args[1],
															args[2],
															args[3],
														}, w, r)

														return
													}
												}
											}
										}
									}
								}
							}
						case 'r': // Prefix: "releases"
							if l := len("releases"); len(elem) >= l && elem[0:l] == "releases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReposCreateReleaseRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "release_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/reactions"
									if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReactionsCreateForRelease
										s.handleReactionsCreateForReleaseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						case 's': // Prefix: "statuses/"
							if l := len("statuses/"); len(elem) >= l && elem[0:l] == "statuses/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "sha"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ReposCreateCommitStatus
								s.handleReposCreateCommitStatusRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						case 't': // Prefix: "transfer"
							if l := len("transfer"); len(elem) >= l && elem[0:l] == "transfer" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposTransfer
								s.handleReposTransferRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups"
						if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseGroup
							s.handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'U': // Prefix: "Users"
						if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseUser
							s.handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/discussions"
					if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleTeamsCreateDiscussionLegacyRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleReactionsCreateForTeamDiscussionLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'c': // Prefix: "comments"
								if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleTeamsCreateDiscussionCommentLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/reactions"
										if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForTeamDiscussionCommentLegacy
											s.handleReactionsCreateForTeamDiscussionCommentLegacyRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 'r': // Prefix: "reactions"
								if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReactionsCreateForTeamDiscussionLegacy
									s.handleReactionsCreateForTeamDiscussionLegacyRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handlePackagesRestorePackageForUserRequest([3]string{
						args[0],
						args[1],
						args[2],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handlePackagesRestorePackageForAuthenticatedUserRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersAddEmailForAuthenticated
							s.handleUsersAddEmailForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreateGpgKeyForAuthenticated
							s.handleUsersCreateGpgKeyForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreatePublicSSHKeyForAuthenticated
							s.handleUsersCreatePublicSSHKeyForAuthenticatedRequest([0]string{}, w, r)

							return
						}
					case 'm': // Prefix: "migrations"
						if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: MigrationsStartForAuthenticatedUser
							s.handleMigrationsStartForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleProjectsCreateForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'r': // Prefix: "restore"
										if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageForAuthenticatedUser
											s.handlePackagesRestorePackageForAuthenticatedUserRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									case 'v': // Prefix: "versions/"
										if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_version_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"
											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PackagesRestorePackageVersionForAuthenticatedUser
												s.handlePackagesRestorePackageVersionForAuthenticatedUserRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsCreateForAuthenticatedUser
								s.handleProjectsCreateForAuthenticatedUserRequest([0]string{}, w, r)

								return
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ReposCreateForAuthenticatedUser
							s.handleReposCreateForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/packages/"
						if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handlePackagesRestorePackageVersionForUserRequest([4]string{
										args[0],
										args[1],
										args[2],
										args[3],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'r': // Prefix: "restore"
									if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: PackagesRestorePackageForUser
										s.handlePackagesRestorePackageForUserRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'v': // Prefix: "versions/"
									if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_version_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[3] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/restore"
										if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageVersionForUser
											s.handlePackagesRestorePackageVersionForUserRequest([4]string{
												args[0],
												args[1],
												args[2],
												args[3],
											}, w, r)

											return
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case "PUT":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				s.handleActionsCreateOrUpdateEnvironmentSecretRequest([3]string{
					args[0],
					args[1],
					args[2],
				}, w, r)

				return
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest([1]string{
						args[0],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'p': // Prefix: "pp/installations/"
					if l := len("pp/installations/"); len(elem) >= l && elem[0:l] == "pp/installations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "installation_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/suspended"
						if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: AppsSuspendInstallation
							s.handleAppsSuspendInstallationRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				case 'u': // Prefix: "uthorizations/clients/"
					if l := len("uthorizations/clients/"); len(elem) >= l && elem[0:l] == "uthorizations/clients/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "client_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "fingerprint"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint
							s.handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/"
					if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'p': // Prefix: "permissions"
						if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest([1]string{
								args[0],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'o': // Prefix: "organizations"
								if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
										s.handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							case 's': // Prefix: "selected-actions"
								if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminSetAllowedActionsEnterprise
									s.handleEnterpriseAdminSetAllowedActionsEnterpriseRequest([1]string{
										args[0],
									}, w, r)

									return
								}
							}
						}
					case 'r': // Prefix: "runner-groups/"
						if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "runner_group_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'o': // Prefix: "organizations"
								if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
										s.handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							case 'r': // Prefix: "runners"
								if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
										s.handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/star"
					if l := len("/star"); len(elem) >= l && elem[0:l] == "/star" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: GistsStar
						s.handleGistsStarRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				}
			case 'n': // Prefix: "notifications"
				if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActivityMarkNotificationsAsReadRequest([0]string{}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/threads/"
					if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "thread_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/subscription"
						if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ActivitySetThreadSubscription
							s.handleActivitySetThreadSubscriptionRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleInteractionsSetRestrictionsForOrgRequest([1]string{
							args[0],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleActionsAddSelectedRepoToOrgSecretRequest([3]string{
								args[0],
								args[1],
								args[2],
							}, w, r)

							return
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions"
							if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActionsSetGithubActionsPermissionsOrganizationRequest([1]string{
									args[0],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsSetAllowedActionsOrganizationRequest([1]string{
										args[0],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'r': // Prefix: "repositories"
									if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest([1]string{
											args[0],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsEnableSelectedRepositoryGithubActionsOrganization
											s.handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
									}
								case 's': // Prefix: "selected-actions"
									if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActionsSetAllowedActionsOrganization
										s.handleActionsSetAllowedActionsOrganizationRequest([1]string{
											args[0],
										}, w, r)

										return
									}
								}
							}
						case 'r': // Prefix: "runner-groups/"
							if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/r"
								if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'e': // Prefix: "epositories"
									if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
											s.handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								case 'u': // Prefix: "unners"
									if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsSetSelfHostedRunnersInGroupForOrgRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "runner_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsAddSelfHostedRunnerToGroupForOrg
											s.handleActionsAddSelfHostedRunnerToGroupForOrgRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							}
						case 's': // Prefix: "secrets/"
							if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								s.handleActionsCreateOrUpdateOrgSecretRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories"
								if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleActionsSetSelectedReposForOrgSecretRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repository_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActionsAddSelectedRepoToOrgSecret
										s.handleActionsAddSelectedRepoToOrgSecretRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							}
						}
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsBlockUser
							s.handleOrgsBlockUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'i': // Prefix: "interaction-limits"
						if l := len("interaction-limits"); len(elem) >= l && elem[0:l] == "interaction-limits" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: InteractionsSetRestrictionsForOrg
							s.handleInteractionsSetRestrictionsForOrgRequest([1]string{
								args[0],
							}, w, r)

							return
						}
					case 'm': // Prefix: "memberships/"
						if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsSetMembershipForUser
							s.handleOrgsSetMembershipForUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'o': // Prefix: "outside_collaborators/"
						if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsConvertMemberToOutsideCollaborator
							s.handleOrgsConvertMemberToOutsideCollaboratorRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'p': // Prefix: "public_members/"
						if l := len("public_members/"); len(elem) >= l && elem[0:l] == "public_members/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsSetPublicMembershipForAuthenticatedUser
							s.handleOrgsSetPublicMembershipForAuthenticatedUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'm': // Prefix: "memberships/"
								if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddOrUpdateMembershipForUserInOrg
									s.handleTeamsAddOrUpdateMembershipForUserInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							case 'p': // Prefix: "projects/"
								if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddOrUpdateProjectPermissionsInOrg
									s.handleTeamsAddOrUpdateProjectPermissionsInOrgRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsAddOrUpdateRepoPermissionsInOrg
										s.handleTeamsAddOrUpdateRepoPermissionsInOrgRequest([4]string{
											args[0],
											args[1],
											args[2],
											args[3],
										}, w, r)

										return
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/collaborators/"
					if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsAddCollaborator
						s.handleProjectsAddCollaboratorRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
				}
			case 'r': // Prefix: "repos"
				if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleActionsCreateOrUpdateRepoSecretRequest([3]string{
						args[0],
						args[1],
						args[2],
					}, w, r)

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								s.handleActivityMarkRepoNotificationsAsReadRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
							switch elem[0] {
							case 'a': // Prefix: "a"
								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposEnableAutomatedSecurityFixesRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"
									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleActionsSetAllowedActionsRepositoryRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"
										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleActionsSetGithubActionsPermissionsRepositoryRequest([2]string{
												args[0],
												args[1],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/selected-actions"
											if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsSetAllowedActionsRepository
												s.handleActionsSetAllowedActionsRepositoryRequest([2]string{
													args[0],
													args[1],
												}, w, r)

												return
											}
										}
									case 's': // Prefix: "secrets/"
										if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "secret_name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsCreateOrUpdateRepoSecret
											s.handleActionsCreateOrUpdateRepoSecretRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								case 'u': // Prefix: "utomated-security-fixes"
									if l := len("utomated-security-fixes"); len(elem) >= l && elem[0:l] == "utomated-security-fixes" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposEnableAutomatedSecurityFixes
										s.handleReposEnableAutomatedSecurityFixesRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								}
							case 'b': // Prefix: "branches/"
								if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "branch"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/protection"
									if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handleReposUpdateBranchProtectionRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/re"
										if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											s.handleReposSetStatusCheckContextsRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
										switch elem[0] {
										case 'q': // Prefix: "quired_status_checks/contexts"
											if l := len("quired_status_checks/contexts"); len(elem) >= l && elem[0:l] == "quired_status_checks/contexts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposSetStatusCheckContexts
												s.handleReposSetStatusCheckContextsRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
										case 's': // Prefix: "strictions/"
											if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												s.handleReposSetTeamAccessRestrictionsRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, w, r)

												return
											}
											switch elem[0] {
											case 'a': // Prefix: "apps"
												if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetAppAccessRestrictions
													s.handleReposSetAppAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 't': // Prefix: "teams"
												if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetTeamAccessRestrictions
													s.handleReposSetTeamAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											case 'u': // Prefix: "users"
												if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetUserAccessRestrictions
													s.handleReposSetUserAccessRestrictionsRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, w, r)

													return
												}
											}
										}
									}
								}
							case 'c': // Prefix: "co"
								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleReposCreateOrUpdateFileContentsRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'l': // Prefix: "llaborators/"
									if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposAddCollaborator
										s.handleReposAddCollaboratorRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								case 'n': // Prefix: "ntents/"
									if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "path"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposCreateOrUpdateFileContents
										s.handleReposCreateOrUpdateFileContentsRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
								}
							case 'i': // Prefix: "i"
								if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									s.handleIssuesLockRequest([3]string{
										args[0],
										args[1],
										args[2],
									}, w, r)

									return
								}
								switch elem[0] {
								case 'm': // Prefix: "mport"
									if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsStartImport
										s.handleMigrationsStartImportRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 'n': // Prefix: "nteraction-limits"
									if l := len("nteraction-limits"); len(elem) >= l && elem[0:l] == "nteraction-limits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: InteractionsSetRestrictionsForRepo
										s.handleInteractionsSetRestrictionsForRepoRequest([2]string{
											args[0],
											args[1],
										}, w, r)

										return
									}
								case 's': // Prefix: "ssues/"
									if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "issue_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/lock"
										if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesLock
											s.handleIssuesLockRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 'l': // Prefix: "lfs"
								if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposEnableLfsForRepo
									s.handleReposEnableLfsForRepoRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'n': // Prefix: "notifications"
								if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivityMarkRepoNotificationsAsRead
									s.handleActivityMarkRepoNotificationsAsReadRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'p': // Prefix: "pulls/"
								if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "pull_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										s.handlePullsMergeRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, w, r)

										return
									}
									switch elem[0] {
									case 'm': // Prefix: "merge"
										if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PullsMerge
											s.handlePullsMergeRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									case 'r': // Prefix: "reviews/"
										if l := len("reviews/"); len(elem) >= l && elem[0:l] == "reviews/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "review_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											s.handlePullsUpdateReviewRequest([4]string{
												args[0],
												args[1],
												args[2],
												args[3],
											}, w, r)

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/dismissals"
											if l := len("/dismissals"); len(elem) >= l && elem[0:l] == "/dismissals" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PullsDismissReview
												s.handlePullsDismissReviewRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, w, r)

												return
											}
										}
									case 'u': // Prefix: "update-branch"
										if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PullsUpdateBranch
											s.handlePullsUpdateBranchRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, w, r)

											return
										}
									}
								}
							case 's': // Prefix: "subscription"
								if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivitySetRepoSubscription
									s.handleActivitySetRepoSubscriptionRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 't': // Prefix: "topics"
								if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposReplaceAllTopics
									s.handleReposReplaceAllTopicsRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							case 'v': // Prefix: "vulnerability-alerts"
								if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposEnableVulnerabilityAlerts
									s.handleReposEnableVulnerabilityAlertsRequest([2]string{
										args[0],
										args[1],
									}, w, r)

									return
								}
							}
						}
					}
				case 'i': // Prefix: "itories/"
					if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repository_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/environments/"
						if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "environment_name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/secrets/"
							if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActionsCreateOrUpdateEnvironmentSecret
								s.handleActionsCreateOrUpdateEnvironmentSecretRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups/"
						if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseGroup
							s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'U': // Prefix: "Users/"
						if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseUser
							s.handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest([2]string{
							args[0],
							args[1],
						}, w, r)

						return
					}
					switch elem[0] {
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddMemberLegacy
								s.handleTeamsAddMemberLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddOrUpdateMembershipForUserLegacy
								s.handleTeamsAddOrUpdateMembershipForUserLegacyRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 'p': // Prefix: "projects/"
						if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: TeamsAddOrUpdateProjectPermissionsLegacy
							s.handleTeamsAddOrUpdateProjectPermissionsLegacyRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					case 'r': // Prefix: "repos/"
						if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddOrUpdateRepoPermissionsLegacy
								s.handleTeamsAddOrUpdateRepoPermissionsLegacyRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					}
				}
			case 'u': // Prefix: "user/"
				if l := len("user/"); len(elem) >= l && elem[0:l] == "user/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					s.handleAppsAddRepoToInstallationRequest([2]string{
						args[0],
						args[1],
					}, w, r)

					return
				}
				switch elem[0] {
				case 'b': // Prefix: "blocks/"
					if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersBlock
						s.handleUsersBlockRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				case 'f': // Prefix: "following/"
					if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersFollow
						s.handleUsersFollowRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				case 'i': // Prefix: "in"
					if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)

						return
					}
					switch elem[0] {
					case 's': // Prefix: "stallations/"
						if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/repositories/"
							if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: AppsAddRepoToInstallation
								s.handleAppsAddRepoToInstallationRequest([2]string{
									args[0],
									args[1],
								}, w, r)

								return
							}
						}
					case 't': // Prefix: "teraction-limits"
						if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: InteractionsSetRestrictionsForAuthenticatedUser
							s.handleInteractionsSetRestrictionsForAuthenticatedUserRequest([0]string{}, w, r)

							return
						}
					}
				case 's': // Prefix: "starred/"
					if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ActivityStarRepoForAuthenticatedUser
							s.handleActivityStarRepoForAuthenticatedUserRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name  string
	count int
	args  [5]string
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.name
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
func (s *Server) FindRoute(method, path string) (r Route, _ bool) {
	var (
		args = [5]string{}
		elem = path
	)
	r.args = args
	if elem == "" {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch method {
	case "DELETE":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				r.name = "ActionsDeleteOrgSecret"
				r.args = args
				r.count = 0
				return r, true
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OAuthAuthorizationsDeleteAuthorization"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsDeleteInstallation"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/installations/"
						if l := len("/installations/"); len(elem) >= l && elem[0:l] == "/installations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "AppsDeleteInstallation"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/suspended"
							if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsUnsuspendInstallation
								r.name = "AppsUnsuspendInstallation"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "grants/"
							if l := len("grants/"); len(elem) >= l && elem[0:l] == "grants/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsDeleteGrant
								r.name = "OAuthAuthorizationsDeleteGrant"
								r.args = args
								r.count = 1
								return r, true
							}
						}
						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "AppsDeleteToken"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'g': // Prefix: "grant"
								if l := len("grant"); len(elem) >= l && elem[0:l] == "grant" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsDeleteAuthorization
									r.name = "AppsDeleteAuthorization"
									r.args = args
									r.count = 1
									return r, true
								}
							case 't': // Prefix: "token"
								if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsDeleteToken
									r.name = "AppsDeleteToken"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsDeleteAuthorization
						r.name = "OAuthAuthorizationsDeleteAuthorization"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/"
					if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'p': // Prefix: "permissions/organizations/"
						if l := len("permissions/organizations/"); len(elem) >= l && elem[0:l] == "permissions/organizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
							r.name = "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'r': // Prefix: "runner"
						if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '-': // Prefix: "-groups/"
							if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'o': // Prefix: "organizations/"
									if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
										r.name = "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'r': // Prefix: "runners/"
									if l := len("runners/"); len(elem) >= l && elem[0:l] == "runners/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
										r.name = "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						case 's': // Prefix: "s/"
							if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
								r.name = "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "GistsDelete"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "GistsUnstar"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "comments/"
						if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "comment_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GistsDeleteComment
							r.name = "GistsDeleteComment"
							r.args = args
							r.count = 2
							return r, true
						}
					case 's': // Prefix: "star"
						if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: GistsUnstar
							r.name = "GistsUnstar"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'i': // Prefix: "installation/token"
				if l := len("installation/token"); len(elem) >= l && elem[0:l] == "installation/token" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: AppsRevokeInstallationAccessToken
					r.name = "AppsRevokeInstallationAccessToken"
					r.args = args
					r.count = 0
					return r, true
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/subscription"
					if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ActivityDeleteThreadSubscription
						r.name = "ActivityDeleteThreadSubscription"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "InteractionsRemoveRestrictionsForOrg"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ActionsDeleteSelfHostedRunnerFromOrg"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions/repositories/"
							if l := len("permissions/repositories/"); len(elem) >= l && elem[0:l] == "permissions/repositories/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActionsDisableSelectedRepositoryGithubActionsOrganization
								r.name = "ActionsDisableSelectedRepositoryGithubActionsOrganization"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'r': // Prefix: "runner"
							if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActionsDeleteSelfHostedRunnerGroupFromOrg"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '-': // Prefix: "-groups/"
								if l := len("-groups/"); len(elem) >= l && elem[0:l] == "-groups/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_group_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "ActionsDeleteSelfHostedRunnerGroupFromOrg"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/r"
									if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsRemoveSelfHostedRunnerFromGroupForOrg"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'e': // Prefix: "epositories/"
										if l := len("epositories/"); len(elem) >= l && elem[0:l] == "epositories/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
											r.name = "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'u': // Prefix: "unners/"
										if l := len("unners/"); len(elem) >= l && elem[0:l] == "unners/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "runner_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsRemoveSelfHostedRunnerFromGroupForOrg
											r.name = "ActionsRemoveSelfHostedRunnerFromGroupForOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 's': // Prefix: "s/"
								if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "runner_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsDeleteSelfHostedRunnerFromOrg
									r.name = "ActionsDeleteSelfHostedRunnerFromOrg"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 's': // Prefix: "secrets/"
							if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "ActionsDeleteOrgSecret"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories/"
								if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsRemoveSelectedRepoFromOrgSecret
									r.name = "ActionsRemoveSelectedRepoFromOrgSecret"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						}
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsUnblockUser
							r.name = "OrgsUnblockUser"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'c': // Prefix: "credential-authorizations/"
						if l := len("credential-authorizations/"); len(elem) >= l && elem[0:l] == "credential-authorizations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "credential_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsRemoveSamlSSOAuthorization
							r.name = "OrgsRemoveSamlSSOAuthorization"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'h': // Prefix: "hooks/"
						if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "hook_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsDeleteWebhook
							r.name = "OrgsDeleteWebhook"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'i': // Prefix: "in"
						if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "OrgsCancelInvitation"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 't': // Prefix: "teraction-limits"
							if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsRemoveRestrictionsForOrg
								r.name = "InteractionsRemoveRestrictionsForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'v': // Prefix: "vitations/"
							if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "invitation_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsCancelInvitation
								r.name = "OrgsCancelInvitation"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "OrgsRemoveMember"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'e': // Prefix: "embers"
							if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsRemoveMembershipForUser"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsRemoveMember
									r.name = "OrgsRemoveMember"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'h': // Prefix: "hips/"
								if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsRemoveMembershipForUser
									r.name = "OrgsRemoveMembershipForUser"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'i': // Prefix: "igrations/"
							if l := len("igrations/"); len(elem) >= l && elem[0:l] == "igrations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "migration_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "MigrationsUnlockRepoForOrg"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'a': // Prefix: "archive"
									if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsDeleteArchiveForOrg
										r.name = "MigrationsDeleteArchiveForOrg"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'r': // Prefix: "repos/"
									if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/lock"
										if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsUnlockRepoForOrg
											r.name = "MigrationsUnlockRepoForOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						}
					case 'o': // Prefix: "outside_collaborators/"
						if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsRemoveOutsideCollaborator
							r.name = "OrgsRemoveOutsideCollaborator"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "PackagesDeletePackageForOrg"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "PackagesDeletePackageForOrg"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/versions/"
									if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_version_id"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: PackagesDeletePackageVersionForOrg
										r.name = "PackagesDeletePackageVersionForOrg"
										r.args = args
										r.count = 4
										return r, true
									}
								}
							}
						case 'u': // Prefix: "ublic_members/"
							if l := len("ublic_members/"); len(elem) >= l && elem[0:l] == "ublic_members/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OrgsRemovePublicMembershipForAuthenticatedUser
								r.name = "OrgsRemovePublicMembershipForAuthenticatedUser"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "TeamsDeleteInOrg"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "TeamsRemoveMembershipForUserInOrg"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'd': // Prefix: "discussions/"
								if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "discussion_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "TeamsDeleteDiscussionInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReactionsDeleteForTeamDiscussionComment"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'c': // Prefix: "comments/"
										if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "TeamsDeleteDiscussionCommentInOrg"
											r.args = args
											r.count = 4
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions/"
											if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "reaction_id"
											// Leaf parameter
											args[4] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReactionsDeleteForTeamDiscussionComment
												r.name = "ReactionsDeleteForTeamDiscussionComment"
												r.args = args
												r.count = 5
												return r, true
											}
										}
									case 'r': // Prefix: "reactions/"
										if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "reaction_id"
										// Leaf parameter
										args[3] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReactionsDeleteForTeamDiscussion
											r.name = "ReactionsDeleteForTeamDiscussion"
											r.args = args
											r.count = 4
											return r, true
										}
									}
								}
							case 'm': // Prefix: "memberships/"
								if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveMembershipForUserInOrg
									r.name = "TeamsRemoveMembershipForUserInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
							case 'p': // Prefix: "projects/"
								if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsRemoveProjectInOrg
									r.name = "TeamsRemoveProjectInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsRemoveRepoInOrg
										r.name = "TeamsRemoveRepoInOrg"
										r.args = args
										r.count = 4
										return r, true
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ProjectsDeleteColumn"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsDeleteCard
							r.name = "ProjectsDeleteCard"
							r.args = args
							r.count = 1
							return r, true
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsDeleteColumn
						r.name = "ProjectsDeleteColumn"
						r.args = args
						r.count = 1
						return r, true
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "ProjectsDelete"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/collaborators/"
					if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsRemoveCollaborator
						r.name = "ProjectsRemoveCollaborator"
						r.args = args
						r.count = 2
						return r, true
					}
				}
			case 'r': // Prefix: "re"
				if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "ReactionsDeleteLegacy"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'a': // Prefix: "actions/"
					if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "reaction_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ReactionsDeleteLegacy
						r.name = "ReactionsDeleteLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
				case 'p': // Prefix: "pos"
					if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ActionsDeleteEnvironmentSecret"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "ReposDelete"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActivityDeleteRepoSubscription"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'a': // Prefix: "a"
									if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposDeleteAutolink"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'c': // Prefix: "ctions/"
										if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsDeleteRepoSecret"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'a': // Prefix: "artifacts/"
											if l := len("artifacts/"); len(elem) >= l && elem[0:l] == "artifacts/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "artifact_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsDeleteArtifact
												r.name = "ActionsDeleteArtifact"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'r': // Prefix: "run"
											if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsDeleteWorkflowRun"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'n': // Prefix: "ners/"
												if l := len("ners/"); len(elem) >= l && elem[0:l] == "ners/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "runner_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsDeleteSelfHostedRunnerFromRepo
													r.name = "ActionsDeleteSelfHostedRunnerFromRepo"
													r.args = args
													r.count = 3
													return r, true
												}
											case 's': // Prefix: "s/"
												if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "run_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													r.name = "ActionsDeleteWorkflowRun"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/logs"
													if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsDeleteWorkflowRunLogs
														r.name = "ActionsDeleteWorkflowRunLogs"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											}
										case 's': // Prefix: "secrets/"
											if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "secret_name"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsDeleteRepoSecret
												r.name = "ActionsDeleteRepoSecret"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 'u': // Prefix: "uto"
										if l := len("uto"); len(elem) >= l && elem[0:l] == "uto" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposDisableAutomatedSecurityFixes"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'l': // Prefix: "links/"
											if l := len("links/"); len(elem) >= l && elem[0:l] == "links/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "autolink_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteAutolink
												r.name = "ReposDeleteAutolink"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'm': // Prefix: "mated-security-fixes"
											if l := len("mated-security-fixes"); len(elem) >= l && elem[0:l] == "mated-security-fixes" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposDisableAutomatedSecurityFixes
												r.name = "ReposDisableAutomatedSecurityFixes"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								case 'b': // Prefix: "branches/"
									if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "branch"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/protection"
										if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposDeleteBranchProtection"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposDeleteAdminBranchProtection"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'e': // Prefix: "enforce_admins"
												if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposDeleteAdminBranchProtection
													r.name = "ReposDeleteAdminBranchProtection"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'r': // Prefix: "re"
												if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ReposDeleteCommitSignatureProtection"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case 'q': // Prefix: "quired_"
													if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposDeletePullRequestReviewProtection"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case 'p': // Prefix: "pull_request_reviews"
														if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposDeletePullRequestReviewProtection
															r.name = "ReposDeletePullRequestReviewProtection"
															r.args = args
															r.count = 3
															return r, true
														}
													case 's': // Prefix: "s"
														if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "ReposRemoveStatusCheckContexts"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case 'i': // Prefix: "ignatures"
															if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposDeleteCommitSignatureProtection
																r.name = "ReposDeleteCommitSignatureProtection"
																r.args = args
																r.count = 3
																return r, true
															}
														case 't': // Prefix: "tatus_checks"
															if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																r.name = "ReposRemoveStatusCheckProtection"
																r.args = args
																r.count = 3
																return r, true
															}
															switch elem[0] {
															case '/': // Prefix: "/contexts"
																if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposRemoveStatusCheckContexts
																	r.name = "ReposRemoveStatusCheckContexts"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															}
														}
													}
												case 's': // Prefix: "strictions"
													if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposDeleteAccessRestrictions"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "ReposRemoveTeamAccessRestrictions"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case 'a': // Prefix: "apps"
															if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveAppAccessRestrictions
																r.name = "ReposRemoveAppAccessRestrictions"
																r.args = args
																r.count = 3
																return r, true
															}
														case 't': // Prefix: "teams"
															if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveTeamAccessRestrictions
																r.name = "ReposRemoveTeamAccessRestrictions"
																r.args = args
																r.count = 3
																return r, true
															}
														case 'u': // Prefix: "users"
															if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposRemoveUserAccessRestrictions
																r.name = "ReposRemoveUserAccessRestrictions"
																r.args = args
																r.count = 3
																return r, true
															}
														}
													}
												}
											}
										}
									}
								case 'c': // Prefix: "co"
									if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReactionsDeleteForCommitComment"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'd': // Prefix: "de-scanning/analyses/"
										if l := len("de-scanning/analyses/"); len(elem) >= l && elem[0:l] == "de-scanning/analyses/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "analysis_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: CodeScanningDeleteAnalysis
											r.name = "CodeScanningDeleteAnalysis"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'l': // Prefix: "llaborators/"
										if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "username"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposRemoveCollaborator
											r.name = "ReposRemoveCollaborator"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'm': // Prefix: "mments/"
										if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "ReposDeleteCommitComment"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions/"
											if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "reaction_id"
											// Leaf parameter
											args[3] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReactionsDeleteForCommitComment
												r.name = "ReactionsDeleteForCommitComment"
												r.args = args
												r.count = 4
												return r, true
											}
										}
									case 'n': // Prefix: "ntents/"
										if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "path"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposDeleteFile
											r.name = "ReposDeleteFile"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								case 'd': // Prefix: "deployments/"
									if l := len("deployments/"); len(elem) >= l && elem[0:l] == "deployments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "deployment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteDeployment
										r.name = "ReposDeleteDeployment"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'e': // Prefix: "environments/"
									if l := len("environments/"); len(elem) >= l && elem[0:l] == "environments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "environment_name"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteAnEnvironment
										r.name = "ReposDeleteAnEnvironment"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'g': // Prefix: "git/refs/"
									if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "ref"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: GitDeleteRef
										r.name = "GitDeleteRef"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'h': // Prefix: "hooks/"
									if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "hook_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteWebhook
										r.name = "ReposDeleteWebhook"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'i': // Prefix: "i"
									if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "IssuesDeleteComment"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'm': // Prefix: "mport"
										if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsCancelImport
											r.name = "MigrationsCancelImport"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'n': // Prefix: "n"
										if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposDeleteInvitation"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 't': // Prefix: "teraction-limits"
											if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: InteractionsRemoveRestrictionsForRepo
												r.name = "InteractionsRemoveRestrictionsForRepo"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'v': // Prefix: "vitations/"
											if l := len("vitations/"); len(elem) >= l && elem[0:l] == "vitations/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDeleteInvitation
												r.name = "ReposDeleteInvitation"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 's': // Prefix: "ssues/"
										if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "IssuesRemoveAllLabels"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "IssuesDeleteComment"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/reactions/"
												if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForIssueComment
													r.name = "ReactionsDeleteForIssueComment"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
										// Param: "issue_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "IssuesRemoveAssignees"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "assignees"
												if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: IssuesRemoveAssignees
													r.name = "IssuesRemoveAssignees"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'l': // Prefix: "l"
												if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "IssuesUnlock"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case 'a': // Prefix: "abels"
													if l := len("abels"); len(elem) >= l && elem[0:l] == "abels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "IssuesRemoveAllLabels"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "name"
														// Leaf parameter
														args[3] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: IssuesRemoveLabel
															r.name = "IssuesRemoveLabel"
															r.args = args
															r.count = 4
															return r, true
														}
													}
												case 'o': // Prefix: "ock"
													if l := len("ock"); len(elem) >= l && elem[0:l] == "ock" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesUnlock
														r.name = "IssuesUnlock"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											case 'r': // Prefix: "reactions/"
												if l := len("reactions/"); len(elem) >= l && elem[0:l] == "reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForIssue
													r.name = "ReactionsDeleteForIssue"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
									}
								case 'k': // Prefix: "keys/"
									if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "key_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteDeployKey
										r.name = "ReposDeleteDeployKey"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'l': // Prefix: "l"
									if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposDisableLfsForRepo"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "abels/"
										if l := len("abels/"); len(elem) >= l && elem[0:l] == "abels/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: IssuesDeleteLabel
											r.name = "IssuesDeleteLabel"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'f': // Prefix: "fs"
										if l := len("fs"); len(elem) >= l && elem[0:l] == "fs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposDisableLfsForRepo
											r.name = "ReposDisableLfsForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								case 'm': // Prefix: "milestones/"
									if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "milestone_number"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesDeleteMilestone
										r.name = "IssuesDeleteMilestone"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposDeletePagesSite"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "ages"
										if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposDeletePagesSite
											r.name = "ReposDeletePagesSite"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'u': // Prefix: "ulls/"
										if l := len("ulls/"); len(elem) >= l && elem[0:l] == "ulls/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "comments/"
											if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "comment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "PullsDeleteReviewComment"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/reactions/"
												if l := len("/reactions/"); len(elem) >= l && elem[0:l] == "/reactions/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "reaction_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReactionsDeleteForPullRequestComment
													r.name = "ReactionsDeleteForPullRequestComment"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
										// Param: "pull_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/re"
											if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "PullsRemoveRequestedReviewers"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'q': // Prefix: "quested_reviewers"
												if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: PullsRemoveRequestedReviewers
													r.name = "PullsRemoveRequestedReviewers"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'v': // Prefix: "views/"
												if l := len("views/"); len(elem) >= l && elem[0:l] == "views/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "review_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: PullsDeletePendingReview
													r.name = "PullsDeletePendingReview"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
									}
								case 'r': // Prefix: "releases/"
									if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "assets/"
										if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "asset_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposDeleteReleaseAsset
											r.name = "ReposDeleteReleaseAsset"
											r.args = args
											r.count = 3
											return r, true
										}
									}
									// Param: "release_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDeleteRelease
										r.name = "ReposDeleteRelease"
										r.args = args
										r.count = 3
										return r, true
									}
								case 's': // Prefix: "subscription"
									if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityDeleteRepoSubscription
										r.name = "ActivityDeleteRepoSubscription"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'v': // Prefix: "vulnerability-alerts"
									if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposDisableVulnerabilityAlerts
										r.name = "ReposDisableVulnerabilityAlerts"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						}
					case 'i': // Prefix: "itories/"
						if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repository_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/environments/"
							if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "environment_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/secrets/"
								if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "secret_name"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ActionsDeleteEnvironmentSecret
									r.name = "ActionsDeleteEnvironmentSecret"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/"
				if l := len("scim/v2/"); len(elem) >= l && elem[0:l] == "scim/v2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "ScimDeleteUserFromOrg"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'e': // Prefix: "enterprises/"
					if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminDeleteUserFromEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups/"
							if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_group_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteScimGroupFromEnterprise
								r.name = "EnterpriseAdminDeleteScimGroupFromEnterprise"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'U': // Prefix: "Users/"
							if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "scim_user_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminDeleteUserFromEnterprise
								r.name = "EnterpriseAdminDeleteUserFromEnterprise"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				case 'o': // Prefix: "organizations/"
					if l := len("organizations/"); len(elem) >= l && elem[0:l] == "organizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/Users/"
						if l := len("/Users/"); len(elem) >= l && elem[0:l] == "/Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ScimDeleteUserFromOrg
							r.name = "ScimDeleteUserFromOrg"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "TeamsDeleteLegacy"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "TeamsRemoveMemberLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions/"
						if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "TeamsDeleteDiscussionLegacy"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/comments/"
							if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "comment_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsDeleteDiscussionCommentLegacy
								r.name = "TeamsDeleteDiscussionCommentLegacy"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsRemoveMembershipForUserLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveMemberLegacy
								r.name = "TeamsRemoveMemberLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveMembershipForUserLegacy
								r.name = "TeamsRemoveMembershipForUserLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 'p': // Prefix: "projects/"
						if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: TeamsRemoveProjectLegacy
							r.name = "TeamsRemoveProjectLegacy"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'r': // Prefix: "repos/"
						if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsRemoveRepoLegacy
								r.name = "TeamsRemoveRepoLegacy"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "PackagesDeletePackageForUser"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsRemoveRepoFromInstallation"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnblock
							r.name = "UsersUnblock"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersDeleteEmailForAuthenticated
							r.name = "UsersDeleteEmailForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'f': // Prefix: "following/"
						if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersUnfollow
							r.name = "UsersUnfollow"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'g': // Prefix: "gpg_keys/"
						if l := len("gpg_keys/"); len(elem) >= l && elem[0:l] == "gpg_keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "gpg_key_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeleteGpgKeyForAuthenticated
							r.name = "UsersDeleteGpgKeyForAuthenticated"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'i': // Prefix: "in"
						if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "InteractionsRemoveRestrictionsForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 's': // Prefix: "stallations/"
							if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories/"
								if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repository_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsRemoveRepoFromInstallation
									r.name = "AppsRemoveRepoFromInstallation"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 't': // Prefix: "teraction-limits"
							if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: InteractionsRemoveRestrictionsForAuthenticatedUser
								r.name = "InteractionsRemoveRestrictionsForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 'k': // Prefix: "keys/"
						if l := len("keys/"); len(elem) >= l && elem[0:l] == "keys/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "key_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: UsersDeletePublicSSHKeyForAuthenticated
							r.name = "UsersDeletePublicSSHKeyForAuthenticated"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'm': // Prefix: "migrations/"
						if l := len("migrations/"); len(elem) >= l && elem[0:l] == "migrations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "migration_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "MigrationsUnlockRepoForAuthenticatedUser"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'a': // Prefix: "archive"
								if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: MigrationsDeleteArchiveForAuthenticatedUser
									r.name = "MigrationsDeleteArchiveForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/lock"
									if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsUnlockRepoForAuthenticatedUser
										r.name = "MigrationsUnlockRepoForAuthenticatedUser"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						}
					case 'p': // Prefix: "packages/"
						if l := len("packages/"); len(elem) >= l && elem[0:l] == "packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "PackagesDeletePackageForAuthenticatedUser"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/versions/"
								if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_version_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PackagesDeletePackageVersionForAuthenticatedUser
									r.name = "PackagesDeletePackageVersionForAuthenticatedUser"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposDeclineInvitation
							r.name = "ReposDeclineInvitation"
							r.args = args
							r.count = 1
							return r, true
						}
					case 's': // Prefix: "starred/"
						if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActivityUnstarRepoForAuthenticatedUser
								r.name = "ActivityUnstarRepoForAuthenticatedUser"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/packages/"
						if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "PackagesDeletePackageForUser"
								r.args = args
								r.count = 3
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/versions/"
								if l := len("/versions/"); len(elem) >= l && elem[0:l] == "/versions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_version_id"
								// Leaf parameter
								args[3] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PackagesDeletePackageVersionForUser
									r.name = "PackagesDeletePackageVersionForUser"
									r.args = args
									r.count = 4
									return r, true
								}
							}
						}
					}
				}
			}
		}
	case "GET":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				r.name = "MetaRoot"
				r.args = args
				r.count = 0
				return r, true
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OAuthAuthorizationsGetAuthorization"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsGetAuthenticated"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/"
						if l := len("/hook/"); len(elem) >= l && elem[0:l] == "/hook/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "AppsGetWebhookDelivery"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'c': // Prefix: "config"
							if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsGetWebhookConfigForApp
								r.name = "AppsGetWebhookConfigForApp"
								r.args = args
								r.count = 0
								return r, true
							}
						case 'd': // Prefix: "deliveries"
							if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "AppsListWebhookDeliveries"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "delivery_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: AppsGetWebhookDelivery
									r.name = "AppsGetWebhookDelivery"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 'l': // Prefix: "lications/grants"
						if l := len("lications/grants"); len(elem) >= l && elem[0:l] == "lications/grants" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "OAuthAuthorizationsListGrants"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "grant_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: OAuthAuthorizationsGetGrant
								r.name = "OAuthAuthorizationsGetGrant"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 's': // Prefix: "s/"
						if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "app_slug"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetBySlug
							r.name = "AppsGetBySlug"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "OAuthAuthorizationsListAuthorizations"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "authorization_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OAuthAuthorizationsGetAuthorization
							r.name = "OAuthAuthorizationsGetAuthorization"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'c': // Prefix: "codes_of_conduct"
				if l := len("codes_of_conduct"); len(elem) >= l && elem[0:l] == "codes_of_conduct" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "CodesOfConductGetAllCodesOfConduct"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: CodesOfConductGetConductCode
						r.name = "CodesOfConductGetConductCode"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "BillingGetGithubActionsBillingGhe"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'm': // Prefix: "mojis"
					if l := len("mojis"); len(elem) >= l && elem[0:l] == "mojis" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: EmojisGet
						r.name = "EmojisGet"
						r.args = args
						r.count = 0
						return r, true
					}
				case 'n': // Prefix: "nterprises/"
					if l := len("nterprises/"); len(elem) >= l && elem[0:l] == "nterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminGetAllowedActionsEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "EnterpriseAdminGetAuditLog"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "EnterpriseAdminGetSelfHostedRunnerForEnterprise"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "EnterpriseAdminGetGithubActionsPermissionsEnterprise"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case 'o': // Prefix: "organizations"
											if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise
												r.name = "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise"
												r.args = args
												r.count = 1
												return r, true
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminGetAllowedActionsEnterprise
												r.name = "EnterpriseAdminGetAllowedActionsEnterprise"
												r.args = args
												r.count = 1
												return r, true
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case 'o': // Prefix: "organizations"
													if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise
														r.name = "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise"
														r.args = args
														r.count = 2
														return r, true
													}
												case 'r': // Prefix: "runners"
													if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise
														r.name = "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise"
														r.args = args
														r.count = 2
														return r, true
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "EnterpriseAdminListSelfHostedRunnersForEnterprise"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: EnterpriseAdminListRunnerApplicationsForEnterprise
													r.name = "EnterpriseAdminListRunnerApplicationsForEnterprise"
													r.args = args
													r.count = 1
													return r, true
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: EnterpriseAdminGetSelfHostedRunnerForEnterprise
												r.name = "EnterpriseAdminGetSelfHostedRunnerForEnterprise"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetAuditLog
									r.name = "EnterpriseAdminGetAuditLog"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 's': // Prefix: "settings/billing/"
							if l := len("settings/billing/"); len(elem) >= l && elem[0:l] == "settings/billing/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "BillingGetGithubPackagesBillingGhe"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'a': // Prefix: "actions"
								if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetGithubActionsBillingGhe
									r.name = "BillingGetGithubActionsBillingGhe"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'p': // Prefix: "packages"
								if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetGithubPackagesBillingGhe
									r.name = "BillingGetGithubPackagesBillingGhe"
									r.args = args
									r.count = 1
									return r, true
								}
							case 's': // Prefix: "shared-storage"
								if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: BillingGetSharedStorageBillingGhe
									r.name = "BillingGetSharedStorageBillingGhe"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					}
				case 'v': // Prefix: "vents"
					if l := len("vents"); len(elem) >= l && elem[0:l] == "vents" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ActivityListPublicEvents
						r.name = "ActivityListPublicEvents"
						r.args = args
						r.count = 0
						return r, true
					}
				}
			case 'f': // Prefix: "feeds"
				if l := len("feeds"); len(elem) >= l && elem[0:l] == "feeds" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: ActivityGetFeeds
					r.name = "ActivityGetFeeds"
					r.args = args
					r.count = 0
					return r, true
				}
			case 'g': // Prefix: "gi"
				if l := len("gi"); len(elem) >= l && elem[0:l] == "gi" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "GitignoreGetAllTemplates"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 's': // Prefix: "sts"
					if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "GistsList"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "public"
							if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListPublic
								r.name = "GistsListPublic"
								r.args = args
								r.count = 0
								return r, true
							}
						case 's': // Prefix: "starred"
							if l := len("starred"); len(elem) >= l && elem[0:l] == "starred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsListStarred
								r.name = "GistsListStarred"
								r.args = args
								r.count = 0
								return r, true
							}
						}
						// Param: "gist_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "GistsGet"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "GistsGetComment"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "comm"
								if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "GistsListCommits"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'e': // Prefix: "ents"
									if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "GistsListComments"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GistsGetComment
											r.name = "GistsGetComment"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								case 'i': // Prefix: "its"
									if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsListCommits
										r.name = "GistsListCommits"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							case 'f': // Prefix: "forks"
								if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsListForks
									r.name = "GistsListForks"
									r.args = args
									r.count = 1
									return r, true
								}
							case 's': // Prefix: "star"
								if l := len("star"); len(elem) >= l && elem[0:l] == "star" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: GistsCheckIsStarred
									r.name = "GistsCheckIsStarred"
									r.args = args
									r.count = 1
									return r, true
								}
							}
							// Param: "sha"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: GistsGetRevision
								r.name = "GistsGetRevision"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				case 't': // Prefix: "tignore/templates"
					if l := len("tignore/templates"); len(elem) >= l && elem[0:l] == "tignore/templates" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "GitignoreGetAllTemplates"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: GitignoreGetTemplate
							r.name = "GitignoreGetTemplate"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "IssuesList"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'n': // Prefix: "nstallation/repositories"
					if l := len("nstallation/repositories"); len(elem) >= l && elem[0:l] == "nstallation/repositories" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: AppsListReposAccessibleToInstallation
						r.name = "AppsListReposAccessibleToInstallation"
						r.args = args
						r.count = 0
						return r, true
					}
				case 's': // Prefix: "ssues"
					if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: IssuesList
						r.name = "IssuesList"
						r.args = args
						r.count = 0
						return r, true
					}
				}
			case 'l': // Prefix: "licenses"
				if l := len("licenses"); len(elem) >= l && elem[0:l] == "licenses" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "LicensesGetAllCommonlyUsed"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "license"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: LicensesGet
						r.name = "LicensesGet"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'm': // Prefix: "m"
				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "MetaGet"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'a': // Prefix: "arketplace_listing/"
					if l := len("arketplace_listing/"); len(elem) >= l && elem[0:l] == "arketplace_listing/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsGetSubscriptionPlanForAccountStubbed"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'a': // Prefix: "accounts/"
						if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "account_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: AppsGetSubscriptionPlanForAccount
							r.name = "AppsGetSubscriptionPlanForAccount"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'p': // Prefix: "plans"
						if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "AppsListPlans"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "plan_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/accounts"
								if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListAccountsForPlan
									r.name = "AppsListAccountsForPlan"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 's': // Prefix: "stubbed/"
						if l := len("stubbed/"); len(elem) >= l && elem[0:l] == "stubbed/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "AppsListAccountsForPlanStubbed"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "accounts/"
							if l := len("accounts/"); len(elem) >= l && elem[0:l] == "accounts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "account_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: AppsGetSubscriptionPlanForAccountStubbed
								r.name = "AppsGetSubscriptionPlanForAccountStubbed"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'p': // Prefix: "plans"
							if l := len("plans"); len(elem) >= l && elem[0:l] == "plans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "AppsListPlansStubbed"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "plan_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/accounts"
									if l := len("/accounts"); len(elem) >= l && elem[0:l] == "/accounts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: AppsListAccountsForPlanStubbed
										r.name = "AppsListAccountsForPlanStubbed"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eta"
					if l := len("eta"); len(elem) >= l && elem[0:l] == "eta" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: MetaGet
						r.name = "MetaGet"
						r.args = args
						r.count = 0
						return r, true
					}
				}
			case 'n': // Prefix: "n"
				if l := len("n"); len(elem) >= l && elem[0:l] == "n" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "ActivityListPublicEventsForRepoNetwork"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'e': // Prefix: "etworks/"
					if l := len("etworks/"); len(elem) >= l && elem[0:l] == "etworks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/events"
							if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListPublicEventsForRepoNetwork
								r.name = "ActivityListPublicEventsForRepoNetwork"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				case 'o': // Prefix: "otifications"
					if l := len("otifications"); len(elem) >= l && elem[0:l] == "otifications" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ActivityListNotificationsForAuthenticatedUser"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/threads/"
						if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "ActivityGetThread"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/subscription"
							if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityGetThreadSubscriptionForAuthenticatedUser
								r.name = "ActivityGetThreadSubscriptionForAuthenticatedUser"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
				}
			case 'o': // Prefix: "org"
				if l := len("org"); len(elem) >= l && elem[0:l] == "org" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OrgsList"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'a': // Prefix: "anizations"
					if l := len("anizations"); len(elem) >= l && elem[0:l] == "anizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OrgsList
						r.name = "OrgsList"
						r.args = args
						r.count = 0
						return r, true
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "org"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						r.name = "OrgsGet"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ActivityListPublicOrgEvents"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsGetAuditLog"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/"
								if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActionsGetOrgPublicKey"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'p': // Prefix: "permissions"
									if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsGetGithubActionsPermissionsOrganization"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
												r.name = "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization"
												r.args = args
												r.count = 1
												return r, true
											}
										case 's': // Prefix: "selected-actions"
											if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetAllowedActionsOrganization
												r.name = "ActionsGetAllowedActionsOrganization"
												r.args = args
												r.count = 1
												return r, true
											}
										}
									}
								case 'r': // Prefix: "runner"
									if l := len("runner"); len(elem) >= l && elem[0:l] == "runner" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsGetSelfHostedRunnerGroupForOrg"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '-': // Prefix: "-groups"
										if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsListSelfHostedRunnerGroupsForOrg"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "runner_group_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "ActionsGetSelfHostedRunnerGroupForOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/r"
												if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ActionsListSelfHostedRunnersInGroupForOrg"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case 'e': // Prefix: "epositories"
													if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
														r.name = "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg"
														r.args = args
														r.count = 2
														return r, true
													}
												case 'u': // Prefix: "unners"
													if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsListSelfHostedRunnersInGroupForOrg
														r.name = "ActionsListSelfHostedRunnersInGroupForOrg"
														r.args = args
														r.count = 2
														return r, true
													}
												}
											}
										}
									case 's': // Prefix: "s"
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsListSelfHostedRunnersForOrg"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "downloads"
												if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsListRunnerApplicationsForOrg
													r.name = "ActionsListRunnerApplicationsForOrg"
													r.args = args
													r.count = 1
													return r, true
												}
											}
											// Param: "runner_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ActionsGetSelfHostedRunnerForOrg
												r.name = "ActionsGetSelfHostedRunnerForOrg"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								case 's': // Prefix: "secrets"
									if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsListOrgSecrets"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsGetOrgSecret"
											r.args = args
											r.count = 1
											return r, true
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetOrgPublicKey
												r.name = "ActionsGetOrgPublicKey"
												r.args = args
												r.count = 1
												return r, true
											}
										}
										// Param: "secret_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "ActionsGetOrgSecret"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/repositories"
											if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListSelectedReposForOrgSecret
												r.name = "ActionsListSelectedReposForOrgSecret"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								}
							case 'u': // Prefix: "udit-log"
								if l := len("udit-log"); len(elem) >= l && elem[0:l] == "udit-log" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsGetAuditLog
									r.name = "OrgsGetAuditLog"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 'b': // Prefix: "blocks"
							if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsListBlockedUsers"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsCheckBlockedUser
									r.name = "OrgsCheckBlockedUser"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'c': // Prefix: "credential-authorizations"
							if l := len("credential-authorizations"); len(elem) >= l && elem[0:l] == "credential-authorizations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListSamlSSOAuthorizations
								r.name = "OrgsListSamlSSOAuthorizations"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'e': // Prefix: "events"
							if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListPublicOrgEvents
								r.name = "ActivityListPublicOrgEvents"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'f': // Prefix: "failed_invitations"
							if l := len("failed_invitations"); len(elem) >= l && elem[0:l] == "failed_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListFailedInvitations
								r.name = "OrgsListFailedInvitations"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsListWebhooks"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "OrgsGetWebhook"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "OrgsGetWebhookDelivery"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsGetWebhookConfigForOrg
											r.name = "OrgsGetWebhookConfigForOrg"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'd': // Prefix: "deliveries"
										if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "OrgsListWebhookDeliveries"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "delivery_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: OrgsGetWebhookDelivery
												r.name = "OrgsGetWebhookDelivery"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsListInvitationTeams"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'n': // Prefix: "nvitations"
								if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "OrgsListPendingInvitations"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "invitation_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/teams"
										if l := len("/teams"); len(elem) >= l && elem[0:l] == "/teams" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsListInvitationTeams
											r.name = "OrgsListInvitationTeams"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								}
							case 's': // Prefix: "ssues"
								if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: IssuesListForOrg
									r.name = "IssuesListForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsCheckMembershipForUser"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'e': // Prefix: "embers"
								if l := len("embers"); len(elem) >= l && elem[0:l] == "embers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "OrgsListMembers"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsCheckMembershipForUser
										r.name = "OrgsCheckMembershipForUser"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'h': // Prefix: "hips/"
									if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsGetMembershipForUser
										r.name = "OrgsGetMembershipForUser"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							case 'i': // Prefix: "igrations"
								if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "MigrationsListForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "migration_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										r.name = "MigrationsGetStatusForOrg"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "MigrationsListReposForOrg"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'a': // Prefix: "archive"
											if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsDownloadArchiveForOrg
												r.name = "MigrationsDownloadArchiveForOrg"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'r': // Prefix: "repositories"
											if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: MigrationsListReposForOrg
												r.name = "MigrationsListReposForOrg"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								}
							}
						case 'o': // Prefix: "outside_collaborators"
							if l := len("outside_collaborators"); len(elem) >= l && elem[0:l] == "outside_collaborators" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsListOutsideCollaborators
								r.name = "OrgsListOutsideCollaborators"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "PackagesGetAllPackageVersionsForPackageOwnedByOrg"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'a': // Prefix: "ackages"
								if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "PackagesListPackagesForOrganization"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_name"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "PackagesGetPackageForOrganization"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/versions"
											if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "PackagesGetAllPackageVersionsForPackageOwnedByOrg"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "package_version_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: PackagesGetPackageVersionForOrganization
													r.name = "PackagesGetPackageVersionForOrganization"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsListForOrg
									r.name = "ProjectsListForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'u': // Prefix: "ublic_members"
								if l := len("ublic_members"); len(elem) >= l && elem[0:l] == "ublic_members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "OrgsListPublicMembers"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: OrgsCheckPublicMembershipForUser
										r.name = "OrgsCheckPublicMembershipForUser"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						case 'r': // Prefix: "repos"
							if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposListForOrg
								r.name = "ReposListForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
						case 's': // Prefix: "se"
							if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "SecretScanningListAlertsForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "cret-scanning/alerts"
								if l := len("cret-scanning/alerts"); len(elem) >= l && elem[0:l] == "cret-scanning/alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: SecretScanningListAlertsForOrg
									r.name = "SecretScanningListAlertsForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							case 't': // Prefix: "ttings/billing/"
								if l := len("ttings/billing/"); len(elem) >= l && elem[0:l] == "ttings/billing/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "BillingGetGithubPackagesBillingOrg"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'a': // Prefix: "actions"
									if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubActionsBillingOrg
										r.name = "BillingGetGithubActionsBillingOrg"
										r.args = args
										r.count = 1
										return r, true
									}
								case 'p': // Prefix: "packages"
									if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetGithubPackagesBillingOrg
										r.name = "BillingGetGithubPackagesBillingOrg"
										r.args = args
										r.count = 1
										return r, true
									}
								case 's': // Prefix: "shared-storage"
									if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: BillingGetSharedStorageBillingOrg
										r.name = "BillingGetSharedStorageBillingOrg"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							}
						case 't': // Prefix: "team"
							if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "TeamsListIdpGroupsForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '-': // Prefix: "-sync/groups"
								if l := len("-sync/groups"); len(elem) >= l && elem[0:l] == "-sync/groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsListIdpGroupsForOrg
									r.name = "TeamsListIdpGroupsForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "TeamsList"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "team_slug"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										r.name = "TeamsGetByName"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "TeamsCheckPermissionsForProjectInOrg"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'd': // Prefix: "discussions"
											if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsListDiscussionsInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "discussion_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													r.name = "TeamsGetDiscussionInOrg"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReactionsListForTeamDiscussionInOrg"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case 'c': // Prefix: "comments"
														if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "TeamsListDiscussionCommentsInOrg"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "comment_number"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																r.name = "TeamsGetDiscussionCommentInOrg"
																r.args = args
																r.count = 4
																return r, true
															}
															switch elem[0] {
															case '/': // Prefix: "/reactions"
																if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReactionsListForTeamDiscussionCommentInOrg
																	r.name = "ReactionsListForTeamDiscussionCommentInOrg"
																	r.args = args
																	r.count = 4
																	return r, true
																}
															}
														}
													case 'r': // Prefix: "reactions"
														if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForTeamDiscussionInOrg
															r.name = "ReactionsListForTeamDiscussionInOrg"
															r.args = args
															r.count = 3
															return r, true
														}
													}
												}
											}
										case 'i': // Prefix: "invitations"
											if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: TeamsListPendingInvitationsInOrg
												r.name = "TeamsListPendingInvitationsInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'm': // Prefix: "members"
											if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsListMembersInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'h': // Prefix: "hips/"
												if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsGetMembershipForUserInOrg
													r.name = "TeamsGetMembershipForUserInOrg"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'p': // Prefix: "projects"
											if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsListProjectsInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "project_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: TeamsCheckPermissionsForProjectInOrg
													r.name = "TeamsCheckPermissionsForProjectInOrg"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'r': // Prefix: "repos"
											if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsListReposInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "owner"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "repo"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: TeamsCheckPermissionsForRepoInOrg
														r.name = "TeamsCheckPermissionsForRepoInOrg"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										case 't': // Prefix: "team"
											if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsListIdpGroupsInOrg"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '-': // Prefix: "-sync/group-mappings"
												if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: TeamsListIdpGroupsInOrg
													r.name = "TeamsListIdpGroupsInOrg"
													r.args = args
													r.count = 2
													return r, true
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: TeamsListChildInOrg
													r.name = "TeamsListChildInOrg"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ProjectsGetColumn"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsGetCard
							r.name = "ProjectsGetCard"
							r.args = args
							r.count = 1
							return r, true
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						r.name = "ProjectsGetColumn"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/cards"
						if l := len("/cards"); len(elem) >= l && elem[0:l] == "/cards" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsListCards
							r.name = "ProjectsListCards"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "ProjectsGet"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/col"
					if l := len("/col"); len(elem) >= l && elem[0:l] == "/col" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ProjectsListColumns"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'l': // Prefix: "laborators"
						if l := len("laborators"); len(elem) >= l && elem[0:l] == "laborators" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ProjectsListCollaborators"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/permission"
								if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsGetPermissionForUser
									r.name = "ProjectsGetPermissionForUser"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						}
					case 'u': // Prefix: "umns"
						if l := len("umns"); len(elem) >= l && elem[0:l] == "umns" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsListColumns
							r.name = "ProjectsListColumns"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'r': // Prefix: "r"
				if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "RateLimitGet"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'a': // Prefix: "ate_limit"
					if l := len("ate_limit"); len(elem) >= l && elem[0:l] == "ate_limit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: RateLimitGet
						r.name = "RateLimitGet"
						r.args = args
						r.count = 0
						return r, true
					}
				case 'e': // Prefix: "epos"
					if l := len("epos"); len(elem) >= l && elem[0:l] == "epos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ActionsGetEnvironmentPublicKey"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "ReposGet"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActivityGetRepoSubscription"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'a': // Prefix: "a"
									if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "IssuesCheckUserCanBeAssigned"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'c': // Prefix: "ctions/"
										if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsDownloadJobLogsForWorkflowRun"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'a': // Prefix: "artifacts"
											if l := len("artifacts"); len(elem) >= l && elem[0:l] == "artifacts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsListArtifactsForRepo"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "artifact_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													r.name = "ActionsGetArtifact"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "archive_format"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsDownloadArtifact
														r.name = "ActionsDownloadArtifact"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										case 'j': // Prefix: "jobs/"
											if l := len("jobs/"); len(elem) >= l && elem[0:l] == "jobs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "job_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "ActionsGetJobForWorkflowRun"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/logs"
												if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsDownloadJobLogsForWorkflowRun
													r.name = "ActionsDownloadJobLogsForWorkflowRun"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'p': // Prefix: "permissions"
											if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsGetGithubActionsPermissionsRepository"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/selected-actions"
												if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsGetAllowedActionsRepository
													r.name = "ActionsGetAllowedActionsRepository"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										case 'r': // Prefix: "run"
											if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsGetSelfHostedRunnerForRepo"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'n': // Prefix: "ners"
												if l := len("ners"); len(elem) >= l && elem[0:l] == "ners" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ActionsListSelfHostedRunnersForRepo"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'd': // Prefix: "downloads"
														if l := len("downloads"); len(elem) >= l && elem[0:l] == "downloads" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ActionsListRunnerApplicationsForRepo
															r.name = "ActionsListRunnerApplicationsForRepo"
															r.args = args
															r.count = 2
															return r, true
														}
													}
													// Param: "runner_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ActionsGetSelfHostedRunnerForRepo
														r.name = "ActionsGetSelfHostedRunnerForRepo"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											case 's': // Prefix: "s"
												if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ActionsListWorkflowRunsForRepo"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "run_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														r.name = "ActionsGetWorkflowRun"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "ActionsGetReviewsForRun"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case 'a': // Prefix: "a"
															if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																r.name = "ActionsListWorkflowRunArtifacts"
																r.args = args
																r.count = 3
																return r, true
															}
															switch elem[0] {
															case 'p': // Prefix: "pprovals"
																if l := len("pprovals"); len(elem) >= l && elem[0:l] == "pprovals" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsGetReviewsForRun
																	r.name = "ActionsGetReviewsForRun"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 'r': // Prefix: "rtifacts"
																if l := len("rtifacts"); len(elem) >= l && elem[0:l] == "rtifacts" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ActionsListWorkflowRunArtifacts
																	r.name = "ActionsListWorkflowRunArtifacts"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															}
														case 'j': // Prefix: "jobs"
															if l := len("jobs"); len(elem) >= l && elem[0:l] == "jobs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsListJobsForWorkflowRun
																r.name = "ActionsListJobsForWorkflowRun"
																r.args = args
																r.count = 3
																return r, true
															}
														case 'l': // Prefix: "logs"
															if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsDownloadWorkflowRunLogs
																r.name = "ActionsDownloadWorkflowRunLogs"
																r.args = args
																r.count = 3
																return r, true
															}
														case 't': // Prefix: "timing"
															if l := len("timing"); len(elem) >= l && elem[0:l] == "timing" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ActionsGetWorkflowRunUsage
																r.name = "ActionsGetWorkflowRunUsage"
																r.args = args
																r.count = 3
																return r, true
															}
														}
													}
												}
											}
										case 's': // Prefix: "secrets"
											if l := len("secrets"); len(elem) >= l && elem[0:l] == "secrets" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsListRepoSecrets"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ActionsGetRepoSecret"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case 'p': // Prefix: "public-key"
													if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ActionsGetRepoPublicKey
														r.name = "ActionsGetRepoPublicKey"
														r.args = args
														r.count = 2
														return r, true
													}
												}
												// Param: "secret_name"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ActionsGetRepoSecret
													r.name = "ActionsGetRepoSecret"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'w': // Prefix: "workflows"
											if l := len("workflows"); len(elem) >= l && elem[0:l] == "workflows" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsListRepoWorkflows
												r.name = "ActionsListRepoWorkflows"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									case 's': // Prefix: "ssignees"
										if l := len("ssignees"); len(elem) >= l && elem[0:l] == "ssignees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "IssuesListAssignees"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "assignee"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: IssuesCheckUserCanBeAssigned
												r.name = "IssuesCheckUserCanBeAssigned"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 'u': // Prefix: "utolinks"
										if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposListAutolinks"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "autolink_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposGetAutolink
												r.name = "ReposGetAutolink"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								case 'b': // Prefix: "branches"
									if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposListBranches"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "branch"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "ReposGetBranch"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/protection"
											if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetBranchProtection"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ReposGetAdminBranchProtection"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case 'e': // Prefix: "enforce_admins"
													if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetAdminBranchProtection
														r.name = "ReposGetAdminBranchProtection"
														r.args = args
														r.count = 3
														return r, true
													}
												case 'r': // Prefix: "re"
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposGetAllStatusCheckContexts"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case 'q': // Prefix: "quired_"
														if l := len("quired_"); len(elem) >= l && elem[0:l] == "quired_" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "ReposGetPullRequestReviewProtection"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case 'p': // Prefix: "pull_request_reviews"
															if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReposGetPullRequestReviewProtection
																r.name = "ReposGetPullRequestReviewProtection"
																r.args = args
																r.count = 3
																return r, true
															}
														case 's': // Prefix: "s"
															if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																r.name = "ReposGetCommitSignatureProtection"
																r.args = args
																r.count = 3
																return r, true
															}
															switch elem[0] {
															case 'i': // Prefix: "ignatures"
																if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetCommitSignatureProtection
																	r.name = "ReposGetCommitSignatureProtection"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 't': // Prefix: "tatus_checks"
																if l := len("tatus_checks"); len(elem) >= l && elem[0:l] == "tatus_checks" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	r.name = "ReposGetStatusChecksProtection"
																	r.args = args
																	r.count = 3
																	return r, true
																}
																switch elem[0] {
																case '/': // Prefix: "/contexts"
																	if l := len("/contexts"); len(elem) >= l && elem[0:l] == "/contexts" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposGetAllStatusCheckContexts
																		r.name = "ReposGetAllStatusCheckContexts"
																		r.args = args
																		r.count = 3
																		return r, true
																	}
																}
															}
														}
													case 's': // Prefix: "strictions"
														if l := len("strictions"); len(elem) >= l && elem[0:l] == "strictions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "ReposGetAccessRestrictions"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																r.name = "ReposGetTeamsWithAccessToProtectedBranch"
																r.args = args
																r.count = 3
																return r, true
															}
															switch elem[0] {
															case 'a': // Prefix: "apps"
																if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetAppsWithAccessToProtectedBranch
																	r.name = "ReposGetAppsWithAccessToProtectedBranch"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 't': // Prefix: "teams"
																if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetTeamsWithAccessToProtectedBranch
																	r.name = "ReposGetTeamsWithAccessToProtectedBranch"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 'u': // Prefix: "users"
																if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposGetUsersWithAccessToProtectedBranch
																	r.name = "ReposGetUsersWithAccessToProtectedBranch"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															}
														}
													}
												}
											}
										}
									}
								case 'c': // Prefix: "c"
									if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ChecksListForRef"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'h': // Prefix: "heck-"
										if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ChecksGetSuite"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'r': // Prefix: "runs/"
											if l := len("runs/"); len(elem) >= l && elem[0:l] == "runs/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "check_run_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "ChecksGet"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/annotations"
												if l := len("/annotations"); len(elem) >= l && elem[0:l] == "/annotations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ChecksListAnnotations
													r.name = "ChecksListAnnotations"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 's': // Prefix: "suites/"
											if l := len("suites/"); len(elem) >= l && elem[0:l] == "suites/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "check_suite_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "ChecksGetSuite"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/check-runs"
												if l := len("/check-runs"); len(elem) >= l && elem[0:l] == "/check-runs" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ChecksListForSuite
													r.name = "ChecksListForSuite"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										}
									case 'o': // Prefix: "o"
										if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "CodeScanningGetAlert"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'd': // Prefix: "de-scanning/"
											if l := len("de-scanning/"); len(elem) >= l && elem[0:l] == "de-scanning/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "CodeScanningGetSarif"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "a"
												if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "CodeScanningGetAnalysis"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case 'l': // Prefix: "lerts"
													if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "CodeScanningListAlertsForRepo"
														r.args = args
														r.count = 2
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "alert_number"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															r.name = "CodeScanningGetAlert"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/instances"
															if l := len("/instances"); len(elem) >= l && elem[0:l] == "/instances" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: CodeScanningListAlertInstances
																r.name = "CodeScanningListAlertInstances"
																r.args = args
																r.count = 3
																return r, true
															}
														}
													}
												case 'n': // Prefix: "nalyses"
													if l := len("nalyses"); len(elem) >= l && elem[0:l] == "nalyses" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "CodeScanningListRecentAnalyses"
														r.args = args
														r.count = 2
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "analysis_id"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf: CodeScanningGetAnalysis
															r.name = "CodeScanningGetAnalysis"
															r.args = args
															r.count = 3
															return r, true
														}
													}
												}
											case 's': // Prefix: "sarifs/"
												if l := len("sarifs/"); len(elem) >= l && elem[0:l] == "sarifs/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "sarif_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: CodeScanningGetSarif
													r.name = "CodeScanningGetSarif"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'l': // Prefix: "llaborators"
											if l := len("llaborators"); len(elem) >= l && elem[0:l] == "llaborators" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposListCollaborators"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "username"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[2] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													r.name = "ReposCheckCollaborator"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/permission"
													if l := len("/permission"); len(elem) >= l && elem[0:l] == "/permission" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetCollaboratorPermissionLevel
														r.name = "ReposGetCollaboratorPermissionLevel"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											}
										case 'm': // Prefix: "m"
											if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposCompareCommits"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'm': // Prefix: "m"
												if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ReactionsListForCommitComment"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case 'e': // Prefix: "ents"
													if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposListCommitCommentsForRepo"
														r.args = args
														r.count = 2
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "comment_id"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															r.name = "ReposGetCommitComment"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/reactions"
															if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf: ReactionsListForCommitComment
																r.name = "ReactionsListForCommitComment"
																r.args = args
																r.count = 3
																return r, true
															}
														}
													}
												case 'i': // Prefix: "its"
													if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposListCommits"
														r.args = args
														r.count = 2
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ref"
														// Match until "/"
														idx := strings.IndexByte(elem, '/')
														if idx < 0 {
															idx = len(elem)
														}
														args[2] = elem[:idx]
														elem = elem[idx:]

														if len(elem) == 0 {
															r.name = "ReposGetCommit"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																r.name = "ReposGetCombinedStatusForRef"
																r.args = args
																r.count = 3
																return r, true
															}
															switch elem[0] {
															case 'b': // Prefix: "branches-where-head"
																if l := len("branches-where-head"); len(elem) >= l && elem[0:l] == "branches-where-head" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposListBranchesForHeadCommit
																	r.name = "ReposListBranchesForHeadCommit"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 'c': // Prefix: "c"
																if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	r.name = "ReposListCommentsForCommit"
																	r.args = args
																	r.count = 3
																	return r, true
																}
																switch elem[0] {
																case 'h': // Prefix: "heck-"
																	if l := len("heck-"); len(elem) >= l && elem[0:l] == "heck-" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		r.name = "ChecksListSuitesForRef"
																		r.args = args
																		r.count = 3
																		return r, true
																	}
																	switch elem[0] {
																	case 'r': // Prefix: "runs"
																		if l := len("runs"); len(elem) >= l && elem[0:l] == "runs" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ChecksListForRef
																			r.name = "ChecksListForRef"
																			r.args = args
																			r.count = 3
																			return r, true
																		}
																	case 's': // Prefix: "suites"
																		if l := len("suites"); len(elem) >= l && elem[0:l] == "suites" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf: ChecksListSuitesForRef
																			r.name = "ChecksListSuitesForRef"
																			r.args = args
																			r.count = 3
																			return r, true
																		}
																	}
																case 'o': // Prefix: "omments"
																	if l := len("omments"); len(elem) >= l && elem[0:l] == "omments" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposListCommentsForCommit
																		r.name = "ReposListCommentsForCommit"
																		r.args = args
																		r.count = 3
																		return r, true
																	}
																}
															case 'p': // Prefix: "pulls"
																if l := len("pulls"); len(elem) >= l && elem[0:l] == "pulls" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: ReposListPullRequestsAssociatedWithCommit
																	r.name = "ReposListPullRequestsAssociatedWithCommit"
																	r.args = args
																	r.count = 3
																	return r, true
																}
															case 's': // Prefix: "status"
																if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	r.name = "ReposGetCombinedStatusForRef"
																	r.args = args
																	r.count = 3
																	return r, true
																}
																switch elem[0] {
																case 'e': // Prefix: "es"
																	if l := len("es"); len(elem) >= l && elem[0:l] == "es" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	if len(elem) == 0 {
																		// Leaf: ReposListCommitStatusesForRef
																		r.name = "ReposListCommitStatusesForRef"
																		r.args = args
																		r.count = 3
																		return r, true
																	}
																}
															}
														}
													}
												case 'u': // Prefix: "unity/profile"
													if l := len("unity/profile"); len(elem) >= l && elem[0:l] == "unity/profile" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReposGetCommunityProfileMetrics
														r.name = "ReposGetCommunityProfileMetrics"
														r.args = args
														r.count = 2
														return r, true
													}
												}
											case 'p': // Prefix: "pare/"
												if l := len("pare/"); len(elem) >= l && elem[0:l] == "pare/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "basehead"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposCompareCommits
													r.name = "ReposCompareCommits"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'n': // Prefix: "ntributors"
											if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListContributors
												r.name = "ReposListContributors"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								case 'd': // Prefix: "deployments"
									if l := len("deployments"); len(elem) >= l && elem[0:l] == "deployments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposListDeployments"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "deployment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "ReposGetDeployment"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/statuses"
											if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposListDeploymentStatuses"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "status_id"
												// Leaf parameter
												args[3] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetDeploymentStatus
													r.name = "ReposGetDeploymentStatus"
													r.args = args
													r.count = 4
													return r, true
												}
											}
										}
									}
								case 'e': // Prefix: "events"
									if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListRepoEvents
										r.name = "ActivityListRepoEvents"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'f': // Prefix: "forks"
									if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposListForks
										r.name = "ReposListForks"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'g': // Prefix: "git/"
									if l := len("git/"); len(elem) >= l && elem[0:l] == "git/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "GitGetCommit"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'b': // Prefix: "blobs/"
										if l := len("blobs/"); len(elem) >= l && elem[0:l] == "blobs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "file_sha"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetBlob
											r.name = "GitGetBlob"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'c': // Prefix: "commits/"
										if l := len("commits/"); len(elem) >= l && elem[0:l] == "commits/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commit_sha"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetCommit
											r.name = "GitGetCommit"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'm': // Prefix: "matching-refs/"
										if l := len("matching-refs/"); len(elem) >= l && elem[0:l] == "matching-refs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitListMatchingRefs
											r.name = "GitListMatchingRefs"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'r': // Prefix: "ref/"
										if l := len("ref/"); len(elem) >= l && elem[0:l] == "ref/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "ref"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: GitGetRef
											r.name = "GitGetRef"
											r.args = args
											r.count = 3
											return r, true
										}
									case 't': // Prefix: "t"
										if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "GitGetTree"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'a': // Prefix: "ags/"
											if l := len("ags/"); len(elem) >= l && elem[0:l] == "ags/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "tag_sha"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GitGetTag
												r.name = "GitGetTag"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'r': // Prefix: "rees/"
											if l := len("rees/"); len(elem) >= l && elem[0:l] == "rees/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "tree_sha"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: GitGetTree
												r.name = "GitGetTree"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								case 'h': // Prefix: "hooks"
									if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposListWebhooks"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "hook_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "ReposGetWebhook"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetWebhookDelivery"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'c': // Prefix: "config"
												if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetWebhookConfigForRepo
													r.name = "ReposGetWebhookConfigForRepo"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'd': // Prefix: "deliveries"
												if l := len("deliveries"); len(elem) >= l && elem[0:l] == "deliveries" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ReposListWebhookDeliveries"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "delivery_id"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetWebhookDelivery
														r.name = "ReposGetWebhookDelivery"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										}
									}
								case 'i': // Prefix: "i"
									if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "MigrationsGetCommitAuthors"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'm': // Prefix: "mport"
										if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "MigrationsGetImportStatus"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "MigrationsGetLargeFiles"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "authors"
												if l := len("authors"); len(elem) >= l && elem[0:l] == "authors" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsGetCommitAuthors
													r.name = "MigrationsGetCommitAuthors"
													r.args = args
													r.count = 2
													return r, true
												}
											case 'l': // Prefix: "large_files"
												if l := len("large_files"); len(elem) >= l && elem[0:l] == "large_files" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: MigrationsGetLargeFiles
													r.name = "MigrationsGetLargeFiles"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										}
									case 'n': // Prefix: "nvitations"
										if l := len("nvitations"); len(elem) >= l && elem[0:l] == "nvitations" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposListInvitations
											r.name = "ReposListInvitations"
											r.args = args
											r.count = 2
											return r, true
										}
									case 's': // Prefix: "ssues"
										if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "IssuesListForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "comments"
												if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "IssuesListCommentsForRepo"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														r.name = "IssuesGetComment"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForIssueComment
															r.name = "ReactionsListForIssueComment"
															r.args = args
															r.count = 3
															return r, true
														}
													}
												}
											case 'e': // Prefix: "events"
												if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "IssuesListEventsForRepo"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "event_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: IssuesGetEvent
														r.name = "IssuesGetEvent"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											}
											// Param: "issue_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "IssuesGet"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "IssuesListLabelsOnIssue"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case 'c': // Prefix: "comments"
													if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesListComments
														r.name = "IssuesListComments"
														r.args = args
														r.count = 3
														return r, true
													}
												case 'l': // Prefix: "labels"
													if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: IssuesListLabelsOnIssue
														r.name = "IssuesListLabelsOnIssue"
														r.args = args
														r.count = 3
														return r, true
													}
												case 'r': // Prefix: "reactions"
													if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsListForIssue
														r.name = "ReactionsListForIssue"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											}
										}
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposListDeployKeys"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "key_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ReposGetDeployKey
											r.name = "ReposGetDeployKey"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								case 'l': // Prefix: "l"
									if l := len("l"); len(elem) >= l && elem[0:l] == "l" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "LicensesGetForRepo"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposListLanguages"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'b': // Prefix: "bels"
											if l := len("bels"); len(elem) >= l && elem[0:l] == "bels" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "IssuesListLabelsForRepo"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "name"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: IssuesGetLabel
													r.name = "IssuesGetLabel"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 'n': // Prefix: "nguages"
											if l := len("nguages"); len(elem) >= l && elem[0:l] == "nguages" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListLanguages
												r.name = "ReposListLanguages"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									case 'i': // Prefix: "icense"
										if l := len("icense"); len(elem) >= l && elem[0:l] == "icense" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: LicensesGetForRepo
											r.name = "LicensesGetForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								case 'm': // Prefix: "milestones"
									if l := len("milestones"); len(elem) >= l && elem[0:l] == "milestones" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "IssuesListMilestones"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "milestone_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "IssuesGetMilestone"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/labels"
											if l := len("/labels"); len(elem) >= l && elem[0:l] == "/labels" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: IssuesListLabelsForMilestone
												r.name = "IssuesListLabelsForMilestone"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								case 'n': // Prefix: "notifications"
									if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListRepoNotificationsForAuthenticatedUser
										r.name = "ActivityListRepoNotificationsForAuthenticatedUser"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "PullsCheckIfMerged"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "ages"
										if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposGetPages"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetPagesHealthCheck"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'b': // Prefix: "builds"
												if l := len("builds"); len(elem) >= l && elem[0:l] == "builds" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "ReposListPagesBuilds"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "ReposGetPagesBuild"
														r.args = args
														r.count = 2
														return r, true
													}
													switch elem[0] {
													case 'l': // Prefix: "latest"
														if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReposGetLatestPagesBuild
															r.name = "ReposGetLatestPagesBuild"
															r.args = args
															r.count = 2
															return r, true
														}
													}
													// Param: "build_id"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: ReposGetPagesBuild
														r.name = "ReposGetPagesBuild"
														r.args = args
														r.count = 3
														return r, true
													}
												}
											case 'h': // Prefix: "health"
												if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetPagesHealthCheck
													r.name = "ReposGetPagesHealthCheck"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										}
									case 'r': // Prefix: "rojects"
										if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ProjectsListForRepo
											r.name = "ProjectsListForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'u': // Prefix: "ulls"
										if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "PullsList"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "comments"
												if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "PullsListReviewCommentsForRepo"
													r.args = args
													r.count = 2
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "comment_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[2] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														r.name = "PullsGetReviewComment"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case '/': // Prefix: "/reactions"
														if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: ReactionsListForPullRequestReviewComment
															r.name = "ReactionsListForPullRequestReviewComment"
															r.args = args
															r.count = 3
															return r, true
														}
													}
												}
											}
											// Param: "pull_number"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "PullsGet"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "PullsGetReview"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case 'c': // Prefix: "comm"
													if l := len("comm"); len(elem) >= l && elem[0:l] == "comm" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "PullsListReviewComments"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case 'e': // Prefix: "ents"
														if l := len("ents"); len(elem) >= l && elem[0:l] == "ents" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListReviewComments
															r.name = "PullsListReviewComments"
															r.args = args
															r.count = 3
															return r, true
														}
													case 'i': // Prefix: "its"
														if l := len("its"); len(elem) >= l && elem[0:l] == "its" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListCommits
															r.name = "PullsListCommits"
															r.args = args
															r.count = 3
															return r, true
														}
													}
												case 'f': // Prefix: "files"
													if l := len("files"); len(elem) >= l && elem[0:l] == "files" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsListFiles
														r.name = "PullsListFiles"
														r.args = args
														r.count = 3
														return r, true
													}
												case 'm': // Prefix: "merge"
													if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsCheckIfMerged
														r.name = "PullsCheckIfMerged"
														r.args = args
														r.count = 3
														return r, true
													}
												case 'r': // Prefix: "re"
													if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														r.name = "PullsListRequestedReviewers"
														r.args = args
														r.count = 3
														return r, true
													}
													switch elem[0] {
													case 'q': // Prefix: "quested_reviewers"
														if l := len("quested_reviewers"); len(elem) >= l && elem[0:l] == "quested_reviewers" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf: PullsListRequestedReviewers
															r.name = "PullsListRequestedReviewers"
															r.args = args
															r.count = 3
															return r, true
														}
													case 'v': // Prefix: "views"
														if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															r.name = "PullsListReviews"
															r.args = args
															r.count = 3
															return r, true
														}
														switch elem[0] {
														case '/': // Prefix: "/"
															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "review_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[3] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																r.name = "PullsGetReview"
																r.args = args
																r.count = 4
																return r, true
															}
															switch elem[0] {
															case '/': // Prefix: "/comments"
																if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf: PullsListCommentsForReview
																	r.name = "PullsListCommentsForReview"
																	r.args = args
																	r.count = 4
																	return r, true
																}
															}
														}
													}
												}
											}
										}
									}
								case 'r': // Prefix: "re"
									if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposGetReadme"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "adme"
										if l := len("adme"); len(elem) >= l && elem[0:l] == "adme" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposGetReadme"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "dir"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposGetReadmeInDirectory
												r.name = "ReposGetReadmeInDirectory"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 'l': // Prefix: "leases"
										if l := len("leases"); len(elem) >= l && elem[0:l] == "leases" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposListReleases"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetRelease"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "assets/"
												if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "asset_id"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetReleaseAsset
													r.name = "ReposGetReleaseAsset"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'l': // Prefix: "latest"
												if l := len("latest"); len(elem) >= l && elem[0:l] == "latest" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetLatestRelease
													r.name = "ReposGetLatestRelease"
													r.args = args
													r.count = 2
													return r, true
												}
											case 't': // Prefix: "tags/"
												if l := len("tags/"); len(elem) >= l && elem[0:l] == "tags/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tag"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf: ReposGetReleaseByTag
													r.name = "ReposGetReleaseByTag"
													r.args = args
													r.count = 3
													return r, true
												}
											}
											// Param: "release_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "ReposGetRelease"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/assets"
												if l := len("/assets"); len(elem) >= l && elem[0:l] == "/assets" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposListReleaseAssets
													r.name = "ReposListReleaseAssets"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposGetCodeFrequencyStats"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'e': // Prefix: "ecret-scanning/alerts"
										if l := len("ecret-scanning/alerts"); len(elem) >= l && elem[0:l] == "ecret-scanning/alerts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "SecretScanningListAlertsForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "alert_number"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: SecretScanningGetAlert
												r.name = "SecretScanningGetAlert"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 't': // Prefix: "tats/"
										if l := len("tats/"); len(elem) >= l && elem[0:l] == "tats/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposGetParticipationStats"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'c': // Prefix: "co"
											if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetCommitActivityStats"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'd': // Prefix: "de_frequency"
												if l := len("de_frequency"); len(elem) >= l && elem[0:l] == "de_frequency" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetCodeFrequencyStats
													r.name = "ReposGetCodeFrequencyStats"
													r.args = args
													r.count = 2
													return r, true
												}
											case 'm': // Prefix: "mmit_activity"
												if l := len("mmit_activity"); len(elem) >= l && elem[0:l] == "mmit_activity" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetCommitActivityStats
													r.name = "ReposGetCommitActivityStats"
													r.args = args
													r.count = 2
													return r, true
												}
											case 'n': // Prefix: "ntributors"
												if l := len("ntributors"); len(elem) >= l && elem[0:l] == "ntributors" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetContributorsStats
													r.name = "ReposGetContributorsStats"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										case 'p': // Prefix: "p"
											if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetPunchCardStats"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "articipation"
												if l := len("articipation"); len(elem) >= l && elem[0:l] == "articipation" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetParticipationStats
													r.name = "ReposGetParticipationStats"
													r.args = args
													r.count = 2
													return r, true
												}
											case 'u': // Prefix: "unch_card"
												if l := len("unch_card"); len(elem) >= l && elem[0:l] == "unch_card" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetPunchCardStats
													r.name = "ReposGetPunchCardStats"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										}
									case 'u': // Prefix: "ubscri"
										if l := len("ubscri"); len(elem) >= l && elem[0:l] == "ubscri" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActivityListWatchersForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'b': // Prefix: "bers"
											if l := len("bers"); len(elem) >= l && elem[0:l] == "bers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityListWatchersForRepo
												r.name = "ActivityListWatchersForRepo"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'p': // Prefix: "ption"
											if l := len("ption"); len(elem) >= l && elem[0:l] == "ption" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActivityGetRepoSubscription
												r.name = "ActivityGetRepoSubscription"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposGetAllTopics"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "a"
										if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposListTags"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'g': // Prefix: "gs"
											if l := len("gs"); len(elem) >= l && elem[0:l] == "gs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposListTags
												r.name = "ReposListTags"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'r': // Prefix: "rball/"
											if l := len("rball/"); len(elem) >= l && elem[0:l] == "rball/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "ref"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: ReposDownloadTarballArchive
												r.name = "ReposDownloadTarballArchive"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 'e': // Prefix: "eams"
										if l := len("eams"); len(elem) >= l && elem[0:l] == "eams" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposListTeams
											r.name = "ReposListTeams"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'o': // Prefix: "opics"
										if l := len("opics"); len(elem) >= l && elem[0:l] == "opics" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposGetAllTopics
											r.name = "ReposGetAllTopics"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'r': // Prefix: "raffic/"
										if l := len("raffic/"); len(elem) >= l && elem[0:l] == "raffic/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposGetTopPaths"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'c': // Prefix: "clones"
											if l := len("clones"); len(elem) >= l && elem[0:l] == "clones" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposGetClones
												r.name = "ReposGetClones"
												r.args = args
												r.count = 2
												return r, true
											}
										case 'p': // Prefix: "popular/"
											if l := len("popular/"); len(elem) >= l && elem[0:l] == "popular/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposGetTopReferrers"
												r.args = args
												r.count = 2
												return r, true
											}
											switch elem[0] {
											case 'p': // Prefix: "paths"
												if l := len("paths"); len(elem) >= l && elem[0:l] == "paths" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetTopPaths
													r.name = "ReposGetTopPaths"
													r.args = args
													r.count = 2
													return r, true
												}
											case 'r': // Prefix: "referrers"
												if l := len("referrers"); len(elem) >= l && elem[0:l] == "referrers" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposGetTopReferrers
													r.name = "ReposGetTopReferrers"
													r.args = args
													r.count = 2
													return r, true
												}
											}
										case 'v': // Prefix: "views"
											if l := len("views"); len(elem) >= l && elem[0:l] == "views" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposGetViews
												r.name = "ReposGetViews"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									}
								case 'v': // Prefix: "vulnerability-alerts"
									if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposCheckVulnerabilityAlerts
										r.name = "ReposCheckVulnerabilityAlerts"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'z': // Prefix: "zipball/"
									if l := len("zipball/"); len(elem) >= l && elem[0:l] == "zipball/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "ref"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposDownloadZipballArchive
										r.name = "ReposDownloadZipballArchive"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						}
					case 'i': // Prefix: "itories"
						if l := len("itories"); len(elem) >= l && elem[0:l] == "itories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ReposListPublic"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/environments/"
								if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "environment_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/secrets"
									if l := len("/secrets"); len(elem) >= l && elem[0:l] == "/secrets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsListEnvironmentSecrets"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsGetEnvironmentSecret"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case 'p': // Prefix: "public-key"
											if l := len("public-key"); len(elem) >= l && elem[0:l] == "public-key" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsGetEnvironmentPublicKey
												r.name = "ActionsGetEnvironmentPublicKey"
												r.args = args
												r.count = 2
												return r, true
											}
										}
										// Param: "secret_name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsGetEnvironmentSecret
											r.name = "ActionsGetEnvironmentSecret"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "SearchCode"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'c': // Prefix: "cim/v2/enterprises/"
					if l := len("cim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "cim/v2/enterprises/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "enterprise"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminGetProvisioningInformationForEnterpriseUser"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'G': // Prefix: "Groups"
							if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "EnterpriseAdminListProvisionedGroupsEnterprise"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_group_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseGroup
									r.name = "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'U': // Prefix: "Users"
							if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "EnterpriseAdminListProvisionedIdentitiesEnterprise"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "scim_user_id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminGetProvisioningInformationForEnterpriseUser
									r.name = "EnterpriseAdminGetProvisioningInformationForEnterpriseUser"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						}
					}
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "SearchIssuesAndPullRequests"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "co"
						if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "SearchCommits"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'd': // Prefix: "de"
							if l := len("de"); len(elem) >= l && elem[0:l] == "de" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCode
								r.name = "SearchCode"
								r.args = args
								r.count = 0
								return r, true
							}
						case 'm': // Prefix: "mmits"
							if l := len("mmits"); len(elem) >= l && elem[0:l] == "mmits" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: SearchCommits
								r.name = "SearchCommits"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 'i': // Prefix: "issues"
						if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchIssuesAndPullRequests
							r.name = "SearchIssuesAndPullRequests"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'l': // Prefix: "labels"
						if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchLabels
							r.name = "SearchLabels"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'r': // Prefix: "repositories"
						if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchRepos
							r.name = "SearchRepos"
							r.args = args
							r.count = 0
							return r, true
						}
					case 't': // Prefix: "topics"
						if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchTopics
							r.name = "SearchTopics"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'u': // Prefix: "users"
						if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: SearchUsers
							r.name = "SearchUsers"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "TeamsGetLegacy"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "TeamsCheckPermissionsForProjectLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions"
						if l := len("discussions"); len(elem) >= l && elem[0:l] == "discussions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsListDiscussionsLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "discussion_number"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "TeamsGetDiscussionLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReactionsListForTeamDiscussionLegacy"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"
									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "TeamsListDiscussionCommentsLegacy"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_number"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "TeamsGetDiscussionCommentLegacy"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsListForTeamDiscussionCommentLegacy
												r.name = "ReactionsListForTeamDiscussionCommentLegacy"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								case 'r': // Prefix: "reactions"
									if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReactionsListForTeamDiscussionLegacy
										r.name = "ReactionsListForTeamDiscussionLegacy"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsListPendingInvitationsLegacy
							r.name = "TeamsListPendingInvitationsLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsListMembersLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsGetMemberLegacy
								r.name = "TeamsGetMemberLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsGetMembershipForUserLegacy
								r.name = "TeamsGetMembershipForUserLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 'p': // Prefix: "projects"
						if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsListProjectsLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "project_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsCheckPermissionsForProjectLegacy
								r.name = "TeamsCheckPermissionsForProjectLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsListReposLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "owner"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "repo"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsCheckPermissionsForRepoLegacy
									r.name = "TeamsCheckPermissionsForRepoLegacy"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						}
					case 't': // Prefix: "team"
						if l := len("team"); len(elem) >= l && elem[0:l] == "team" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsListIdpGroupsForLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '-': // Prefix: "-sync/group-mappings"
							if l := len("-sync/group-mappings"); len(elem) >= l && elem[0:l] == "-sync/group-mappings" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsListIdpGroupsForLegacy
								r.name = "TeamsListIdpGroupsForLegacy"
								r.args = args
								r.count = 1
								return r, true
							}
						case 's': // Prefix: "s"
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: TeamsListChildLegacy
								r.name = "TeamsListChildLegacy"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "UsersGetAuthenticated"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsListInstallationReposForAuthenticatedUser"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'b': // Prefix: "blocks"
						if l := len("blocks"); len(elem) >= l && elem[0:l] == "blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "UsersListBlockedByAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersCheckBlocked
								r.name = "UsersCheckBlocked"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersListEmailsForAuthenticated
							r.name = "UsersListEmailsForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'f': // Prefix: "follow"
						if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "UsersListFollowersForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'e': // Prefix: "ers"
							if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListFollowersForAuthenticatedUser
								r.name = "UsersListFollowersForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						case 'i': // Prefix: "ing"
							if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "UsersListFollowedByAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: UsersCheckPersonIsFollowedByAuthenticated
									r.name = "UsersCheckPersonIsFollowedByAuthenticated"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "UsersListGpgKeysForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "gpg_key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetGpgKeyForAuthenticated
								r.name = "UsersGetGpgKeyForAuthenticated"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 'i': // Prefix: "i"
						if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "IssuesListForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'n': // Prefix: "nstallations/"
							if l := len("nstallations/"); len(elem) >= l && elem[0:l] == "nstallations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories"
								if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListInstallationReposForAuthenticatedUser
									r.name = "AppsListInstallationReposForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 's': // Prefix: "ssues"
							if l := len("ssues"); len(elem) >= l && elem[0:l] == "ssues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: IssuesListForAuthenticatedUser
								r.name = "IssuesListForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "UsersListPublicSSHKeysForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "key_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: UsersGetPublicSSHKeyForAuthenticated
								r.name = "UsersGetPublicSSHKeyForAuthenticated"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "MigrationsGetArchiveForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "arketplace_purchases"
							if l := len("arketplace_purchases"); len(elem) >= l && elem[0:l] == "arketplace_purchases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "AppsListSubscriptionsForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/stubbed"
								if l := len("/stubbed"); len(elem) >= l && elem[0:l] == "/stubbed" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsListSubscriptionsForAuthenticatedUserStubbed
									r.name = "AppsListSubscriptionsForAuthenticatedUserStubbed"
									r.args = args
									r.count = 0
									return r, true
								}
							}
						case 'e': // Prefix: "emberships/orgs"
							if l := len("emberships/orgs"); len(elem) >= l && elem[0:l] == "emberships/orgs" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "OrgsListMembershipsForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "org"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: OrgsGetMembershipForAuthenticatedUser
									r.name = "OrgsGetMembershipForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 'i': // Prefix: "igrations"
							if l := len("igrations"); len(elem) >= l && elem[0:l] == "igrations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "MigrationsListForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "migration_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "MigrationsGetStatusForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "MigrationsListReposForUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "archive"
										if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsGetArchiveForAuthenticatedUser
											r.name = "MigrationsGetArchiveForAuthenticatedUser"
											r.args = args
											r.count = 1
											return r, true
										}
									case 'r': // Prefix: "repositories"
										if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsListReposForUser
											r.name = "MigrationsListReposForUser"
											r.args = args
											r.count = 1
											return r, true
										}
									}
								}
							}
						}
					case 'o': // Prefix: "orgs"
						if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: OrgsListForAuthenticatedUser
							r.name = "OrgsListForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "UsersListPublicEmailsForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages"
							if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "PackagesListPackagesForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_name"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										r.name = "PackagesGetPackageForAuthenticatedUser"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/versions"
										if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_version_id"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf: PackagesGetPackageVersionForAuthenticatedUser
												r.name = "PackagesGetPackageVersionForAuthenticatedUser"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								}
							}
						case 'u': // Prefix: "ublic_emails"
							if l := len("ublic_emails"); len(elem) >= l && elem[0:l] == "ublic_emails" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: UsersListPublicEmailsForAuthenticated
								r.name = "UsersListPublicEmailsForAuthenticated"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ReposListForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'i': // Prefix: "itory_invitations"
							if l := len("itory_invitations"); len(elem) >= l && elem[0:l] == "itory_invitations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposListInvitationsForAuthenticatedUser
								r.name = "ReposListInvitationsForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 's': // Prefix: "s"
						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ActivityListWatchedReposForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 't': // Prefix: "tarred"
							if l := len("tarred"); len(elem) >= l && elem[0:l] == "tarred" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActivityListReposStarredByAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActivityCheckRepoIsStarredByAuthenticatedUser
										r.name = "ActivityCheckRepoIsStarredByAuthenticatedUser"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						case 'u': // Prefix: "ubscriptions"
							if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActivityListWatchedReposForAuthenticatedUser
								r.name = "ActivityListWatchedReposForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsListForAuthenticatedUser
							r.name = "TeamsListForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				case 's': // Prefix: "s"
					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "UsersList"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "UsersGetByUsername"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActivityListReceivedEventsForUser"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'e': // Prefix: "events"
								if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActivityListEventsForAuthenticatedUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActivityListPublicEventsForUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case 'o': // Prefix: "orgs/"
										if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "org"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActivityListOrgEventsForAuthenticatedUser
											r.name = "ActivityListOrgEventsForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'p': // Prefix: "public"
										if l := len("public"); len(elem) >= l && elem[0:l] == "public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityListPublicEventsForUser
											r.name = "ActivityListPublicEventsForUser"
											r.args = args
											r.count = 1
											return r, true
										}
									}
								}
							case 'f': // Prefix: "follow"
								if l := len("follow"); len(elem) >= l && elem[0:l] == "follow" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "UsersListFollowersForUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'e': // Prefix: "ers"
									if l := len("ers"); len(elem) >= l && elem[0:l] == "ers" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersListFollowersForUser
										r.name = "UsersListFollowersForUser"
										r.args = args
										r.count = 1
										return r, true
									}
								case 'i': // Prefix: "ing"
									if l := len("ing"); len(elem) >= l && elem[0:l] == "ing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "UsersListFollowingForUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "target_user"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: UsersCheckFollowingForUser
											r.name = "UsersCheckFollowingForUser"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								}
							case 'g': // Prefix: "g"
								if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "UsersListGpgKeysForUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'i': // Prefix: "ists"
									if l := len("ists"); len(elem) >= l && elem[0:l] == "ists" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GistsListForUser
										r.name = "GistsListForUser"
										r.args = args
										r.count = 1
										return r, true
									}
								case 'p': // Prefix: "pg_keys"
									if l := len("pg_keys"); len(elem) >= l && elem[0:l] == "pg_keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: UsersListGpgKeysForUser
										r.name = "UsersListGpgKeysForUser"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							case 'h': // Prefix: "hovercard"
								if l := len("hovercard"); len(elem) >= l && elem[0:l] == "hovercard" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: UsersGetContextForUser
									r.name = "UsersGetContextForUser"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'k': // Prefix: "keys"
								if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: UsersListPublicKeysForUser
									r.name = "UsersListPublicKeysForUser"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'o': // Prefix: "orgs"
								if l := len("orgs"); len(elem) >= l && elem[0:l] == "orgs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: OrgsListForUser
									r.name = "OrgsListForUser"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'p': // Prefix: "p"
								if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ProjectsListForUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'a': // Prefix: "ackages"
									if l := len("ackages"); len(elem) >= l && elem[0:l] == "ackages" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "PackagesListPackagesForUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_type"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "package_name"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[2] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												r.name = "PackagesGetPackageForUser"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/versions"
												if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													r.name = "PackagesGetAllPackageVersionsForPackageOwnedByUser"
													r.args = args
													r.count = 3
													return r, true
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "package_version_id"
													// Leaf parameter
													args[3] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf: PackagesGetPackageVersionForUser
														r.name = "PackagesGetPackageVersionForUser"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										}
									}
								case 'r': // Prefix: "rojects"
									if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ProjectsListForUser
										r.name = "ProjectsListForUser"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposListForUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'c': // Prefix: "ceived_events"
									if l := len("ceived_events"); len(elem) >= l && elem[0:l] == "ceived_events" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActivityListReceivedEventsForUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/public"
										if l := len("/public"); len(elem) >= l && elem[0:l] == "/public" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActivityListReceivedPublicEventsForUser
											r.name = "ActivityListReceivedPublicEventsForUser"
											r.args = args
											r.count = 1
											return r, true
										}
									}
								case 'p': // Prefix: "pos"
									if l := len("pos"); len(elem) >= l && elem[0:l] == "pos" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposListForUser
										r.name = "ReposListForUser"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "BillingGetGithubActionsBillingUser"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'e': // Prefix: "ettings/billing/"
									if l := len("ettings/billing/"); len(elem) >= l && elem[0:l] == "ettings/billing/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "BillingGetGithubPackagesBillingUser"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "actions"
										if l := len("actions"); len(elem) >= l && elem[0:l] == "actions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubActionsBillingUser
											r.name = "BillingGetGithubActionsBillingUser"
											r.args = args
											r.count = 1
											return r, true
										}
									case 'p': // Prefix: "packages"
										if l := len("packages"); len(elem) >= l && elem[0:l] == "packages" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetGithubPackagesBillingUser
											r.name = "BillingGetGithubPackagesBillingUser"
											r.args = args
											r.count = 1
											return r, true
										}
									case 's': // Prefix: "shared-storage"
										if l := len("shared-storage"); len(elem) >= l && elem[0:l] == "shared-storage" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: BillingGetSharedStorageBillingUser
											r.name = "BillingGetSharedStorageBillingUser"
											r.args = args
											r.count = 1
											return r, true
										}
									}
								case 'u': // Prefix: "ubscriptions"
									if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActivityListReposWatchedByUser
										r.name = "ActivityListReposWatchedByUser"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							}
						}
					}
				}
			}
		}
	case "PATCH":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				r.name = "ActivityMarkThreadAsRead"
				r.args = args
				r.count = 0
				return r, true
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OAuthAuthorizationsUpdateAuthorization"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsUpdateWebhookConfigForApp"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/hook/config"
						if l := len("/hook/config"); len(elem) >= l && elem[0:l] == "/hook/config" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: AppsUpdateWebhookConfigForApp
							r.name = "AppsUpdateWebhookConfigForApp"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/token"
							if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: AppsResetToken
								r.name = "AppsResetToken"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
				case 'u': // Prefix: "uthorizations/"
					if l := len("uthorizations/"); len(elem) >= l && elem[0:l] == "uthorizations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "authorization_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsUpdateAuthorization
						r.name = "OAuthAuthorizationsUpdateAuthorization"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/runner-groups/"
					if l := len("/actions/runner-groups/"); len(elem) >= l && elem[0:l] == "/actions/runner-groups/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "runner_group_id"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise
						r.name = "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise"
						r.args = args
						r.count = 2
						return r, true
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/comments/"
					if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "comment_id"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: GistsUpdateComment
						r.name = "GistsUpdateComment"
						r.args = args
						r.count = 2
						return r, true
					}
				}
			case 'n': // Prefix: "notifications/threads/"
				if l := len("notifications/threads/"); len(elem) >= l && elem[0:l] == "notifications/threads/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "thread_id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ActivityMarkThreadAsRead
					r.name = "ActivityMarkThreadAsRead"
					r.args = args
					r.count = 1
					return r, true
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "OrgsUpdateWebhook"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/runner-groups/"
						if l := len("actions/runner-groups/"); len(elem) >= l && elem[0:l] == "actions/runner-groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "runner_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ActionsUpdateSelfHostedRunnerGroupForOrg
							r.name = "ActionsUpdateSelfHostedRunnerGroupForOrg"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'h': // Prefix: "hooks/"
						if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "hook_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "OrgsUpdateWebhook"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/config"
							if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: OrgsUpdateWebhookConfigForOrg
								r.name = "OrgsUpdateWebhookConfigForOrg"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "TeamsUpdateInOrg"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "TeamsUpdateDiscussionCommentInOrg"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'd': // Prefix: "discussions/"
								if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "discussion_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									r.name = "TeamsUpdateDiscussionInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/comments/"
									if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsUpdateDiscussionCommentInOrg
										r.name = "TeamsUpdateDiscussionCommentInOrg"
										r.args = args
										r.count = 4
										return r, true
									}
								}
							case 't': // Prefix: "team-sync/group-mappings"
								if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsInOrg
									r.name = "TeamsCreateOrUpdateIdpGroupConnectionsInOrg"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ProjectsUpdateColumn"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ProjectsUpdateCard
							r.name = "ProjectsUpdateCard"
							r.args = args
							r.count = 1
							return r, true
						}
					}
					// Param: "column_id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsUpdateColumn
						r.name = "ProjectsUpdateColumn"
						r.args = args
						r.count = 1
						return r, true
					}
				}
				// Param: "project_id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf: ProjectsUpdate
					r.name = "ProjectsUpdate"
					r.args = args
					r.count = 1
					return r, true
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repo"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[1] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						r.name = "ReposUpdate"
						r.args = args
						r.count = 2
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "GitUpdateRef"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case 'b': // Prefix: "branches/"
							if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "branch"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/protection/required_"
								if l := len("/protection/required_"); len(elem) >= l && elem[0:l] == "/protection/required_" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposUpdateStatusCheckProtection"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case 'p': // Prefix: "pull_request_reviews"
									if l := len("pull_request_reviews"); len(elem) >= l && elem[0:l] == "pull_request_reviews" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposUpdatePullRequestReviewProtection
										r.name = "ReposUpdatePullRequestReviewProtection"
										r.args = args
										r.count = 3
										return r, true
									}
								case 's': // Prefix: "status_checks"
									if l := len("status_checks"); len(elem) >= l && elem[0:l] == "status_checks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposUpdateStatusCheckProtection
										r.name = "ReposUpdateStatusCheckProtection"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "CodeScanningUpdateAlert"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'h': // Prefix: "heck-suites/preferences"
								if l := len("heck-suites/preferences"); len(elem) >= l && elem[0:l] == "heck-suites/preferences" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ChecksSetSuitesPreferences
									r.name = "ChecksSetSuitesPreferences"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'o': // Prefix: "o"
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposUpdateCommitComment"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'd': // Prefix: "de-scanning/alerts/"
									if l := len("de-scanning/alerts/"); len(elem) >= l && elem[0:l] == "de-scanning/alerts/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "alert_number"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: CodeScanningUpdateAlert
										r.name = "CodeScanningUpdateAlert"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'm': // Prefix: "mments/"
									if l := len("mments/"); len(elem) >= l && elem[0:l] == "mments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposUpdateCommitComment
										r.name = "ReposUpdateCommitComment"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						case 'g': // Prefix: "git/refs/"
							if l := len("git/refs/"); len(elem) >= l && elem[0:l] == "git/refs/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "ref"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: GitUpdateRef
								r.name = "GitUpdateRef"
								r.args = args
								r.count = 3
								return r, true
							}
						case 'h': // Prefix: "hooks/"
							if l := len("hooks/"); len(elem) >= l && elem[0:l] == "hooks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "ReposUpdateWebhook"
								r.args = args
								r.count = 3
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/config"
								if l := len("/config"); len(elem) >= l && elem[0:l] == "/config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposUpdateWebhookConfigForRepo
									r.name = "ReposUpdateWebhookConfigForRepo"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						case 'i': // Prefix: "i"
							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "MigrationsMapCommitAuthor"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'm': // Prefix: "mport"
								if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "MigrationsUpdateImport"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "MigrationsSetLfsPreference"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "authors/"
										if l := len("authors/"); len(elem) >= l && elem[0:l] == "authors/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "author_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: MigrationsMapCommitAuthor
											r.name = "MigrationsMapCommitAuthor"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'l': // Prefix: "lfs"
										if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: MigrationsSetLfsPreference
											r.name = "MigrationsSetLfsPreference"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								}
							case 'n': // Prefix: "nvitations/"
								if l := len("nvitations/"); len(elem) >= l && elem[0:l] == "nvitations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "invitation_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ReposUpdateInvitation
									r.name = "ReposUpdateInvitation"
									r.args = args
									r.count = 3
									return r, true
								}
							case 's': // Prefix: "ssues/"
								if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments/"
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: IssuesUpdateComment
										r.name = "IssuesUpdateComment"
										r.args = args
										r.count = 3
										return r, true
									}
								}
								// Param: "issue_number"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: IssuesUpdate
									r.name = "IssuesUpdate"
									r.args = args
									r.count = 3
									return r, true
								}
							}
						case 'l': // Prefix: "labels/"
							if l := len("labels/"); len(elem) >= l && elem[0:l] == "labels/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: IssuesUpdateLabel
								r.name = "IssuesUpdateLabel"
								r.args = args
								r.count = 3
								return r, true
							}
						case 'm': // Prefix: "milestones/"
							if l := len("milestones/"); len(elem) >= l && elem[0:l] == "milestones/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "milestone_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: IssuesUpdateMilestone
								r.name = "IssuesUpdateMilestone"
								r.args = args
								r.count = 3
								return r, true
							}
						case 'p': // Prefix: "pulls/"
							if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "comments/"
								if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "comment_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: PullsUpdateReviewComment
									r.name = "PullsUpdateReviewComment"
									r.args = args
									r.count = 3
									return r, true
								}
							}
							// Param: "pull_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: PullsUpdate
								r.name = "PullsUpdate"
								r.args = args
								r.count = 3
								return r, true
							}
						case 'r': // Prefix: "releases/"
							if l := len("releases/"); len(elem) >= l && elem[0:l] == "releases/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "assets/"
								if l := len("assets/"); len(elem) >= l && elem[0:l] == "assets/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "asset_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: ReposUpdateReleaseAsset
									r.name = "ReposUpdateReleaseAsset"
									r.args = args
									r.count = 3
									return r, true
								}
							}
							// Param: "release_id"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ReposUpdateRelease
								r.name = "ReposUpdateRelease"
								r.args = args
								r.count = 3
								return r, true
							}
						case 's': // Prefix: "secret-scanning/alerts/"
							if l := len("secret-scanning/alerts/"); len(elem) >= l && elem[0:l] == "secret-scanning/alerts/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "alert_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: SecretScanningUpdateAlert
								r.name = "SecretScanningUpdateAlert"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminUpdateAttributeForEnterpriseUser"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups/"
						if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseGroup
							r.name = "EnterpriseAdminUpdateAttributeForEnterpriseGroup"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'U': // Prefix: "Users/"
						if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminUpdateAttributeForEnterpriseUser
							r.name = "EnterpriseAdminUpdateAttributeForEnterpriseUser"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					r.name = "TeamsUpdateLegacy"
					r.args = args
					r.count = 1
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "TeamsUpdateDiscussionCommentLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'd': // Prefix: "discussions/"
						if l := len("discussions/"); len(elem) >= l && elem[0:l] == "discussions/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							r.name = "TeamsUpdateDiscussionLegacy"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/comments/"
							if l := len("/comments/"); len(elem) >= l && elem[0:l] == "/comments/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "comment_number"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsUpdateDiscussionCommentLegacy
								r.name = "TeamsUpdateDiscussionCommentLegacy"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					case 't': // Prefix: "team-sync/group-mappings"
						if l := len("team-sync/group-mappings"); len(elem) >= l && elem[0:l] == "team-sync/group-mappings" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: TeamsCreateOrUpdateIdpGroupConnectionsLegacy
							r.name = "TeamsCreateOrUpdateIdpGroupConnectionsLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "UsersUpdateAuthenticated"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ReposAcceptInvitation"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'e': // Prefix: "email/visibility"
						if l := len("email/visibility"); len(elem) >= l && elem[0:l] == "email/visibility" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersSetPrimaryEmailVisibilityForAuthenticated
							r.name = "UsersSetPrimaryEmailVisibilityForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'm': // Prefix: "memberships/orgs/"
						if l := len("memberships/orgs/"); len(elem) >= l && elem[0:l] == "memberships/orgs/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "org"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsUpdateMembershipForAuthenticatedUser
							r.name = "OrgsUpdateMembershipForAuthenticatedUser"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'r': // Prefix: "repository_invitations/"
						if l := len("repository_invitations/"); len(elem) >= l && elem[0:l] == "repository_invitations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "invitation_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ReposAcceptInvitation
							r.name = "ReposAcceptInvitation"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			}
		}
	case "POST":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				r.name = "ActionsCreateRegistrationTokenForOrg"
				r.args = args
				r.count = 0
				return r, true
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OAuthAuthorizationsCreateAuthorization"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'p': // Prefix: "pp"
					if l := len("pp"); len(elem) >= l && elem[0:l] == "pp" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "AppsCreateInstallationAccessToken"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "AppsRedeliverWebhookDelivery"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'h': // Prefix: "hook/deliveries/"
							if l := len("hook/deliveries/"); len(elem) >= l && elem[0:l] == "hook/deliveries/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "delivery_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/attempts"
								if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsRedeliverWebhookDelivery
									r.name = "AppsRedeliverWebhookDelivery"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						case 'i': // Prefix: "installations/"
							if l := len("installations/"); len(elem) >= l && elem[0:l] == "installations/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "installation_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/access_tokens"
								if l := len("/access_tokens"); len(elem) >= l && elem[0:l] == "/access_tokens" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsCreateInstallationAccessToken
									r.name = "AppsCreateInstallationAccessToken"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 'l': // Prefix: "lications/"
						if l := len("lications/"); len(elem) >= l && elem[0:l] == "lications/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "client_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/token"
							if l := len("/token"); len(elem) >= l && elem[0:l] == "/token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "AppsCheckToken"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/scoped"
								if l := len("/scoped"); len(elem) >= l && elem[0:l] == "/scoped" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: AppsScopeToken
									r.name = "AppsScopeToken"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					}
				case 'u': // Prefix: "uthorizations"
					if l := len("uthorizations"); len(elem) >= l && elem[0:l] == "uthorizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: OAuthAuthorizationsCreateAuthorization
						r.name = "OAuthAuthorizationsCreateAuthorization"
						r.args = args
						r.count = 0
						return r, true
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/runner"
					if l := len("/actions/runner"); len(elem) >= l && elem[0:l] == "/actions/runner" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case '-': // Prefix: "-groups"
						if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
							r.name = "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
					case 's': // Prefix: "s/re"
						if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminCreateRemoveTokenForEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'g': // Prefix: "gistration-token"
							if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminCreateRegistrationTokenForEnterprise
								r.name = "EnterpriseAdminCreateRegistrationTokenForEnterprise"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'm': // Prefix: "move-token"
							if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: EnterpriseAdminCreateRemoveTokenForEnterprise
								r.name = "EnterpriseAdminCreateRemoveTokenForEnterprise"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
				}
			case 'g': // Prefix: "gists"
				if l := len("gists"); len(elem) >= l && elem[0:l] == "gists" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "GistsCreate"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "gist_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "GistsFork"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'c': // Prefix: "comments"
							if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsCreateComment
								r.name = "GistsCreateComment"
								r.args = args
								r.count = 1
								return r, true
							}
						case 'f': // Prefix: "forks"
							if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: GistsFork
								r.name = "GistsFork"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "MigrationsStartForOrg"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/runner"
						if l := len("actions/runner"); len(elem) >= l && elem[0:l] == "actions/runner" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ActionsCreateSelfHostedRunnerGroupForOrg"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '-': // Prefix: "-groups"
							if l := len("-groups"); len(elem) >= l && elem[0:l] == "-groups" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ActionsCreateSelfHostedRunnerGroupForOrg
								r.name = "ActionsCreateSelfHostedRunnerGroupForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
						case 's': // Prefix: "s/re"
							if l := len("s/re"); len(elem) >= l && elem[0:l] == "s/re" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActionsCreateRemoveTokenForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'g': // Prefix: "gistration-token"
								if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActionsCreateRegistrationTokenForOrg
									r.name = "ActionsCreateRegistrationTokenForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							case 'm': // Prefix: "move-token"
								if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActionsCreateRemoveTokenForOrg
									r.name = "ActionsCreateRemoveTokenForOrg"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 'h': // Prefix: "hooks"
						if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "OrgsCreateWebhook"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "hook_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "OrgsRedeliverWebhookDelivery"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'd': // Prefix: "deliveries/"
									if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "delivery_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/attempts"
										if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: OrgsRedeliverWebhookDelivery
											r.name = "OrgsRedeliverWebhookDelivery"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								case 'p': // Prefix: "pings"
									if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: OrgsPingWebhook
										r.name = "OrgsPingWebhook"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							}
						}
					case 'i': // Prefix: "invitations"
						if l := len("invitations"); len(elem) >= l && elem[0:l] == "invitations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: OrgsCreateInvitation
							r.name = "OrgsCreateInvitation"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'm': // Prefix: "migrations"
						if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: MigrationsStartForOrg
							r.name = "MigrationsStartForOrg"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ProjectsCreateForOrg"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "PackagesRestorePackageVersionForOrg"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'r': // Prefix: "restore"
										if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageForOrg
											r.name = "PackagesRestorePackageForOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'v': // Prefix: "versions/"
										if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_version_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"
											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PackagesRestorePackageVersionForOrg
												r.name = "PackagesRestorePackageVersionForOrg"
												r.args = args
												r.count = 4
												return r, true
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsCreateForOrg
								r.name = "ProjectsCreateForOrg"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ReposCreateInOrg
							r.name = "ReposCreateInOrg"
							r.args = args
							r.count = 1
							return r, true
						}
					case 't': // Prefix: "teams"
						if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsCreate"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "team_slug"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/discussions"
								if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "TeamsCreateDiscussionInOrg"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "discussion_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReactionsCreateForTeamDiscussionInOrg"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case 'c': // Prefix: "comments"
											if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "TeamsCreateDiscussionCommentInOrg"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_number"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/reactions"
													if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: ReactionsCreateForTeamDiscussionCommentInOrg
														r.name = "ReactionsCreateForTeamDiscussionCommentInOrg"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										case 'r': // Prefix: "reactions"
											if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForTeamDiscussionInOrg
												r.name = "ReactionsCreateForTeamDiscussionInOrg"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "columns/"
					if l := len("columns/"); len(elem) >= l && elem[0:l] == "columns/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "ProjectsMoveColumn"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'c': // Prefix: "cards/"
						if l := len("cards/"); len(elem) >= l && elem[0:l] == "cards/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "card_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/moves"
							if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsMoveCard
								r.name = "ProjectsMoveCard"
								r.args = args
								r.count = 1
								return r, true
							}
						}
					}
					// Param: "column_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/moves"
						if l := len("/moves"); len(elem) >= l && elem[0:l] == "/moves" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ProjectsMoveColumn
							r.name = "ProjectsMoveColumn"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/columns"
					if l := len("/columns"); len(elem) >= l && elem[0:l] == "/columns" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: ProjectsCreateColumn
						r.name = "ProjectsCreateColumn"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'r': // Prefix: "repos/"
				if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "owner"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repo"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[1] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "AppsCreateContentAttachment"
							r.args = args
							r.count = 2
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposCreateAutolink"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "ctions/run"
								if l := len("ctions/run"); len(elem) >= l && elem[0:l] == "ctions/run" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActionsCreateRegistrationTokenForRepo"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'n': // Prefix: "ners/re"
									if l := len("ners/re"); len(elem) >= l && elem[0:l] == "ners/re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsCreateRemoveTokenForRepo"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'g': // Prefix: "gistration-token"
										if l := len("gistration-token"); len(elem) >= l && elem[0:l] == "gistration-token" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActionsCreateRegistrationTokenForRepo
											r.name = "ActionsCreateRegistrationTokenForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'm': // Prefix: "move-token"
										if l := len("move-token"); len(elem) >= l && elem[0:l] == "move-token" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ActionsCreateRemoveTokenForRepo
											r.name = "ActionsCreateRemoveTokenForRepo"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								case 's': // Prefix: "s/"
									if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "run_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsCancelWorkflowRun"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case 'a': // Prefix: "approve"
											if l := len("approve"); len(elem) >= l && elem[0:l] == "approve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsApproveWorkflowRun
												r.name = "ActionsApproveWorkflowRun"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'c': // Prefix: "cancel"
											if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsCancelWorkflowRun
												r.name = "ActionsCancelWorkflowRun"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'p': // Prefix: "pending_deployments"
											if l := len("pending_deployments"); len(elem) >= l && elem[0:l] == "pending_deployments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsReviewPendingDeploymentsForRun
												r.name = "ActionsReviewPendingDeploymentsForRun"
												r.args = args
												r.count = 3
												return r, true
											}
										case 'r': // Prefix: "re"
											if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ActionsRetryWorkflow"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'r': // Prefix: "run"
												if l := len("run"); len(elem) >= l && elem[0:l] == "run" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsReRunWorkflow
													r.name = "ActionsReRunWorkflow"
													r.args = args
													r.count = 3
													return r, true
												}
											case 't': // Prefix: "try"
												if l := len("try"); len(elem) >= l && elem[0:l] == "try" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ActionsRetryWorkflow
													r.name = "ActionsRetryWorkflow"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										}
									}
								}
							case 'u': // Prefix: "utolinks"
								if l := len("utolinks"); len(elem) >= l && elem[0:l] == "utolinks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateAutolink
									r.name = "ReposCreateAutolink"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'b': // Prefix: "branches/"
							if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "branch"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposRenameBranch"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case 'p': // Prefix: "protection/"
									if l := len("protection/"); len(elem) >= l && elem[0:l] == "protection/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposSetAdminBranchProtection"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'e': // Prefix: "enforce_admins"
										if l := len("enforce_admins"); len(elem) >= l && elem[0:l] == "enforce_admins" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposSetAdminBranchProtection
											r.name = "ReposSetAdminBranchProtection"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'r': // Prefix: "re"
										if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposAddStatusCheckContexts"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case 'q': // Prefix: "quired_s"
											if l := len("quired_s"); len(elem) >= l && elem[0:l] == "quired_s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposCreateCommitSignatureProtection"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'i': // Prefix: "ignatures"
												if l := len("ignatures"); len(elem) >= l && elem[0:l] == "ignatures" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposCreateCommitSignatureProtection
													r.name = "ReposCreateCommitSignatureProtection"
													r.args = args
													r.count = 3
													return r, true
												}
											case 't': // Prefix: "tatus_checks/contexts"
												if l := len("tatus_checks/contexts"); len(elem) >= l && elem[0:l] == "tatus_checks/contexts" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddStatusCheckContexts
													r.name = "ReposAddStatusCheckContexts"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										case 's': // Prefix: "strictions/"
											if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposAddTeamAccessRestrictions"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "apps"
												if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddAppAccessRestrictions
													r.name = "ReposAddAppAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											case 't': // Prefix: "teams"
												if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddTeamAccessRestrictions
													r.name = "ReposAddTeamAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'u': // Prefix: "users"
												if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposAddUserAccessRestrictions
													r.name = "ReposAddUserAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										}
									}
								case 'r': // Prefix: "rename"
									if l := len("rename"); len(elem) >= l && elem[0:l] == "rename" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposRenameBranch
										r.name = "ReposRenameBranch"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ChecksCreateSuite"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'h': // Prefix: "heck-suites"
								if l := len("heck-suites"); len(elem) >= l && elem[0:l] == "heck-suites" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ChecksCreateSuite"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "check_suite_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/rerequest"
										if l := len("/rerequest"); len(elem) >= l && elem[0:l] == "/rerequest" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ChecksRerequestSuite
											r.name = "ChecksRerequestSuite"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 'o': // Prefix: "o"
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "CodeScanningUploadSarif"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'd': // Prefix: "de-scanning/sarifs"
									if l := len("de-scanning/sarifs"); len(elem) >= l && elem[0:l] == "de-scanning/sarifs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: CodeScanningUploadSarif
										r.name = "CodeScanningUploadSarif"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'm': // Prefix: "mm"
									if l := len("mm"); len(elem) >= l && elem[0:l] == "mm" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposCreateCommitComment"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'e': // Prefix: "ents/"
										if l := len("ents/"); len(elem) >= l && elem[0:l] == "ents/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForCommitComment
												r.name = "ReactionsCreateForCommitComment"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									case 'i': // Prefix: "its/"
										if l := len("its/"); len(elem) >= l && elem[0:l] == "its/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commit_sha"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/comments"
											if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposCreateCommitComment
												r.name = "ReposCreateCommitComment"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								case 'n': // Prefix: "ntent_references/"
									if l := len("ntent_references/"); len(elem) >= l && elem[0:l] == "ntent_references/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "content_reference_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/attachments"
										if l := len("/attachments"); len(elem) >= l && elem[0:l] == "/attachments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: AppsCreateContentAttachment
											r.name = "AppsCreateContentAttachment"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						case 'd': // Prefix: "d"
							if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposCreateDispatchEvent"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'e': // Prefix: "eployments"
								if l := len("eployments"); len(elem) >= l && elem[0:l] == "eployments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposCreateDeployment"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "deployment_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/statuses"
										if l := len("/statuses"); len(elem) >= l && elem[0:l] == "/statuses" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposCreateDeploymentStatus
											r.name = "ReposCreateDeploymentStatus"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 'i': // Prefix: "ispatches"
								if l := len("ispatches"); len(elem) >= l && elem[0:l] == "ispatches" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateDispatchEvent
									r.name = "ReposCreateDispatchEvent"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'f': // Prefix: "forks"
							if l := len("forks"); len(elem) >= l && elem[0:l] == "forks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposCreateFork
								r.name = "ReposCreateFork"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'g': // Prefix: "g"
							if l := len("g"); len(elem) >= l && elem[0:l] == "g" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposCreateUsingTemplate"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'e': // Prefix: "enerate"
								if l := len("enerate"); len(elem) >= l && elem[0:l] == "enerate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposCreateUsingTemplate
									r.name = "ReposCreateUsingTemplate"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'i': // Prefix: "it/"
								if l := len("it/"); len(elem) >= l && elem[0:l] == "it/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "GitCreateCommit"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'b': // Prefix: "blobs"
									if l := len("blobs"); len(elem) >= l && elem[0:l] == "blobs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateBlob
										r.name = "GitCreateBlob"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'c': // Prefix: "commits"
									if l := len("commits"); len(elem) >= l && elem[0:l] == "commits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateCommit
										r.name = "GitCreateCommit"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'r': // Prefix: "refs"
									if l := len("refs"); len(elem) >= l && elem[0:l] == "refs" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: GitCreateRef
										r.name = "GitCreateRef"
										r.args = args
										r.count = 2
										return r, true
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "GitCreateTree"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "ags"
										if l := len("ags"); len(elem) >= l && elem[0:l] == "ags" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GitCreateTag
											r.name = "GitCreateTag"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'r': // Prefix: "rees"
										if l := len("rees"); len(elem) >= l && elem[0:l] == "rees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: GitCreateTree
											r.name = "GitCreateTree"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								}
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposCreateWebhook"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hook_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposRedeliverWebhookDelivery"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'd': // Prefix: "deliveries/"
										if l := len("deliveries/"); len(elem) >= l && elem[0:l] == "deliveries/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "delivery_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/attempts"
											if l := len("/attempts"); len(elem) >= l && elem[0:l] == "/attempts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposRedeliverWebhookDelivery
												r.name = "ReposRedeliverWebhookDelivery"
												r.args = args
												r.count = 4
												return r, true
											}
										}
									case 'p': // Prefix: "pings"
										if l := len("pings"); len(elem) >= l && elem[0:l] == "pings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposPingWebhook
											r.name = "ReposPingWebhook"
											r.args = args
											r.count = 3
											return r, true
										}
									case 't': // Prefix: "tests"
										if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReposTestPushWebhook
											r.name = "ReposTestPushWebhook"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						case 'i': // Prefix: "issues"
							if l := len("issues"); len(elem) >= l && elem[0:l] == "issues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "IssuesCreate"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments/"
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/reactions"
										if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForIssueComment
											r.name = "ReactionsCreateForIssueComment"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
								// Param: "issue_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "IssuesCreateComment"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'a': // Prefix: "assignees"
										if l := len("assignees"); len(elem) >= l && elem[0:l] == "assignees" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesAddAssignees
											r.name = "IssuesAddAssignees"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'c': // Prefix: "comments"
										if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesCreateComment
											r.name = "IssuesCreateComment"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'r': // Prefix: "reactions"
										if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForIssue
											r.name = "ReactionsCreateForIssue"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						case 'k': // Prefix: "keys"
							if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposCreateDeployKey
								r.name = "ReposCreateDeployKey"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'l': // Prefix: "labels"
							if l := len("labels"); len(elem) >= l && elem[0:l] == "labels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: IssuesCreateLabel
								r.name = "IssuesCreateLabel"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'm': // Prefix: "m"
							if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposMerge"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'e': // Prefix: "erge"
								if l := len("erge"); len(elem) >= l && elem[0:l] == "erge" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposMergeUpstream"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '-': // Prefix: "-upstream"
									if l := len("-upstream"); len(elem) >= l && elem[0:l] == "-upstream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposMergeUpstream
										r.name = "ReposMergeUpstream"
										r.args = args
										r.count = 2
										return r, true
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposMerge
										r.name = "ReposMerge"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							case 'i': // Prefix: "ilestones"
								if l := len("ilestones"); len(elem) >= l && elem[0:l] == "ilestones" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: IssuesCreateMilestone
									r.name = "IssuesCreateMilestone"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "PullsCreate"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'a': // Prefix: "ages"
								if l := len("ages"); len(elem) >= l && elem[0:l] == "ages" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposCreatePagesSite"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/builds"
									if l := len("/builds"); len(elem) >= l && elem[0:l] == "/builds" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposRequestPagesBuild
										r.name = "ReposRequestPagesBuild"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							case 'r': // Prefix: "rojects"
								if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ProjectsCreateForRepo
									r.name = "ProjectsCreateForRepo"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'u': // Prefix: "ulls"
								if l := len("ulls"); len(elem) >= l && elem[0:l] == "ulls" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "PullsCreate"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "comments/"
										if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "comment_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/reactions"
											if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReactionsCreateForPullRequestReviewComment
												r.name = "ReactionsCreateForPullRequestReviewComment"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
									// Param: "pull_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "PullsCreateReview"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case 'c': // Prefix: "comments"
											if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "PullsCreateReviewComment"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "comment_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/replies"
													if l := len("/replies"); len(elem) >= l && elem[0:l] == "/replies" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsCreateReplyForReviewComment
														r.name = "PullsCreateReplyForReviewComment"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										case 'r': // Prefix: "reviews"
											if l := len("reviews"); len(elem) >= l && elem[0:l] == "reviews" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "PullsCreateReview"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "review_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[3] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case '/': // Prefix: "/events"
													if l := len("/events"); len(elem) >= l && elem[0:l] == "/events" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf: PullsSubmitReview
														r.name = "PullsSubmitReview"
														r.args = args
														r.count = 4
														return r, true
													}
												}
											}
										}
									}
								}
							}
						case 'r': // Prefix: "releases"
							if l := len("releases"); len(elem) >= l && elem[0:l] == "releases" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReposCreateRelease"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "release_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/reactions"
									if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReactionsCreateForRelease
										r.name = "ReactionsCreateForRelease"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						case 's': // Prefix: "statuses/"
							if l := len("statuses/"); len(elem) >= l && elem[0:l] == "statuses/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "sha"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ReposCreateCommitStatus
								r.name = "ReposCreateCommitStatus"
								r.args = args
								r.count = 3
								return r, true
							}
						case 't': // Prefix: "transfer"
							if l := len("transfer"); len(elem) >= l && elem[0:l] == "transfer" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ReposTransfer
								r.name = "ReposTransfer"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminProvisionAndInviteEnterpriseUser"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups"
						if l := len("Groups"); len(elem) >= l && elem[0:l] == "Groups" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseGroup
							r.name = "EnterpriseAdminProvisionAndInviteEnterpriseGroup"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'U': // Prefix: "Users"
						if l := len("Users"); len(elem) >= l && elem[0:l] == "Users" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminProvisionAndInviteEnterpriseUser
							r.name = "EnterpriseAdminProvisionAndInviteEnterpriseUser"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/discussions"
					if l := len("/discussions"); len(elem) >= l && elem[0:l] == "/discussions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "TeamsCreateDiscussionLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "discussion_number"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ReactionsCreateForTeamDiscussionLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'c': // Prefix: "comments"
								if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "TeamsCreateDiscussionCommentLegacy"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "comment_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/reactions"
										if l := len("/reactions"); len(elem) >= l && elem[0:l] == "/reactions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: ReactionsCreateForTeamDiscussionCommentLegacy
											r.name = "ReactionsCreateForTeamDiscussionCommentLegacy"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 'r': // Prefix: "reactions"
								if l := len("reactions"); len(elem) >= l && elem[0:l] == "reactions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReactionsCreateForTeamDiscussionLegacy
									r.name = "ReactionsCreateForTeamDiscussionLegacy"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						}
					}
				}
			case 'u': // Prefix: "user"
				if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "PackagesRestorePackageForUser"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "PackagesRestorePackageForAuthenticatedUser"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 'e': // Prefix: "emails"
						if l := len("emails"); len(elem) >= l && elem[0:l] == "emails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersAddEmailForAuthenticated
							r.name = "UsersAddEmailForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'g': // Prefix: "gpg_keys"
						if l := len("gpg_keys"); len(elem) >= l && elem[0:l] == "gpg_keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreateGpgKeyForAuthenticated
							r.name = "UsersCreateGpgKeyForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'k': // Prefix: "keys"
						if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: UsersCreatePublicSSHKeyForAuthenticated
							r.name = "UsersCreatePublicSSHKeyForAuthenticated"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'm': // Prefix: "migrations"
						if l := len("migrations"); len(elem) >= l && elem[0:l] == "migrations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: MigrationsStartForAuthenticatedUser
							r.name = "MigrationsStartForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'p': // Prefix: "p"
						if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ProjectsCreateForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
						switch elem[0] {
						case 'a': // Prefix: "ackages/"
							if l := len("ackages/"); len(elem) >= l && elem[0:l] == "ackages/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_type"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "package_name"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "PackagesRestorePackageVersionForAuthenticatedUser"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'r': // Prefix: "restore"
										if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageForAuthenticatedUser
											r.name = "PackagesRestorePackageForAuthenticatedUser"
											r.args = args
											r.count = 2
											return r, true
										}
									case 'v': // Prefix: "versions/"
										if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "package_version_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[2] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"
											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PackagesRestorePackageVersionForAuthenticatedUser
												r.name = "PackagesRestorePackageVersionForAuthenticatedUser"
												r.args = args
												r.count = 3
												return r, true
											}
										}
									}
								}
							}
						case 'r': // Prefix: "rojects"
							if l := len("rojects"); len(elem) >= l && elem[0:l] == "rojects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf: ProjectsCreateForAuthenticatedUser
								r.name = "ProjectsCreateForAuthenticatedUser"
								r.args = args
								r.count = 0
								return r, true
							}
						}
					case 'r': // Prefix: "repos"
						if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ReposCreateForAuthenticatedUser
							r.name = "ReposCreateForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				case 's': // Prefix: "s/"
					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/packages/"
						if l := len("/packages/"); len(elem) >= l && elem[0:l] == "/packages/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "package_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "package_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[2] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "PackagesRestorePackageVersionForUser"
									r.args = args
									r.count = 3
									return r, true
								}
								switch elem[0] {
								case 'r': // Prefix: "restore"
									if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: PackagesRestorePackageForUser
										r.name = "PackagesRestorePackageForUser"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'v': // Prefix: "versions/"
									if l := len("versions/"); len(elem) >= l && elem[0:l] == "versions/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "package_version_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[3] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/restore"
										if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PackagesRestorePackageVersionForUser
											r.name = "PackagesRestorePackageVersionForUser"
											r.args = args
											r.count = 4
											return r, true
										}
									}
								}
							}
						}
					}
				}
			}
		}
	case "PUT":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				r.name = "ActionsCreateOrUpdateEnvironmentSecret"
				r.args = args
				r.count = 0
				return r, true
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "OAuthAuthorizationsGetOrCreateAuthorizationForApp"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'p': // Prefix: "pp/installations/"
					if l := len("pp/installations/"); len(elem) >= l && elem[0:l] == "pp/installations/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "installation_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/suspended"
						if l := len("/suspended"); len(elem) >= l && elem[0:l] == "/suspended" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: AppsSuspendInstallation
							r.name = "AppsSuspendInstallation"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				case 'u': // Prefix: "uthorizations/clients/"
					if l := len("uthorizations/clients/"); len(elem) >= l && elem[0:l] == "uthorizations/clients/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "client_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						r.name = "OAuthAuthorizationsGetOrCreateAuthorizationForApp"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "fingerprint"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint
							r.name = "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			case 'e': // Prefix: "enterprises/"
				if l := len("enterprises/"); len(elem) >= l && elem[0:l] == "enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/actions/"
					if l := len("/actions/"); len(elem) >= l && elem[0:l] == "/actions/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'p': // Prefix: "permissions"
						if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "EnterpriseAdminSetGithubActionsPermissionsEnterprise"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "EnterpriseAdminSetAllowedActionsEnterprise"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case 'o': // Prefix: "organizations"
								if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
										r.name = "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							case 's': // Prefix: "selected-actions"
								if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: EnterpriseAdminSetAllowedActionsEnterprise
									r.name = "EnterpriseAdminSetAllowedActionsEnterprise"
									r.args = args
									r.count = 1
									return r, true
								}
							}
						}
					case 'r': // Prefix: "runner-groups/"
						if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "runner_group_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'o': // Prefix: "organizations"
								if l := len("organizations"); len(elem) >= l && elem[0:l] == "organizations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "org_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
										r.name = "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							case 'r': // Prefix: "runners"
								if l := len("runners"); len(elem) >= l && elem[0:l] == "runners" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "runner_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
										r.name = "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						}
					}
				}
			case 'g': // Prefix: "gists/"
				if l := len("gists/"); len(elem) >= l && elem[0:l] == "gists/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "gist_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/star"
					if l := len("/star"); len(elem) >= l && elem[0:l] == "/star" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: GistsStar
						r.name = "GistsStar"
						r.args = args
						r.count = 1
						return r, true
					}
				}
			case 'n': // Prefix: "notifications"
				if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "ActivityMarkNotificationsAsRead"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/threads/"
					if l := len("/threads/"); len(elem) >= l && elem[0:l] == "/threads/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "thread_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/subscription"
						if l := len("/subscription"); len(elem) >= l && elem[0:l] == "/subscription" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: ActivitySetThreadSubscription
							r.name = "ActivitySetThreadSubscription"
							r.args = args
							r.count = 1
							return r, true
						}
					}
				}
			case 'o': // Prefix: "orgs/"
				if l := len("orgs/"); len(elem) >= l && elem[0:l] == "orgs/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "org"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "InteractionsSetRestrictionsForOrg"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'a': // Prefix: "actions/"
						if l := len("actions/"); len(elem) >= l && elem[0:l] == "actions/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "ActionsAddSelectedRepoToOrgSecret"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case 'p': // Prefix: "permissions"
							if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActionsSetGithubActionsPermissionsOrganization"
								r.args = args
								r.count = 1
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActionsSetAllowedActionsOrganization"
									r.args = args
									r.count = 1
									return r, true
								}
								switch elem[0] {
								case 'r': // Prefix: "repositories"
									if l := len("repositories"); len(elem) >= l && elem[0:l] == "repositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization"
										r.args = args
										r.count = 1
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsEnableSelectedRepositoryGithubActionsOrganization
											r.name = "ActionsEnableSelectedRepositoryGithubActionsOrganization"
											r.args = args
											r.count = 2
											return r, true
										}
									}
								case 's': // Prefix: "selected-actions"
									if l := len("selected-actions"); len(elem) >= l && elem[0:l] == "selected-actions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ActionsSetAllowedActionsOrganization
										r.name = "ActionsSetAllowedActionsOrganization"
										r.args = args
										r.count = 1
										return r, true
									}
								}
							}
						case 'r': // Prefix: "runner-groups/"
							if l := len("runner-groups/"); len(elem) >= l && elem[0:l] == "runner-groups/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "runner_group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/r"
								if l := len("/r"); len(elem) >= l && elem[0:l] == "/r" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActionsAddSelfHostedRunnerToGroupForOrg"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'e': // Prefix: "epositories"
									if l := len("epositories"); len(elem) >= l && elem[0:l] == "epositories" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "repository_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
											r.name = "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								case 'u': // Prefix: "unners"
									if l := len("unners"); len(elem) >= l && elem[0:l] == "unners" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsSetSelfHostedRunnersInGroupForOrg"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "runner_id"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsAddSelfHostedRunnerToGroupForOrg
											r.name = "ActionsAddSelfHostedRunnerToGroupForOrg"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							}
						case 's': // Prefix: "secrets/"
							if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								r.name = "ActionsCreateOrUpdateOrgSecret"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case '/': // Prefix: "/repositories"
								if l := len("/repositories"); len(elem) >= l && elem[0:l] == "/repositories" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ActionsSetSelectedReposForOrgSecret"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repository_id"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ActionsAddSelectedRepoToOrgSecret
										r.name = "ActionsAddSelectedRepoToOrgSecret"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							}
						}
					case 'b': // Prefix: "blocks/"
						if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsBlockUser
							r.name = "OrgsBlockUser"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'i': // Prefix: "interaction-limits"
						if l := len("interaction-limits"); len(elem) >= l && elem[0:l] == "interaction-limits" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: InteractionsSetRestrictionsForOrg
							r.name = "InteractionsSetRestrictionsForOrg"
							r.args = args
							r.count = 1
							return r, true
						}
					case 'm': // Prefix: "memberships/"
						if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsSetMembershipForUser
							r.name = "OrgsSetMembershipForUser"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'o': // Prefix: "outside_collaborators/"
						if l := len("outside_collaborators/"); len(elem) >= l && elem[0:l] == "outside_collaborators/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsConvertMemberToOutsideCollaborator
							r.name = "OrgsConvertMemberToOutsideCollaborator"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'p': // Prefix: "public_members/"
						if l := len("public_members/"); len(elem) >= l && elem[0:l] == "public_members/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "username"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: OrgsSetPublicMembershipForAuthenticatedUser
							r.name = "OrgsSetPublicMembershipForAuthenticatedUser"
							r.args = args
							r.count = 2
							return r, true
						}
					case 't': // Prefix: "teams/"
						if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "team_slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "TeamsAddOrUpdateProjectPermissionsInOrg"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'm': // Prefix: "memberships/"
								if l := len("memberships/"); len(elem) >= l && elem[0:l] == "memberships/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "username"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddOrUpdateMembershipForUserInOrg
									r.name = "TeamsAddOrUpdateMembershipForUserInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
							case 'p': // Prefix: "projects/"
								if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf: TeamsAddOrUpdateProjectPermissionsInOrg
									r.name = "TeamsAddOrUpdateProjectPermissionsInOrg"
									r.args = args
									r.count = 3
									return r, true
								}
							case 'r': // Prefix: "repos/"
								if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "owner"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "repo"
									// Leaf parameter
									args[3] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: TeamsAddOrUpdateRepoPermissionsInOrg
										r.name = "TeamsAddOrUpdateRepoPermissionsInOrg"
										r.args = args
										r.count = 4
										return r, true
									}
								}
							}
						}
					}
				}
			case 'p': // Prefix: "projects/"
				if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "project_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/collaborators/"
					if l := len("/collaborators/"); len(elem) >= l && elem[0:l] == "/collaborators/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[1] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: ProjectsAddCollaborator
						r.name = "ProjectsAddCollaborator"
						r.args = args
						r.count = 2
						return r, true
					}
				}
			case 'r': // Prefix: "repos"
				if l := len("repos"); len(elem) >= l && elem[0:l] == "repos" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "ActionsCreateOrUpdateRepoSecret"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								r.name = "ActivityMarkRepoNotificationsAsRead"
								r.args = args
								r.count = 2
								return r, true
							}
							switch elem[0] {
							case 'a': // Prefix: "a"
								if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposEnableAutomatedSecurityFixes"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'c': // Prefix: "ctions/"
									if l := len("ctions/"); len(elem) >= l && elem[0:l] == "ctions/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ActionsSetAllowedActionsRepository"
										r.args = args
										r.count = 2
										return r, true
									}
									switch elem[0] {
									case 'p': // Prefix: "permissions"
										if l := len("permissions"); len(elem) >= l && elem[0:l] == "permissions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ActionsSetGithubActionsPermissionsRepository"
											r.args = args
											r.count = 2
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/selected-actions"
											if l := len("/selected-actions"); len(elem) >= l && elem[0:l] == "/selected-actions" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ActionsSetAllowedActionsRepository
												r.name = "ActionsSetAllowedActionsRepository"
												r.args = args
												r.count = 2
												return r, true
											}
										}
									case 's': // Prefix: "secrets/"
										if l := len("secrets/"); len(elem) >= l && elem[0:l] == "secrets/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "secret_name"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf: ActionsCreateOrUpdateRepoSecret
											r.name = "ActionsCreateOrUpdateRepoSecret"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								case 'u': // Prefix: "utomated-security-fixes"
									if l := len("utomated-security-fixes"); len(elem) >= l && elem[0:l] == "utomated-security-fixes" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: ReposEnableAutomatedSecurityFixes
										r.name = "ReposEnableAutomatedSecurityFixes"
										r.args = args
										r.count = 2
										return r, true
									}
								}
							case 'b': // Prefix: "branches/"
								if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "branch"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/protection"
									if l := len("/protection"); len(elem) >= l && elem[0:l] == "/protection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "ReposUpdateBranchProtection"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case '/': // Prefix: "/re"
										if l := len("/re"); len(elem) >= l && elem[0:l] == "/re" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											r.name = "ReposSetStatusCheckContexts"
											r.args = args
											r.count = 3
											return r, true
										}
										switch elem[0] {
										case 'q': // Prefix: "quired_status_checks/contexts"
											if l := len("quired_status_checks/contexts"); len(elem) >= l && elem[0:l] == "quired_status_checks/contexts" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: ReposSetStatusCheckContexts
												r.name = "ReposSetStatusCheckContexts"
												r.args = args
												r.count = 3
												return r, true
											}
										case 's': // Prefix: "strictions/"
											if l := len("strictions/"); len(elem) >= l && elem[0:l] == "strictions/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												r.name = "ReposSetTeamAccessRestrictions"
												r.args = args
												r.count = 3
												return r, true
											}
											switch elem[0] {
											case 'a': // Prefix: "apps"
												if l := len("apps"); len(elem) >= l && elem[0:l] == "apps" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetAppAccessRestrictions
													r.name = "ReposSetAppAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											case 't': // Prefix: "teams"
												if l := len("teams"); len(elem) >= l && elem[0:l] == "teams" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetTeamAccessRestrictions
													r.name = "ReposSetTeamAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											case 'u': // Prefix: "users"
												if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf: ReposSetUserAccessRestrictions
													r.name = "ReposSetUserAccessRestrictions"
													r.args = args
													r.count = 3
													return r, true
												}
											}
										}
									}
								}
							case 'c': // Prefix: "co"
								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "ReposCreateOrUpdateFileContents"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'l': // Prefix: "llaborators/"
									if l := len("llaborators/"); len(elem) >= l && elem[0:l] == "llaborators/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposAddCollaborator
										r.name = "ReposAddCollaborator"
										r.args = args
										r.count = 3
										return r, true
									}
								case 'n': // Prefix: "ntents/"
									if l := len("ntents/"); len(elem) >= l && elem[0:l] == "ntents/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "path"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf: ReposCreateOrUpdateFileContents
										r.name = "ReposCreateOrUpdateFileContents"
										r.args = args
										r.count = 3
										return r, true
									}
								}
							case 'i': // Prefix: "i"
								if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									r.name = "IssuesLock"
									r.args = args
									r.count = 2
									return r, true
								}
								switch elem[0] {
								case 'm': // Prefix: "mport"
									if l := len("mport"); len(elem) >= l && elem[0:l] == "mport" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: MigrationsStartImport
										r.name = "MigrationsStartImport"
										r.args = args
										r.count = 2
										return r, true
									}
								case 'n': // Prefix: "nteraction-limits"
									if l := len("nteraction-limits"); len(elem) >= l && elem[0:l] == "nteraction-limits" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf: InteractionsSetRestrictionsForRepo
										r.name = "InteractionsSetRestrictionsForRepo"
										r.args = args
										r.count = 2
										return r, true
									}
								case 's': // Prefix: "ssues/"
									if l := len("ssues/"); len(elem) >= l && elem[0:l] == "ssues/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "issue_number"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/lock"
										if l := len("/lock"); len(elem) >= l && elem[0:l] == "/lock" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: IssuesLock
											r.name = "IssuesLock"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 'l': // Prefix: "lfs"
								if l := len("lfs"); len(elem) >= l && elem[0:l] == "lfs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposEnableLfsForRepo
									r.name = "ReposEnableLfsForRepo"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'n': // Prefix: "notifications"
								if l := len("notifications"); len(elem) >= l && elem[0:l] == "notifications" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivityMarkRepoNotificationsAsRead
									r.name = "ActivityMarkRepoNotificationsAsRead"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'p': // Prefix: "pulls/"
								if l := len("pulls/"); len(elem) >= l && elem[0:l] == "pulls/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "pull_number"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										r.name = "PullsMerge"
										r.args = args
										r.count = 3
										return r, true
									}
									switch elem[0] {
									case 'm': // Prefix: "merge"
										if l := len("merge"); len(elem) >= l && elem[0:l] == "merge" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PullsMerge
											r.name = "PullsMerge"
											r.args = args
											r.count = 3
											return r, true
										}
									case 'r': // Prefix: "reviews/"
										if l := len("reviews/"); len(elem) >= l && elem[0:l] == "reviews/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "review_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[3] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											r.name = "PullsUpdateReview"
											r.args = args
											r.count = 4
											return r, true
										}
										switch elem[0] {
										case '/': // Prefix: "/dismissals"
											if l := len("/dismissals"); len(elem) >= l && elem[0:l] == "/dismissals" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf: PullsDismissReview
												r.name = "PullsDismissReview"
												r.args = args
												r.count = 4
												return r, true
											}
										}
									case 'u': // Prefix: "update-branch"
										if l := len("update-branch"); len(elem) >= l && elem[0:l] == "update-branch" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf: PullsUpdateBranch
											r.name = "PullsUpdateBranch"
											r.args = args
											r.count = 3
											return r, true
										}
									}
								}
							case 's': // Prefix: "subscription"
								if l := len("subscription"); len(elem) >= l && elem[0:l] == "subscription" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ActivitySetRepoSubscription
									r.name = "ActivitySetRepoSubscription"
									r.args = args
									r.count = 2
									return r, true
								}
							case 't': // Prefix: "topics"
								if l := len("topics"); len(elem) >= l && elem[0:l] == "topics" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposReplaceAllTopics
									r.name = "ReposReplaceAllTopics"
									r.args = args
									r.count = 2
									return r, true
								}
							case 'v': // Prefix: "vulnerability-alerts"
								if l := len("vulnerability-alerts"); len(elem) >= l && elem[0:l] == "vulnerability-alerts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf: ReposEnableVulnerabilityAlerts
									r.name = "ReposEnableVulnerabilityAlerts"
									r.args = args
									r.count = 2
									return r, true
								}
							}
						}
					}
				case 'i': // Prefix: "itories/"
					if l := len("itories/"); len(elem) >= l && elem[0:l] == "itories/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "repository_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/environments/"
						if l := len("/environments/"); len(elem) >= l && elem[0:l] == "/environments/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "environment_name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/secrets/"
							if l := len("/secrets/"); len(elem) >= l && elem[0:l] == "/secrets/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "secret_name"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: ActionsCreateOrUpdateEnvironmentSecret
								r.name = "ActionsCreateOrUpdateEnvironmentSecret"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					}
				}
			case 's': // Prefix: "scim/v2/enterprises/"
				if l := len("scim/v2/enterprises/"); len(elem) >= l && elem[0:l] == "scim/v2/enterprises/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "enterprise"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "EnterpriseAdminSetInformationForProvisionedEnterpriseUser"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'G': // Prefix: "Groups/"
						if l := len("Groups/"); len(elem) >= l && elem[0:l] == "Groups/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_group_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseGroup
							r.name = "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'U': // Prefix: "Users/"
						if l := len("Users/"); len(elem) >= l && elem[0:l] == "Users/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "scim_user_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: EnterpriseAdminSetInformationForProvisionedEnterpriseUser
							r.name = "EnterpriseAdminSetInformationForProvisionedEnterpriseUser"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			case 't': // Prefix: "teams/"
				if l := len("teams/"); len(elem) >= l && elem[0:l] == "teams/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "team_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "TeamsAddOrUpdateProjectPermissionsLegacy"
						r.args = args
						r.count = 1
						return r, true
					}
					switch elem[0] {
					case 'm': // Prefix: "members"
						if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							r.name = "TeamsAddOrUpdateMembershipForUserLegacy"
							r.args = args
							r.count = 1
							return r, true
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddMemberLegacy
								r.name = "TeamsAddMemberLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						case 'h': // Prefix: "hips/"
							if l := len("hips/"); len(elem) >= l && elem[0:l] == "hips/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "username"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddOrUpdateMembershipForUserLegacy
								r.name = "TeamsAddOrUpdateMembershipForUserLegacy"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 'p': // Prefix: "projects/"
						if l := len("projects/"); len(elem) >= l && elem[0:l] == "projects/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "project_id"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: TeamsAddOrUpdateProjectPermissionsLegacy
							r.name = "TeamsAddOrUpdateProjectPermissionsLegacy"
							r.args = args
							r.count = 2
							return r, true
						}
					case 'r': // Prefix: "repos/"
						if l := len("repos/"); len(elem) >= l && elem[0:l] == "repos/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "owner"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repo"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: TeamsAddOrUpdateRepoPermissionsLegacy
								r.name = "TeamsAddOrUpdateRepoPermissionsLegacy"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					}
				}
			case 'u': // Prefix: "user/"
				if l := len("user/"); len(elem) >= l && elem[0:l] == "user/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					r.name = "AppsAddRepoToInstallation"
					r.args = args
					r.count = 0
					return r, true
				}
				switch elem[0] {
				case 'b': // Prefix: "blocks/"
					if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersBlock
						r.name = "UsersBlock"
						r.args = args
						r.count = 1
						return r, true
					}
				case 'f': // Prefix: "following/"
					if l := len("following/"); len(elem) >= l && elem[0:l] == "following/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "username"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: UsersFollow
						r.name = "UsersFollow"
						r.args = args
						r.count = 1
						return r, true
					}
				case 'i': // Prefix: "in"
					if l := len("in"); len(elem) >= l && elem[0:l] == "in" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						r.name = "InteractionsSetRestrictionsForAuthenticatedUser"
						r.args = args
						r.count = 0
						return r, true
					}
					switch elem[0] {
					case 's': // Prefix: "stallations/"
						if l := len("stallations/"); len(elem) >= l && elem[0:l] == "stallations/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "installation_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/repositories/"
							if l := len("/repositories/"); len(elem) >= l && elem[0:l] == "/repositories/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "repository_id"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: AppsAddRepoToInstallation
								r.name = "AppsAddRepoToInstallation"
								r.args = args
								r.count = 2
								return r, true
							}
						}
					case 't': // Prefix: "teraction-limits"
						if l := len("teraction-limits"); len(elem) >= l && elem[0:l] == "teraction-limits" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: InteractionsSetRestrictionsForAuthenticatedUser
							r.name = "InteractionsSetRestrictionsForAuthenticatedUser"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				case 's': // Prefix: "starred/"
					if l := len("starred/"); len(elem) >= l && elem[0:l] == "starred/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "owner"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "repo"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: ActivityStarRepoForAuthenticatedUser
							r.name = "ActivityStarRepoForAuthenticatedUser"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			}
		}
	}
	return r, false
}
