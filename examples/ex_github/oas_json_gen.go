// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIOverview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIOverview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("verifiable_password_authentication")
		e.Bool(s.VerifiablePasswordAuthentication)
	}
	{
		if s.SSHKeyFingerprints.Set {
			e.FieldStart("ssh_key_fingerprints")
			s.SSHKeyFingerprints.Encode(e)
		}
	}
	{
		if s.Hooks != nil {
			e.FieldStart("hooks")
			e.ArrStart()
			for _, elem := range s.Hooks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Web != nil {
			e.FieldStart("web")
			e.ArrStart()
			for _, elem := range s.Web {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.API != nil {
			e.FieldStart("api")
			e.ArrStart()
			for _, elem := range s.API {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Git != nil {
			e.FieldStart("git")
			e.ArrStart()
			for _, elem := range s.Git {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Packages != nil {
			e.FieldStart("packages")
			e.ArrStart()
			for _, elem := range s.Packages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pages != nil {
			e.FieldStart("pages")
			e.ArrStart()
			for _, elem := range s.Pages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Importer != nil {
			e.FieldStart("importer")
			e.ArrStart()
			for _, elem := range s.Importer {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Actions != nil {
			e.FieldStart("actions")
			e.ArrStart()
			for _, elem := range s.Actions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Dependabot != nil {
			e.FieldStart("dependabot")
			e.ArrStart()
			for _, elem := range s.Dependabot {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIOverview = [11]string{
	0:  "verifiable_password_authentication",
	1:  "ssh_key_fingerprints",
	2:  "hooks",
	3:  "web",
	4:  "api",
	5:  "git",
	6:  "packages",
	7:  "pages",
	8:  "importer",
	9:  "actions",
	10: "dependabot",
}

// Decode decodes APIOverview from json.
func (s *APIOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIOverview to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verifiable_password_authentication":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.VerifiablePasswordAuthentication = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verifiable_password_authentication\"")
			}
		case "ssh_key_fingerprints":
			if err := func() error {
				s.SSHKeyFingerprints.Reset()
				if err := s.SSHKeyFingerprints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_key_fingerprints\"")
			}
		case "hooks":
			if err := func() error {
				s.Hooks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hooks = append(s.Hooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks\"")
			}
		case "web":
			if err := func() error {
				s.Web = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Web = append(s.Web, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web\"")
			}
		case "api":
			if err := func() error {
				s.API = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.API = append(s.API, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api\"")
			}
		case "git":
			if err := func() error {
				s.Git = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Git = append(s.Git, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "packages":
			if err := func() error {
				s.Packages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Packages = append(s.Packages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		case "pages":
			if err := func() error {
				s.Pages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		case "importer":
			if err := func() error {
				s.Importer = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Importer = append(s.Importer, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importer\"")
			}
		case "actions":
			if err := func() error {
				s.Actions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "dependabot":
			if err := func() error {
				s.Dependabot = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Dependabot = append(s.Dependabot, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependabot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIOverview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIOverview) {
					name = jsonFieldsNameOfAPIOverview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIOverview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIOverview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIOverviewSSHKeyFingerprints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIOverviewSSHKeyFingerprints) encodeFields(e *jx.Encoder) {
	{
		if s.SHA256RSA.Set {
			e.FieldStart("SHA256_RSA")
			s.SHA256RSA.Encode(e)
		}
	}
	{
		if s.SHA256DSA.Set {
			e.FieldStart("SHA256_DSA")
			s.SHA256DSA.Encode(e)
		}
	}
	{
		if s.SHA256ECDSA.Set {
			e.FieldStart("SHA256_ECDSA")
			s.SHA256ECDSA.Encode(e)
		}
	}
	{
		if s.SHA256ED25519.Set {
			e.FieldStart("SHA256_ED25519")
			s.SHA256ED25519.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIOverviewSSHKeyFingerprints = [4]string{
	0: "SHA256_RSA",
	1: "SHA256_DSA",
	2: "SHA256_ECDSA",
	3: "SHA256_ED25519",
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (s *APIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIOverviewSSHKeyFingerprints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SHA256_RSA":
			if err := func() error {
				s.SHA256RSA.Reset()
				if err := s.SHA256RSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_RSA\"")
			}
		case "SHA256_DSA":
			if err := func() error {
				s.SHA256DSA.Reset()
				if err := s.SHA256DSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_DSA\"")
			}
		case "SHA256_ECDSA":
			if err := func() error {
				s.SHA256ECDSA.Reset()
				if err := s.SHA256ECDSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_ECDSA\"")
			}
		case "SHA256_ED25519":
			if err := func() error {
				s.SHA256ED25519.Reset()
				if err := s.SHA256ED25519.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_ED25519\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIOverviewSSHKeyFingerprints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIOverviewSSHKeyFingerprints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIOverviewSSHKeyFingerprints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Accepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Accepted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAccepted = [0]string{}

// Decode decodes Accepted from json.
func (s *Accepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Accepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode Accepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Accepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Accepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsApproveWorkflowRunForbidden as json.
func (s *ActionsApproveWorkflowRunForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunForbidden from json.
func (s *ActionsApproveWorkflowRunForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsApproveWorkflowRunForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsApproveWorkflowRunForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsApproveWorkflowRunForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsApproveWorkflowRunNotFound as json.
func (s *ActionsApproveWorkflowRunNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunNotFound from json.
func (s *ActionsApproveWorkflowRunNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsApproveWorkflowRunNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsApproveWorkflowRunNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsApproveWorkflowRunNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsBillingUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_minutes_used")
		e.Int(s.TotalMinutesUsed)
	}
	{
		e.FieldStart("total_paid_minutes_used")
		e.Int(s.TotalPaidMinutesUsed)
	}
	{
		e.FieldStart("included_minutes")
		e.Int(s.IncludedMinutes)
	}
	{
		e.FieldStart("minutes_used_breakdown")
		s.MinutesUsedBreakdown.Encode(e)
	}
}

var jsonFieldsNameOfActionsBillingUsage = [4]string{
	0: "total_minutes_used",
	1: "total_paid_minutes_used",
	2: "included_minutes",
	3: "minutes_used_breakdown",
}

// Decode decodes ActionsBillingUsage from json.
func (s *ActionsBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_minutes_used":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMinutesUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_minutes_used\"")
			}
		case "total_paid_minutes_used":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPaidMinutesUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_paid_minutes_used\"")
			}
		case "included_minutes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.IncludedMinutes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"included_minutes\"")
			}
		case "minutes_used_breakdown":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.MinutesUsedBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minutes_used_breakdown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsBillingUsage) {
					name = jsonFieldsNameOfActionsBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsBillingUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsBillingUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsBillingUsageMinutesUsedBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsBillingUsageMinutesUsedBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.UBUNTU.Set {
			e.FieldStart("UBUNTU")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			e.FieldStart("MACOS")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			e.FieldStart("WINDOWS")
			s.WINDOWS.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsBillingUsageMinutesUsedBreakdown = [3]string{
	0: "UBUNTU",
	1: "MACOS",
	2: "WINDOWS",
}

// Decode decodes ActionsBillingUsageMinutesUsedBreakdown from json.
func (s *ActionsBillingUsageMinutesUsedBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsBillingUsageMinutesUsedBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			if err := func() error {
				s.UBUNTU.Reset()
				if err := s.UBUNTU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UBUNTU\"")
			}
		case "MACOS":
			if err := func() error {
				s.MACOS.Reset()
				if err := s.MACOS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MACOS\"")
			}
		case "WINDOWS":
			if err := func() error {
				s.WINDOWS.Reset()
				if err := s.WINDOWS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WINDOWS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsBillingUsageMinutesUsedBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsBillingUsageMinutesUsedBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsBillingUsageMinutesUsedBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCancelWorkflowRunAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCancelWorkflowRunAccepted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActionsCancelWorkflowRunAccepted = [0]string{}

// Decode decodes ActionsCancelWorkflowRunAccepted from json.
func (s *ActionsCancelWorkflowRunAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCancelWorkflowRunAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCancelWorkflowRunAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCancelWorkflowRunAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCancelWorkflowRunAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encrypted_value")
		e.Str(s.EncryptedValue)
	}
	{
		e.FieldStart("key_id")
		e.Str(s.KeyID)
	}
}

var jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq = [2]string{
	0: "encrypted_value",
	1: "key_id",
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretReq from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EncryptedValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateEnvironmentSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq) {
					name = jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCreateOrUpdateOrgSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCreateOrUpdateOrgSecretReq) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptedValue.Set {
			e.FieldStart("encrypted_value")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			e.FieldStart("key_id")
			s.KeyID.Encode(e)
		}
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.FieldStart("selected_repository_ids")
			e.ArrStart()
			for _, elem := range s.SelectedRepositoryIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq = [4]string{
	0: "encrypted_value",
	1: "key_id",
	2: "visibility",
	3: "selected_repository_ids",
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReq from json.
func (s *ActionsCreateOrUpdateOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateOrgSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			if err := func() error {
				s.EncryptedValue.Reset()
				if err := s.EncryptedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repository_ids":
			if err := func() error {
				s.SelectedRepositoryIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateOrgSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq) {
					name = jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCreateOrUpdateOrgSecretReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateOrUpdateOrgSecretReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsCreateOrUpdateOrgSecretReqVisibility as json.
func (s ActionsCreateOrUpdateOrgSecretReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReqVisibility from json.
func (s *ActionsCreateOrUpdateOrgSecretReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateOrgSecretReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateOrUpdateOrgSecretReqVisibility(v) {
	case ActionsCreateOrUpdateOrgSecretReqVisibilityAll:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityAll
	case ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate
	case ActionsCreateOrUpdateOrgSecretReqVisibilitySelected:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilitySelected
	default:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateOrUpdateOrgSecretReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCreateOrUpdateRepoSecretCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCreateOrUpdateRepoSecretCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActionsCreateOrUpdateRepoSecretCreated = [0]string{}

// Decode decodes ActionsCreateOrUpdateRepoSecretCreated from json.
func (s *ActionsCreateOrUpdateRepoSecretCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateRepoSecretCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateRepoSecretCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCreateOrUpdateRepoSecretCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateOrUpdateRepoSecretCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCreateOrUpdateRepoSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCreateOrUpdateRepoSecretReq) encodeFields(e *jx.Encoder) {
	{
		if s.EncryptedValue.Set {
			e.FieldStart("encrypted_value")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			e.FieldStart("key_id")
			s.KeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsCreateOrUpdateRepoSecretReq = [2]string{
	0: "encrypted_value",
	1: "key_id",
}

// Decode decodes ActionsCreateOrUpdateRepoSecretReq from json.
func (s *ActionsCreateOrUpdateRepoSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateRepoSecretReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			if err := func() error {
				s.EncryptedValue.Reset()
				if err := s.EncryptedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateRepoSecretReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCreateOrUpdateRepoSecretReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateOrUpdateRepoSecretReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.FieldStart("selected_repository_ids")
			e.ArrStart()
			for _, elem := range s.SelectedRepositoryIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.FieldStart("runners")
			e.ArrStart()
			for _, elem := range s.Runners {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq = [4]string{
	0: "name",
	1: "visibility",
	2: "selected_repository_ids",
	3: "runners",
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repository_ids":
			if err := func() error {
				s.SelectedRepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateSelfHostedRunnerGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq) {
					name = jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsEnabled as json.
func (s ActionsEnabled) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes ActionsEnabled from json.
func (s *ActionsEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsEnabled to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsEnabled(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionsEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsEnterprisePermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsEnterprisePermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled_organizations")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.FieldStart("selected_organizations_url")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.FieldStart("selected_actions_url")
			s.SelectedActionsURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsEnterprisePermissions = [4]string{
	0: "enabled_organizations",
	1: "selected_organizations_url",
	2: "allowed_actions",
	3: "selected_actions_url",
}

// Decode decodes ActionsEnterprisePermissions from json.
func (s *ActionsEnterprisePermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsEnterprisePermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledOrganizations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_organizations\"")
			}
		case "selected_organizations_url":
			if err := func() error {
				s.SelectedOrganizationsURL.Reset()
				if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organizations_url\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsEnterprisePermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsEnterprisePermissions) {
					name = jsonFieldsNameOfActionsEnterprisePermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsEnterprisePermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsEnterprisePermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListArtifactsForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListArtifactsForRepoOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("artifacts")
		e.ArrStart()
		for _, elem := range s.Artifacts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListArtifactsForRepoOK = [2]string{
	0: "total_count",
	1: "artifacts",
}

// Decode decodes ActionsListArtifactsForRepoOK from json.
func (s *ActionsListArtifactsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListArtifactsForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "artifacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Artifacts = make([]Artifact, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Artifact
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Artifacts = append(s.Artifacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListArtifactsForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListArtifactsForRepoOK) {
					name = jsonFieldsNameOfActionsListArtifactsForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListArtifactsForRepoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListArtifactsForRepoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListEnvironmentSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListEnvironmentSecretsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("secrets")
		e.ArrStart()
		for _, elem := range s.Secrets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListEnvironmentSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListEnvironmentSecretsOK from json.
func (s *ActionsListEnvironmentSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListEnvironmentSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = make([]ActionsSecret, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListEnvironmentSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListEnvironmentSecretsOK) {
					name = jsonFieldsNameOfActionsListEnvironmentSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListEnvironmentSecretsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListEnvironmentSecretsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListJobsForWorkflowRunOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListJobsForWorkflowRunOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("jobs")
		e.ArrStart()
		for _, elem := range s.Jobs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListJobsForWorkflowRunOK = [2]string{
	0: "total_count",
	1: "jobs",
}

// Decode decodes ActionsListJobsForWorkflowRunOK from json.
func (s *ActionsListJobsForWorkflowRunOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListJobsForWorkflowRunOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Jobs = make([]Job, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Job
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Jobs = append(s.Jobs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListJobsForWorkflowRunOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListJobsForWorkflowRunOK) {
					name = jsonFieldsNameOfActionsListJobsForWorkflowRunOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListJobsForWorkflowRunOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListJobsForWorkflowRunOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListOrgSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListOrgSecretsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("secrets")
		e.ArrStart()
		for _, elem := range s.Secrets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListOrgSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListOrgSecretsOK from json.
func (s *ActionsListOrgSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListOrgSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = make([]OrganizationActionsSecret, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListOrgSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListOrgSecretsOK) {
					name = jsonFieldsNameOfActionsListOrgSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListOrgSecretsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListOrgSecretsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK from json.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = make([]MinimalRepository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MinimalRepository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) {
					name = jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListRepoSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListRepoSecretsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("secrets")
		e.ArrStart()
		for _, elem := range s.Secrets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListRepoSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListRepoSecretsOK from json.
func (s *ActionsListRepoSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = make([]ActionsSecret, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoSecretsOK) {
					name = jsonFieldsNameOfActionsListRepoSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListRepoSecretsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListRepoSecretsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListRepoWorkflowsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListRepoWorkflowsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("workflows")
		e.ArrStart()
		for _, elem := range s.Workflows {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListRepoWorkflowsOK = [2]string{
	0: "total_count",
	1: "workflows",
}

// Decode decodes ActionsListRepoWorkflowsOK from json.
func (s *ActionsListRepoWorkflowsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoWorkflowsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "workflows":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Workflows = make([]Workflow, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Workflow
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Workflows = append(s.Workflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoWorkflowsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoWorkflowsOK) {
					name = jsonFieldsNameOfActionsListRepoWorkflowsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListRepoWorkflowsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListRepoWorkflowsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelectedReposForOrgSecretOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelectedReposForOrgSecretOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListSelectedReposForOrgSecretOK from json.
func (s *ActionsListSelectedReposForOrgSecretOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelectedReposForOrgSecretOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = make([]MinimalRepository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MinimalRepository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelectedReposForOrgSecretOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK) {
					name = jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelectedReposForOrgSecretOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelectedReposForOrgSecretOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK from json.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) {
					name = jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("runner_groups")
		e.ArrStart()
		for _, elem := range s.RunnerGroups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK = [2]string{
	0: "total_count",
	1: "runner_groups",
}

// Decode decodes ActionsListSelfHostedRunnerGroupsForOrgOK from json.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnerGroupsForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runner_groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RunnerGroups = make([]RunnerGroupsOrg, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerGroupsOrg
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RunnerGroups = append(s.RunnerGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runner_groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnerGroupsForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelfHostedRunnersForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelfHostedRunnersForOrgOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersForOrgOK from json.
func (s *ActionsListSelfHostedRunnersForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = make([]Runner, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelfHostedRunnersForOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelfHostedRunnersForOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelfHostedRunnersForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelfHostedRunnersForRepoOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersForRepoOK from json.
func (s *ActionsListSelfHostedRunnersForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = make([]Runner, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelfHostedRunnersForRepoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelfHostedRunnersForRepoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersInGroupForOrgOK from json.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersInGroupForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = make([]Runner, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersInGroupForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListWorkflowRunArtifactsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListWorkflowRunArtifactsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("artifacts")
		e.ArrStart()
		for _, elem := range s.Artifacts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListWorkflowRunArtifactsOK = [2]string{
	0: "total_count",
	1: "artifacts",
}

// Decode decodes ActionsListWorkflowRunArtifactsOK from json.
func (s *ActionsListWorkflowRunArtifactsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListWorkflowRunArtifactsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "artifacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Artifacts = make([]Artifact, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Artifact
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Artifacts = append(s.Artifacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListWorkflowRunArtifactsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListWorkflowRunArtifactsOK) {
					name = jsonFieldsNameOfActionsListWorkflowRunArtifactsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListWorkflowRunArtifactsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListWorkflowRunArtifactsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsListWorkflowRunsForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsListWorkflowRunsForRepoOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("workflow_runs")
		e.ArrStart()
		for _, elem := range s.WorkflowRuns {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsListWorkflowRunsForRepoOK = [2]string{
	0: "total_count",
	1: "workflow_runs",
}

// Decode decodes ActionsListWorkflowRunsForRepoOK from json.
func (s *ActionsListWorkflowRunsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListWorkflowRunsForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "workflow_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.WorkflowRuns = make([]WorkflowRun, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WorkflowRuns = append(s.WorkflowRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListWorkflowRunsForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListWorkflowRunsForRepoOK) {
					name = jsonFieldsNameOfActionsListWorkflowRunsForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsListWorkflowRunsForRepoOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsListWorkflowRunsForRepoOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsOrganizationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsOrganizationPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled_repositories")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.FieldStart("selected_repositories_url")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.FieldStart("selected_actions_url")
			s.SelectedActionsURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsOrganizationPermissions = [4]string{
	0: "enabled_repositories",
	1: "selected_repositories_url",
	2: "allowed_actions",
	3: "selected_actions_url",
}

// Decode decodes ActionsOrganizationPermissions from json.
func (s *ActionsOrganizationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsOrganizationPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_repositories\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsOrganizationPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsOrganizationPermissions) {
					name = jsonFieldsNameOfActionsOrganizationPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsOrganizationPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsOrganizationPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsPublicKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsPublicKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key_id")
		e.Str(s.KeyID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsPublicKey = [6]string{
	0: "key_id",
	1: "key",
	2: "id",
	3: "url",
	4: "title",
	5: "created_at",
}

// Decode decodes ActionsPublicKey from json.
func (s *ActionsPublicKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsPublicKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsPublicKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsPublicKey) {
					name = jsonFieldsNameOfActionsPublicKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsPublicKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsPublicKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsReRunWorkflowCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsReRunWorkflowCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActionsReRunWorkflowCreated = [0]string{}

// Decode decodes ActionsReRunWorkflowCreated from json.
func (s *ActionsReRunWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReRunWorkflowCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActionsReRunWorkflowCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsReRunWorkflowCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsReRunWorkflowCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.FieldStart("selected_actions_url")
			s.SelectedActionsURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsRepositoryPermissions = [3]string{
	0: "enabled",
	1: "allowed_actions",
	2: "selected_actions_url",
}

// Decode decodes ActionsRepositoryPermissions from json.
func (s *ActionsRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsRepositoryPermissions) {
					name = jsonFieldsNameOfActionsRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsRetryWorkflowCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsRetryWorkflowCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActionsRetryWorkflowCreated = [0]string{}

// Decode decodes ActionsRetryWorkflowCreated from json.
func (s *ActionsRetryWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsRetryWorkflowCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActionsRetryWorkflowCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsRetryWorkflowCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsRetryWorkflowCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsReviewPendingDeploymentsForRunReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsReviewPendingDeploymentsForRunReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("environment_ids")
		e.ArrStart()
		for _, elem := range s.EnvironmentIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("comment")
		e.Str(s.Comment)
	}
}

var jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq = [3]string{
	0: "environment_ids",
	1: "state",
	2: "comment",
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReq from json.
func (s *ActionsReviewPendingDeploymentsForRunReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReviewPendingDeploymentsForRunReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environment_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.EnvironmentIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.EnvironmentIds = append(s.EnvironmentIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_ids\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsReviewPendingDeploymentsForRunReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq) {
					name = jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsReviewPendingDeploymentsForRunReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsReviewPendingDeploymentsForRunReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsReviewPendingDeploymentsForRunReqState as json.
func (s ActionsReviewPendingDeploymentsForRunReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReqState from json.
func (s *ActionsReviewPendingDeploymentsForRunReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReviewPendingDeploymentsForRunReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsReviewPendingDeploymentsForRunReqState(v) {
	case ActionsReviewPendingDeploymentsForRunReqStateApproved:
		*s = ActionsReviewPendingDeploymentsForRunReqStateApproved
	case ActionsReviewPendingDeploymentsForRunReqStateRejected:
		*s = ActionsReviewPendingDeploymentsForRunReqStateRejected
	default:
		*s = ActionsReviewPendingDeploymentsForRunReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionsReviewPendingDeploymentsForRunReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsReviewPendingDeploymentsForRunReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSecret) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSecret) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfActionsSecret = [3]string{
	0: "name",
	1: "created_at",
	2: "updated_at",
}

// Decode decodes ActionsSecret from json.
func (s *ActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSecret to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSecret")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSecret) {
					name = jsonFieldsNameOfActionsSecret[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSecret) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSecret) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled_repositories")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq = [2]string{
	0: "enabled_repositories",
	1: "allowed_actions",
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationReq from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_repositories\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetGithubActionsPermissionsOrganizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq) {
					name = jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq = [2]string{
	0: "enabled",
	1: "allowed_actions",
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryReq from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetGithubActionsPermissionsRepositoryReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq) {
					name = jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("selected_repository_ids")
		e.ArrStart()
		for _, elem := range s.SelectedRepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) {
					name = jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetSelectedReposForOrgSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetSelectedReposForOrgSecretReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("selected_repository_ids")
		e.ArrStart()
		for _, elem := range s.SelectedRepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetSelectedReposForOrgSecretReq from json.
func (s *ActionsSetSelectedReposForOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelectedReposForOrgSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelectedReposForOrgSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq) {
					name = jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetSelectedReposForOrgSecretReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetSelectedReposForOrgSecretReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("selected_repository_ids")
		e.ArrStart()
		for _, elem := range s.SelectedRepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) {
					name = jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq = [1]string{
	0: "runners",
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgReq from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Runners = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelfHostedRunnersInGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq) {
					name = jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq = [2]string{
	0: "name",
	1: "visibility",
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsUpdateSelfHostedRunnerGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq) {
					name = jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserForbidden as json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserForbidden from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserNotFound as json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserNotFound from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized as json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityDeleteThreadSubscriptionForbidden as json.
func (s *ActivityDeleteThreadSubscriptionForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionForbidden from json.
func (s *ActivityDeleteThreadSubscriptionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityDeleteThreadSubscriptionForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityDeleteThreadSubscriptionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityDeleteThreadSubscriptionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityDeleteThreadSubscriptionUnauthorized as json.
func (s *ActivityDeleteThreadSubscriptionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionUnauthorized from json.
func (s *ActivityDeleteThreadSubscriptionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityDeleteThreadSubscriptionUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityDeleteThreadSubscriptionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityDeleteThreadSubscriptionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityGetThreadForbidden as json.
func (s *ActivityGetThreadForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadForbidden from json.
func (s *ActivityGetThreadForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityGetThreadForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityGetThreadForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserForbidden as json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserForbidden from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized as json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityGetThreadUnauthorized as json.
func (s *ActivityGetThreadUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadUnauthorized from json.
func (s *ActivityGetThreadUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityGetThreadUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityGetThreadUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserForbidden as json.
func (s *ActivityListNotificationsForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserForbidden from json.
func (s *ActivityListNotificationsForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListNotificationsForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListNotificationsForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListNotificationsForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserUnauthorized as json.
func (s *ActivityListNotificationsForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserUnauthorized from json.
func (s *ActivityListNotificationsForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListNotificationsForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListNotificationsForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListNotificationsForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListPublicEventsForRepoNetworkForbidden as json.
func (s *ActivityListPublicEventsForRepoNetworkForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkForbidden from json.
func (s *ActivityListPublicEventsForRepoNetworkForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListPublicEventsForRepoNetworkForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListPublicEventsForRepoNetworkForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListPublicEventsForRepoNetworkMovedPermanently as json.
func (s *ActivityListPublicEventsForRepoNetworkMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkMovedPermanently from json.
func (s *ActivityListPublicEventsForRepoNetworkMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListPublicEventsForRepoNetworkMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListPublicEventsForRepoNetworkMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListPublicEventsForRepoNetworkNotFound as json.
func (s *ActivityListPublicEventsForRepoNetworkNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkNotFound from json.
func (s *ActivityListPublicEventsForRepoNetworkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListPublicEventsForRepoNetworkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListPublicEventsForRepoNetworkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON as json.
func (s ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Event(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON from json.
func (s *ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkOKApplicationJSON to nil")
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = make([]Event, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivityListPublicEventsForRepoNetworkOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListPublicEventsForRepoNetworkOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListPublicEventsOKApplicationJSON as json.
func (s ActivityListPublicEventsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Event(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsOKApplicationJSON from json.
func (s *ActivityListPublicEventsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsOKApplicationJSON to nil")
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = make([]Event, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivityListPublicEventsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListPublicEventsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserForbidden as json.
func (s *ActivityListReposStarredByAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserForbidden from json.
func (s *ActivityListReposStarredByAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListReposStarredByAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListReposStarredByAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListReposStarredByAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserUnauthorized as json.
func (s *ActivityListReposStarredByAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserUnauthorized from json.
func (s *ActivityListReposStarredByAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListReposStarredByAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListReposStarredByAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListReposStarredByAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserForbidden as json.
func (s *ActivityListWatchedReposForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserForbidden from json.
func (s *ActivityListWatchedReposForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListWatchedReposForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListWatchedReposForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserUnauthorized as json.
func (s *ActivityListWatchedReposForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserUnauthorized from json.
func (s *ActivityListWatchedReposForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityListWatchedReposForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityListWatchedReposForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityMarkNotificationsAsReadAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityMarkNotificationsAsReadAccepted) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivityMarkNotificationsAsReadAccepted = [1]string{
	0: "message",
}

// Decode decodes ActivityMarkNotificationsAsReadAccepted from json.
func (s *ActivityMarkNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkNotificationsAsReadAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkNotificationsAsReadAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkNotificationsAsReadAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityMarkNotificationsAsReadForbidden as json.
func (s *ActivityMarkNotificationsAsReadForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadForbidden from json.
func (s *ActivityMarkNotificationsAsReadForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkNotificationsAsReadForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkNotificationsAsReadForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityMarkNotificationsAsReadReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityMarkNotificationsAsReadReq) encodeFields(e *jx.Encoder) {
	{
		if s.LastReadAt.Set {
			e.FieldStart("last_read_at")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Read.Set {
			e.FieldStart("read")
			s.Read.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivityMarkNotificationsAsReadReq = [2]string{
	0: "last_read_at",
	1: "read",
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (s *ActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			if err := func() error {
				s.LastReadAt.Reset()
				if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		case "read":
			if err := func() error {
				s.Read.Reset()
				if err := s.Read.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkNotificationsAsReadReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkNotificationsAsReadReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkNotificationsAsReadReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityMarkNotificationsAsReadUnauthorized as json.
func (s *ActivityMarkNotificationsAsReadUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadUnauthorized from json.
func (s *ActivityMarkNotificationsAsReadUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkNotificationsAsReadUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkNotificationsAsReadUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivityMarkRepoNotificationsAsReadAccepted = [2]string{
	0: "message",
	1: "url",
}

// Decode decodes ActivityMarkRepoNotificationsAsReadAccepted from json.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkRepoNotificationsAsReadAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkRepoNotificationsAsReadAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityMarkRepoNotificationsAsReadReq) encodeFields(e *jx.Encoder) {
	{
		if s.LastReadAt.Set {
			e.FieldStart("last_read_at")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfActivityMarkRepoNotificationsAsReadReq = [1]string{
	0: "last_read_at",
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (s *ActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkRepoNotificationsAsReadReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			if err := func() error {
				s.LastReadAt.Reset()
				if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkRepoNotificationsAsReadReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityMarkRepoNotificationsAsReadReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityMarkRepoNotificationsAsReadReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivitySetRepoSubscriptionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivitySetRepoSubscriptionReq) encodeFields(e *jx.Encoder) {
	{
		if s.Subscribed.Set {
			e.FieldStart("subscribed")
			s.Subscribed.Encode(e)
		}
	}
	{
		if s.Ignored.Set {
			e.FieldStart("ignored")
			s.Ignored.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivitySetRepoSubscriptionReq = [2]string{
	0: "subscribed",
	1: "ignored",
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (s *ActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetRepoSubscriptionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			if err := func() error {
				s.Subscribed.Reset()
				if err := s.Subscribed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			if err := func() error {
				s.Ignored.Reset()
				if err := s.Ignored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivitySetRepoSubscriptionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivitySetRepoSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivitySetRepoSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivitySetThreadSubscriptionForbidden as json.
func (s *ActivitySetThreadSubscriptionForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionForbidden from json.
func (s *ActivitySetThreadSubscriptionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivitySetThreadSubscriptionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivitySetThreadSubscriptionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivitySetThreadSubscriptionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivitySetThreadSubscriptionReq) encodeFields(e *jx.Encoder) {
	{
		if s.Ignored.Set {
			e.FieldStart("ignored")
			s.Ignored.Encode(e)
		}
	}
}

var jsonFieldsNameOfActivitySetThreadSubscriptionReq = [1]string{
	0: "ignored",
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (s *ActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ignored":
			if err := func() error {
				s.Ignored.Reset()
				if err := s.Ignored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivitySetThreadSubscriptionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivitySetThreadSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivitySetThreadSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivitySetThreadSubscriptionUnauthorized as json.
func (s *ActivitySetThreadSubscriptionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionUnauthorized from json.
func (s *ActivitySetThreadSubscriptionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivitySetThreadSubscriptionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivitySetThreadSubscriptionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityStarRepoForAuthenticatedUserForbidden as json.
func (s *ActivityStarRepoForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserForbidden from json.
func (s *ActivityStarRepoForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityStarRepoForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityStarRepoForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityStarRepoForAuthenticatedUserNotFound as json.
func (s *ActivityStarRepoForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserNotFound from json.
func (s *ActivityStarRepoForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityStarRepoForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityStarRepoForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityStarRepoForAuthenticatedUserUnauthorized as json.
func (s *ActivityStarRepoForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserUnauthorized from json.
func (s *ActivityStarRepoForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityStarRepoForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityStarRepoForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserForbidden as json.
func (s *ActivityUnstarRepoForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserForbidden from json.
func (s *ActivityUnstarRepoForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserNotFound as json.
func (s *ActivityUnstarRepoForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserNotFound from json.
func (s *ActivityUnstarRepoForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserUnauthorized as json.
func (s *ActivityUnstarRepoForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserUnauthorized from json.
func (s *ActivityUnstarRepoForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityUnstarRepoForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Actor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Actor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		if s.DisplayLogin.Set {
			e.FieldStart("display_login")
			s.DisplayLogin.Encode(e)
		}
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
}

var jsonFieldsNameOfActor = [6]string{
	0: "id",
	1: "login",
	2: "display_login",
	3: "gravatar_id",
	4: "url",
	5: "avatar_url",
}

// Decode decodes Actor from json.
func (s *Actor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Actor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "display_login":
			if err := func() error {
				s.DisplayLogin.Reset()
				if err := s.DisplayLogin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_login\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Actor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActor) {
					name = jsonFieldsNameOfActor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Actor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Actor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertCreatedAt as json.
func (s AlertCreatedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes AlertCreatedAt from json.
func (s *AlertCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertCreatedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertCreatedAt(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertCreatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertCreatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertHTMLURL as json.
func (s AlertHTMLURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertHTMLURL from json.
func (s *AlertHTMLURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertHTMLURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertHTMLURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertHTMLURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertHTMLURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertInstancesURL as json.
func (s AlertInstancesURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertInstancesURL from json.
func (s *AlertInstancesURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertInstancesURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertInstancesURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertInstancesURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertInstancesURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertNumber as json.
func (s AlertNumber) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes AlertNumber from json.
func (s *AlertNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertNumber to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertNumber(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertURL as json.
func (s AlertURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertURL from json.
func (s *AlertURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllowedActions as json.
func (s AllowedActions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllowedActions from json.
func (s *AllowedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllowedActions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllowedActions(v) {
	case AllowedActionsAll:
		*s = AllowedActionsAll
	case AllowedActionsLocalOnly:
		*s = AllowedActionsLocalOnly
	case AllowedActionsSelected:
		*s = AllowedActionsSelected
	default:
		*s = AllowedActions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AllowedActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllowedActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Actions.Set {
			e.FieldStart("actions")
			s.Actions.Encode(e)
		}
	}
	{
		if s.Administration.Set {
			e.FieldStart("administration")
			s.Administration.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
	{
		if s.ContentReferences.Set {
			e.FieldStart("content_references")
			s.ContentReferences.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			e.FieldStart("deployments")
			s.Deployments.Encode(e)
		}
	}
	{
		if s.Environments.Set {
			e.FieldStart("environments")
			s.Environments.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			e.FieldStart("issues")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Packages.Set {
			e.FieldStart("packages")
			s.Packages.Encode(e)
		}
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
	{
		if s.PullRequests.Set {
			e.FieldStart("pull_requests")
			s.PullRequests.Encode(e)
		}
	}
	{
		if s.RepositoryHooks.Set {
			e.FieldStart("repository_hooks")
			s.RepositoryHooks.Encode(e)
		}
	}
	{
		if s.RepositoryProjects.Set {
			e.FieldStart("repository_projects")
			s.RepositoryProjects.Encode(e)
		}
	}
	{
		if s.SecretScanningAlerts.Set {
			e.FieldStart("secret_scanning_alerts")
			s.SecretScanningAlerts.Encode(e)
		}
	}
	{
		if s.Secrets.Set {
			e.FieldStart("secrets")
			s.Secrets.Encode(e)
		}
	}
	{
		if s.SecurityEvents.Set {
			e.FieldStart("security_events")
			s.SecurityEvents.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			e.FieldStart("single_file")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.Statuses.Set {
			e.FieldStart("statuses")
			s.Statuses.Encode(e)
		}
	}
	{
		if s.VulnerabilityAlerts.Set {
			e.FieldStart("vulnerability_alerts")
			s.VulnerabilityAlerts.Encode(e)
		}
	}
	{
		if s.Workflows.Set {
			e.FieldStart("workflows")
			s.Workflows.Encode(e)
		}
	}
	{
		if s.Members.Set {
			e.FieldStart("members")
			s.Members.Encode(e)
		}
	}
	{
		if s.OrganizationAdministration.Set {
			e.FieldStart("organization_administration")
			s.OrganizationAdministration.Encode(e)
		}
	}
	{
		if s.OrganizationHooks.Set {
			e.FieldStart("organization_hooks")
			s.OrganizationHooks.Encode(e)
		}
	}
	{
		if s.OrganizationPlan.Set {
			e.FieldStart("organization_plan")
			s.OrganizationPlan.Encode(e)
		}
	}
	{
		if s.OrganizationProjects.Set {
			e.FieldStart("organization_projects")
			s.OrganizationProjects.Encode(e)
		}
	}
	{
		if s.OrganizationPackages.Set {
			e.FieldStart("organization_packages")
			s.OrganizationPackages.Encode(e)
		}
	}
	{
		if s.OrganizationSecrets.Set {
			e.FieldStart("organization_secrets")
			s.OrganizationSecrets.Encode(e)
		}
	}
	{
		if s.OrganizationSelfHostedRunners.Set {
			e.FieldStart("organization_self_hosted_runners")
			s.OrganizationSelfHostedRunners.Encode(e)
		}
	}
	{
		if s.OrganizationUserBlocking.Set {
			e.FieldStart("organization_user_blocking")
			s.OrganizationUserBlocking.Encode(e)
		}
	}
	{
		if s.TeamDiscussions.Set {
			e.FieldStart("team_discussions")
			s.TeamDiscussions.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppPermissions = [31]string{
	0:  "actions",
	1:  "administration",
	2:  "checks",
	3:  "content_references",
	4:  "contents",
	5:  "deployments",
	6:  "environments",
	7:  "issues",
	8:  "metadata",
	9:  "packages",
	10: "pages",
	11: "pull_requests",
	12: "repository_hooks",
	13: "repository_projects",
	14: "secret_scanning_alerts",
	15: "secrets",
	16: "security_events",
	17: "single_file",
	18: "statuses",
	19: "vulnerability_alerts",
	20: "workflows",
	21: "members",
	22: "organization_administration",
	23: "organization_hooks",
	24: "organization_plan",
	25: "organization_projects",
	26: "organization_packages",
	27: "organization_secrets",
	28: "organization_self_hosted_runners",
	29: "organization_user_blocking",
	30: "team_discussions",
}

// Decode decodes AppPermissions from json.
func (s *AppPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actions":
			if err := func() error {
				s.Actions.Reset()
				if err := s.Actions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "administration":
			if err := func() error {
				s.Administration.Reset()
				if err := s.Administration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"administration\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "content_references":
			if err := func() error {
				s.ContentReferences.Reset()
				if err := s.ContentReferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_references\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		case "environments":
			if err := func() error {
				s.Environments.Reset()
				if err := s.Environments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environments\"")
			}
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "packages":
			if err := func() error {
				s.Packages.Reset()
				if err := s.Packages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		case "pull_requests":
			if err := func() error {
				s.PullRequests.Reset()
				if err := s.PullRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "repository_hooks":
			if err := func() error {
				s.RepositoryHooks.Reset()
				if err := s.RepositoryHooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_hooks\"")
			}
		case "repository_projects":
			if err := func() error {
				s.RepositoryProjects.Reset()
				if err := s.RepositoryProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_projects\"")
			}
		case "secret_scanning_alerts":
			if err := func() error {
				s.SecretScanningAlerts.Reset()
				if err := s.SecretScanningAlerts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning_alerts\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets.Reset()
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		case "security_events":
			if err := func() error {
				s.SecurityEvents.Reset()
				if err := s.SecurityEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_events\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "statuses":
			if err := func() error {
				s.Statuses.Reset()
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "vulnerability_alerts":
			if err := func() error {
				s.VulnerabilityAlerts.Reset()
				if err := s.VulnerabilityAlerts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vulnerability_alerts\"")
			}
		case "workflows":
			if err := func() error {
				s.Workflows.Reset()
				if err := s.Workflows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		case "members":
			if err := func() error {
				s.Members.Reset()
				if err := s.Members.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "organization_administration":
			if err := func() error {
				s.OrganizationAdministration.Reset()
				if err := s.OrganizationAdministration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_administration\"")
			}
		case "organization_hooks":
			if err := func() error {
				s.OrganizationHooks.Reset()
				if err := s.OrganizationHooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_hooks\"")
			}
		case "organization_plan":
			if err := func() error {
				s.OrganizationPlan.Reset()
				if err := s.OrganizationPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_plan\"")
			}
		case "organization_projects":
			if err := func() error {
				s.OrganizationProjects.Reset()
				if err := s.OrganizationProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_projects\"")
			}
		case "organization_packages":
			if err := func() error {
				s.OrganizationPackages.Reset()
				if err := s.OrganizationPackages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_packages\"")
			}
		case "organization_secrets":
			if err := func() error {
				s.OrganizationSecrets.Reset()
				if err := s.OrganizationSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_secrets\"")
			}
		case "organization_self_hosted_runners":
			if err := func() error {
				s.OrganizationSelfHostedRunners.Reset()
				if err := s.OrganizationSelfHostedRunners.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_self_hosted_runners\"")
			}
		case "organization_user_blocking":
			if err := func() error {
				s.OrganizationUserBlocking.Reset()
				if err := s.OrganizationUserBlocking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_user_blocking\"")
			}
		case "team_discussions":
			if err := func() error {
				s.TeamDiscussions.Reset()
				if err := s.TeamDiscussions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_discussions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsActions as json.
func (s AppPermissionsActions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsActions from json.
func (s *AppPermissionsActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsActions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsActions(v) {
	case AppPermissionsActionsRead:
		*s = AppPermissionsActionsRead
	case AppPermissionsActionsWrite:
		*s = AppPermissionsActionsWrite
	default:
		*s = AppPermissionsActions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsAdministration as json.
func (s AppPermissionsAdministration) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsAdministration from json.
func (s *AppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsAdministration to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsAdministration(v) {
	case AppPermissionsAdministrationRead:
		*s = AppPermissionsAdministrationRead
	case AppPermissionsAdministrationWrite:
		*s = AppPermissionsAdministrationWrite
	default:
		*s = AppPermissionsAdministration(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsAdministration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsAdministration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsChecks as json.
func (s AppPermissionsChecks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsChecks from json.
func (s *AppPermissionsChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsChecks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsChecks(v) {
	case AppPermissionsChecksRead:
		*s = AppPermissionsChecksRead
	case AppPermissionsChecksWrite:
		*s = AppPermissionsChecksWrite
	default:
		*s = AppPermissionsChecks(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsContentReferences as json.
func (s AppPermissionsContentReferences) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContentReferences from json.
func (s *AppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsContentReferences to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContentReferences(v) {
	case AppPermissionsContentReferencesRead:
		*s = AppPermissionsContentReferencesRead
	case AppPermissionsContentReferencesWrite:
		*s = AppPermissionsContentReferencesWrite
	default:
		*s = AppPermissionsContentReferences(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsContentReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsContentReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsContents as json.
func (s AppPermissionsContents) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContents from json.
func (s *AppPermissionsContents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsContents to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContents(v) {
	case AppPermissionsContentsRead:
		*s = AppPermissionsContentsRead
	case AppPermissionsContentsWrite:
		*s = AppPermissionsContentsWrite
	default:
		*s = AppPermissionsContents(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsContents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsContents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsDeployments as json.
func (s AppPermissionsDeployments) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsDeployments from json.
func (s *AppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsDeployments to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsDeployments(v) {
	case AppPermissionsDeploymentsRead:
		*s = AppPermissionsDeploymentsRead
	case AppPermissionsDeploymentsWrite:
		*s = AppPermissionsDeploymentsWrite
	default:
		*s = AppPermissionsDeployments(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsDeployments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsDeployments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsEnvironments as json.
func (s AppPermissionsEnvironments) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsEnvironments from json.
func (s *AppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsEnvironments to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsEnvironments(v) {
	case AppPermissionsEnvironmentsRead:
		*s = AppPermissionsEnvironmentsRead
	case AppPermissionsEnvironmentsWrite:
		*s = AppPermissionsEnvironmentsWrite
	default:
		*s = AppPermissionsEnvironments(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsEnvironments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsEnvironments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsIssues as json.
func (s AppPermissionsIssues) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsIssues from json.
func (s *AppPermissionsIssues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsIssues to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsIssues(v) {
	case AppPermissionsIssuesRead:
		*s = AppPermissionsIssuesRead
	case AppPermissionsIssuesWrite:
		*s = AppPermissionsIssuesWrite
	default:
		*s = AppPermissionsIssues(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsIssues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsIssues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsMembers as json.
func (s AppPermissionsMembers) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMembers from json.
func (s *AppPermissionsMembers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsMembers to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMembers(v) {
	case AppPermissionsMembersRead:
		*s = AppPermissionsMembersRead
	case AppPermissionsMembersWrite:
		*s = AppPermissionsMembersWrite
	default:
		*s = AppPermissionsMembers(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsMembers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsMembers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsMetadata as json.
func (s AppPermissionsMetadata) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMetadata from json.
func (s *AppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsMetadata to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMetadata(v) {
	case AppPermissionsMetadataRead:
		*s = AppPermissionsMetadataRead
	case AppPermissionsMetadataWrite:
		*s = AppPermissionsMetadataWrite
	default:
		*s = AppPermissionsMetadata(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (s AppPermissionsOrganizationAdministration) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (s *AppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationAdministration to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationAdministration(v) {
	case AppPermissionsOrganizationAdministrationRead:
		*s = AppPermissionsOrganizationAdministrationRead
	case AppPermissionsOrganizationAdministrationWrite:
		*s = AppPermissionsOrganizationAdministrationWrite
	default:
		*s = AppPermissionsOrganizationAdministration(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationAdministration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationAdministration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (s AppPermissionsOrganizationHooks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (s *AppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationHooks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationHooks(v) {
	case AppPermissionsOrganizationHooksRead:
		*s = AppPermissionsOrganizationHooksRead
	case AppPermissionsOrganizationHooksWrite:
		*s = AppPermissionsOrganizationHooksWrite
	default:
		*s = AppPermissionsOrganizationHooks(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationHooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationHooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (s AppPermissionsOrganizationPackages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (s *AppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationPackages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPackages(v) {
	case AppPermissionsOrganizationPackagesRead:
		*s = AppPermissionsOrganizationPackagesRead
	case AppPermissionsOrganizationPackagesWrite:
		*s = AppPermissionsOrganizationPackagesWrite
	default:
		*s = AppPermissionsOrganizationPackages(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (s AppPermissionsOrganizationPlan) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (s *AppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationPlan to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPlan(v) {
	case AppPermissionsOrganizationPlanRead:
		*s = AppPermissionsOrganizationPlanRead
	default:
		*s = AppPermissionsOrganizationPlan(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (s AppPermissionsOrganizationProjects) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (s *AppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationProjects to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationProjects(v) {
	case AppPermissionsOrganizationProjectsRead:
		*s = AppPermissionsOrganizationProjectsRead
	case AppPermissionsOrganizationProjectsWrite:
		*s = AppPermissionsOrganizationProjectsWrite
	case AppPermissionsOrganizationProjectsAdmin:
		*s = AppPermissionsOrganizationProjectsAdmin
	default:
		*s = AppPermissionsOrganizationProjects(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationProjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationProjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (s AppPermissionsOrganizationSecrets) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (s *AppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationSecrets to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSecrets(v) {
	case AppPermissionsOrganizationSecretsRead:
		*s = AppPermissionsOrganizationSecretsRead
	case AppPermissionsOrganizationSecretsWrite:
		*s = AppPermissionsOrganizationSecretsWrite
	default:
		*s = AppPermissionsOrganizationSecrets(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (s AppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (s *AppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationSelfHostedRunners to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSelfHostedRunners(v) {
	case AppPermissionsOrganizationSelfHostedRunnersRead:
		*s = AppPermissionsOrganizationSelfHostedRunnersRead
	case AppPermissionsOrganizationSelfHostedRunnersWrite:
		*s = AppPermissionsOrganizationSelfHostedRunnersWrite
	default:
		*s = AppPermissionsOrganizationSelfHostedRunners(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationSelfHostedRunners) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationSelfHostedRunners) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (s AppPermissionsOrganizationUserBlocking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (s *AppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationUserBlocking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationUserBlocking(v) {
	case AppPermissionsOrganizationUserBlockingRead:
		*s = AppPermissionsOrganizationUserBlockingRead
	case AppPermissionsOrganizationUserBlockingWrite:
		*s = AppPermissionsOrganizationUserBlockingWrite
	default:
		*s = AppPermissionsOrganizationUserBlocking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsOrganizationUserBlocking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsOrganizationUserBlocking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPackages as json.
func (s AppPermissionsPackages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPackages from json.
func (s *AppPermissionsPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPackages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPackages(v) {
	case AppPermissionsPackagesRead:
		*s = AppPermissionsPackagesRead
	case AppPermissionsPackagesWrite:
		*s = AppPermissionsPackagesWrite
	default:
		*s = AppPermissionsPackages(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPages as json.
func (s AppPermissionsPages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPages from json.
func (s *AppPermissionsPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPages(v) {
	case AppPermissionsPagesRead:
		*s = AppPermissionsPagesRead
	case AppPermissionsPagesWrite:
		*s = AppPermissionsPagesWrite
	default:
		*s = AppPermissionsPages(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPullRequests as json.
func (s AppPermissionsPullRequests) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPullRequests from json.
func (s *AppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPullRequests to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPullRequests(v) {
	case AppPermissionsPullRequestsRead:
		*s = AppPermissionsPullRequestsRead
	case AppPermissionsPullRequestsWrite:
		*s = AppPermissionsPullRequestsWrite
	default:
		*s = AppPermissionsPullRequests(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsPullRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsPullRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (s AppPermissionsRepositoryHooks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (s *AppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsRepositoryHooks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryHooks(v) {
	case AppPermissionsRepositoryHooksRead:
		*s = AppPermissionsRepositoryHooksRead
	case AppPermissionsRepositoryHooksWrite:
		*s = AppPermissionsRepositoryHooksWrite
	default:
		*s = AppPermissionsRepositoryHooks(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsRepositoryHooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsRepositoryHooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (s AppPermissionsRepositoryProjects) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (s *AppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsRepositoryProjects to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryProjects(v) {
	case AppPermissionsRepositoryProjectsRead:
		*s = AppPermissionsRepositoryProjectsRead
	case AppPermissionsRepositoryProjectsWrite:
		*s = AppPermissionsRepositoryProjectsWrite
	case AppPermissionsRepositoryProjectsAdmin:
		*s = AppPermissionsRepositoryProjectsAdmin
	default:
		*s = AppPermissionsRepositoryProjects(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsRepositoryProjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsRepositoryProjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (s AppPermissionsSecretScanningAlerts) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (s *AppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecretScanningAlerts to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecretScanningAlerts(v) {
	case AppPermissionsSecretScanningAlertsRead:
		*s = AppPermissionsSecretScanningAlertsRead
	case AppPermissionsSecretScanningAlertsWrite:
		*s = AppPermissionsSecretScanningAlertsWrite
	default:
		*s = AppPermissionsSecretScanningAlerts(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsSecretScanningAlerts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsSecretScanningAlerts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecrets as json.
func (s AppPermissionsSecrets) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecrets from json.
func (s *AppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecrets to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecrets(v) {
	case AppPermissionsSecretsRead:
		*s = AppPermissionsSecretsRead
	case AppPermissionsSecretsWrite:
		*s = AppPermissionsSecretsWrite
	default:
		*s = AppPermissionsSecrets(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (s AppPermissionsSecurityEvents) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (s *AppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecurityEvents to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecurityEvents(v) {
	case AppPermissionsSecurityEventsRead:
		*s = AppPermissionsSecurityEventsRead
	case AppPermissionsSecurityEventsWrite:
		*s = AppPermissionsSecurityEventsWrite
	default:
		*s = AppPermissionsSecurityEvents(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsSecurityEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsSecurityEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSingleFile as json.
func (s AppPermissionsSingleFile) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSingleFile from json.
func (s *AppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSingleFile to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSingleFile(v) {
	case AppPermissionsSingleFileRead:
		*s = AppPermissionsSingleFileRead
	case AppPermissionsSingleFileWrite:
		*s = AppPermissionsSingleFileWrite
	default:
		*s = AppPermissionsSingleFile(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsSingleFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsSingleFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsStatuses as json.
func (s AppPermissionsStatuses) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsStatuses from json.
func (s *AppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsStatuses to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsStatuses(v) {
	case AppPermissionsStatusesRead:
		*s = AppPermissionsStatusesRead
	case AppPermissionsStatusesWrite:
		*s = AppPermissionsStatusesWrite
	default:
		*s = AppPermissionsStatuses(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsStatuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsStatuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (s AppPermissionsTeamDiscussions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (s *AppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsTeamDiscussions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsTeamDiscussions(v) {
	case AppPermissionsTeamDiscussionsRead:
		*s = AppPermissionsTeamDiscussionsRead
	case AppPermissionsTeamDiscussionsWrite:
		*s = AppPermissionsTeamDiscussionsWrite
	default:
		*s = AppPermissionsTeamDiscussions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsTeamDiscussions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsTeamDiscussions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (s AppPermissionsVulnerabilityAlerts) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (s *AppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsVulnerabilityAlerts to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsVulnerabilityAlerts(v) {
	case AppPermissionsVulnerabilityAlertsRead:
		*s = AppPermissionsVulnerabilityAlertsRead
	default:
		*s = AppPermissionsVulnerabilityAlerts(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsVulnerabilityAlerts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsVulnerabilityAlerts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsWorkflows as json.
func (s AppPermissionsWorkflows) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsWorkflows from json.
func (s *AppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsWorkflows to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsWorkflows(v) {
	case AppPermissionsWorkflowsWrite:
		*s = AppPermissionsWorkflowsWrite
	default:
		*s = AppPermissionsWorkflows(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppPermissionsWorkflows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppPermissionsWorkflows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplicationGrant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplicationGrant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("app")
		s.App.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("scopes")
		e.ArrStart()
		for _, elem := range s.Scopes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfApplicationGrant = [7]string{
	0: "id",
	1: "url",
	2: "app",
	3: "created_at",
	4: "updated_at",
	5: "scopes",
	6: "user",
}

// Decode decodes ApplicationGrant from json.
func (s *ApplicationGrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationGrant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "app":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "scopes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplicationGrant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplicationGrant) {
					name = jsonFieldsNameOfApplicationGrant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplicationGrant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplicationGrant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApplicationGrantApp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApplicationGrantApp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_id")
		e.Str(s.ClientID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfApplicationGrantApp = [3]string{
	0: "client_id",
	1: "name",
	2: "url",
}

// Decode decodes ApplicationGrantApp from json.
func (s *ApplicationGrantApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationGrantApp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplicationGrantApp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplicationGrantApp) {
					name = jsonFieldsNameOfApplicationGrantApp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApplicationGrantApp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplicationGrantApp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsAddRepoToInstallationForbidden as json.
func (s *AppsAddRepoToInstallationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationForbidden from json.
func (s *AppsAddRepoToInstallationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsAddRepoToInstallationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsAddRepoToInstallationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsAddRepoToInstallationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsAddRepoToInstallationNotFound as json.
func (s *AppsAddRepoToInstallationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationNotFound from json.
func (s *AppsAddRepoToInstallationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsAddRepoToInstallationNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsAddRepoToInstallationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsAddRepoToInstallationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCheckTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCheckTokenReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfAppsCheckTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsCheckTokenReq from json.
func (s *AppsCheckTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCheckTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCheckTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsCheckTokenReq) {
					name = jsonFieldsNameOfAppsCheckTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCheckTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCheckTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateContentAttachmentForbidden as json.
func (s *AppsCreateContentAttachmentForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentForbidden from json.
func (s *AppsCreateContentAttachmentForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateContentAttachmentForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateContentAttachmentForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateContentAttachmentGone as json.
func (s *AppsCreateContentAttachmentGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentGone from json.
func (s *AppsCreateContentAttachmentGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateContentAttachmentGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateContentAttachmentGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateContentAttachmentNotFound as json.
func (s *AppsCreateContentAttachmentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentNotFound from json.
func (s *AppsCreateContentAttachmentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateContentAttachmentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateContentAttachmentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCreateContentAttachmentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCreateContentAttachmentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfAppsCreateContentAttachmentReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes AppsCreateContentAttachmentReq from json.
func (s *AppsCreateContentAttachmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateContentAttachmentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsCreateContentAttachmentReq) {
					name = jsonFieldsNameOfAppsCreateContentAttachmentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateContentAttachmentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateContentAttachmentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCreateFromManifestCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCreateFromManifestCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("external_url")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.FieldStart("installations_count")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		e.FieldStart("client_id")
		e.Str(s.ClientID)
	}
	{
		e.FieldStart("client_secret")
		e.Str(s.ClientSecret)
	}
	{
		e.FieldStart("webhook_secret")
		s.WebhookSecret.Encode(e)
	}
	{
		e.FieldStart("pem")
		e.Str(s.Pem)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfAppsCreateFromManifestCreated = [17]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
	12: "installations_count",
	13: "client_id",
	14: "client_secret",
	15: "webhook_secret",
	16: "pem",
}

// Decode decodes AppsCreateFromManifestCreated from json.
func (s *AppsCreateFromManifestCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestCreated to nil")
	}
	var requiredBitSet [3]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "installations_count":
			if err := func() error {
				s.InstallationsCount.Reset()
				if err := s.InstallationsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installations_count\"")
			}
		case "client_id":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ClientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "webhook_secret":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		case "pem":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Pem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pem\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsCreateFromManifestCreated) {
					name = jsonFieldsNameOfAppsCreateFromManifestCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateFromManifestCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateFromManifestCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AppsCreateFromManifestCreatedAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AppsCreateFromManifestCreatedAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AppsCreateFromManifestCreatedAdditional from json.
func (s *AppsCreateFromManifestCreatedAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestCreatedAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestCreatedAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppsCreateFromManifestCreatedAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateFromManifestCreatedAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCreateFromManifestCreatedPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCreateFromManifestCreatedPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Issues.Set {
			e.FieldStart("issues")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			e.FieldStart("deployments")
			s.Deployments.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		e.Str(elem)
	}
}

var jsonFieldsNameOfAppsCreateFromManifestCreatedPermissions = [5]string{
	0: "issues",
	1: "checks",
	2: "metadata",
	3: "contents",
	4: "deployments",
}

// Decode decodes AppsCreateFromManifestCreatedPermissions from json.
func (s *AppsCreateFromManifestCreatedPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestCreatedPermissions to nil")
	}
	s.AdditionalProps = map[string]string{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestCreatedPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateFromManifestCreatedPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateFromManifestCreatedPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AppsCreateFromManifestCreatedPermissionsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AppsCreateFromManifestCreatedPermissionsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AppsCreateFromManifestCreatedPermissionsAdditional from json.
func (s *AppsCreateFromManifestCreatedPermissionsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestCreatedPermissionsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestCreatedPermissionsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppsCreateFromManifestCreatedPermissionsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateFromManifestCreatedPermissionsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCreateFromManifestReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCreateFromManifestReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAppsCreateFromManifestReq = [0]string{}

// Decode decodes AppsCreateFromManifestReq from json.
func (s *AppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateFromManifestReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateFromManifestReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateInstallationAccessTokenForbidden as json.
func (s *AppsCreateInstallationAccessTokenForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenForbidden from json.
func (s *AppsCreateInstallationAccessTokenForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateInstallationAccessTokenForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateInstallationAccessTokenForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateInstallationAccessTokenNotFound as json.
func (s *AppsCreateInstallationAccessTokenNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenNotFound from json.
func (s *AppsCreateInstallationAccessTokenNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateInstallationAccessTokenNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateInstallationAccessTokenNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsCreateInstallationAccessTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsCreateInstallationAccessTokenReq) encodeFields(e *jx.Encoder) {
	{
		if s.Repositories != nil {
			e.FieldStart("repositories")
			e.ArrStart()
			for _, elem := range s.Repositories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			e.FieldStart("repository_ids")
			e.ArrStart()
			for _, elem := range s.RepositoryIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppsCreateInstallationAccessTokenReq = [3]string{
	0: "repositories",
	1: "repository_ids",
	2: "permissions",
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (s *AppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			if err := func() error {
				s.Repositories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_ids":
			if err := func() error {
				s.RepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.RepositoryIds = append(s.RepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_ids\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateInstallationAccessTokenReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateInstallationAccessTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateInstallationAccessTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateInstallationAccessTokenUnauthorized as json.
func (s *AppsCreateInstallationAccessTokenUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenUnauthorized from json.
func (s *AppsCreateInstallationAccessTokenUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsCreateInstallationAccessTokenUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsCreateInstallationAccessTokenUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsDeleteAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsDeleteAuthorizationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfAppsDeleteAuthorizationReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsDeleteAuthorizationReq from json.
func (s *AppsDeleteAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsDeleteAuthorizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsDeleteAuthorizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsDeleteAuthorizationReq) {
					name = jsonFieldsNameOfAppsDeleteAuthorizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsDeleteAuthorizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsDeleteAuthorizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsDeleteTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsDeleteTokenReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfAppsDeleteTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsDeleteTokenReq from json.
func (s *AppsDeleteTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsDeleteTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsDeleteTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsDeleteTokenReq) {
					name = jsonFieldsNameOfAppsDeleteTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsDeleteTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsDeleteTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsGetBySlugForbidden as json.
func (s *AppsGetBySlugForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugForbidden from json.
func (s *AppsGetBySlugForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetBySlugForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsGetBySlugForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsGetBySlugForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsGetBySlugNotFound as json.
func (s *AppsGetBySlugNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugNotFound from json.
func (s *AppsGetBySlugNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetBySlugNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsGetBySlugNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsGetBySlugNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsGetSubscriptionPlanForAccountNotFound as json.
func (s *AppsGetSubscriptionPlanForAccountNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetSubscriptionPlanForAccountNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsGetSubscriptionPlanForAccountNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsGetSubscriptionPlanForAccountNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsGetSubscriptionPlanForAccountUnauthorized as json.
func (s *AppsGetSubscriptionPlanForAccountUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountUnauthorized from json.
func (s *AppsGetSubscriptionPlanForAccountUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetSubscriptionPlanForAccountUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsGetSubscriptionPlanForAccountUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsGetSubscriptionPlanForAccountUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListAccountsForPlanNotFound as json.
func (s *AppsListAccountsForPlanNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanNotFound from json.
func (s *AppsListAccountsForPlanNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListAccountsForPlanNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListAccountsForPlanNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListAccountsForPlanUnauthorized as json.
func (s *AppsListAccountsForPlanUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanUnauthorized from json.
func (s *AppsListAccountsForPlanUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListAccountsForPlanUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListAccountsForPlanUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserForbidden as json.
func (s *AppsListInstallationReposForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserForbidden from json.
func (s *AppsListInstallationReposForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListInstallationReposForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListInstallationReposForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserNotFound as json.
func (s *AppsListInstallationReposForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserNotFound from json.
func (s *AppsListInstallationReposForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListInstallationReposForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListInstallationReposForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsListInstallationReposForAuthenticatedUserOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsListInstallationReposForAuthenticatedUserOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		if s.RepositorySelection.Set {
			e.FieldStart("repository_selection")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK = [3]string{
	0: "total_count",
	1: "repository_selection",
	2: "repositories",
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserOK from json.
func (s *AppsListInstallationReposForAuthenticatedUserOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsListInstallationReposForAuthenticatedUserOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK) {
					name = jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListInstallationReposForAuthenticatedUserOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListInstallationReposForAuthenticatedUserOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListPlansNotFound as json.
func (s *AppsListPlansNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansNotFound from json.
func (s *AppsListPlansNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListPlansNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListPlansNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListPlansUnauthorized as json.
func (s *AppsListPlansUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansUnauthorized from json.
func (s *AppsListPlansUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListPlansUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListPlansUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListReposAccessibleToInstallationForbidden as json.
func (s *AppsListReposAccessibleToInstallationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationForbidden from json.
func (s *AppsListReposAccessibleToInstallationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListReposAccessibleToInstallationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListReposAccessibleToInstallationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsListReposAccessibleToInstallationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsListReposAccessibleToInstallationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RepositorySelection.Set {
			e.FieldStart("repository_selection")
			s.RepositorySelection.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppsListReposAccessibleToInstallationOK = [3]string{
	0: "total_count",
	1: "repositories",
	2: "repository_selection",
}

// Decode decodes AppsListReposAccessibleToInstallationOK from json.
func (s *AppsListReposAccessibleToInstallationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsListReposAccessibleToInstallationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsListReposAccessibleToInstallationOK) {
					name = jsonFieldsNameOfAppsListReposAccessibleToInstallationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListReposAccessibleToInstallationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListReposAccessibleToInstallationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListReposAccessibleToInstallationUnauthorized as json.
func (s *AppsListReposAccessibleToInstallationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationUnauthorized from json.
func (s *AppsListReposAccessibleToInstallationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListReposAccessibleToInstallationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListReposAccessibleToInstallationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserNotFound as json.
func (s *AppsListSubscriptionsForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserNotFound from json.
func (s *AppsListSubscriptionsForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListSubscriptionsForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListSubscriptionsForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserUnauthorized as json.
func (s *AppsListSubscriptionsForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserUnauthorized from json.
func (s *AppsListSubscriptionsForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsListSubscriptionsForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListSubscriptionsForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsListWebhookDeliveriesOKApplicationJSON as json.
func (s AppsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HookDeliveryItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListWebhookDeliveriesOKApplicationJSON from json.
func (s *AppsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = make([]HookDeliveryItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppsListWebhookDeliveriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsListWebhookDeliveriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsRemoveRepoFromInstallationForbidden as json.
func (s *AppsRemoveRepoFromInstallationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationForbidden from json.
func (s *AppsRemoveRepoFromInstallationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsRemoveRepoFromInstallationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsRemoveRepoFromInstallationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsRemoveRepoFromInstallationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsRemoveRepoFromInstallationNotFound as json.
func (s *AppsRemoveRepoFromInstallationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationNotFound from json.
func (s *AppsRemoveRepoFromInstallationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsRemoveRepoFromInstallationNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsRemoveRepoFromInstallationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsRemoveRepoFromInstallationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsResetTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsResetTokenReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfAppsResetTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsResetTokenReq from json.
func (s *AppsResetTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsResetTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsResetTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsResetTokenReq) {
					name = jsonFieldsNameOfAppsResetTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsResetTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsResetTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsScopeTokenForbidden as json.
func (s *AppsScopeTokenForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenForbidden from json.
func (s *AppsScopeTokenForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsScopeTokenForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsScopeTokenForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsScopeTokenNotFound as json.
func (s *AppsScopeTokenNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenNotFound from json.
func (s *AppsScopeTokenNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsScopeTokenNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsScopeTokenNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsScopeTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsScopeTokenReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		if s.Target.Set {
			e.FieldStart("target")
			s.Target.Encode(e)
		}
	}
	{
		if s.TargetID.Set {
			e.FieldStart("target_id")
			s.TargetID.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.FieldStart("repositories")
			e.ArrStart()
			for _, elem := range s.Repositories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			e.FieldStart("repository_ids")
			e.ArrStart()
			for _, elem := range s.RepositoryIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppsScopeTokenReq = [6]string{
	0: "access_token",
	1: "target",
	2: "target_id",
	3: "repositories",
	4: "repository_ids",
	5: "permissions",
}

// Decode decodes AppsScopeTokenReq from json.
func (s *AppsScopeTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "target_id":
			if err := func() error {
				s.TargetID.Reset()
				if err := s.TargetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_ids":
			if err := func() error {
				s.RepositoryIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.RepositoryIds = append(s.RepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_ids\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsScopeTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsScopeTokenReq) {
					name = jsonFieldsNameOfAppsScopeTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsScopeTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsScopeTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsScopeTokenUnauthorized as json.
func (s *AppsScopeTokenUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenUnauthorized from json.
func (s *AppsScopeTokenUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsScopeTokenUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsScopeTokenUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AppsUpdateWebhookConfigForAppReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppsUpdateWebhookConfigForAppReq) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppsUpdateWebhookConfigForAppReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (s *AppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsUpdateWebhookConfigForAppReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsUpdateWebhookConfigForAppReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppsUpdateWebhookConfigForAppReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppsUpdateWebhookConfigForAppReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Artifact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Artifact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("size_in_bytes")
		e.Int(s.SizeInBytes)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("archive_download_url")
		e.Str(s.ArchiveDownloadURL)
	}
	{
		e.FieldStart("expired")
		e.Bool(s.Expired)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expires_at")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
}

var jsonFieldsNameOfArtifact = [10]string{
	0: "id",
	1: "node_id",
	2: "name",
	3: "size_in_bytes",
	4: "url",
	5: "archive_download_url",
	6: "expired",
	7: "created_at",
	8: "expires_at",
	9: "updated_at",
}

// Decode decodes Artifact from json.
func (s *Artifact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Artifact to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "size_in_bytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.SizeInBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_in_bytes\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_download_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArchiveDownloadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_download_url\"")
			}
		case "expired":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Expired = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Artifact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfArtifact) {
					name = jsonFieldsNameOfArtifact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Artifact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Artifact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditLogEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditLogEvent) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("@timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.ActiveWas.Set {
			e.FieldStart("active_was")
			s.ActiveWas.Encode(e)
		}
	}
	{
		if s.Actor.Set {
			e.FieldStart("actor")
			s.Actor.Encode(e)
		}
	}
	{
		if s.ActorID.Set {
			e.FieldStart("actor_id")
			s.ActorID.Encode(e)
		}
	}
	{
		if s.ActorLocation.Set {
			e.FieldStart("actor_location")
			s.ActorLocation.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.OrgID.Set {
			e.FieldStart("org_id")
			s.OrgID.Encode(e)
		}
	}
	{
		if s.BlockedUser.Set {
			e.FieldStart("blocked_user")
			s.BlockedUser.Encode(e)
		}
	}
	{
		if s.Business.Set {
			e.FieldStart("business")
			s.Business.Encode(e)
		}
	}
	{
		if s.Config != nil {
			e.FieldStart("config")
			e.ArrStart()
			for _, elem := range s.Config {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ConfigWas != nil {
			e.FieldStart("config_was")
			e.ArrStart()
			for _, elem := range s.ConfigWas {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.DeployKeyFingerprint.Set {
			e.FieldStart("deploy_key_fingerprint")
			s.DeployKeyFingerprint.Encode(e)
		}
	}
	{
		if s.DocumentID.Set {
			e.FieldStart("_document_id")
			s.DocumentID.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EventsWere != nil {
			e.FieldStart("events_were")
			e.ArrStart()
			for _, elem := range s.EventsWere {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Explanation.Set {
			e.FieldStart("explanation")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.HookID.Set {
			e.FieldStart("hook_id")
			s.HookID.Encode(e)
		}
	}
	{
		if s.LimitedAvailability.Set {
			e.FieldStart("limited_availability")
			s.LimitedAvailability.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.OldUser.Set {
			e.FieldStart("old_user")
			s.OldUser.Encode(e)
		}
	}
	{
		if s.OpensshPublicKey.Set {
			e.FieldStart("openssh_public_key")
			s.OpensshPublicKey.Encode(e)
		}
	}
	{
		if s.Org.Set {
			e.FieldStart("org")
			s.Org.Encode(e)
		}
	}
	{
		if s.PreviousVisibility.Set {
			e.FieldStart("previous_visibility")
			s.PreviousVisibility.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("read_only")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.Repo.Set {
			e.FieldStart("repo")
			s.Repo.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		if s.RepositoryPublic.Set {
			e.FieldStart("repository_public")
			s.RepositoryPublic.Encode(e)
		}
	}
	{
		if s.TargetLogin.Set {
			e.FieldStart("target_login")
			s.TargetLogin.Encode(e)
		}
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
	{
		if s.TransportProtocol.Set {
			e.FieldStart("transport_protocol")
			s.TransportProtocol.Encode(e)
		}
	}
	{
		if s.TransportProtocolName.Set {
			e.FieldStart("transport_protocol_name")
			s.TransportProtocolName.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditLogEvent = [40]string{
	0:  "@timestamp",
	1:  "action",
	2:  "active",
	3:  "active_was",
	4:  "actor",
	5:  "actor_id",
	6:  "actor_location",
	7:  "data",
	8:  "org_id",
	9:  "blocked_user",
	10: "business",
	11: "config",
	12: "config_was",
	13: "content_type",
	14: "created_at",
	15: "deploy_key_fingerprint",
	16: "_document_id",
	17: "emoji",
	18: "events",
	19: "events_were",
	20: "explanation",
	21: "fingerprint",
	22: "hook_id",
	23: "limited_availability",
	24: "message",
	25: "name",
	26: "old_user",
	27: "openssh_public_key",
	28: "org",
	29: "previous_visibility",
	30: "read_only",
	31: "repo",
	32: "repository",
	33: "repository_public",
	34: "target_login",
	35: "team",
	36: "transport_protocol",
	37: "transport_protocol_name",
	38: "user",
	39: "visibility",
}

// Decode decodes AuditLogEvent from json.
func (s *AuditLogEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEvent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "@timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"@timestamp\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "active_was":
			if err := func() error {
				s.ActiveWas.Reset()
				if err := s.ActiveWas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_was\"")
			}
		case "actor":
			if err := func() error {
				s.Actor.Reset()
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "actor_id":
			if err := func() error {
				s.ActorID.Reset()
				if err := s.ActorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_id\"")
			}
		case "actor_location":
			if err := func() error {
				s.ActorLocation.Reset()
				if err := s.ActorLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_location\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "org_id":
			if err := func() error {
				s.OrgID.Reset()
				if err := s.OrgID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org_id\"")
			}
		case "blocked_user":
			if err := func() error {
				s.BlockedUser.Reset()
				if err := s.BlockedUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_user\"")
			}
		case "business":
			if err := func() error {
				s.Business.Reset()
				if err := s.Business.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business\"")
			}
		case "config":
			if err := func() error {
				s.Config = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Config = append(s.Config, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "config_was":
			if err := func() error {
				s.ConfigWas = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.ConfigWas = append(s.ConfigWas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config_was\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "deploy_key_fingerprint":
			if err := func() error {
				s.DeployKeyFingerprint.Reset()
				if err := s.DeployKeyFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploy_key_fingerprint\"")
			}
		case "_document_id":
			if err := func() error {
				s.DocumentID.Reset()
				if err := s.DocumentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_document_id\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "events_were":
			if err := func() error {
				s.EventsWere = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.EventsWere = append(s.EventsWere, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_were\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "hook_id":
			if err := func() error {
				s.HookID.Reset()
				if err := s.HookID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_id\"")
			}
		case "limited_availability":
			if err := func() error {
				s.LimitedAvailability.Reset()
				if err := s.LimitedAvailability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited_availability\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "old_user":
			if err := func() error {
				s.OldUser.Reset()
				if err := s.OldUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_user\"")
			}
		case "openssh_public_key":
			if err := func() error {
				s.OpensshPublicKey.Reset()
				if err := s.OpensshPublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openssh_public_key\"")
			}
		case "org":
			if err := func() error {
				s.Org.Reset()
				if err := s.Org.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "previous_visibility":
			if err := func() error {
				s.PreviousVisibility.Reset()
				if err := s.PreviousVisibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_visibility\"")
			}
		case "read_only":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		case "repo":
			if err := func() error {
				s.Repo.Reset()
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "repository_public":
			if err := func() error {
				s.RepositoryPublic.Reset()
				if err := s.RepositoryPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_public\"")
			}
		case "target_login":
			if err := func() error {
				s.TargetLogin.Reset()
				if err := s.TargetLogin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_login\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "transport_protocol":
			if err := func() error {
				s.TransportProtocol.Reset()
				if err := s.TransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport_protocol\"")
			}
		case "transport_protocol_name":
			if err := func() error {
				s.TransportProtocolName.Reset()
				if err := s.TransportProtocolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport_protocol_name\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEvent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditLogEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditLogEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditLogEventActorLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditLogEventActorLocation) encodeFields(e *jx.Encoder) {
	{
		if s.CountryName.Set {
			e.FieldStart("country_name")
			s.CountryName.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditLogEventActorLocation = [1]string{
	0: "country_name",
}

// Decode decodes AuditLogEventActorLocation from json.
func (s *AuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEventActorLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_name":
			if err := func() error {
				s.CountryName.Reset()
				if err := s.CountryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEventActorLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditLogEventActorLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditLogEventActorLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuditLogEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AuditLogEventData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AuditLogEventData from json.
func (s *AuditLogEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEventData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditLogEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditLogEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationToken) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationToken) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.FieldStart("repositories")
			e.ArrStart()
			for _, elem := range s.Repositories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.FieldStart("single_file")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.FieldStart("repository_selection")
			s.RepositorySelection.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthenticationToken = [6]string{
	0: "token",
	1: "expires_at",
	2: "permissions",
	3: "repositories",
	4: "single_file",
	5: "repository_selection",
}

// Decode decodes AuthenticationToken from json.
func (s *AuthenticationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationToken to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = nil
				var elem AuthenticationTokenPermissions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Permissions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationToken")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationToken) {
					name = jsonFieldsNameOfAuthenticationToken[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthenticationTokenPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthenticationTokenPermissions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthenticationTokenPermissions = [0]string{}

// Decode decodes AuthenticationTokenPermissions from json.
func (s *AuthenticationTokenPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationTokenPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthenticationTokenPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationTokenPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (s AuthenticationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (s *AuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationTokenRepositorySelection(v) {
	case AuthenticationTokenRepositorySelectionAll:
		*s = AuthenticationTokenRepositorySelectionAll
	case AuthenticationTokenRepositorySelectionSelected:
		*s = AuthenticationTokenRepositorySelectionSelected
	default:
		*s = AuthenticationTokenRepositorySelection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationTokenRepositorySelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationTokenRepositorySelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthorAssociation as json.
func (s AuthorAssociation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthorAssociation from json.
func (s *AuthorAssociation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorAssociation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthorAssociation(v) {
	case AuthorAssociationCOLLABORATOR:
		*s = AuthorAssociationCOLLABORATOR
	case AuthorAssociationCONTRIBUTOR:
		*s = AuthorAssociationCONTRIBUTOR
	case AuthorAssociationFIRSTTIMER:
		*s = AuthorAssociationFIRSTTIMER
	case AuthorAssociationFIRSTTIMECONTRIBUTOR:
		*s = AuthorAssociationFIRSTTIMECONTRIBUTOR
	case AuthorAssociationMANNEQUIN:
		*s = AuthorAssociationMANNEQUIN
	case AuthorAssociationMEMBER:
		*s = AuthorAssociationMEMBER
	case AuthorAssociationNONE:
		*s = AuthorAssociationNONE
	case AuthorAssociationOWNER:
		*s = AuthorAssociationOWNER
	default:
		*s = AuthorAssociation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthorAssociation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthorAssociation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Authorization) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Authorization) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("scopes")
		if s.Scopes == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Scopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("token_last_eight")
		s.TokenLastEight.Encode(e)
	}
	{
		e.FieldStart("hashed_token")
		s.HashedToken.Encode(e)
	}
	{
		e.FieldStart("app")
		s.App.Encode(e)
	}
	{
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	{
		e.FieldStart("note_url")
		s.NoteURL.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Installation.Set {
			e.FieldStart("installation")
			s.Installation.Encode(e)
		}
	}
	{
		e.FieldStart("expires_at")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
}

var jsonFieldsNameOfAuthorization = [15]string{
	0:  "id",
	1:  "url",
	2:  "scopes",
	3:  "token",
	4:  "token_last_eight",
	5:  "hashed_token",
	6:  "app",
	7:  "note",
	8:  "note_url",
	9:  "updated_at",
	10: "created_at",
	11: "fingerprint",
	12: "user",
	13: "installation",
	14: "expires_at",
}

// Decode decodes Authorization from json.
func (s *Authorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Authorization to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "scopes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Scopes = make([]string, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem string
						v, err := d.Str()
						elem = string(v)
						if err != nil {
							return err
						}
						s.Scopes = append(s.Scopes, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "token_last_eight":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TokenLastEight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_last_eight\"")
			}
		case "hashed_token":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HashedToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashed_token\"")
			}
		case "app":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "note":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "installation":
			if err := func() error {
				s.Installation.Reset()
				if err := s.Installation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Authorization")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthorization) {
					name = jsonFieldsNameOfAuthorization[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Authorization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Authorization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthorizationApp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthorizationApp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_id")
		e.Str(s.ClientID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfAuthorizationApp = [3]string{
	0: "client_id",
	1: "name",
	2: "url",
}

// Decode decodes AuthorizationApp from json.
func (s *AuthorizationApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorizationApp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthorizationApp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthorizationApp) {
					name = jsonFieldsNameOfAuthorizationApp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthorizationApp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthorizationApp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutoMerge) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutoMerge) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled_by")
		s.EnabledBy.Encode(e)
	}
	{
		e.FieldStart("merge_method")
		s.MergeMethod.Encode(e)
	}
	{
		e.FieldStart("commit_title")
		e.Str(s.CommitTitle)
	}
	{
		e.FieldStart("commit_message")
		e.Str(s.CommitMessage)
	}
}

var jsonFieldsNameOfAutoMerge = [4]string{
	0: "enabled_by",
	1: "merge_method",
	2: "commit_title",
	3: "commit_message",
}

// Decode decodes AutoMerge from json.
func (s *AutoMerge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoMerge to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_by":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_by\"")
			}
		case "merge_method":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MergeMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_method\"")
			}
		case "commit_title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CommitTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_title\"")
			}
		case "commit_message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutoMerge")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutoMerge) {
					name = jsonFieldsNameOfAutoMerge[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutoMerge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoMerge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoMergeMergeMethod as json.
func (s AutoMergeMergeMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutoMergeMergeMethod from json.
func (s *AutoMergeMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoMergeMergeMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoMergeMergeMethod(v) {
	case AutoMergeMergeMethodMerge:
		*s = AutoMergeMergeMethodMerge
	case AutoMergeMergeMethodSquash:
		*s = AutoMergeMergeMethodSquash
	case AutoMergeMergeMethodRebase:
		*s = AutoMergeMergeMethodRebase
	default:
		*s = AutoMergeMergeMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutoMergeMergeMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoMergeMergeMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Autolink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Autolink) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("key_prefix")
		e.Str(s.KeyPrefix)
	}
	{
		e.FieldStart("url_template")
		e.Str(s.URLTemplate)
	}
}

var jsonFieldsNameOfAutolink = [3]string{
	0: "id",
	1: "key_prefix",
	2: "url_template",
}

// Decode decodes Autolink from json.
func (s *Autolink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Autolink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key_prefix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.KeyPrefix = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_prefix\"")
			}
		case "url_template":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URLTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Autolink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutolink) {
					name = jsonFieldsNameOfAutolink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Autolink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Autolink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseGist) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseGist) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("commits_url")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("git_pull_url")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.FieldStart("git_push_url")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("files")
		s.Files.Encode(e)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.FieldStart("truncated")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.FieldStart("forks")
			e.ArrStart()
			for _, elem := range s.Forks {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.FieldStart("history")
			e.ArrStart()
			for _, elem := range s.History {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBaseGist = [20]string{
	0:  "url",
	1:  "forks_url",
	2:  "commits_url",
	3:  "id",
	4:  "node_id",
	5:  "git_pull_url",
	6:  "git_push_url",
	7:  "html_url",
	8:  "files",
	9:  "public",
	10: "created_at",
	11: "updated_at",
	12: "description",
	13: "comments",
	14: "user",
	15: "comments_url",
	16: "owner",
	17: "truncated",
	18: "forks",
	19: "history",
}

// Decode decodes BaseGist from json.
func (s *BaseGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGist to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPullURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPushURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "forks":
			if err := func() error {
				s.Forks = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Forks = append(s.Forks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGist")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseGist) {
					name = jsonFieldsNameOfBaseGist[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseGist) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseGist) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BaseGistFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BaseGistFiles) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes BaseGistFiles from json.
func (s *BaseGistFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGistFiles to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem BaseGistFilesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGistFiles")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BaseGistFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseGistFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BaseGistFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BaseGistFilesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			e.FieldStart("raw_url")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfBaseGistFilesItem = [5]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
}

// Decode decodes BaseGistFilesItem from json.
func (s *BaseGistFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGistFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGistFilesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BaseGistFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BaseGistFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BasicError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BasicError) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfBasicError = [4]string{
	0: "message",
	1: "documentation_url",
	2: "url",
	3: "status",
}

// Decode decodes BasicError from json.
func (s *BasicError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BasicError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BasicError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Blob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Blob) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("encoding")
		e.Str(s.Encoding)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.HighlightedContent.Set {
			e.FieldStart("highlighted_content")
			s.HighlightedContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfBlob = [7]string{
	0: "content",
	1: "encoding",
	2: "url",
	3: "sha",
	4: "size",
	5: "node_id",
	6: "highlighted_content",
}

// Decode decodes Blob from json.
func (s *Blob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Blob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "highlighted_content":
			if err := func() error {
				s.HighlightedContent.Reset()
				if err := s.HighlightedContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlighted_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Blob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBlob) {
					name = jsonFieldsNameOfBlob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Blob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Blob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtection) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.RequiredStatusChecks.Set {
			e.FieldStart("required_status_checks")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			e.FieldStart("enforce_admins")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			e.FieldStart("required_pull_request_reviews")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			e.FieldStart("restrictions")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			e.FieldStart("required_linear_history")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.FieldStart("allow_force_pushes")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.FieldStart("allow_deletions")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.FieldStart("required_conversation_resolution")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			e.FieldStart("protection_url")
			s.ProtectionURL.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			e.FieldStart("required_signatures")
			s.RequiredSignatures.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtection = [13]string{
	0:  "url",
	1:  "enabled",
	2:  "required_status_checks",
	3:  "enforce_admins",
	4:  "required_pull_request_reviews",
	5:  "restrictions",
	6:  "required_linear_history",
	7:  "allow_force_pushes",
	8:  "allow_deletions",
	9:  "required_conversation_resolution",
	10: "name",
	11: "protection_url",
	12: "required_signatures",
}

// Decode decodes BranchProtection from json.
func (s *BranchProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "required_status_checks":
			if err := func() error {
				s.RequiredStatusChecks.Reset()
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "enforce_admins":
			if err := func() error {
				s.EnforceAdmins.Reset()
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_pull_request_reviews":
			if err := func() error {
				s.RequiredPullRequestReviews.Reset()
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "restrictions":
			if err := func() error {
				s.Restrictions.Reset()
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "protection_url":
			if err := func() error {
				s.ProtectionURL.Reset()
				if err := s.ProtectionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		case "required_signatures":
			if err := func() error {
				s.RequiredSignatures.Reset()
				if err := s.RequiredSignatures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_signatures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionAllowDeletions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionAllowDeletions) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtectionAllowDeletions = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (s *BranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionAllowDeletions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionAllowDeletions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionAllowDeletions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionAllowDeletions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionAllowForcePushes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionAllowForcePushes) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtectionAllowForcePushes = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (s *BranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionAllowForcePushes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionAllowForcePushes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionAllowForcePushes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionAllowForcePushes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionRequiredConversationResolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionRequiredConversationResolution) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtectionRequiredConversationResolution = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (s *BranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredConversationResolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredConversationResolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionRequiredConversationResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionRequiredConversationResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionRequiredLinearHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionRequiredLinearHistory) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtectionRequiredLinearHistory = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (s *BranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredLinearHistory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredLinearHistory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionRequiredLinearHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionRequiredLinearHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionRequiredSignatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionRequiredSignatures) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfBranchProtectionRequiredSignatures = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (s *BranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredSignatures to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredSignatures")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchProtectionRequiredSignatures) {
					name = jsonFieldsNameOfBranchProtectionRequiredSignatures[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionRequiredSignatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionRequiredSignatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchProtectionRequiredStatusChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchProtectionRequiredStatusChecks) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.EnforcementLevel.Set {
			e.FieldStart("enforcement_level")
			s.EnforcementLevel.Encode(e)
		}
	}
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ContextsURL.Set {
			e.FieldStart("contexts_url")
			s.ContextsURL.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchProtectionRequiredStatusChecks = [5]string{
	0: "url",
	1: "enforcement_level",
	2: "contexts",
	3: "contexts_url",
	4: "strict",
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (s *BranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredStatusChecks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enforcement_level":
			if err := func() error {
				s.EnforcementLevel.Reset()
				if err := s.EnforcementLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforcement_level\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		case "contexts_url":
			if err := func() error {
				s.ContextsURL.Reset()
				if err := s.ContextsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts_url\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredStatusChecks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchProtectionRequiredStatusChecks) {
					name = jsonFieldsNameOfBranchProtectionRequiredStatusChecks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchProtectionRequiredStatusChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchProtectionRequiredStatusChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("users_url")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("apps_url")
		json.EncodeURI(e, s.AppsURL)
	}
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("apps")
		e.ArrStart()
		for _, elem := range s.Apps {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBranchRestrictionPolicy = [7]string{
	0: "url",
	1: "users_url",
	2: "teams_url",
	3: "apps_url",
	4: "users",
	5: "teams",
	6: "apps",
}

// Decode decodes BranchRestrictionPolicy from json.
func (s *BranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.UsersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "apps_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AppsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps_url\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Users = make([]BranchRestrictionPolicyUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Teams = make([]BranchRestrictionPolicyTeamsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyTeamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "apps":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Apps = make([]BranchRestrictionPolicyAppsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyAppsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchRestrictionPolicy) {
					name = jsonFieldsNameOfBranchRestrictionPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicyAppsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicyAppsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			e.FieldStart("external_url")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItem = [12]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
}

// Decode decodes BranchRestrictionPolicyAppsItem from json.
func (s *BranchRestrictionPolicyAppsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			if err := func() error {
				s.ExternalURL.Reset()
				if err := s.ExternalURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicyAppsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicyAppsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicyAppsItemOwner) encodeFields(e *jx.Encoder) {
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			e.FieldStart("repos_url")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			e.FieldStart("hooks_url")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			e.FieldStart("members_url")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.PublicMembersURL.Set {
			e.FieldStart("public_members_url")
			s.PublicMembersURL.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			e.FieldStart("gravatar_id")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			e.FieldStart("followers_url")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			e.FieldStart("following_url")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			e.FieldStart("gists_url")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			e.FieldStart("starred_url")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			e.FieldStart("subscriptions_url")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			e.FieldStart("organizations_url")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			e.FieldStart("received_events_url")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			e.FieldStart("site_admin")
			s.SiteAdmin.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItemOwner = [23]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
	12: "gravatar_id",
	13: "html_url",
	14: "followers_url",
	15: "following_url",
	16: "gists_url",
	17: "starred_url",
	18: "subscriptions_url",
	19: "organizations_url",
	20: "received_events_url",
	21: "type",
	22: "site_admin",
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (s *BranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItemOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			if err := func() error {
				s.MembersURL.Reset()
				if err := s.MembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			if err := func() error {
				s.PublicMembersURL.Reset()
				if err := s.PublicMembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItemOwner")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicyAppsItemOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicyAppsItemOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicyAppsItemPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			e.FieldStart("issues")
			s.Issues.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			e.FieldStart("single_file")
			s.SingleFile.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItemPermissions = [4]string{
	0: "metadata",
	1: "contents",
	2: "issues",
	3: "single_file",
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (s *BranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItemPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItemPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicyAppsItemPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicyAppsItemPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicyTeamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicyTeamsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			e.FieldStart("members_url")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.RepositoriesURL.Set {
			e.FieldStart("repositories_url")
			s.RepositoriesURL.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			e.FieldStart("parent")
			s.Parent.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchRestrictionPolicyTeamsItem = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "html_url",
	4:  "name",
	5:  "slug",
	6:  "description",
	7:  "privacy",
	8:  "permission",
	9:  "members_url",
	10: "repositories_url",
	11: "parent",
}

// Decode decodes BranchRestrictionPolicyTeamsItem from json.
func (s *BranchRestrictionPolicyTeamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyTeamsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "members_url":
			if err := func() error {
				s.MembersURL.Reset()
				if err := s.MembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			if err := func() error {
				s.RepositoriesURL.Reset()
				if err := s.RepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyTeamsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicyTeamsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicyTeamsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchRestrictionPolicyUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchRestrictionPolicyUsersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			e.FieldStart("gravatar_id")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			e.FieldStart("followers_url")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			e.FieldStart("following_url")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			e.FieldStart("gists_url")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			e.FieldStart("starred_url")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			e.FieldStart("subscriptions_url")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			e.FieldStart("organizations_url")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			e.FieldStart("repos_url")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			e.FieldStart("received_events_url")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			e.FieldStart("site_admin")
			s.SiteAdmin.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchRestrictionPolicyUsersItem = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes BranchRestrictionPolicyUsersItem from json.
func (s *BranchRestrictionPolicyUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyUsersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchRestrictionPolicyUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchRestrictionPolicyUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchShort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchShort) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("protected")
		e.Bool(s.Protected)
	}
}

var jsonFieldsNameOfBranchShort = [3]string{
	0: "name",
	1: "commit",
	2: "protected",
}

// Decode decodes BranchShort from json.
func (s *BranchShort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchShort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchShort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchShort) {
					name = jsonFieldsNameOfBranchShort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchShort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchShort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchShortCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchShortCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfBranchShortCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes BranchShortCommit from json.
func (s *BranchShortCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchShortCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchShortCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchShortCommit) {
					name = jsonFieldsNameOfBranchShortCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchShortCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchShortCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchWithProtection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchWithProtection) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		e.FieldStart("protected")
		e.Bool(s.Protected)
	}
	{
		e.FieldStart("protection")
		s.Protection.Encode(e)
	}
	{
		e.FieldStart("protection_url")
		json.EncodeURI(e, s.ProtectionURL)
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.FieldStart("required_approving_review_count")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchWithProtection = [8]string{
	0: "name",
	1: "commit",
	2: "_links",
	3: "protected",
	4: "protection",
	5: "protection_url",
	6: "pattern",
	7: "required_approving_review_count",
}

// Decode decodes BranchWithProtection from json.
func (s *BranchWithProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchWithProtection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "_links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		case "protection":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Protection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection\"")
			}
		case "protection_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProtectionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchWithProtection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchWithProtection) {
					name = jsonFieldsNameOfBranchWithProtection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchWithProtection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchWithProtection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchWithProtectionLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchWithProtectionLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("html")
		e.Str(s.HTML)
	}
	{
		e.FieldStart("self")
		json.EncodeURI(e, s.Self)
	}
}

var jsonFieldsNameOfBranchWithProtectionLinks = [2]string{
	0: "html",
	1: "self",
}

// Decode decodes BranchWithProtectionLinks from json.
func (s *BranchWithProtectionLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchWithProtectionLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchWithProtectionLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchWithProtectionLinks) {
					name = jsonFieldsNameOfBranchWithProtectionLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchWithProtectionLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchWithProtectionLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckAnnotation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("start_line")
		e.Int(s.StartLine)
	}
	{
		e.FieldStart("end_line")
		e.Int(s.EndLine)
	}
	{
		e.FieldStart("start_column")
		s.StartColumn.Encode(e)
	}
	{
		e.FieldStart("end_column")
		s.EndColumn.Encode(e)
	}
	{
		e.FieldStart("annotation_level")
		s.AnnotationLevel.Encode(e)
	}
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	{
		e.FieldStart("raw_details")
		s.RawDetails.Encode(e)
	}
	{
		e.FieldStart("blob_href")
		e.Str(s.BlobHref)
	}
}

var jsonFieldsNameOfCheckAnnotation = [10]string{
	0: "path",
	1: "start_line",
	2: "end_line",
	3: "start_column",
	4: "end_column",
	5: "annotation_level",
	6: "title",
	7: "message",
	8: "raw_details",
	9: "blob_href",
}

// Decode decodes CheckAnnotation from json.
func (s *CheckAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAnnotation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "start_line":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StartLine = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "end_line":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.EndLine = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_line\"")
			}
		case "start_column":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.StartColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_column\"")
			}
		case "end_column":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EndColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_column\"")
			}
		case "annotation_level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.AnnotationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotation_level\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "raw_details":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.RawDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_details\"")
			}
		case "blob_href":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BlobHref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckAnnotation) {
					name = jsonFieldsNameOfCheckAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckAnnotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckAnnotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckRun) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckRun) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("head_sha")
		e.Str(s.HeadSha)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("external_id")
		s.ExternalID.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("details_url")
		s.DetailsURL.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("conclusion")
		s.Conclusion.Encode(e)
	}
	{
		e.FieldStart("started_at")
		s.StartedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("check_suite")
		s.CheckSuite.Encode(e)
	}
	{
		e.FieldStart("app")
		s.App.Encode(e)
	}
	{
		e.FieldStart("pull_requests")
		e.ArrStart()
		for _, elem := range s.PullRequests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Deployment.Set {
			e.FieldStart("deployment")
			s.Deployment.Encode(e)
		}
	}
}

var jsonFieldsNameOfCheckRun = [17]string{
	0:  "id",
	1:  "head_sha",
	2:  "node_id",
	3:  "external_id",
	4:  "url",
	5:  "html_url",
	6:  "details_url",
	7:  "status",
	8:  "conclusion",
	9:  "started_at",
	10: "completed_at",
	11: "output",
	12: "name",
	13: "check_suite",
	14: "app",
	15: "pull_requests",
	16: "deployment",
}

// Decode decodes CheckRun from json.
func (s *CheckRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRun to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "external_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "details_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.DetailsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details_url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "started_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "output":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "check_suite":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CheckSuite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite\"")
			}
		case "app":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.PullRequests = make([]PullRequestMinimal, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestMinimal
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PullRequests = append(s.PullRequests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "deployment":
			if err := func() error {
				s.Deployment.Reset()
				if err := s.Deployment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRun) {
					name = jsonFieldsNameOfCheckRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckRun) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRun) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckRunCheckSuite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckRunCheckSuite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
}

var jsonFieldsNameOfCheckRunCheckSuite = [1]string{
	0: "id",
}

// Decode decodes CheckRunCheckSuite from json.
func (s *CheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunCheckSuite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRunCheckSuite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRunCheckSuite) {
					name = jsonFieldsNameOfCheckRunCheckSuite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckRunCheckSuite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRunCheckSuite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckRunConclusion as json.
func (s CheckRunConclusion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckRunConclusion from json.
func (s *CheckRunConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunConclusion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunConclusion(v) {
	case CheckRunConclusionSuccess:
		*s = CheckRunConclusionSuccess
	case CheckRunConclusionFailure:
		*s = CheckRunConclusionFailure
	case CheckRunConclusionNeutral:
		*s = CheckRunConclusionNeutral
	case CheckRunConclusionCancelled:
		*s = CheckRunConclusionCancelled
	case CheckRunConclusionSkipped:
		*s = CheckRunConclusionSkipped
	case CheckRunConclusionTimedOut:
		*s = CheckRunConclusionTimedOut
	case CheckRunConclusionActionRequired:
		*s = CheckRunConclusionActionRequired
	default:
		*s = CheckRunConclusion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckRunConclusion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRunConclusion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckRunOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckRunOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("summary")
		s.Summary.Encode(e)
	}
	{
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	{
		e.FieldStart("annotations_count")
		e.Int(s.AnnotationsCount)
	}
	{
		e.FieldStart("annotations_url")
		json.EncodeURI(e, s.AnnotationsURL)
	}
}

var jsonFieldsNameOfCheckRunOutput = [5]string{
	0: "title",
	1: "summary",
	2: "text",
	3: "annotations_count",
	4: "annotations_url",
}

// Decode decodes CheckRunOutput from json.
func (s *CheckRunOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "annotations_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AnnotationsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations_count\"")
			}
		case "annotations_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AnnotationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRunOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRunOutput) {
					name = jsonFieldsNameOfCheckRunOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckRunOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRunOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckRunStatus as json.
func (s CheckRunStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckRunStatus from json.
func (s *CheckRunStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunStatus(v) {
	case CheckRunStatusQueued:
		*s = CheckRunStatusQueued
	case CheckRunStatusInProgress:
		*s = CheckRunStatusInProgress
	case CheckRunStatusCompleted:
		*s = CheckRunStatusCompleted
	default:
		*s = CheckRunStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckRunStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRunStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSuite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSuite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("head_branch")
		s.HeadBranch.Encode(e)
	}
	{
		e.FieldStart("head_sha")
		e.Str(s.HeadSha)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("conclusion")
		s.Conclusion.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("before")
		s.Before.Encode(e)
	}
	{
		e.FieldStart("after")
		s.After.Encode(e)
	}
	{
		e.FieldStart("pull_requests")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.PullRequests {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("app")
		s.App.Encode(e)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("head_commit")
		s.HeadCommit.Encode(e)
	}
	{
		e.FieldStart("latest_check_runs_count")
		e.Int(s.LatestCheckRunsCount)
	}
	{
		e.FieldStart("check_runs_url")
		e.Str(s.CheckRunsURL)
	}
}

var jsonFieldsNameOfCheckSuite = [17]string{
	0:  "id",
	1:  "node_id",
	2:  "head_branch",
	3:  "head_sha",
	4:  "status",
	5:  "conclusion",
	6:  "url",
	7:  "before",
	8:  "after",
	9:  "pull_requests",
	10: "app",
	11: "repository",
	12: "created_at",
	13: "updated_at",
	14: "head_commit",
	15: "latest_check_runs_count",
	16: "check_runs_url",
}

// Decode decodes CheckSuite from json.
func (s *CheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuite to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "head_branch":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HeadBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_branch\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "before":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Before.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"before\"")
			}
		case "after":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.After.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.PullRequests = make([]PullRequestMinimal, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem PullRequestMinimal
						if err := elem.Decode(d); err != nil {
							return err
						}
						s.PullRequests = append(s.PullRequests, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "app":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "repository":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "head_commit":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.HeadCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_commit\"")
			}
		case "latest_check_runs_count":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.LatestCheckRunsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_runs_count\"")
			}
		case "check_runs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CheckRunsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuite) {
					name = jsonFieldsNameOfCheckSuite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSuite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckSuiteConclusion as json.
func (s CheckSuiteConclusion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteConclusion from json.
func (s *CheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuiteConclusion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteConclusion(v) {
	case CheckSuiteConclusionSuccess:
		*s = CheckSuiteConclusionSuccess
	case CheckSuiteConclusionFailure:
		*s = CheckSuiteConclusionFailure
	case CheckSuiteConclusionNeutral:
		*s = CheckSuiteConclusionNeutral
	case CheckSuiteConclusionCancelled:
		*s = CheckSuiteConclusionCancelled
	case CheckSuiteConclusionSkipped:
		*s = CheckSuiteConclusionSkipped
	case CheckSuiteConclusionTimedOut:
		*s = CheckSuiteConclusionTimedOut
	case CheckSuiteConclusionActionRequired:
		*s = CheckSuiteConclusionActionRequired
	default:
		*s = CheckSuiteConclusion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckSuiteConclusion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuiteConclusion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSuitePreference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSuitePreference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("preferences")
		s.Preferences.Encode(e)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
}

var jsonFieldsNameOfCheckSuitePreference = [2]string{
	0: "preferences",
	1: "repository",
}

// Decode decodes CheckSuitePreference from json.
func (s *CheckSuitePreference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferences":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Preferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferences\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuitePreference) {
					name = jsonFieldsNameOfCheckSuitePreference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSuitePreference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuitePreference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSuitePreferencePreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSuitePreferencePreferences) encodeFields(e *jx.Encoder) {
	{
		if s.AutoTriggerChecks != nil {
			e.FieldStart("auto_trigger_checks")
			e.ArrStart()
			for _, elem := range s.AutoTriggerChecks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCheckSuitePreferencePreferences = [1]string{
	0: "auto_trigger_checks",
}

// Decode decodes CheckSuitePreferencePreferences from json.
func (s *CheckSuitePreferencePreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreferencePreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			if err := func() error {
				s.AutoTriggerChecks = make([]CheckSuitePreferencePreferencesAutoTriggerChecksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSuitePreferencePreferencesAutoTriggerChecksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_trigger_checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreferencePreferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSuitePreferencePreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuitePreferencePreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("app_id")
		e.Int(s.AppID)
	}
	{
		e.FieldStart("setting")
		e.Bool(s.Setting)
	}
}

var jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem = [2]string{
	0: "app_id",
	1: "setting",
}

// Decode decodes CheckSuitePreferencePreferencesAutoTriggerChecksItem from json.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreferencePreferencesAutoTriggerChecksItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AppID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_id\"")
			}
		case "setting":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Setting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreferencePreferencesAutoTriggerChecksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem) {
					name = jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckSuiteStatus as json.
func (s CheckSuiteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteStatus from json.
func (s *CheckSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuiteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteStatus(v) {
	case CheckSuiteStatusQueued:
		*s = CheckSuiteStatusQueued
	case CheckSuiteStatusInProgress:
		*s = CheckSuiteStatusInProgress
	case CheckSuiteStatusCompleted:
		*s = CheckSuiteStatusCompleted
	default:
		*s = CheckSuiteStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckSuiteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckSuiteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChecksCreateSuiteCreated as json.
func (s *ChecksCreateSuiteCreated) Encode(e *jx.Encoder) {
	unwrapped := (*CheckSuite)(s)

	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteCreated from json.
func (s *ChecksCreateSuiteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteCreated to nil")
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksCreateSuiteCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksCreateSuiteCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChecksCreateSuiteOK as json.
func (s *ChecksCreateSuiteOK) Encode(e *jx.Encoder) {
	unwrapped := (*CheckSuite)(s)

	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteOK from json.
func (s *ChecksCreateSuiteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteOK to nil")
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksCreateSuiteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksCreateSuiteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksCreateSuiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksCreateSuiteReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("head_sha")
		e.Str(s.HeadSha)
	}
}

var jsonFieldsNameOfChecksCreateSuiteReq = [1]string{
	0: "head_sha",
}

// Decode decodes ChecksCreateSuiteReq from json.
func (s *ChecksCreateSuiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "head_sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksCreateSuiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksCreateSuiteReq) {
					name = jsonFieldsNameOfChecksCreateSuiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksCreateSuiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksCreateSuiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksListForRefOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksListForRefOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("check_runs")
		e.ArrStart()
		for _, elem := range s.CheckRuns {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChecksListForRefOK = [2]string{
	0: "total_count",
	1: "check_runs",
}

// Decode decodes ChecksListForRefOK from json.
func (s *ChecksListForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListForRefOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckRuns = make([]CheckRun, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckRuns = append(s.CheckRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListForRefOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListForRefOK) {
					name = jsonFieldsNameOfChecksListForRefOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksListForRefOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksListForRefOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksListForSuiteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksListForSuiteOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("check_runs")
		e.ArrStart()
		for _, elem := range s.CheckRuns {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChecksListForSuiteOK = [2]string{
	0: "total_count",
	1: "check_runs",
}

// Decode decodes ChecksListForSuiteOK from json.
func (s *ChecksListForSuiteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListForSuiteOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckRuns = make([]CheckRun, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckRuns = append(s.CheckRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListForSuiteOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListForSuiteOK) {
					name = jsonFieldsNameOfChecksListForSuiteOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksListForSuiteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksListForSuiteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksListSuitesForRefOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksListSuitesForRefOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("check_suites")
		e.ArrStart()
		for _, elem := range s.CheckSuites {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChecksListSuitesForRefOK = [2]string{
	0: "total_count",
	1: "check_suites",
}

// Decode decodes ChecksListSuitesForRefOK from json.
func (s *ChecksListSuitesForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListSuitesForRefOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_suites":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckSuites = make([]CheckSuite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSuite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckSuites = append(s.CheckSuites, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suites\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListSuitesForRefOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListSuitesForRefOK) {
					name = jsonFieldsNameOfChecksListSuitesForRefOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksListSuitesForRefOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksListSuitesForRefOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksRerequestSuiteCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksRerequestSuiteCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfChecksRerequestSuiteCreated = [0]string{}

// Decode decodes ChecksRerequestSuiteCreated from json.
func (s *ChecksRerequestSuiteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksRerequestSuiteCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ChecksRerequestSuiteCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksRerequestSuiteCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksRerequestSuiteCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksSetSuitesPreferencesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksSetSuitesPreferencesReq) encodeFields(e *jx.Encoder) {
	{
		if s.AutoTriggerChecks != nil {
			e.FieldStart("auto_trigger_checks")
			e.ArrStart()
			for _, elem := range s.AutoTriggerChecks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfChecksSetSuitesPreferencesReq = [1]string{
	0: "auto_trigger_checks",
}

// Decode decodes ChecksSetSuitesPreferencesReq from json.
func (s *ChecksSetSuitesPreferencesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksSetSuitesPreferencesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			if err := func() error {
				s.AutoTriggerChecks = make([]ChecksSetSuitesPreferencesReqAutoTriggerChecksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_trigger_checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksSetSuitesPreferencesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksSetSuitesPreferencesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksSetSuitesPreferencesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("app_id")
		e.Int(s.AppID)
	}
	{
		e.FieldStart("setting")
		e.Bool(s.Setting)
	}
}

var jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem = [2]string{
	0: "app_id",
	1: "setting",
}

// Decode decodes ChecksSetSuitesPreferencesReqAutoTriggerChecksItem from json.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AppID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_id\"")
			}
		case "setting":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Setting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem) {
					name = jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CloneTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CloneTraffic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("uniques")
		e.Int(s.Uniques)
	}
	{
		e.FieldStart("clones")
		e.ArrStart()
		for _, elem := range s.Clones {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCloneTraffic = [3]string{
	0: "count",
	1: "uniques",
	2: "clones",
}

// Decode decodes CloneTraffic from json.
func (s *CloneTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CloneTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "clones":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Clones = make([]Traffic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Traffic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clones = append(s.Clones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CloneTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCloneTraffic) {
					name = jsonFieldsNameOfCloneTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CloneTraffic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CloneTraffic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeFrequencyStat as json.
func (s CodeFrequencyStat) Encode(e *jx.Encoder) {
	unwrapped := []int(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Int(elem)
	}
	e.ArrEnd()
}

// Decode decodes CodeFrequencyStat from json.
func (s *CodeFrequencyStat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeFrequencyStat to nil")
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = make([]int, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeFrequencyStat(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeFrequencyStat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeFrequencyStat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeOfConduct) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeOfConduct) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
}

var jsonFieldsNameOfCodeOfConduct = [5]string{
	0: "key",
	1: "name",
	2: "url",
	3: "body",
	4: "html_url",
}

// Decode decodes CodeOfConduct from json.
func (s *CodeOfConduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeOfConduct to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeOfConduct")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeOfConduct) {
					name = jsonFieldsNameOfCodeOfConduct[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeOfConduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeOfConduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeOfConductSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeOfConductSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
}

var jsonFieldsNameOfCodeOfConductSimple = [4]string{
	0: "url",
	1: "key",
	2: "name",
	3: "html_url",
}

// Decode decodes CodeOfConductSimple from json.
func (s *CodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeOfConductSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeOfConductSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeOfConductSimple) {
					name = jsonFieldsNameOfCodeOfConductSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeOfConductSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeOfConductSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlert) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number")
		s.Number.Encode(e)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		if len(s.Instances) != 0 {
			e.FieldStart("instances")
			e.Raw(s.Instances)
		}
	}
	{
		e.FieldStart("instances_url")
		s.InstancesURL.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("dismissed_by")
		s.DismissedBy.Encode(e)
	}
	{
		e.FieldStart("dismissed_at")
		s.DismissedAt.Encode(e)
	}
	{
		e.FieldStart("dismissed_reason")
		s.DismissedReason.Encode(e)
	}
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		e.FieldStart("tool")
		s.Tool.Encode(e)
	}
	{
		e.FieldStart("most_recent_instance")
		s.MostRecentInstance.Encode(e)
	}
}

var jsonFieldsNameOfCodeScanningAlert = [13]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "instances",
	5:  "instances_url",
	6:  "state",
	7:  "dismissed_by",
	8:  "dismissed_at",
	9:  "dismissed_reason",
	10: "rule",
	11: "tool",
	12: "most_recent_instance",
}

// Decode decodes CodeScanningAlert from json.
func (s *CodeScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlert to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "instances":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Instances = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances\"")
			}
		case "instances_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.InstancesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances_url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_by":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DismissedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_by\"")
			}
		case "dismissed_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.DismissedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_at\"")
			}
		case "dismissed_reason":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		case "rule":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "most_recent_instance":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.MostRecentInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlert")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAlert) {
					name = jsonFieldsNameOfCodeScanningAlert[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlert) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlert) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertClassification as json.
func (s CodeScanningAlertClassification) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertClassification from json.
func (s *CodeScanningAlertClassification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertClassification to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertClassification(v) {
	case CodeScanningAlertClassificationSource:
		*s = CodeScanningAlertClassificationSource
	case CodeScanningAlertClassificationGenerated:
		*s = CodeScanningAlertClassificationGenerated
	case CodeScanningAlertClassificationTest:
		*s = CodeScanningAlertClassificationTest
	case CodeScanningAlertClassificationLibrary:
		*s = CodeScanningAlertClassificationLibrary
	default:
		*s = CodeScanningAlertClassification(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertClassification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertClassification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (s CodeScanningAlertDismissedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (s *CodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertDismissedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertDismissedAt(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertDismissedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertDismissedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (s CodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (s *CodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertDismissedReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertDismissedReason(v) {
	case CodeScanningAlertDismissedReasonFalsePositive:
		*s = CodeScanningAlertDismissedReasonFalsePositive
	case CodeScanningAlertDismissedReasonWonTFix:
		*s = CodeScanningAlertDismissedReasonWonTFix
	case CodeScanningAlertDismissedReasonUsedInTests:
		*s = CodeScanningAlertDismissedReasonUsedInTests
	default:
		*s = CodeScanningAlertDismissedReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertDismissedReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertDismissedReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (s CodeScanningAlertEnvironment) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (s *CodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertEnvironment to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertEnvironment(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertInstance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertInstance) encodeFields(e *jx.Encoder) {
	{
		if s.Ref.Set {
			e.FieldStart("ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.AnalysisKey.Set {
			e.FieldStart("analysis_key")
			s.AnalysisKey.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.CommitSha.Set {
			e.FieldStart("commit_sha")
			s.CommitSha.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Classifications != nil {
			e.FieldStart("classifications")
			e.ArrStart()
			for _, elem := range s.Classifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCodeScanningAlertInstance = [10]string{
	0: "ref",
	1: "analysis_key",
	2: "environment",
	3: "category",
	4: "state",
	5: "commit_sha",
	6: "message",
	7: "location",
	8: "html_url",
	9: "classifications",
}

// Decode decodes CodeScanningAlertInstance from json.
func (s *CodeScanningAlertInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertInstance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "analysis_key":
			if err := func() error {
				s.AnalysisKey.Reset()
				if err := s.AnalysisKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_key\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "commit_sha":
			if err := func() error {
				s.CommitSha.Reset()
				if err := s.CommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "classifications":
			if err := func() error {
				s.Classifications = make([]NilCodeScanningAlertClassification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilCodeScanningAlertClassification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Classifications = append(s.Classifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertInstance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertInstanceMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertInstanceMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAlertInstanceMessage = [1]string{
	0: "text",
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (s *CodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertInstanceMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertInstanceMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertInstanceMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertInstanceMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertItems) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertItems) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number")
		s.Number.Encode(e)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("instances_url")
		s.InstancesURL.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("dismissed_by")
		s.DismissedBy.Encode(e)
	}
	{
		e.FieldStart("dismissed_at")
		s.DismissedAt.Encode(e)
	}
	{
		e.FieldStart("dismissed_reason")
		s.DismissedReason.Encode(e)
	}
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		e.FieldStart("tool")
		s.Tool.Encode(e)
	}
	{
		e.FieldStart("most_recent_instance")
		s.MostRecentInstance.Encode(e)
	}
}

var jsonFieldsNameOfCodeScanningAlertItems = [12]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "instances_url",
	5:  "state",
	6:  "dismissed_by",
	7:  "dismissed_at",
	8:  "dismissed_reason",
	9:  "rule",
	10: "tool",
	11: "most_recent_instance",
}

// Decode decodes CodeScanningAlertItems from json.
func (s *CodeScanningAlertItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertItems to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "instances_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.InstancesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances_url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_by":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.DismissedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_by\"")
			}
		case "dismissed_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DismissedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_at\"")
			}
		case "dismissed_reason":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		case "rule":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "most_recent_instance":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.MostRecentInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertItems")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAlertItems) {
					name = jsonFieldsNameOfCodeScanningAlertItems[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertLocation) encodeFields(e *jx.Encoder) {
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.FieldStart("start_line")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.EndLine.Set {
			e.FieldStart("end_line")
			s.EndLine.Encode(e)
		}
	}
	{
		if s.StartColumn.Set {
			e.FieldStart("start_column")
			s.StartColumn.Encode(e)
		}
	}
	{
		if s.EndColumn.Set {
			e.FieldStart("end_column")
			s.EndColumn.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAlertLocation = [5]string{
	0: "path",
	1: "start_line",
	2: "end_line",
	3: "start_column",
	4: "end_column",
}

// Decode decodes CodeScanningAlertLocation from json.
func (s *CodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "end_line":
			if err := func() error {
				s.EndLine.Reset()
				if err := s.EndLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_line\"")
			}
		case "start_column":
			if err := func() error {
				s.StartColumn.Reset()
				if err := s.StartColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_column\"")
			}
		case "end_column":
			if err := func() error {
				s.EndColumn.Reset()
				if err := s.EndColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_column\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertLocation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertRule) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.SecuritySeverityLevel.Set {
			e.FieldStart("security_severity_level")
			s.SecuritySeverityLevel.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.FullDescription.Set {
			e.FieldStart("full_description")
			s.FullDescription.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Help.Set {
			e.FieldStart("help")
			s.Help.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAlertRule = [8]string{
	0: "id",
	1: "name",
	2: "severity",
	3: "security_severity_level",
	4: "description",
	5: "full_description",
	6: "tags",
	7: "help",
}

// Decode decodes CodeScanningAlertRule from json.
func (s *CodeScanningAlertRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "security_severity_level":
			if err := func() error {
				s.SecuritySeverityLevel.Reset()
				if err := s.SecuritySeverityLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_severity_level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "full_description":
			if err := func() error {
				s.FullDescription.Reset()
				if err := s.FullDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "help":
			if err := func() error {
				s.Help.Reset()
				if err := s.Help.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"help\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (s CodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (s *CodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSecuritySeverityLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSecuritySeverityLevel(v) {
	case CodeScanningAlertRuleSecuritySeverityLevelLow:
		*s = CodeScanningAlertRuleSecuritySeverityLevelLow
	case CodeScanningAlertRuleSecuritySeverityLevelMedium:
		*s = CodeScanningAlertRuleSecuritySeverityLevelMedium
	case CodeScanningAlertRuleSecuritySeverityLevelHigh:
		*s = CodeScanningAlertRuleSecuritySeverityLevelHigh
	case CodeScanningAlertRuleSecuritySeverityLevelCritical:
		*s = CodeScanningAlertRuleSecuritySeverityLevelCritical
	default:
		*s = CodeScanningAlertRuleSecuritySeverityLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertRuleSecuritySeverityLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertRuleSecuritySeverityLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (s CodeScanningAlertRuleSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (s *CodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSeverity(v) {
	case CodeScanningAlertRuleSeverityNone:
		*s = CodeScanningAlertRuleSeverityNone
	case CodeScanningAlertRuleSeverityNote:
		*s = CodeScanningAlertRuleSeverityNote
	case CodeScanningAlertRuleSeverityWarning:
		*s = CodeScanningAlertRuleSeverityWarning
	case CodeScanningAlertRuleSeverityError:
		*s = CodeScanningAlertRuleSeverityError
	default:
		*s = CodeScanningAlertRuleSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertRuleSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertRuleSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAlertRuleSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAlertRuleSummary) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAlertRuleSummary = [4]string{
	0: "id",
	1: "name",
	2: "severity",
	3: "description",
}

// Decode decodes CodeScanningAlertRuleSummary from json.
func (s *CodeScanningAlertRuleSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertRuleSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAlertRuleSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertRuleSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (s CodeScanningAlertRuleSummarySeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (s *CodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSummarySeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSummarySeverity(v) {
	case CodeScanningAlertRuleSummarySeverityNone:
		*s = CodeScanningAlertRuleSummarySeverityNone
	case CodeScanningAlertRuleSummarySeverityNote:
		*s = CodeScanningAlertRuleSummarySeverityNote
	case CodeScanningAlertRuleSummarySeverityWarning:
		*s = CodeScanningAlertRuleSummarySeverityWarning
	case CodeScanningAlertRuleSummarySeverityError:
		*s = CodeScanningAlertRuleSummarySeverityError
	default:
		*s = CodeScanningAlertRuleSummarySeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertRuleSummarySeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertRuleSummarySeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertSetState as json.
func (s CodeScanningAlertSetState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertSetState from json.
func (s *CodeScanningAlertSetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertSetState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertSetState(v) {
	case CodeScanningAlertSetStateOpen:
		*s = CodeScanningAlertSetStateOpen
	case CodeScanningAlertSetStateDismissed:
		*s = CodeScanningAlertSetStateDismissed
	default:
		*s = CodeScanningAlertSetState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertSetState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertSetState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertState as json.
func (s CodeScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertState from json.
func (s *CodeScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertState(v) {
	case CodeScanningAlertStateOpen:
		*s = CodeScanningAlertStateOpen
	case CodeScanningAlertStateClosed:
		*s = CodeScanningAlertStateClosed
	case CodeScanningAlertStateDismissed:
		*s = CodeScanningAlertStateDismissed
	case CodeScanningAlertStateFixed:
		*s = CodeScanningAlertStateFixed
	default:
		*s = CodeScanningAlertState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAlertState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAlertState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAnalysis) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		s.Ref.Encode(e)
	}
	{
		e.FieldStart("commit_sha")
		s.CommitSha.Encode(e)
	}
	{
		e.FieldStart("analysis_key")
		s.AnalysisKey.Encode(e)
	}
	{
		e.FieldStart("environment")
		s.Environment.Encode(e)
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	{
		e.FieldStart("results_count")
		e.Int(s.ResultsCount)
	}
	{
		e.FieldStart("rules_count")
		e.Int(s.RulesCount)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("sarif_id")
		s.SarifID.Encode(e)
	}
	{
		e.FieldStart("tool")
		s.Tool.Encode(e)
	}
	{
		e.FieldStart("deletable")
		e.Bool(s.Deletable)
	}
	{
		e.FieldStart("warning")
		e.Str(s.Warning)
	}
	{
		if s.ToolName.Set {
			e.FieldStart("tool_name")
			s.ToolName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAnalysis = [16]string{
	0:  "ref",
	1:  "commit_sha",
	2:  "analysis_key",
	3:  "environment",
	4:  "category",
	5:  "error",
	6:  "created_at",
	7:  "results_count",
	8:  "rules_count",
	9:  "id",
	10: "url",
	11: "sarif_id",
	12: "tool",
	13: "deletable",
	14: "warning",
	15: "tool_name",
}

// Decode decodes CodeScanningAnalysis from json.
func (s *CodeScanningAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysis to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "commit_sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "analysis_key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.AnalysisKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_key\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "results_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResultsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results_count\"")
			}
		case "rules_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RulesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules_count\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sarif_id":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.SarifID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sarif_id\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "deletable":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Deletable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletable\"")
			}
		case "warning":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Warning = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warning\"")
			}
		case "tool_name":
			if err := func() error {
				s.ToolName.Reset()
				if err := s.ToolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysis")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAnalysis) {
					name = jsonFieldsNameOfCodeScanningAnalysis[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (s CodeScanningAnalysisAnalysisKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (s *CodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisAnalysisKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisAnalysisKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisAnalysisKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisAnalysisKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (s CodeScanningAnalysisCategory) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (s *CodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCategory to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCategory(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisCommitSha as json.
func (s CodeScanningAnalysisCommitSha) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCommitSha from json.
func (s *CodeScanningAnalysisCommitSha) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCommitSha to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCommitSha(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisCommitSha) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisCommitSha) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisCreatedAt as json.
func (s CodeScanningAnalysisCreatedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisCreatedAt from json.
func (s *CodeScanningAnalysisCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCreatedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCreatedAt(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisCreatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisCreatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAnalysisDeletion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAnalysisDeletion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("next_analysis_url")
		s.NextAnalysisURL.Encode(e)
	}
	{
		e.FieldStart("confirm_delete_url")
		s.ConfirmDeleteURL.Encode(e)
	}
}

var jsonFieldsNameOfCodeScanningAnalysisDeletion = [2]string{
	0: "next_analysis_url",
	1: "confirm_delete_url",
}

// Decode decodes CodeScanningAnalysisDeletion from json.
func (s *CodeScanningAnalysisDeletion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisDeletion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "next_analysis_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NextAnalysisURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_analysis_url\"")
			}
		case "confirm_delete_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfirmDeleteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confirm_delete_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysisDeletion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAnalysisDeletion) {
					name = jsonFieldsNameOfCodeScanningAnalysisDeletion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAnalysisDeletion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisDeletion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisEnvironment as json.
func (s CodeScanningAnalysisEnvironment) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisEnvironment from json.
func (s *CodeScanningAnalysisEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisEnvironment to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisEnvironment(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisSarifFile as json.
func (s CodeScanningAnalysisSarifFile) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifFile from json.
func (s *CodeScanningAnalysisSarifFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisSarifFile to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifFile(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisSarifFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisSarifFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (s CodeScanningAnalysisSarifID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (s *CodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisSarifID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisSarifID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisSarifID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningAnalysisTool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningAnalysisTool) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.GUID.Set {
			e.FieldStart("guid")
			s.GUID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningAnalysisTool = [3]string{
	0: "name",
	1: "version",
	2: "guid",
}

// Decode decodes CodeScanningAnalysisTool from json.
func (s *CodeScanningAnalysisTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisTool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "guid":
			if err := func() error {
				s.GUID.Reset()
				if err := s.GUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysisTool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningAnalysisTool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisTool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (s CodeScanningAnalysisToolGUID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (s *CodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolGUID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolGUID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisToolGUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisToolGUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (s CodeScanningAnalysisToolName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (s *CodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisToolName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisToolName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (s CodeScanningAnalysisToolVersion) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (s *CodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolVersion to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolVersion(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisToolVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisToolVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisURL as json.
func (s CodeScanningAnalysisURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisURL from json.
func (s *CodeScanningAnalysisURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningAnalysisURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningAnalysisURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningDeleteAnalysisBadRequest as json.
func (s *CodeScanningDeleteAnalysisBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisBadRequest from json.
func (s *CodeScanningDeleteAnalysisBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningDeleteAnalysisBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningDeleteAnalysisBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningDeleteAnalysisForbidden as json.
func (s *CodeScanningDeleteAnalysisForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisForbidden from json.
func (s *CodeScanningDeleteAnalysisForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningDeleteAnalysisForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningDeleteAnalysisForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningDeleteAnalysisNotFound as json.
func (s *CodeScanningDeleteAnalysisNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisNotFound from json.
func (s *CodeScanningDeleteAnalysisNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningDeleteAnalysisNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningDeleteAnalysisNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningGetAlertForbidden as json.
func (s *CodeScanningGetAlertForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertForbidden from json.
func (s *CodeScanningGetAlertForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAlertForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningGetAlertForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningGetAlertForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningGetAlertNotFound as json.
func (s *CodeScanningGetAlertNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertNotFound from json.
func (s *CodeScanningGetAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAlertNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningGetAlertNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningGetAlertNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningGetAnalysisForbidden as json.
func (s *CodeScanningGetAnalysisForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisForbidden from json.
func (s *CodeScanningGetAnalysisForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAnalysisForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningGetAnalysisForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningGetAnalysisForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningGetAnalysisNotFound as json.
func (s *CodeScanningGetAnalysisNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisNotFound from json.
func (s *CodeScanningGetAnalysisNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAnalysisNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningGetAnalysisNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningGetAnalysisNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertInstancesForbidden as json.
func (s *CodeScanningListAlertInstancesForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesForbidden from json.
func (s *CodeScanningListAlertInstancesForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListAlertInstancesForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertInstancesForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertInstancesNotFound as json.
func (s *CodeScanningListAlertInstancesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesNotFound from json.
func (s *CodeScanningListAlertInstancesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListAlertInstancesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertInstancesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertInstancesOKApplicationJSON as json.
func (s CodeScanningListAlertInstancesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAlertInstance(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertInstancesOKApplicationJSON from json.
func (s *CodeScanningListAlertInstancesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAlertInstance
	if err := func() error {
		unwrapped = make([]CodeScanningAlertInstance, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertInstance
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningListAlertInstancesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertInstancesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertsForRepoForbidden as json.
func (s *CodeScanningListAlertsForRepoForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoForbidden from json.
func (s *CodeScanningListAlertsForRepoForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListAlertsForRepoForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertsForRepoForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertsForRepoNotFound as json.
func (s *CodeScanningListAlertsForRepoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoNotFound from json.
func (s *CodeScanningListAlertsForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListAlertsForRepoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertsForRepoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListAlertsForRepoOKApplicationJSON as json.
func (s CodeScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAlertItems(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertsForRepoOKApplicationJSON from json.
func (s *CodeScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAlertItems
	if err := func() error {
		unwrapped = make([]CodeScanningAlertItems, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertItems
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningListAlertsForRepoOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListAlertsForRepoOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListRecentAnalysesForbidden as json.
func (s *CodeScanningListRecentAnalysesForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesForbidden from json.
func (s *CodeScanningListRecentAnalysesForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListRecentAnalysesForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListRecentAnalysesForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListRecentAnalysesNotFound as json.
func (s *CodeScanningListRecentAnalysesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesNotFound from json.
func (s *CodeScanningListRecentAnalysesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningListRecentAnalysesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListRecentAnalysesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningListRecentAnalysesOKApplicationJSON as json.
func (s CodeScanningListRecentAnalysesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAnalysis(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListRecentAnalysesOKApplicationJSON from json.
func (s *CodeScanningListRecentAnalysesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAnalysis
	if err := func() error {
		unwrapped = make([]CodeScanningAnalysis, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAnalysis
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningListRecentAnalysesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningListRecentAnalysesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningRef as json.
func (s CodeScanningRef) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CodeScanningRef from json.
func (s *CodeScanningRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningRef to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningRef(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningSarifsReceipt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningSarifsReceipt) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningSarifsReceipt = [2]string{
	0: "id",
	1: "url",
}

// Decode decodes CodeScanningSarifsReceipt from json.
func (s *CodeScanningSarifsReceipt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsReceipt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningSarifsReceipt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningSarifsReceipt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningSarifsReceipt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningSarifsStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningSarifsStatus) encodeFields(e *jx.Encoder) {
	{
		if s.ProcessingStatus.Set {
			e.FieldStart("processing_status")
			s.ProcessingStatus.Encode(e)
		}
	}
	{
		if s.AnalysesURL.Set {
			e.FieldStart("analyses_url")
			s.AnalysesURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningSarifsStatus = [2]string{
	0: "processing_status",
	1: "analyses_url",
}

// Decode decodes CodeScanningSarifsStatus from json.
func (s *CodeScanningSarifsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_status":
			if err := func() error {
				s.ProcessingStatus.Reset()
				if err := s.ProcessingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_status\"")
			}
		case "analyses_url":
			if err := func() error {
				s.AnalysesURL.Reset()
				if err := s.AnalysesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyses_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningSarifsStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningSarifsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningSarifsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (s CodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (s *CodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsStatusProcessingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningSarifsStatusProcessingStatus(v) {
	case CodeScanningSarifsStatusProcessingStatusPending:
		*s = CodeScanningSarifsStatusProcessingStatusPending
	case CodeScanningSarifsStatusProcessingStatusComplete:
		*s = CodeScanningSarifsStatusProcessingStatusComplete
	default:
		*s = CodeScanningSarifsStatusProcessingStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodeScanningSarifsStatusProcessingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningSarifsStatusProcessingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningUpdateAlertForbidden as json.
func (s *CodeScanningUpdateAlertForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertForbidden from json.
func (s *CodeScanningUpdateAlertForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUpdateAlertForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUpdateAlertForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningUpdateAlertNotFound as json.
func (s *CodeScanningUpdateAlertNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertNotFound from json.
func (s *CodeScanningUpdateAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUpdateAlertNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUpdateAlertNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningUpdateAlertReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningUpdateAlertReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.DismissedReason.Set {
			e.FieldStart("dismissed_reason")
			s.DismissedReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningUpdateAlertReq = [2]string{
	0: "state",
	1: "dismissed_reason",
}

// Decode decodes CodeScanningUpdateAlertReq from json.
func (s *CodeScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_reason":
			if err := func() error {
				s.DismissedReason.Reset()
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningUpdateAlertReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningUpdateAlertReq) {
					name = jsonFieldsNameOfCodeScanningUpdateAlertReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUpdateAlertReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUpdateAlertReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningUploadSarifForbidden as json.
func (s *CodeScanningUploadSarifForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifForbidden from json.
func (s *CodeScanningUploadSarifForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUploadSarifForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUploadSarifForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningUploadSarifNotFound as json.
func (s *CodeScanningUploadSarifNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifNotFound from json.
func (s *CodeScanningUploadSarifNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUploadSarifNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUploadSarifNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeScanningUploadSarifReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeScanningUploadSarifReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("commit_sha")
		s.CommitSha.Encode(e)
	}
	{
		e.FieldStart("ref")
		s.Ref.Encode(e)
	}
	{
		e.FieldStart("sarif")
		s.Sarif.Encode(e)
	}
	{
		if s.CheckoutURI.Set {
			e.FieldStart("checkout_uri")
			s.CheckoutURI.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ToolName.Set {
			e.FieldStart("tool_name")
			s.ToolName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeScanningUploadSarifReq = [6]string{
	0: "commit_sha",
	1: "ref",
	2: "sarif",
	3: "checkout_uri",
	4: "started_at",
	5: "tool_name",
}

// Decode decodes CodeScanningUploadSarifReq from json.
func (s *CodeScanningUploadSarifReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sarif":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Sarif.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sarif\"")
			}
		case "checkout_uri":
			if err := func() error {
				s.CheckoutURI.Reset()
				if err := s.CheckoutURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkout_uri\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "tool_name":
			if err := func() error {
				s.ToolName.Reset()
				if err := s.ToolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningUploadSarifReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningUploadSarifReq) {
					name = jsonFieldsNameOfCodeScanningUploadSarifReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeScanningUploadSarifReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeScanningUploadSarifReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CodeSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CodeSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("git_url")
		json.EncodeURI(e, s.GitURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		if s.FileSize.Set {
			e.FieldStart("file_size")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.LastModifiedAt.Set {
			e.FieldStart("last_modified_at")
			s.LastModifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LineNumbers != nil {
			e.FieldStart("line_numbers")
			e.ArrStart()
			for _, elem := range s.LineNumbers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
}

var jsonFieldsNameOfCodeSearchResultItem = [13]string{
	0:  "name",
	1:  "path",
	2:  "sha",
	3:  "url",
	4:  "git_url",
	5:  "html_url",
	6:  "repository",
	7:  "score",
	8:  "file_size",
	9:  "language",
	10: "last_modified_at",
	11: "line_numbers",
	12: "text_matches",
}

// Decode decodes CodeSearchResultItem from json.
func (s *CodeSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "git_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "last_modified_at":
			if err := func() error {
				s.LastModifiedAt.Reset()
				if err := s.LastModifiedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_modified_at\"")
			}
		case "line_numbers":
			if err := func() error {
				s.LineNumbers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LineNumbers = append(s.LineNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line_numbers\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeSearchResultItem) {
					name = jsonFieldsNameOfCodeSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CodeSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodeSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodesOfConductGetAllCodesOfConductOKApplicationJSON as json.
func (s CodesOfConductGetAllCodesOfConductOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeOfConduct(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodesOfConductGetAllCodesOfConductOKApplicationJSON from json.
func (s *CodesOfConductGetAllCodesOfConductOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodesOfConductGetAllCodesOfConductOKApplicationJSON to nil")
	}
	var unwrapped []CodeOfConduct
	if err := func() error {
		unwrapped = make([]CodeOfConduct, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeOfConduct
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodesOfConductGetAllCodesOfConductOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CodesOfConductGetAllCodesOfConductOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CodesOfConductGetAllCodesOfConductOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Collaborator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Collaborator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfCollaborator = [21]string{
	0:  "login",
	1:  "id",
	2:  "email",
	3:  "name",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "permissions",
}

// Decode decodes Collaborator from json.
func (s *Collaborator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Collaborator to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Collaborator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11110011,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaborator) {
					name = jsonFieldsNameOfCollaborator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Collaborator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Collaborator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CollaboratorPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CollaboratorPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
}

var jsonFieldsNameOfCollaboratorPermissions = [5]string{
	0: "pull",
	1: "triage",
	2: "push",
	3: "maintain",
	4: "admin",
}

// Decode decodes CollaboratorPermissions from json.
func (s *CollaboratorPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaboratorPermissions) {
					name = jsonFieldsNameOfCollaboratorPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CollaboratorPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CollaboratorPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombinedBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombinedBillingUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("days_left_in_billing_cycle")
		e.Int(s.DaysLeftInBillingCycle)
	}
	{
		e.FieldStart("estimated_paid_storage_for_month")
		e.Int(s.EstimatedPaidStorageForMonth)
	}
	{
		e.FieldStart("estimated_storage_for_month")
		e.Int(s.EstimatedStorageForMonth)
	}
}

var jsonFieldsNameOfCombinedBillingUsage = [3]string{
	0: "days_left_in_billing_cycle",
	1: "estimated_paid_storage_for_month",
	2: "estimated_storage_for_month",
}

// Decode decodes CombinedBillingUsage from json.
func (s *CombinedBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombinedBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days_left_in_billing_cycle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DaysLeftInBillingCycle = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days_left_in_billing_cycle\"")
			}
		case "estimated_paid_storage_for_month":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.EstimatedPaidStorageForMonth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_paid_storage_for_month\"")
			}
		case "estimated_storage_for_month":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.EstimatedStorageForMonth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_storage_for_month\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombinedBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombinedBillingUsage) {
					name = jsonFieldsNameOfCombinedBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombinedBillingUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombinedBillingUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CombinedCommitStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CombinedCommitStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("statuses")
		e.ArrStart()
		for _, elem := range s.Statuses {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("commit_url")
		json.EncodeURI(e, s.CommitURL)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfCombinedCommitStatus = [7]string{
	0: "state",
	1: "statuses",
	2: "sha",
	3: "total_count",
	4: "repository",
	5: "commit_url",
	6: "url",
}

// Decode decodes CombinedCommitStatus from json.
func (s *CombinedCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombinedCommitStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Statuses = make([]SimpleCommitStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleCommitStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Statuses = append(s.Statuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "commit_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombinedCommitStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombinedCommitStatus) {
					name = jsonFieldsNameOfCombinedCommitStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CombinedCommitStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CombinedCommitStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Commit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Commit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	{
		e.FieldStart("parents")
		e.ArrStart()
		for _, elem := range s.Parents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Stats.Set {
			e.FieldStart("stats")
			s.Stats.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCommit = [11]string{
	0:  "url",
	1:  "sha",
	2:  "node_id",
	3:  "html_url",
	4:  "comments_url",
	5:  "commit",
	6:  "author",
	7:  "committer",
	8:  "parents",
	9:  "stats",
	10: "files",
}

// Decode decodes Commit from json.
func (s *Commit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Commit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "parents":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Parents = make([]CommitParentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]CommitFilesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitFilesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Commit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommit) {
					name = jsonFieldsNameOfCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Commit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Commit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitActivity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitActivity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("days")
		e.ArrStart()
		for _, elem := range s.Days {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("week")
		e.Int(s.Week)
	}
}

var jsonFieldsNameOfCommitActivity = [3]string{
	0: "days",
	1: "total",
	2: "week",
}

// Decode decodes CommitActivity from json.
func (s *CommitActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitActivity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Days = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Days = append(s.Days, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "week":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Week = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"week\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitActivity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitActivity) {
					name = jsonFieldsNameOfCommitActivity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitActivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitActivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	{
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	{
		e.FieldStart("commit_id")
		e.Str(s.CommitID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitComment = [14]string{
	0:  "html_url",
	1:  "url",
	2:  "id",
	3:  "node_id",
	4:  "body",
	5:  "path",
	6:  "position",
	7:  "line",
	8:  "commit_id",
	9:  "user",
	10: "created_at",
	11: "updated_at",
	12: "author_association",
	13: "reactions",
}

// Decode decodes CommitComment from json.
func (s *CommitComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "line":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitComment) {
					name = jsonFieldsNameOfCommitComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("comment_count")
		e.Int(s.CommentCount)
	}
	{
		e.FieldStart("tree")
		s.Tree.Encode(e)
	}
	{
		if s.Verification.Set {
			e.FieldStart("verification")
			s.Verification.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitCommit = [7]string{
	0: "url",
	1: "author",
	2: "committer",
	3: "message",
	4: "comment_count",
	5: "tree",
	6: "verification",
}

// Decode decodes CommitCommit from json.
func (s *CommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "comment_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CommentCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment_count\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitCommit) {
					name = jsonFieldsNameOfCommitCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitCommitTree) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfCommitCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes CommitCommitTree from json.
func (s *CommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitCommitTree) {
					name = jsonFieldsNameOfCommitCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitCommitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitCommitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitComparison) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitComparison) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("permalink_url")
		json.EncodeURI(e, s.PermalinkURL)
	}
	{
		e.FieldStart("diff_url")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.FieldStart("patch_url")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.FieldStart("base_commit")
		s.BaseCommit.Encode(e)
	}
	{
		e.FieldStart("merge_base_commit")
		s.MergeBaseCommit.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("ahead_by")
		e.Int(s.AheadBy)
	}
	{
		e.FieldStart("behind_by")
		e.Int(s.BehindBy)
	}
	{
		e.FieldStart("total_commits")
		e.Int(s.TotalCommits)
	}
	{
		e.FieldStart("commits")
		e.ArrStart()
		for _, elem := range s.Commits {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCommitComparison = [13]string{
	0:  "url",
	1:  "html_url",
	2:  "permalink_url",
	3:  "diff_url",
	4:  "patch_url",
	5:  "base_commit",
	6:  "merge_base_commit",
	7:  "status",
	8:  "ahead_by",
	9:  "behind_by",
	10: "total_commits",
	11: "commits",
	12: "files",
}

// Decode decodes CommitComparison from json.
func (s *CommitComparison) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComparison to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "permalink_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PermalinkURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permalink_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "base_commit":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.BaseCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_commit\"")
			}
		case "merge_base_commit":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.MergeBaseCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_base_commit\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "ahead_by":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AheadBy = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ahead_by\"")
			}
		case "behind_by":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.BehindBy = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behind_by\"")
			}
		case "total_commits":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalCommits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_commits\"")
			}
		case "commits":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Commits = make([]Commit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Commit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Commits = append(s.Commits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]DiffEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DiffEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitComparison")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitComparison) {
					name = jsonFieldsNameOfCommitComparison[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitComparison) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitComparison) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommitComparisonStatus as json.
func (s CommitComparisonStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CommitComparisonStatus from json.
func (s *CommitComparisonStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComparisonStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CommitComparisonStatus(v) {
	case CommitComparisonStatusDiverged:
		*s = CommitComparisonStatusDiverged
	case CommitComparisonStatusAhead:
		*s = CommitComparisonStatusAhead
	case CommitComparisonStatusBehind:
		*s = CommitComparisonStatusBehind
	case CommitComparisonStatusIdentical:
		*s = CommitComparisonStatusIdentical
	default:
		*s = CommitComparisonStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommitComparisonStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitComparisonStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitFilesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			e.FieldStart("additions")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			e.FieldStart("deletions")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Changes.Set {
			e.FieldStart("changes")
			s.Changes.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			e.FieldStart("raw_url")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.BlobURL.Set {
			e.FieldStart("blob_url")
			s.BlobURL.Encode(e)
		}
	}
	{
		if s.Patch.Set {
			e.FieldStart("patch")
			s.Patch.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			e.FieldStart("contents_url")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			e.FieldStart("previous_filename")
			s.PreviousFilename.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitFilesItem = [11]string{
	0:  "filename",
	1:  "additions",
	2:  "deletions",
	3:  "changes",
	4:  "status",
	5:  "raw_url",
	6:  "blob_url",
	7:  "patch",
	8:  "sha",
	9:  "contents_url",
	10: "previous_filename",
}

// Decode decodes CommitFilesItem from json.
func (s *CommitFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changes":
			if err := func() error {
				s.Changes.Reset()
				if err := s.Changes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changes\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "blob_url":
			if err := func() error {
				s.BlobURL.Reset()
				if err := s.BlobURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_url\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "previous_filename":
			if err := func() error {
				s.PreviousFilename.Reset()
				if err := s.PreviousFilename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_filename\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitFilesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitParentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitParentsItem = [3]string{
	0: "sha",
	1: "url",
	2: "html_url",
}

// Decode decodes CommitParentsItem from json.
func (s *CommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitParentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitParentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitParentsItem) {
					name = jsonFieldsNameOfCommitParentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitParentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitParentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	{
		e.FieldStart("parents")
		e.ArrStart()
		for _, elem := range s.Parents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitSearchResultItem = [12]string{
	0:  "url",
	1:  "sha",
	2:  "html_url",
	3:  "comments_url",
	4:  "commit",
	5:  "author",
	6:  "committer",
	7:  "parents",
	8:  "repository",
	9:  "score",
	10: "node_id",
	11: "text_matches",
}

// Decode decodes CommitSearchResultItem from json.
func (s *CommitSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "parents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Parents = make([]CommitSearchResultItemParentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitSearchResultItemParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "repository":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItem) {
					name = jsonFieldsNameOfCommitSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitSearchResultItemCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitSearchResultItemCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	{
		e.FieldStart("comment_count")
		e.Int(s.CommentCount)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("tree")
		s.Tree.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Verification.Set {
			e.FieldStart("verification")
			s.Verification.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitSearchResultItemCommit = [7]string{
	0: "author",
	1: "committer",
	2: "comment_count",
	3: "message",
	4: "tree",
	5: "url",
	6: "verification",
}

// Decode decodes CommitSearchResultItemCommit from json.
func (s *CommitSearchResultItemCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "comment_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CommentCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment_count\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommit) {
					name = jsonFieldsNameOfCommitSearchResultItemCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitSearchResultItemCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitSearchResultItemCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitSearchResultItemCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitSearchResultItemCommitAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
}

var jsonFieldsNameOfCommitSearchResultItemCommitAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes CommitSearchResultItemCommitAuthor from json.
func (s *CommitSearchResultItemCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommitAuthor) {
					name = jsonFieldsNameOfCommitSearchResultItemCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitSearchResultItemCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitSearchResultItemCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitSearchResultItemCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitSearchResultItemCommitTree) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfCommitSearchResultItemCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes CommitSearchResultItemCommitTree from json.
func (s *CommitSearchResultItemCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommitTree) {
					name = jsonFieldsNameOfCommitSearchResultItemCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitSearchResultItemCommitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitSearchResultItemCommitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitSearchResultItemParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitSearchResultItemParentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitSearchResultItemParentsItem = [3]string{
	0: "url",
	1: "html_url",
	2: "sha",
}

// Decode decodes CommitSearchResultItemParentsItem from json.
func (s *CommitSearchResultItemParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemParentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemParentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitSearchResultItemParentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitSearchResultItemParentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommitStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommitStats) encodeFields(e *jx.Encoder) {
	{
		if s.Additions.Set {
			e.FieldStart("additions")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			e.FieldStart("deletions")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommitStats = [3]string{
	0: "additions",
	1: "deletions",
	2: "total",
}

// Decode decodes CommitStats from json.
func (s *CommitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommitStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommitStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommunityProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommunityProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("health_percentage")
		e.Int(s.HealthPercentage)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("documentation")
		s.Documentation.Encode(e)
	}
	{
		e.FieldStart("files")
		s.Files.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.ContentReportsEnabled.Set {
			e.FieldStart("content_reports_enabled")
			s.ContentReportsEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommunityProfile = [6]string{
	0: "health_percentage",
	1: "description",
	2: "documentation",
	3: "files",
	4: "updated_at",
	5: "content_reports_enabled",
}

// Decode decodes CommunityProfile from json.
func (s *CommunityProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommunityProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_percentage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.HealthPercentage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_percentage\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "documentation":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Documentation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation\"")
			}
		case "files":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "content_reports_enabled":
			if err := func() error {
				s.ContentReportsEnabled.Reset()
				if err := s.ContentReportsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_reports_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommunityProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommunityProfile) {
					name = jsonFieldsNameOfCommunityProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommunityProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommunityProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommunityProfileFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommunityProfileFiles) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code_of_conduct")
		s.CodeOfConduct.Encode(e)
	}
	{
		e.FieldStart("code_of_conduct_file")
		s.CodeOfConductFile.Encode(e)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		e.FieldStart("contributing")
		s.Contributing.Encode(e)
	}
	{
		e.FieldStart("readme")
		s.Readme.Encode(e)
	}
	{
		e.FieldStart("issue_template")
		s.IssueTemplate.Encode(e)
	}
	{
		e.FieldStart("pull_request_template")
		s.PullRequestTemplate.Encode(e)
	}
}

var jsonFieldsNameOfCommunityProfileFiles = [7]string{
	0: "code_of_conduct",
	1: "code_of_conduct_file",
	2: "license",
	3: "contributing",
	4: "readme",
	5: "issue_template",
	6: "pull_request_template",
}

// Decode decodes CommunityProfileFiles from json.
func (s *CommunityProfileFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommunityProfileFiles to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code_of_conduct":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "code_of_conduct_file":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CodeOfConductFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct_file\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "contributing":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Contributing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributing\"")
			}
		case "readme":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Readme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readme\"")
			}
		case "issue_template":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.IssueTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_template\"")
			}
		case "pull_request_template":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.PullRequestTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommunityProfileFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommunityProfileFiles) {
					name = jsonFieldsNameOfCommunityProfileFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommunityProfileFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommunityProfileFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("encoding")
		e.Str(s.Encoding)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("download_url")
		s.DownloadURL.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		if s.Target.Set {
			e.FieldStart("target")
			s.Target.Encode(e)
		}
	}
	{
		if s.SubmoduleGitURL.Set {
			e.FieldStart("submodule_git_url")
			s.SubmoduleGitURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentFile = [14]string{
	0:  "type",
	1:  "encoding",
	2:  "size",
	3:  "name",
	4:  "path",
	5:  "content",
	6:  "sha",
	7:  "url",
	8:  "git_url",
	9:  "html_url",
	10: "download_url",
	11: "_links",
	12: "target",
	13: "submodule_git_url",
}

// Decode decodes ContentFile from json.
func (s *ContentFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentFile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "encoding":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "git_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "download_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "submodule_git_url":
			if err := func() error {
				s.SubmoduleGitURL.Reset()
				if err := s.SubmoduleGitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"submodule_git_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentFile) {
					name = jsonFieldsNameOfContentFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentFileLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentFileLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("git")
		s.Git.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("self")
		json.EncodeURI(e, s.Self)
	}
}

var jsonFieldsNameOfContentFileLinks = [3]string{
	0: "git",
	1: "html",
	2: "self",
}

// Decode decodes ContentFileLinks from json.
func (s *ContentFileLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentFileLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentFileLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentFileLinks) {
					name = jsonFieldsNameOfContentFileLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentFileLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentFileLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentReferenceAttachment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentReferenceAttachment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentReferenceAttachment = [4]string{
	0: "id",
	1: "title",
	2: "body",
	3: "node_id",
}

// Decode decodes ContentReferenceAttachment from json.
func (s *ContentReferenceAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentReferenceAttachment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentReferenceAttachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentReferenceAttachment) {
					name = jsonFieldsNameOfContentReferenceAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentReferenceAttachment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentReferenceAttachment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentTraffic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("uniques")
		e.Int(s.Uniques)
	}
}

var jsonFieldsNameOfContentTraffic = [4]string{
	0: "path",
	1: "title",
	2: "count",
	3: "uniques",
}

// Decode decodes ContentTraffic from json.
func (s *ContentTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentTraffic) {
					name = jsonFieldsNameOfContentTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentTraffic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentTraffic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Contributor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Contributor) encodeFields(e *jx.Encoder) {
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			e.FieldStart("gravatar_id")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			e.FieldStart("followers_url")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			e.FieldStart("following_url")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			e.FieldStart("gists_url")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			e.FieldStart("starred_url")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			e.FieldStart("subscriptions_url")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			e.FieldStart("organizations_url")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			e.FieldStart("repos_url")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			e.FieldStart("received_events_url")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.SiteAdmin.Set {
			e.FieldStart("site_admin")
			s.SiteAdmin.Encode(e)
		}
	}
	{
		e.FieldStart("contributions")
		e.Int(s.Contributions)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfContributor = [21]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "contributions",
	19: "email",
	20: "name",
}

// Decode decodes Contributor from json.
func (s *Contributor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contributor to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "contributions":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Contributions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributions\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contributor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000000,
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContributor) {
					name = jsonFieldsNameOfContributor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Contributor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Contributor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContributorActivity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContributorActivity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("weeks")
		e.ArrStart()
		for _, elem := range s.Weeks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfContributorActivity = [3]string{
	0: "author",
	1: "total",
	2: "weeks",
}

// Decode decodes ContributorActivity from json.
func (s *ContributorActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContributorActivity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "weeks":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Weeks = make([]ContributorActivityWeeksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContributorActivityWeeksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Weeks = append(s.Weeks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weeks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContributorActivity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContributorActivity) {
					name = jsonFieldsNameOfContributorActivity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContributorActivity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContributorActivity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContributorActivityWeeksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContributorActivityWeeksItem) encodeFields(e *jx.Encoder) {
	{
		if s.W.Set {
			e.FieldStart("w")
			s.W.Encode(e)
		}
	}
	{
		if s.A.Set {
			e.FieldStart("a")
			s.A.Encode(e)
		}
	}
	{
		if s.D.Set {
			e.FieldStart("d")
			s.D.Encode(e)
		}
	}
	{
		if s.C.Set {
			e.FieldStart("c")
			s.C.Encode(e)
		}
	}
}

var jsonFieldsNameOfContributorActivityWeeksItem = [4]string{
	0: "w",
	1: "a",
	2: "d",
	3: "c",
}

// Decode decodes ContributorActivityWeeksItem from json.
func (s *ContributorActivityWeeksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContributorActivityWeeksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "w":
			if err := func() error {
				s.W.Reset()
				if err := s.W.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"w\"")
			}
		case "a":
			if err := func() error {
				s.A.Reset()
				if err := s.A.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"a\"")
			}
		case "d":
			if err := func() error {
				s.D.Reset()
				if err := s.D.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"d\"")
			}
		case "c":
			if err := func() error {
				s.C.Reset()
				if err := s.C.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"c\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContributorActivityWeeksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContributorActivityWeeksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContributorActivityWeeksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialAuthorization) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialAuthorization) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("credential_id")
		e.Int(s.CredentialID)
	}
	{
		e.FieldStart("credential_type")
		e.Str(s.CredentialType)
	}
	{
		if s.TokenLastEight.Set {
			e.FieldStart("token_last_eight")
			s.TokenLastEight.Encode(e)
		}
	}
	{
		e.FieldStart("credential_authorized_at")
		json.EncodeDateTime(e, s.CredentialAuthorizedAt)
	}
	{
		if s.Scopes != nil {
			e.FieldStart("scopes")
			e.ArrStart()
			for _, elem := range s.Scopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.CredentialAccessedAt.Set {
			e.FieldStart("credential_accessed_at")
			s.CredentialAccessedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AuthorizedCredentialID.Set {
			e.FieldStart("authorized_credential_id")
			s.AuthorizedCredentialID.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialTitle.Set {
			e.FieldStart("authorized_credential_title")
			s.AuthorizedCredentialTitle.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialNote.Set {
			e.FieldStart("authorized_credential_note")
			s.AuthorizedCredentialNote.Encode(e)
		}
	}
}

var jsonFieldsNameOfCredentialAuthorization = [11]string{
	0:  "login",
	1:  "credential_id",
	2:  "credential_type",
	3:  "token_last_eight",
	4:  "credential_authorized_at",
	5:  "scopes",
	6:  "fingerprint",
	7:  "credential_accessed_at",
	8:  "authorized_credential_id",
	9:  "authorized_credential_title",
	10: "authorized_credential_note",
}

// Decode decodes CredentialAuthorization from json.
func (s *CredentialAuthorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialAuthorization to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "credential_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CredentialID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_id\"")
			}
		case "credential_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CredentialType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_type\"")
			}
		case "token_last_eight":
			if err := func() error {
				s.TokenLastEight.Reset()
				if err := s.TokenLastEight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_last_eight\"")
			}
		case "credential_authorized_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CredentialAuthorizedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_authorized_at\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "credential_accessed_at":
			if err := func() error {
				s.CredentialAccessedAt.Reset()
				if err := s.CredentialAccessedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_accessed_at\"")
			}
		case "authorized_credential_id":
			if err := func() error {
				s.AuthorizedCredentialID.Reset()
				if err := s.AuthorizedCredentialID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_id\"")
			}
		case "authorized_credential_title":
			if err := func() error {
				s.AuthorizedCredentialTitle.Reset()
				if err := s.AuthorizedCredentialTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_title\"")
			}
		case "authorized_credential_note":
			if err := func() error {
				s.AuthorizedCredentialNote.Reset()
				if err := s.AuthorizedCredentialNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_note\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialAuthorization")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialAuthorization) {
					name = jsonFieldsNameOfCredentialAuthorization[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialAuthorization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialAuthorization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("read_only")
		e.Bool(s.ReadOnly)
	}
}

var jsonFieldsNameOfDeployKey = [7]string{
	0: "id",
	1: "key",
	2: "url",
	3: "title",
	4: "verified",
	5: "created_at",
	6: "read_only",
}

// Decode decodes DeployKey from json.
func (s *DeployKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "read_only":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployKey) {
					name = jsonFieldsNameOfDeployKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Deployment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Deployment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
	{
		if s.OriginalEnvironment.Set {
			e.FieldStart("original_environment")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.FieldStart("environment")
		e.Str(s.Environment)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("statuses_url")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.FieldStart("transient_environment")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.FieldStart("production_environment")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeployment = [18]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "sha",
	4:  "ref",
	5:  "task",
	6:  "payload",
	7:  "original_environment",
	8:  "environment",
	9:  "description",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "statuses_url",
	14: "repository_url",
	15: "transient_environment",
	16: "production_environment",
	17: "performed_via_github_app",
}

// Decode decodes Deployment from json.
func (s *Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Deployment to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "original_environment":
			if err := func() error {
				s.OriginalEnvironment.Reset()
				if err := s.OriginalEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_environment\"")
			}
		case "environment":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Deployment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployment) {
					name = jsonFieldsNameOfDeployment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Deployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Deployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeploymentPayload as json.
func (s DeploymentPayload) Encode(e *jx.Encoder) {
	switch s.Type {
	case DeploymentPayload0DeploymentPayload:
		s.DeploymentPayload0.Encode(e)
	case StringDeploymentPayload:
		e.Str(s.String)
	}
}

// Decode decodes DeploymentPayload from json.
func (s *DeploymentPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentPayload to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.DeploymentPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = DeploymentPayload0DeploymentPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDeploymentPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeploymentPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DeploymentPayload0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DeploymentPayload0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DeploymentPayload0 from json.
func (s *DeploymentPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentPayload0 to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentPayload0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeploymentPayload0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentPayload0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeploymentSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeploymentSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		if s.OriginalEnvironment.Set {
			e.FieldStart("original_environment")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.FieldStart("environment")
		e.Str(s.Environment)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("statuses_url")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.FieldStart("transient_environment")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.FieldStart("production_environment")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeploymentSimple = [14]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "task",
	4:  "original_environment",
	5:  "environment",
	6:  "description",
	7:  "created_at",
	8:  "updated_at",
	9:  "statuses_url",
	10: "repository_url",
	11: "transient_environment",
	12: "production_environment",
	13: "performed_via_github_app",
}

// Decode decodes DeploymentSimple from json.
func (s *DeploymentSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "original_environment":
			if err := func() error {
				s.OriginalEnvironment.Reset()
				if err := s.OriginalEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_environment\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeploymentSimple) {
					name = jsonFieldsNameOfDeploymentSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeploymentSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeploymentStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeploymentStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		e.FieldStart("target_url")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("deployment_url")
		json.EncodeURI(e, s.DeploymentURL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.EnvironmentURL.Set {
			e.FieldStart("environment_url")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.FieldStart("log_url")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeploymentStatus = [15]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "state",
	4:  "creator",
	5:  "description",
	6:  "environment",
	7:  "target_url",
	8:  "created_at",
	9:  "updated_at",
	10: "deployment_url",
	11: "repository_url",
	12: "environment_url",
	13: "log_url",
	14: "performed_via_github_app",
}

// Decode decodes DeploymentStatus from json.
func (s *DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentStatus to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TargetURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "deployment_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployment_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "environment_url":
			if err := func() error {
				s.EnvironmentURL.Reset()
				if err := s.EnvironmentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_url\"")
			}
		case "log_url":
			if err := func() error {
				s.LogURL.Reset()
				if err := s.LogURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_url\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeploymentStatus) {
					name = jsonFieldsNameOfDeploymentStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeploymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeploymentStatusState as json.
func (s DeploymentStatusState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeploymentStatusState from json.
func (s *DeploymentStatusState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentStatusState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentStatusState(v) {
	case DeploymentStatusStateError:
		*s = DeploymentStatusStateError
	case DeploymentStatusStateFailure:
		*s = DeploymentStatusStateFailure
	case DeploymentStatusStateInactive:
		*s = DeploymentStatusStateInactive
	case DeploymentStatusStatePending:
		*s = DeploymentStatusStatePending
	case DeploymentStatusStateSuccess:
		*s = DeploymentStatusStateSuccess
	case DeploymentStatusStateQueued:
		*s = DeploymentStatusStateQueued
	case DeploymentStatusStateInProgress:
		*s = DeploymentStatusStateInProgress
	default:
		*s = DeploymentStatusState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeploymentStatusState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentStatusState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DiffEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DiffEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("additions")
		e.Int(s.Additions)
	}
	{
		e.FieldStart("deletions")
		e.Int(s.Deletions)
	}
	{
		e.FieldStart("changes")
		e.Int(s.Changes)
	}
	{
		e.FieldStart("blob_url")
		json.EncodeURI(e, s.BlobURL)
	}
	{
		e.FieldStart("raw_url")
		json.EncodeURI(e, s.RawURL)
	}
	{
		e.FieldStart("contents_url")
		json.EncodeURI(e, s.ContentsURL)
	}
	{
		if s.Patch.Set {
			e.FieldStart("patch")
			s.Patch.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			e.FieldStart("previous_filename")
			s.PreviousFilename.Encode(e)
		}
	}
}

var jsonFieldsNameOfDiffEntry = [11]string{
	0:  "sha",
	1:  "filename",
	2:  "status",
	3:  "additions",
	4:  "deletions",
	5:  "changes",
	6:  "blob_url",
	7:  "raw_url",
	8:  "contents_url",
	9:  "patch",
	10: "previous_filename",
}

// Decode decodes DiffEntry from json.
func (s *DiffEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiffEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "additions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Additions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Deletions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Changes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changes\"")
			}
		case "blob_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BlobURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_url\"")
			}
		case "raw_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RawURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "previous_filename":
			if err := func() error {
				s.PreviousFilename.Reset()
				if err := s.PreviousFilename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_filename\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DiffEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDiffEntry) {
					name = jsonFieldsNameOfDiffEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DiffEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiffEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DiffEntryStatus as json.
func (s DiffEntryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DiffEntryStatus from json.
func (s *DiffEntryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiffEntryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DiffEntryStatus(v) {
	case DiffEntryStatusAdded:
		*s = DiffEntryStatusAdded
	case DiffEntryStatusRemoved:
		*s = DiffEntryStatusRemoved
	case DiffEntryStatusModified:
		*s = DiffEntryStatusModified
	case DiffEntryStatusRenamed:
		*s = DiffEntryStatusRenamed
	case DiffEntryStatusCopied:
		*s = DiffEntryStatusCopied
	case DiffEntryStatusChanged:
		*s = DiffEntryStatusChanged
	case DiffEntryStatusUnchanged:
		*s = DiffEntryStatusUnchanged
	default:
		*s = DiffEntryStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DiffEntryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiffEntryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Email) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Email) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("primary")
		e.Bool(s.Primary)
	}
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
}

var jsonFieldsNameOfEmail = [4]string{
	0: "email",
	1: "primary",
	2: "verified",
	3: "visibility",
}

// Decode decodes Email from json.
func (s *Email) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Email to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Email")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEmail) {
					name = jsonFieldsNameOfEmail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Email) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Email) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EmojisGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EmojisGetOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes EmojisGetOK from json.
func (s *EmojisGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmojisGetOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmojisGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EmojisGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmojisGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EmptyObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EmptyObject) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEmptyObject = [0]string{}

// Decode decodes EmptyObject from json.
func (s *EmptyObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmptyObject to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode EmptyObject")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EmptyObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmptyObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnabledOrganizations as json.
func (s EnabledOrganizations) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnabledOrganizations from json.
func (s *EnabledOrganizations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnabledOrganizations to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledOrganizations(v) {
	case EnabledOrganizationsAll:
		*s = EnabledOrganizationsAll
	case EnabledOrganizationsNone:
		*s = EnabledOrganizationsNone
	case EnabledOrganizationsSelected:
		*s = EnabledOrganizationsSelected
	default:
		*s = EnabledOrganizations(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnabledOrganizations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnabledOrganizations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnabledRepositories as json.
func (s EnabledRepositories) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnabledRepositories from json.
func (s *EnabledRepositories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnabledRepositories to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledRepositories(v) {
	case EnabledRepositoriesAll:
		*s = EnabledRepositoriesAll
	case EnabledRepositoriesNone:
		*s = EnabledRepositoriesNone
	case EnabledRepositoriesSelected:
		*s = EnabledRepositoriesSelected
	default:
		*s = EnabledRepositories(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnabledRepositories) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnabledRepositories) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedOrganizationIds != nil {
			e.FieldStart("selected_organization_ids")
			e.ArrStart()
			for _, elem := range s.SelectedOrganizationIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.FieldStart("runners")
			e.ArrStart()
			for _, elem := range s.Runners {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq = [4]string{
	0: "name",
	1: "visibility",
	2: "selected_organization_ids",
	3: "runners",
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_organization_ids":
			if err := func() error {
				s.SelectedOrganizationIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("organizations")
		e.ArrStart()
		for _, elem := range s.Organizations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK = [2]string{
	0: "total_count",
	1: "organizations",
}

// Decode decodes EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK from json.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "organizations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Organizations = make([]OrganizationSimple, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationSimple
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Organizations = append(s.Organizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("organizations")
		e.ArrStart()
		for _, elem := range s.Organizations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK = [2]string{
	0: "total_count",
	1: "organizations",
}

// Decode decodes EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK from json.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "organizations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Organizations = make([]OrganizationSimple, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationSimple
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Organizations = append(s.Organizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("runner_groups")
		e.ArrStart()
		for _, elem := range s.RunnerGroups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runner_groups",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runner_groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RunnerGroups = make([]RunnerGroupsEnterprise, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerGroupsEnterprise
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RunnerGroups = append(s.RunnerGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runner_groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.Runners != nil {
			e.FieldStart("runners")
			e.ArrStart()
			for _, elem := range s.Runners {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = make([]Runner, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Float64(s.TotalCount)
	}
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = make([]Runner, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.FieldStart("members")
			e.ArrStart()
			for _, elem := range s.Members {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq = [3]string{
	0: "schemas",
	1: "displayName",
	2: "members",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("userName")
		e.Str(s.UserName)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq = [5]string{
	0: "schemas",
	1: "userName",
	2: "name",
	3: "emails",
	4: "groups",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Emails = make([]EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("primary")
		e.Bool(s.Primary)
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("givenName")
		e.Str(s.GivenName)
	}
	{
		e.FieldStart("familyName")
		e.Str(s.FamilyName)
	}
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqName from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled_organizations")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.FieldStart("allowed_actions")
			s.AllowedActions.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq = [2]string{
	0: "enabled_organizations",
	1: "allowed_actions",
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledOrganizations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_organizations\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.FieldStart("members")
			e.ArrStart()
			for _, elem := range s.Members {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq = [3]string{
	0: "schemas",
	1: "displayName",
	2: "members",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("userName")
		e.Str(s.UserName)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq = [5]string{
	0: "schemas",
	1: "userName",
	2: "name",
	3: "emails",
	4: "groups",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Emails = make([]EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("primary")
		e.Bool(s.Primary)
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("givenName")
		e.Str(s.GivenName)
	}
	{
		e.FieldStart("familyName")
		e.Str(s.FamilyName)
	}
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("selected_organization_ids")
		e.ArrStart()
		for _, elem := range s.SelectedOrganizationIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq = [1]string{
	0: "selected_organization_ids",
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedOrganizationIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("selected_organization_ids")
		e.ArrStart()
		for _, elem := range s.SelectedOrganizationIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq = [1]string{
	0: "selected_organization_ids",
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedOrganizationIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq = [1]string{
	0: "runners",
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Runners = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Operations")
		e.ArrStart()
		for _, elem := range s.Operations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq = [2]string{
	0: "schemas",
	1: "Operations",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "Operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = make([]EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("op")
		s.Op.Encode(e)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem = [3]string{
	0: "op",
	1: "path",
	2: "value",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "op":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Op.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"op\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v) {
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_replace
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace
	default:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.Str(s.String)
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Encode(e)
	case AnyArrayEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.ArrStart()
		for _, elem := range s.AnyArray {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.AnyArray = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.AnyArray = append(s.AnyArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = AnyArrayEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.Object:
		if err := s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Decode(d); err != nil {
			return err
		}
		s.Type = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 = [0]string{}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Operations")
		e.ArrStart()
		for _, elem := range s.Operations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq = [2]string{
	0: "schemas",
	1: "Operations",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "Operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = make([]EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem = [0]string{}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq = [2]string{
	0: "name",
	1: "visibility",
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentApprovals) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentApprovals) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("environments")
		e.ArrStart()
		for _, elem := range s.Environments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("comment")
		e.Str(s.Comment)
	}
}

var jsonFieldsNameOfEnvironmentApprovals = [4]string{
	0: "environments",
	1: "state",
	2: "user",
	3: "comment",
}

// Decode decodes EnvironmentApprovals from json.
func (s *EnvironmentApprovals) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovals to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Environments = make([]EnvironmentApprovalsEnvironmentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnvironmentApprovalsEnvironmentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Environments = append(s.Environments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environments\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentApprovals")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnvironmentApprovals) {
					name = jsonFieldsNameOfEnvironmentApprovals[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentApprovals) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentApprovals) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvironmentApprovalsEnvironmentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvironmentApprovalsEnvironmentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfEnvironmentApprovalsEnvironmentsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "name",
	3: "url",
	4: "html_url",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes EnvironmentApprovalsEnvironmentsItem from json.
func (s *EnvironmentApprovalsEnvironmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovalsEnvironmentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentApprovalsEnvironmentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvironmentApprovalsEnvironmentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentApprovalsEnvironmentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnvironmentApprovalsState as json.
func (s EnvironmentApprovalsState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentApprovalsState from json.
func (s *EnvironmentApprovalsState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovalsState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentApprovalsState(v) {
	case EnvironmentApprovalsStateApproved:
		*s = EnvironmentApprovalsStateApproved
	case EnvironmentApprovalsStateRejected:
		*s = EnvironmentApprovalsStateRejected
	default:
		*s = EnvironmentApprovalsState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnvironmentApprovalsState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvironmentApprovalsState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Event) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("actor")
		s.Actor.Encode(e)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	{
		if s.Org.Set {
			e.FieldStart("org")
			s.Org.Encode(e)
		}
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
}

var jsonFieldsNameOfEvent = [8]string{
	0: "id",
	1: "type",
	2: "actor",
	3: "repo",
	4: "org",
	5: "payload",
	6: "public",
	7: "created_at",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "actor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "org":
			if err := func() error {
				s.Org.Reset()
				if err := s.Org.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "public":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvent) {
					name = jsonFieldsNameOfEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventPayload) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			e.FieldStart("issue")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		if s.Pages != nil {
			e.FieldStart("pages")
			e.ArrStart()
			for _, elem := range s.Pages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEventPayload = [4]string{
	0: "action",
	1: "issue",
	2: "comment",
	3: "pages",
}

// Decode decodes EventPayload from json.
func (s *EventPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventPayload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "pages":
			if err := func() error {
				s.Pages = make([]EventPayloadPagesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventPayloadPagesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventPayload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventPayloadPagesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventPayloadPagesItem) encodeFields(e *jx.Encoder) {
	{
		if s.PageName.Set {
			e.FieldStart("page_name")
			s.PageName.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfEventPayloadPagesItem = [6]string{
	0: "page_name",
	1: "title",
	2: "summary",
	3: "action",
	4: "sha",
	5: "html_url",
}

// Decode decodes EventPayloadPagesItem from json.
func (s *EventPayloadPagesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventPayloadPagesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page_name":
			if err := func() error {
				s.PageName.Reset()
				if err := s.PageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_name\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventPayloadPagesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventPayloadPagesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventPayloadPagesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventRepo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventRepo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfEventRepo = [3]string{
	0: "id",
	1: "name",
	2: "url",
}

// Decode decodes EventRepo from json.
func (s *EventRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRepo) {
					name = jsonFieldsNameOfEventRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Feed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Feed) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeline_url")
		e.Str(s.TimelineURL)
	}
	{
		e.FieldStart("user_url")
		e.Str(s.UserURL)
	}
	{
		if s.CurrentUserPublicURL.Set {
			e.FieldStart("current_user_public_url")
			s.CurrentUserPublicURL.Encode(e)
		}
	}
	{
		if s.CurrentUserURL.Set {
			e.FieldStart("current_user_url")
			s.CurrentUserURL.Encode(e)
		}
	}
	{
		if s.CurrentUserActorURL.Set {
			e.FieldStart("current_user_actor_url")
			s.CurrentUserActorURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationURL.Set {
			e.FieldStart("current_user_organization_url")
			s.CurrentUserOrganizationURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationUrls != nil {
			e.FieldStart("current_user_organization_urls")
			e.ArrStart()
			for _, elem := range s.CurrentUserOrganizationUrls {
				json.EncodeURI(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecurityAdvisoriesURL.Set {
			e.FieldStart("security_advisories_url")
			s.SecurityAdvisoriesURL.Encode(e)
		}
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfFeed = [9]string{
	0: "timeline_url",
	1: "user_url",
	2: "current_user_public_url",
	3: "current_user_url",
	4: "current_user_actor_url",
	5: "current_user_organization_url",
	6: "current_user_organization_urls",
	7: "security_advisories_url",
	8: "_links",
}

// Decode decodes Feed from json.
func (s *Feed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Feed to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TimelineURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "user_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_url\"")
			}
		case "current_user_public_url":
			if err := func() error {
				s.CurrentUserPublicURL.Reset()
				if err := s.CurrentUserPublicURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_public_url\"")
			}
		case "current_user_url":
			if err := func() error {
				s.CurrentUserURL.Reset()
				if err := s.CurrentUserURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_url\"")
			}
		case "current_user_actor_url":
			if err := func() error {
				s.CurrentUserActorURL.Reset()
				if err := s.CurrentUserActorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_actor_url\"")
			}
		case "current_user_organization_url":
			if err := func() error {
				s.CurrentUserOrganizationURL.Reset()
				if err := s.CurrentUserOrganizationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization_url\"")
			}
		case "current_user_organization_urls":
			if err := func() error {
				s.CurrentUserOrganizationUrls = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem url.URL
					v, err := json.DecodeURI(d)
					elem = v
					if err != nil {
						return err
					}
					s.CurrentUserOrganizationUrls = append(s.CurrentUserOrganizationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization_urls\"")
			}
		case "security_advisories_url":
			if err := func() error {
				s.SecurityAdvisoriesURL.Reset()
				if err := s.SecurityAdvisoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_advisories_url\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Feed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeed) {
					name = jsonFieldsNameOfFeed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Feed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Feed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeline")
		s.Timeline.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		if s.SecurityAdvisories.Set {
			e.FieldStart("security_advisories")
			s.SecurityAdvisories.Encode(e)
		}
	}
	{
		if s.CurrentUser.Set {
			e.FieldStart("current_user")
			s.CurrentUser.Encode(e)
		}
	}
	{
		if s.CurrentUserPublic.Set {
			e.FieldStart("current_user_public")
			s.CurrentUserPublic.Encode(e)
		}
	}
	{
		if s.CurrentUserActor.Set {
			e.FieldStart("current_user_actor")
			s.CurrentUserActor.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganization.Set {
			e.FieldStart("current_user_organization")
			s.CurrentUserOrganization.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizations != nil {
			e.FieldStart("current_user_organizations")
			e.ArrStart()
			for _, elem := range s.CurrentUserOrganizations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFeedLinks = [8]string{
	0: "timeline",
	1: "user",
	2: "security_advisories",
	3: "current_user",
	4: "current_user_public",
	5: "current_user_actor",
	6: "current_user_organization",
	7: "current_user_organizations",
}

// Decode decodes FeedLinks from json.
func (s *FeedLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Timeline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "security_advisories":
			if err := func() error {
				s.SecurityAdvisories.Reset()
				if err := s.SecurityAdvisories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_advisories\"")
			}
		case "current_user":
			if err := func() error {
				s.CurrentUser.Reset()
				if err := s.CurrentUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user\"")
			}
		case "current_user_public":
			if err := func() error {
				s.CurrentUserPublic.Reset()
				if err := s.CurrentUserPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_public\"")
			}
		case "current_user_actor":
			if err := func() error {
				s.CurrentUserActor.Reset()
				if err := s.CurrentUserActor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_actor\"")
			}
		case "current_user_organization":
			if err := func() error {
				s.CurrentUserOrganization.Reset()
				if err := s.CurrentUserOrganization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization\"")
			}
		case "current_user_organizations":
			if err := func() error {
				s.CurrentUserOrganizations = make([]LinkWithType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LinkWithType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentUserOrganizations = append(s.CurrentUserOrganizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedLinks) {
					name = jsonFieldsNameOfFeedLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
}

var jsonFieldsNameOfFileCommit = [2]string{
	0: "content",
	1: "commit",
}

// Decode decodes FileCommit from json.
func (s *FileCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileCommit) {
					name = jsonFieldsNameOfFileCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommit) encodeFields(e *jx.Encoder) {
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.FieldStart("committer")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Tree.Set {
			e.FieldStart("tree")
			s.Tree.Encode(e)
		}
	}
	{
		if s.Parents != nil {
			e.FieldStart("parents")
			e.ArrStart()
			for _, elem := range s.Parents {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Verification.Set {
			e.FieldStart("verification")
			s.Verification.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommit = [10]string{
	0: "sha",
	1: "node_id",
	2: "url",
	3: "html_url",
	4: "author",
	5: "committer",
	6: "message",
	7: "tree",
	8: "parents",
	9: "verification",
}

// Decode decodes FileCommitCommit from json.
func (s *FileCommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			if err := func() error {
				s.Tree.Reset()
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			if err := func() error {
				s.Parents = make([]FileCommitCommitParentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FileCommitCommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommitAuthor) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommitAuthor = [3]string{
	0: "date",
	1: "name",
	2: "email",
}

// Decode decodes FileCommitCommitAuthor from json.
func (s *FileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitAuthor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommitCommitter) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommitCommitter = [3]string{
	0: "date",
	1: "name",
	2: "email",
}

// Decode decodes FileCommitCommitCommitter from json.
func (s *FileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitCommitter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommitParentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommitParentsItem = [3]string{
	0: "url",
	1: "html_url",
	2: "sha",
}

// Decode decodes FileCommitCommitParentsItem from json.
func (s *FileCommitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitParentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitParentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommitParentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommitParentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommitTree) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommitTree = [2]string{
	0: "url",
	1: "sha",
}

// Decode decodes FileCommitCommitTree from json.
func (s *FileCommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitTree to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitTree")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitCommitVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitCommitVerification) encodeFields(e *jx.Encoder) {
	{
		if s.Verified.Set {
			e.FieldStart("verified")
			s.Verified.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			e.FieldStart("signature")
			s.Signature.Encode(e)
		}
	}
	{
		if s.Payload.Set {
			e.FieldStart("payload")
			s.Payload.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitCommitVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "signature",
	3: "payload",
}

// Decode decodes FileCommitCommitVerification from json.
func (s *FileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitVerification to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			if err := func() error {
				s.Verified.Reset()
				if err := s.Verified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signature":
			if err := func() error {
				s.Signature.Reset()
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitVerification")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitCommitVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitCommitVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitContent) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			e.FieldStart("git_url")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.DownloadURL.Set {
			e.FieldStart("download_url")
			s.DownloadURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("_links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitContent = [10]string{
	0: "name",
	1: "path",
	2: "sha",
	3: "size",
	4: "url",
	5: "html_url",
	6: "git_url",
	7: "download_url",
	8: "type",
	9: "_links",
}

// Decode decodes FileCommitContent from json.
func (s *FileCommitContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "download_url":
			if err := func() error {
				s.DownloadURL.Reset()
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "_links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileCommitContentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileCommitContentLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.Git.Set {
			e.FieldStart("git")
			s.Git.Encode(e)
		}
	}
	{
		if s.HTML.Set {
			e.FieldStart("html")
			s.HTML.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileCommitContentLinks = [3]string{
	0: "self",
	1: "git",
	2: "html",
}

// Decode decodes FileCommitContentLinks from json.
func (s *FileCommitContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitContentLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "git":
			if err := func() error {
				s.Git.Reset()
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			if err := func() error {
				s.HTML.Reset()
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitContentLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileCommitContentLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileCommitContentLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForbiddenGist) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForbiddenGist) encodeFields(e *jx.Encoder) {
	{
		if s.Block.Set {
			e.FieldStart("block")
			s.Block.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfForbiddenGist = [3]string{
	0: "block",
	1: "message",
	2: "documentation_url",
}

// Decode decodes ForbiddenGist from json.
func (s *ForbiddenGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenGist to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block":
			if err := func() error {
				s.Block.Reset()
				if err := s.Block.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForbiddenGist")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForbiddenGist) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForbiddenGist) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForbiddenGistBlock) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForbiddenGistBlock) encodeFields(e *jx.Encoder) {
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfForbiddenGistBlock = [3]string{
	0: "reason",
	1: "created_at",
	2: "html_url",
}

// Decode decodes ForbiddenGistBlock from json.
func (s *ForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenGistBlock to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForbiddenGistBlock")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForbiddenGistBlock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForbiddenGistBlock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullRepository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		e.FieldStart("pushed_at")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
	{
		e.FieldStart("subscribers_count")
		e.Int(s.SubscribersCount)
	}
	{
		e.FieldStart("network_count")
		e.Int(s.NetworkCount)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			e.FieldStart("parent")
			s.Parent.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		if s.AnonymousAccessEnabled.Set {
			e.FieldStart("anonymous_access_enabled")
			s.AnonymousAccessEnabled.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.FieldStart("code_of_conduct")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			e.FieldStart("security_and_analysis")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
}

var jsonFieldsNameOfFullRepository = [94]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "template_repository",
	75: "temp_clone_token",
	76: "allow_squash_merge",
	77: "allow_auto_merge",
	78: "delete_branch_on_merge",
	79: "allow_merge_commit",
	80: "allow_forking",
	81: "subscribers_count",
	82: "network_count",
	83: "license",
	84: "organization",
	85: "parent",
	86: "source",
	87: "forks",
	88: "master_branch",
	89: "open_issues",
	90: "watchers",
	91: "anonymous_access_enabled",
	92: "code_of_conduct",
	93: "security_and_analysis",
}

// Decode decodes FullRepository from json.
func (s *FullRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.SubscribersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.NetworkCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "license":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "forks":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "open_issues":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "anonymous_access_enabled":
			if err := func() error {
				s.AnonymousAccessEnabled.Reset()
				if err := s.AnonymousAccessEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anonymous_access_enabled\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "security_and_analysis":
			if err := func() error {
				s.SecurityAndAnalysis.Reset()
				if err := s.SecurityAndAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_and_analysis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11100111,
		0b11101111,
		0b00000000,
		0b10001110,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFullRepository) {
					name = jsonFieldsNameOfFullRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
}

var jsonFieldsNameOfFullRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes FullRepositoryPermissions from json.
func (s *FullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFullRepositoryPermissions) {
					name = jsonFieldsNameOfFullRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullRepositorySecurityAndAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullRepositorySecurityAndAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.AdvancedSecurity.Set {
			e.FieldStart("advanced_security")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			e.FieldStart("secret_scanning")
			s.SecretScanning.Encode(e)
		}
	}
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysis = [2]string{
	0: "advanced_security",
	1: "secret_scanning",
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (s *FullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			if err := func() error {
				s.AdvancedSecurity.Reset()
				if err := s.AdvancedSecurity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advanced_security\"")
			}
		case "secret_scanning":
			if err := func() error {
				s.SecretScanning.Reset()
				if err := s.SecretScanning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullRepositorySecurityAndAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositorySecurityAndAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysisAdvancedSecurity = [1]string{
	0: "status",
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysisAdvancedSecurity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v) {
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysisSecretScanning = [1]string{
	0: "status",
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysisSecretScanning")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (s FullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanningStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisSecretScanningStatus(v) {
	case FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled
	case FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FullRepositorySecurityAndAnalysisSecretScanningStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FullRepositorySecurityAndAnalysisSecretScanningStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
}

var jsonFieldsNameOfGistComment = [8]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "body",
	4: "user",
	5: "created_at",
	6: "updated_at",
	7: "author_association",
}

// Decode decodes GistComment from json.
func (s *GistComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistComment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistComment) {
					name = jsonFieldsNameOfGistComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("change_status")
		s.ChangeStatus.Encode(e)
	}
	{
		e.FieldStart("committed_at")
		json.EncodeDateTime(e, s.CommittedAt)
	}
}

var jsonFieldsNameOfGistCommit = [5]string{
	0: "url",
	1: "version",
	2: "user",
	3: "change_status",
	4: "committed_at",
}

// Decode decodes GistCommit from json.
func (s *GistCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "change_status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ChangeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_status\"")
			}
		case "committed_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CommittedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistCommit) {
					name = jsonFieldsNameOfGistCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistCommitChangeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistCommitChangeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			e.FieldStart("additions")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			e.FieldStart("deletions")
			s.Deletions.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistCommitChangeStatus = [3]string{
	0: "total",
	1: "additions",
	2: "deletions",
}

// Decode decodes GistCommitChangeStatus from json.
func (s *GistCommitChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistCommitChangeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistCommitChangeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistCommitChangeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistCommitChangeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistHistory) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CommittedAt.Set {
			e.FieldStart("committed_at")
			s.CommittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ChangeStatus.Set {
			e.FieldStart("change_status")
			s.ChangeStatus.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistHistory = [5]string{
	0: "user",
	1: "version",
	2: "committed_at",
	3: "change_status",
	4: "url",
}

// Decode decodes GistHistory from json.
func (s *GistHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistHistory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "committed_at":
			if err := func() error {
				s.CommittedAt.Reset()
				if err := s.CommittedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committed_at\"")
			}
		case "change_status":
			if err := func() error {
				s.ChangeStatus.Reset()
				if err := s.ChangeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_status\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistHistory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistHistoryChangeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistHistoryChangeStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			e.FieldStart("additions")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			e.FieldStart("deletions")
			s.Deletions.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistHistoryChangeStatus = [3]string{
	0: "total",
	1: "additions",
	2: "deletions",
}

// Decode decodes GistHistoryChangeStatus from json.
func (s *GistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistHistoryChangeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistHistoryChangeStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistHistoryChangeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistHistoryChangeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistSimple) encodeFields(e *jx.Encoder) {
	{
		if s.Forks.Set {
			e.FieldStart("forks")
			s.Forks.Encode(e)
		}
	}
	{
		if s.History.Set {
			e.FieldStart("history")
			s.History.Encode(e)
		}
	}
	{
		if s.ForkOf.Set {
			e.FieldStart("fork_of")
			s.ForkOf.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			e.FieldStart("forks_url")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			e.FieldStart("commits_url")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.GitPullURL.Set {
			e.FieldStart("git_pull_url")
			s.GitPullURL.Encode(e)
		}
	}
	{
		if s.GitPushURL.Set {
			e.FieldStart("git_push_url")
			s.GitPushURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Files.Set {
			e.FieldStart("files")
			s.Files.Encode(e)
		}
	}
	{
		if s.Public.Set {
			e.FieldStart("public")
			s.Public.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Comments.Set {
			e.FieldStart("comments")
			s.Comments.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			e.FieldStart("comments_url")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.FieldStart("truncated")
			s.Truncated.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistSimple = [21]string{
	0:  "forks",
	1:  "history",
	2:  "fork_of",
	3:  "url",
	4:  "forks_url",
	5:  "commits_url",
	6:  "id",
	7:  "node_id",
	8:  "git_pull_url",
	9:  "git_push_url",
	10: "html_url",
	11: "files",
	12: "public",
	13: "created_at",
	14: "updated_at",
	15: "description",
	16: "comments",
	17: "user",
	18: "comments_url",
	19: "owner",
	20: "truncated",
}

// Decode decodes GistSimple from json.
func (s *GistSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimple to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History.Reset()
				if err := s.History.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		case "fork_of":
			if err := func() error {
				s.ForkOf.Reset()
				if err := s.ForkOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork_of\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			if err := func() error {
				s.GitPullURL.Reset()
				if err := s.GitPullURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			if err := func() error {
				s.GitPushURL.Reset()
				if err := s.GitPushURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			if err := func() error {
				s.Files.Reset()
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			if err := func() error {
				s.Public.Reset()
				if err := s.Public.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			if err := func() error {
				s.Comments.Reset()
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimple")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GistSimpleFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GistSimpleFiles) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GistSimpleFiles from json.
func (s *GistSimpleFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleFiles to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilGistSimpleFilesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleFiles")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GistSimpleFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistSimpleFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistSimpleFilesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			e.FieldStart("raw_url")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.FieldStart("truncated")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistSimpleFilesItem = [7]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
	5: "truncated",
	6: "content",
}

// Decode decodes GistSimpleFilesItem from json.
func (s *GistSimpleFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleFilesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistSimpleFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistSimpleForkOf) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistSimpleForkOf) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("commits_url")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("git_pull_url")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.FieldStart("git_push_url")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("files")
		s.Files.Encode(e)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.FieldStart("truncated")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.FieldStart("forks")
			e.ArrStart()
			for _, elem := range s.Forks {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.FieldStart("history")
			e.ArrStart()
			for _, elem := range s.History {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGistSimpleForkOf = [20]string{
	0:  "url",
	1:  "forks_url",
	2:  "commits_url",
	3:  "id",
	4:  "node_id",
	5:  "git_pull_url",
	6:  "git_push_url",
	7:  "html_url",
	8:  "files",
	9:  "public",
	10: "created_at",
	11: "updated_at",
	12: "description",
	13: "comments",
	14: "user",
	15: "comments_url",
	16: "owner",
	17: "truncated",
	18: "forks",
	19: "history",
}

// Decode decodes GistSimpleForkOf from json.
func (s *GistSimpleForkOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOf to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPullURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPushURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "forks":
			if err := func() error {
				s.Forks = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Forks = append(s.Forks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOf")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistSimpleForkOf) {
					name = jsonFieldsNameOfGistSimpleForkOf[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistSimpleForkOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleForkOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOfFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GistSimpleForkOfFiles) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GistSimpleForkOfFiles from json.
func (s *GistSimpleForkOfFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOfFiles to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GistSimpleForkOfFilesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOfFiles")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GistSimpleForkOfFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleForkOfFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistSimpleForkOfFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistSimpleForkOfFilesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			e.FieldStart("raw_url")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistSimpleForkOfFilesItem = [5]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
}

// Decode decodes GistSimpleForkOfFilesItem from json.
func (s *GistSimpleForkOfFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOfFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOfFilesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistSimpleForkOfFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleForkOfFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistSimpleForksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistSimpleForksItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGistSimpleForksItem = [5]string{
	0: "id",
	1: "url",
	2: "user",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes GistSimpleForksItem from json.
func (s *GistSimpleForksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistSimpleForksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistSimpleForksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistsCheckIsStarredNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistsCheckIsStarredNotFound) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGistsCheckIsStarredNotFound = [0]string{}

// Decode decodes GistsCheckIsStarredNotFound from json.
func (s *GistsCheckIsStarredNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCheckIsStarredNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode GistsCheckIsStarredNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCheckIsStarredNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCheckIsStarredNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateCommentForbidden as json.
func (s *GistsCreateCommentForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentForbidden from json.
func (s *GistsCreateCommentForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateCommentForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateCommentForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateCommentNotFound as json.
func (s *GistsCreateCommentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentNotFound from json.
func (s *GistsCreateCommentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateCommentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateCommentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistsCreateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistsCreateCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfGistsCreateCommentReq = [1]string{
	0: "body",
}

// Decode decodes GistsCreateCommentReq from json.
func (s *GistsCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateCommentReq) {
					name = jsonFieldsNameOfGistsCreateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateForbidden as json.
func (s *GistsCreateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsCreateForbidden from json.
func (s *GistsCreateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateNotFound as json.
func (s *GistsCreateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsCreateNotFound from json.
func (s *GistsCreateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistsCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistsCreateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("files")
		s.Files.Encode(e)
	}
	{
		if s.Public.Set {
			e.FieldStart("public")
			s.Public.Encode(e)
		}
	}
}

var jsonFieldsNameOfGistsCreateReq = [3]string{
	0: "description",
	1: "files",
	2: "public",
}

// Decode decodes GistsCreateReq from json.
func (s *GistsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "files":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			if err := func() error {
				s.Public.Reset()
				if err := s.Public.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateReq) {
					name = jsonFieldsNameOfGistsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GistsCreateReqFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GistsCreateReqFiles) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GistsCreateReqFiles from json.
func (s *GistsCreateReqFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqFiles to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GistsCreateReqFilesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReqFiles")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GistsCreateReqFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateReqFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistsCreateReqFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistsCreateReqFilesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfGistsCreateReqFilesItem = [1]string{
	0: "content",
}

// Decode decodes GistsCreateReqFilesItem from json.
func (s *GistsCreateReqFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqFilesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReqFilesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateReqFilesItem) {
					name = jsonFieldsNameOfGistsCreateReqFilesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsCreateReqFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateReqFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateReqPublic as json.
func (s GistsCreateReqPublic) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolGistsCreateReqPublic:
		e.Bool(s.Bool)
	case GistsCreateReqPublic1GistsCreateReqPublic:
		s.GistsCreateReqPublic1.Encode(e)
	}
}

// Decode decodes GistsCreateReqPublic from json.
func (s *GistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqPublic to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGistsCreateReqPublic
	case jx.String:
		if err := s.GistsCreateReqPublic1.Decode(d); err != nil {
			return err
		}
		s.Type = GistsCreateReqPublic1GistsCreateReqPublic
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GistsCreateReqPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateReqPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateReqPublic1 as json.
func (s GistsCreateReqPublic1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GistsCreateReqPublic1 from json.
func (s *GistsCreateReqPublic1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqPublic1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GistsCreateReqPublic1(v) {
	case GistsCreateReqPublic1True:
		*s = GistsCreateReqPublic1True
	case GistsCreateReqPublic1False:
		*s = GistsCreateReqPublic1False
	default:
		*s = GistsCreateReqPublic1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GistsCreateReqPublic1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsCreateReqPublic1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsDeleteCommentForbidden as json.
func (s *GistsDeleteCommentForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentForbidden from json.
func (s *GistsDeleteCommentForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteCommentForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsDeleteCommentForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsDeleteCommentForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsDeleteCommentNotFound as json.
func (s *GistsDeleteCommentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentNotFound from json.
func (s *GistsDeleteCommentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteCommentNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsDeleteCommentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsDeleteCommentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsDeleteForbidden as json.
func (s *GistsDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteForbidden from json.
func (s *GistsDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsDeleteNotFound as json.
func (s *GistsDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteNotFound from json.
func (s *GistsDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsForkForbidden as json.
func (s *GistsForkForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsForkForbidden from json.
func (s *GistsForkForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsForkForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsForkForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsForkForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsForkNotFound as json.
func (s *GistsForkNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsForkNotFound from json.
func (s *GistsForkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsForkNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsForkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsForkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsGetRevisionForbidden as json.
func (s *GistsGetRevisionForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionForbidden from json.
func (s *GistsGetRevisionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsGetRevisionForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsGetRevisionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsGetRevisionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsGetRevisionNotFound as json.
func (s *GistsGetRevisionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionNotFound from json.
func (s *GistsGetRevisionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsGetRevisionNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsGetRevisionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsGetRevisionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListCommentsForbidden as json.
func (s *GistsListCommentsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsForbidden from json.
func (s *GistsListCommentsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommentsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListCommentsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListCommentsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListCommentsNotFound as json.
func (s *GistsListCommentsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsNotFound from json.
func (s *GistsListCommentsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommentsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListCommentsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListCommentsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListCommitsForbidden as json.
func (s *GistsListCommitsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsForbidden from json.
func (s *GistsListCommitsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommitsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListCommitsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListCommitsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListCommitsNotFound as json.
func (s *GistsListCommitsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsNotFound from json.
func (s *GistsListCommitsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommitsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListCommitsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListCommitsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListForksForbidden as json.
func (s *GistsListForksForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListForksForbidden from json.
func (s *GistsListForksForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForksForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListForksForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListForksForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListForksNotFound as json.
func (s *GistsListForksNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListForksNotFound from json.
func (s *GistsListForksNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForksNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListForksNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListForksNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListStarredForbidden as json.
func (s *GistsListStarredForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredForbidden from json.
func (s *GistsListStarredForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListStarredForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListStarredForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListStarredForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsListStarredUnauthorized as json.
func (s *GistsListStarredUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredUnauthorized from json.
func (s *GistsListStarredUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListStarredUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsListStarredUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsListStarredUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsStarForbidden as json.
func (s *GistsStarForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsStarForbidden from json.
func (s *GistsStarForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsStarForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsStarForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsStarForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsStarNotFound as json.
func (s *GistsStarNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsStarNotFound from json.
func (s *GistsStarNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsStarNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsStarNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsStarNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsUnstarForbidden as json.
func (s *GistsUnstarForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarForbidden from json.
func (s *GistsUnstarForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUnstarForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsUnstarForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsUnstarForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsUnstarNotFound as json.
func (s *GistsUnstarNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarNotFound from json.
func (s *GistsUnstarNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUnstarNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsUnstarNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsUnstarNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GistsUpdateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GistsUpdateCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfGistsUpdateCommentReq = [1]string{
	0: "body",
}

// Decode decodes GistsUpdateCommentReq from json.
func (s *GistsUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUpdateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsUpdateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsUpdateCommentReq) {
					name = jsonFieldsNameOfGistsUpdateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GistsUpdateCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GistsUpdateCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("tree")
		s.Tree.Encode(e)
	}
	{
		e.FieldStart("parents")
		e.ArrStart()
		for _, elem := range s.Parents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("verification")
		s.Verification.Encode(e)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
}

var jsonFieldsNameOfGitCommit = [10]string{
	0: "sha",
	1: "node_id",
	2: "url",
	3: "author",
	4: "committer",
	5: "message",
	6: "tree",
	7: "parents",
	8: "verification",
	9: "html_url",
}

// Decode decodes GitCommit from json.
func (s *GitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Parents = make([]GitCommitParentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitCommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "verification":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommit) {
					name = jsonFieldsNameOfGitCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommitAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGitCommitAuthor = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitCommitAuthor from json.
func (s *GitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitAuthor) {
					name = jsonFieldsNameOfGitCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommitCommitter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGitCommitCommitter = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitCommitCommitter from json.
func (s *GitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitCommitter) {
					name = jsonFieldsNameOfGitCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommitParentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
}

var jsonFieldsNameOfGitCommitParentsItem = [3]string{
	0: "sha",
	1: "url",
	2: "html_url",
}

// Decode decodes GitCommitParentsItem from json.
func (s *GitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitParentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitParentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitParentsItem) {
					name = jsonFieldsNameOfGitCommitParentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommitParentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommitParentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommitTree) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfGitCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes GitCommitTree from json.
func (s *GitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitTree) {
					name = jsonFieldsNameOfGitCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCommitVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCommitVerification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("signature")
		s.Signature.Encode(e)
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
}

var jsonFieldsNameOfGitCommitVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "signature",
	3: "payload",
}

// Decode decodes GitCommitVerification from json.
func (s *GitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitVerification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signature":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitVerification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitVerification) {
					name = jsonFieldsNameOfGitCommitVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCommitVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCommitVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateBlobConflict as json.
func (s *GitCreateBlobConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobConflict from json.
func (s *GitCreateBlobConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateBlobConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateBlobConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateBlobForbidden as json.
func (s *GitCreateBlobForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobForbidden from json.
func (s *GitCreateBlobForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateBlobForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateBlobForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateBlobNotFound as json.
func (s *GitCreateBlobNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobNotFound from json.
func (s *GitCreateBlobNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateBlobNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateBlobNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateBlobReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateBlobReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		if s.Encoding.Set {
			e.FieldStart("encoding")
			s.Encoding.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateBlobReq = [2]string{
	0: "content",
	1: "encoding",
}

// Decode decodes GitCreateBlobReq from json.
func (s *GitCreateBlobReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			if err := func() error {
				s.Encoding.Reset()
				if err := s.Encoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateBlobReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateBlobReq) {
					name = jsonFieldsNameOfGitCreateBlobReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateBlobReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateBlobReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateCommitReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateCommitReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("tree")
		e.Str(s.Tree)
	}
	{
		if s.Parents != nil {
			e.FieldStart("parents")
			e.ArrStart()
			for _, elem := range s.Parents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.FieldStart("committer")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			e.FieldStart("signature")
			s.Signature.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateCommitReq = [6]string{
	0: "message",
	1: "tree",
	2: "parents",
	3: "author",
	4: "committer",
	5: "signature",
}

// Decode decodes GitCreateCommitReq from json.
func (s *GitCreateCommitReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tree = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			if err := func() error {
				s.Parents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "signature":
			if err := func() error {
				s.Signature.Reset()
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateCommitReq) {
					name = jsonFieldsNameOfGitCreateCommitReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateCommitReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateCommitReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateCommitReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateCommitReqAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGitCreateCommitReqAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (s *GitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReqAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReqAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateCommitReqAuthor) {
					name = jsonFieldsNameOfGitCreateCommitReqAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateCommitReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateCommitReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateCommitReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateCommitReqCommitter) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGitCreateCommitReqCommitter = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (s *GitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReqCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReqCommitter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateCommitReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateCommitReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateRefReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateRefReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateRefReq = [3]string{
	0: "ref",
	1: "sha",
	2: "key",
}

// Decode decodes GitCreateRefReq from json.
func (s *GitCreateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateRefReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateRefReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateRefReq) {
					name = jsonFieldsNameOfGitCreateRefReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateRefReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateRefReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateTagReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateTagReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("object")
		e.Str(s.Object)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Tagger.Set {
			e.FieldStart("tagger")
			s.Tagger.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateTagReq = [5]string{
	0: "tag",
	1: "message",
	2: "object",
	3: "type",
	4: "tagger",
}

// Decode decodes GitCreateTagReq from json.
func (s *GitCreateTagReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "tagger":
			if err := func() error {
				s.Tagger.Reset()
				if err := s.Tagger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagger\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTagReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTagReq) {
					name = jsonFieldsNameOfGitCreateTagReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTagReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTagReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateTagReqTagger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateTagReqTagger) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGitCreateTagReqTagger = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateTagReqTagger from json.
func (s *GitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReqTagger to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTagReqTagger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTagReqTagger) {
					name = jsonFieldsNameOfGitCreateTagReqTagger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTagReqTagger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTagReqTagger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTagReqType as json.
func (s GitCreateTagReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTagReqType from json.
func (s *GitCreateTagReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTagReqType(v) {
	case GitCreateTagReqTypeCommit:
		*s = GitCreateTagReqTypeCommit
	case GitCreateTagReqTypeTree:
		*s = GitCreateTagReqTypeTree
	case GitCreateTagReqTypeBlob:
		*s = GitCreateTagReqTypeBlob
	default:
		*s = GitCreateTagReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GitCreateTagReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTagReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeForbidden as json.
func (s *GitCreateTreeForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeForbidden from json.
func (s *GitCreateTreeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTreeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeNotFound as json.
func (s *GitCreateTreeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeNotFound from json.
func (s *GitCreateTreeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTreeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateTreeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateTreeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tree")
		e.ArrStart()
		for _, elem := range s.Tree {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BaseTree.Set {
			e.FieldStart("base_tree")
			s.BaseTree.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateTreeReq = [2]string{
	0: "tree",
	1: "base_tree",
}

// Decode decodes GitCreateTreeReq from json.
func (s *GitCreateTreeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tree":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tree = make([]GitCreateTreeReqTreeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitCreateTreeReqTreeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tree = append(s.Tree, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "base_tree":
			if err := func() error {
				s.BaseTree.Reset()
				if err := s.BaseTree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_tree\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTreeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTreeReq) {
					name = jsonFieldsNameOfGitCreateTreeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTreeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitCreateTreeReqTreeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitCreateTreeReqTreeItem) encodeFields(e *jx.Encoder) {
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitCreateTreeReqTreeItem = [5]string{
	0: "path",
	1: "mode",
	2: "type",
	3: "sha",
	4: "content",
}

// Decode decodes GitCreateTreeReqTreeItem from json.
func (s *GitCreateTreeReqTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTreeReqTreeItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitCreateTreeReqTreeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeReqTreeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (s GitCreateTreeReqTreeItemMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (s *GitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItemMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemMode(v) {
	case GitCreateTreeReqTreeItemMode100644:
		*s = GitCreateTreeReqTreeItemMode100644
	case GitCreateTreeReqTreeItemMode100755:
		*s = GitCreateTreeReqTreeItemMode100755
	case GitCreateTreeReqTreeItemMode040000:
		*s = GitCreateTreeReqTreeItemMode040000
	case GitCreateTreeReqTreeItemMode160000:
		*s = GitCreateTreeReqTreeItemMode160000
	case GitCreateTreeReqTreeItemMode120000:
		*s = GitCreateTreeReqTreeItemMode120000
	default:
		*s = GitCreateTreeReqTreeItemMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GitCreateTreeReqTreeItemMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeReqTreeItemMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (s GitCreateTreeReqTreeItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (s *GitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemType(v) {
	case GitCreateTreeReqTreeItemTypeBlob:
		*s = GitCreateTreeReqTreeItemTypeBlob
	case GitCreateTreeReqTreeItemTypeTree:
		*s = GitCreateTreeReqTreeItemTypeTree
	case GitCreateTreeReqTreeItemTypeCommit:
		*s = GitCreateTreeReqTreeItemTypeCommit
	default:
		*s = GitCreateTreeReqTreeItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GitCreateTreeReqTreeItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitCreateTreeReqTreeItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitGetBlobForbidden as json.
func (s *GitGetBlobForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobForbidden from json.
func (s *GitGetBlobForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitGetBlobForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitGetBlobForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitGetBlobForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitGetBlobNotFound as json.
func (s *GitGetBlobNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobNotFound from json.
func (s *GitGetBlobNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitGetBlobNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitGetBlobNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitGetBlobNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitRef) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitRef) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
}

var jsonFieldsNameOfGitRef = [4]string{
	0: "ref",
	1: "node_id",
	2: "url",
	3: "object",
}

// Decode decodes GitRef from json.
func (s *GitRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitRef to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitRef")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitRef) {
					name = jsonFieldsNameOfGitRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitRefObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitRefObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfGitRefObject = [3]string{
	0: "type",
	1: "sha",
	2: "url",
}

// Decode decodes GitRefObject from json.
func (s *GitRefObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitRefObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitRefObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitRefObject) {
					name = jsonFieldsNameOfGitRefObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitRefObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitRefObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("tagger")
		s.Tagger.Encode(e)
	}
	{
		e.FieldStart("object")
		s.Object.Encode(e)
	}
	{
		if s.Verification.Set {
			e.FieldStart("verification")
			s.Verification.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitTag = [8]string{
	0: "node_id",
	1: "tag",
	2: "sha",
	3: "url",
	4: "message",
	5: "tagger",
	6: "object",
	7: "verification",
}

// Decode decodes GitTag from json.
func (s *GitTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tagger":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Tagger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagger\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTag) {
					name = jsonFieldsNameOfGitTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitTagObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitTagObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfGitTagObject = [3]string{
	0: "sha",
	1: "type",
	2: "url",
}

// Decode decodes GitTagObject from json.
func (s *GitTagObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTagObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTagObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTagObject) {
					name = jsonFieldsNameOfGitTagObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitTagObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitTagObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitTagTagger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitTagTagger) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGitTagTagger = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitTagTagger from json.
func (s *GitTagTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTagTagger to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTagTagger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTagTagger) {
					name = jsonFieldsNameOfGitTagTagger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitTagTagger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitTagTagger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitTree) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("truncated")
		e.Bool(s.Truncated)
	}
	{
		e.FieldStart("tree")
		e.ArrStart()
		for _, elem := range s.Tree {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGitTree = [4]string{
	0: "sha",
	1: "url",
	2: "truncated",
	3: "tree",
}

// Decode decodes GitTree from json.
func (s *GitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "truncated":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Truncated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Tree = make([]GitTreeTreeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitTreeTreeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tree = append(s.Tree, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTree) {
					name = jsonFieldsNameOfGitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitTreeTreeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitTreeTreeItem) encodeFields(e *jx.Encoder) {
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitTreeTreeItem = [6]string{
	0: "path",
	1: "mode",
	2: "type",
	3: "sha",
	4: "size",
	5: "url",
}

// Decode decodes GitTreeTreeItem from json.
func (s *GitTreeTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTreeTreeItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTreeTreeItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitTreeTreeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitTreeTreeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitUpdateRefReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitUpdateRefReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfGitUpdateRefReq = [2]string{
	0: "sha",
	1: "force",
}

// Decode decodes GitUpdateRefReq from json.
func (s *GitUpdateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitUpdateRefReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitUpdateRefReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitUpdateRefReq) {
					name = jsonFieldsNameOfGitUpdateRefReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitUpdateRefReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitUpdateRefReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitignoreGetAllTemplatesOKApplicationJSON as json.
func (s GitignoreGetAllTemplatesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GitignoreGetAllTemplatesOKApplicationJSON from json.
func (s *GitignoreGetAllTemplatesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitignoreGetAllTemplatesOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitignoreGetAllTemplatesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GitignoreGetAllTemplatesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitignoreGetAllTemplatesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GitignoreTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GitignoreTemplate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
}

var jsonFieldsNameOfGitignoreTemplate = [2]string{
	0: "name",
	1: "source",
}

// Decode decodes GitignoreTemplate from json.
func (s *GitignoreTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitignoreTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitignoreTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitignoreTemplate) {
					name = jsonFieldsNameOfGitignoreTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GitignoreTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GitignoreTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GpgKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GpgKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("primary_key_id")
		s.PrimaryKeyID.Encode(e)
	}
	{
		e.FieldStart("key_id")
		e.Str(s.KeyID)
	}
	{
		e.FieldStart("public_key")
		e.Str(s.PublicKey)
	}
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subkeys")
		e.ArrStart()
		for _, elem := range s.Subkeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("can_sign")
		e.Bool(s.CanSign)
	}
	{
		e.FieldStart("can_encrypt_comms")
		e.Bool(s.CanEncryptComms)
	}
	{
		e.FieldStart("can_encrypt_storage")
		e.Bool(s.CanEncryptStorage)
	}
	{
		e.FieldStart("can_certify")
		e.Bool(s.CanCertify)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("expires_at")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("raw_key")
		s.RawKey.Encode(e)
	}
}

var jsonFieldsNameOfGpgKey = [13]string{
	0:  "id",
	1:  "primary_key_id",
	2:  "key_id",
	3:  "public_key",
	4:  "emails",
	5:  "subkeys",
	6:  "can_sign",
	7:  "can_encrypt_comms",
	8:  "can_encrypt_storage",
	9:  "can_certify",
	10: "created_at",
	11: "expires_at",
	12: "raw_key",
}

// Decode decodes GpgKey from json.
func (s *GpgKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKey to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primary_key_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PrimaryKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_key_id\"")
			}
		case "key_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "public_key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_key\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Emails = make([]GpgKeyEmailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GpgKeyEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "subkeys":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Subkeys = make([]GpgKeySubkeysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GpgKeySubkeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subkeys = append(s.Subkeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subkeys\"")
			}
		case "can_sign":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanSign = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_sign\"")
			}
		case "can_encrypt_comms":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanEncryptComms = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_comms\"")
			}
		case "can_encrypt_storage":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanEncryptStorage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_storage\"")
			}
		case "can_certify":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanCertify = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_certify\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "raw_key":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.RawKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGpgKey) {
					name = jsonFieldsNameOfGpgKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GpgKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GpgKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GpgKeyEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GpgKeyEmailsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Verified.Set {
			e.FieldStart("verified")
			s.Verified.Encode(e)
		}
	}
}

var jsonFieldsNameOfGpgKeyEmailsItem = [2]string{
	0: "email",
	1: "verified",
}

// Decode decodes GpgKeyEmailsItem from json.
func (s *GpgKeyEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKeyEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "verified":
			if err := func() error {
				s.Verified.Reset()
				if err := s.Verified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKeyEmailsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GpgKeyEmailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GpgKeyEmailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GpgKeySubkeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GpgKeySubkeysItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PrimaryKeyID.Set {
			e.FieldStart("primary_key_id")
			s.PrimaryKeyID.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			e.FieldStart("key_id")
			s.KeyID.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			e.FieldStart("public_key")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.FieldStart("emails")
			e.ArrStart()
			for _, elem := range s.Emails {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Subkeys != nil {
			e.FieldStart("subkeys")
			e.ArrStart()
			for _, elem := range s.Subkeys {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.CanSign.Set {
			e.FieldStart("can_sign")
			s.CanSign.Encode(e)
		}
	}
	{
		if s.CanEncryptComms.Set {
			e.FieldStart("can_encrypt_comms")
			s.CanEncryptComms.Encode(e)
		}
	}
	{
		if s.CanEncryptStorage.Set {
			e.FieldStart("can_encrypt_storage")
			s.CanEncryptStorage.Encode(e)
		}
	}
	{
		if s.CanCertify.Set {
			e.FieldStart("can_certify")
			s.CanCertify.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		if s.RawKey.Set {
			e.FieldStart("raw_key")
			s.RawKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfGpgKeySubkeysItem = [13]string{
	0:  "id",
	1:  "primary_key_id",
	2:  "key_id",
	3:  "public_key",
	4:  "emails",
	5:  "subkeys",
	6:  "can_sign",
	7:  "can_encrypt_comms",
	8:  "can_encrypt_storage",
	9:  "can_certify",
	10: "created_at",
	11: "expires_at",
	12: "raw_key",
}

// Decode decodes GpgKeySubkeysItem from json.
func (s *GpgKeySubkeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKeySubkeysItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primary_key_id":
			if err := func() error {
				s.PrimaryKeyID.Reset()
				if err := s.PrimaryKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_key_id\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "public_key":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_key\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "subkeys":
			if err := func() error {
				s.Subkeys = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Subkeys = append(s.Subkeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subkeys\"")
			}
		case "can_sign":
			if err := func() error {
				s.CanSign.Reset()
				if err := s.CanSign.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_sign\"")
			}
		case "can_encrypt_comms":
			if err := func() error {
				s.CanEncryptComms.Reset()
				if err := s.CanEncryptComms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_comms\"")
			}
		case "can_encrypt_storage":
			if err := func() error {
				s.CanEncryptStorage.Reset()
				if err := s.CanEncryptStorage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_storage\"")
			}
		case "can_certify":
			if err := func() error {
				s.CanCertify.Reset()
				if err := s.CanCertify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_certify\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "raw_key":
			if err := func() error {
				s.RawKey.Reset()
				if err := s.RawKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKeySubkeysItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GpgKeySubkeysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GpgKeySubkeysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupMapping) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupMapping) encodeFields(e *jx.Encoder) {
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGroupMapping = [1]string{
	0: "groups",
}

// Decode decodes GroupMapping from json.
func (s *GroupMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupMapping to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = make([]GroupMappingGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GroupMappingGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupMapping")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupMapping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupMapping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupMappingGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupMappingGroupsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("group_id")
		e.Str(s.GroupID)
	}
	{
		e.FieldStart("group_name")
		e.Str(s.GroupName)
	}
	{
		e.FieldStart("group_description")
		e.Str(s.GroupDescription)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SyncedAt.Set {
			e.FieldStart("synced_at")
			s.SyncedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfGroupMappingGroupsItem = [5]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
	3: "status",
	4: "synced_at",
}

// Decode decodes GroupMappingGroupsItem from json.
func (s *GroupMappingGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupMappingGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "synced_at":
			if err := func() error {
				s.SyncedAt.Reset()
				if err := s.SyncedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synced_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupMappingGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupMappingGroupsItem) {
					name = jsonFieldsNameOfGroupMappingGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupMappingGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupMappingGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Hook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Hook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("active")
		e.Bool(s.Active)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("test_url")
		json.EncodeURI(e, s.TestURL)
	}
	{
		e.FieldStart("ping_url")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.FieldStart("deliveries_url")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.FieldStart("last_response")
		s.LastResponse.Encode(e)
	}
}

var jsonFieldsNameOfHook = [13]string{
	0:  "type",
	1:  "id",
	2:  "name",
	3:  "active",
	4:  "events",
	5:  "config",
	6:  "updated_at",
	7:  "created_at",
	8:  "url",
	9:  "test_url",
	10: "ping_url",
	11: "deliveries_url",
	12: "last_response",
}

// Decode decodes Hook from json.
func (s *Hook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Hook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "test_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_url\"")
			}
		case "ping_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PingURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ping_url\"")
			}
		case "deliveries_url":
			if err := func() error {
				s.DeliveriesURL.Reset()
				if err := s.DeliveriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deliveries_url\"")
			}
		case "last_response":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.LastResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Hook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHook) {
					name = jsonFieldsNameOfHook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Hook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Hook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Room.Set {
			e.FieldStart("room")
			s.Room.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			e.FieldStart("subdomain")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			e.FieldStart("digest")
			s.Digest.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
}

var jsonFieldsNameOfHookConfig = [10]string{
	0: "email",
	1: "password",
	2: "room",
	3: "subdomain",
	4: "url",
	5: "insecure_ssl",
	6: "content_type",
	7: "digest",
	8: "secret",
	9: "token",
}

// Decode decodes HookConfig from json.
func (s *HookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "room":
			if err := func() error {
				s.Room.Reset()
				if err := s.Room.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room\"")
			}
		case "subdomain":
			if err := func() error {
				s.Subdomain.Reset()
				if err := s.Subdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdomain\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "digest":
			if err := func() error {
				s.Digest.Reset()
				if err := s.Digest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digest\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookDelivery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookDelivery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("guid")
		e.Str(s.GUID)
	}
	{
		e.FieldStart("delivered_at")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.FieldStart("redelivery")
		e.Bool(s.Redelivery)
	}
	{
		e.FieldStart("duration")
		e.Float64(s.Duration)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("status_code")
		e.Int(s.StatusCode)
	}
	{
		e.FieldStart("event")
		e.Str(s.Event)
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		e.FieldStart("installation_id")
		s.InstallationID.Encode(e)
	}
	{
		e.FieldStart("repository_id")
		s.RepositoryID.Encode(e)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		e.FieldStart("request")
		s.Request.Encode(e)
	}
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfHookDelivery = [14]string{
	0:  "id",
	1:  "guid",
	2:  "delivered_at",
	3:  "redelivery",
	4:  "duration",
	5:  "status",
	6:  "status_code",
	7:  "event",
	8:  "action",
	9:  "installation_id",
	10: "repository_id",
	11: "url",
	12: "request",
	13: "response",
}

// Decode decodes HookDelivery from json.
func (s *HookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDelivery to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "delivered_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DeliveredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivered_at\"")
			}
		case "redelivery":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Redelivery = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redelivery\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_code":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StatusCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "installation_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InstallationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation_id\"")
			}
		case "repository_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.RepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "request":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Request.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "response":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDelivery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDelivery) {
					name = jsonFieldsNameOfHookDelivery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookDelivery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDelivery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookDeliveryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookDeliveryItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("guid")
		e.Str(s.GUID)
	}
	{
		e.FieldStart("delivered_at")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.FieldStart("redelivery")
		e.Bool(s.Redelivery)
	}
	{
		e.FieldStart("duration")
		e.Float64(s.Duration)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("status_code")
		e.Int(s.StatusCode)
	}
	{
		e.FieldStart("event")
		e.Str(s.Event)
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		e.FieldStart("installation_id")
		s.InstallationID.Encode(e)
	}
	{
		e.FieldStart("repository_id")
		s.RepositoryID.Encode(e)
	}
}

var jsonFieldsNameOfHookDeliveryItem = [11]string{
	0:  "id",
	1:  "guid",
	2:  "delivered_at",
	3:  "redelivery",
	4:  "duration",
	5:  "status",
	6:  "status_code",
	7:  "event",
	8:  "action",
	9:  "installation_id",
	10: "repository_id",
}

// Decode decodes HookDeliveryItem from json.
func (s *HookDeliveryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "delivered_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DeliveredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivered_at\"")
			}
		case "redelivery":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Redelivery = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redelivery\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_code":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StatusCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "installation_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InstallationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation_id\"")
			}
		case "repository_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.RepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryItem) {
					name = jsonFieldsNameOfHookDeliveryItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookDeliveryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookDeliveryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookDeliveryRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headers")
		s.Headers.Encode(e)
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
}

var jsonFieldsNameOfHookDeliveryRequest = [2]string{
	0: "headers",
	1: "payload",
}

// Decode decodes HookDeliveryRequest from json.
func (s *HookDeliveryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryRequest) {
					name = jsonFieldsNameOfHookDeliveryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookDeliveryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HookDeliveryRequestHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HookDeliveryRequestHeaders from json.
func (s *HookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequestHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequestHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HookDeliveryRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HookDeliveryRequestPayload) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HookDeliveryRequestPayload from json.
func (s *HookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequestPayload to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequestPayload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HookDeliveryRequestPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryRequestPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookDeliveryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookDeliveryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headers")
		s.Headers.Encode(e)
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
}

var jsonFieldsNameOfHookDeliveryResponse = [2]string{
	0: "headers",
	1: "payload",
}

// Decode decodes HookDeliveryResponse from json.
func (s *HookDeliveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryResponse) {
					name = jsonFieldsNameOfHookDeliveryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookDeliveryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HookDeliveryResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HookDeliveryResponseHeaders from json.
func (s *HookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HookDeliveryResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookDeliveryResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HookResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HookResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfHookResponse = [3]string{
	0: "code",
	1: "status",
	2: "message",
}

// Decode decodes HookResponse from json.
func (s *HookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookResponse) {
					name = jsonFieldsNameOfHookResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HookResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Hovercard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Hovercard) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfHovercard = [1]string{
	0: "contexts",
}

// Decode decodes Hovercard from json.
func (s *Hovercard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Hovercard to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = make([]HovercardContextsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HovercardContextsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Hovercard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHovercard) {
					name = jsonFieldsNameOfHovercard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Hovercard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Hovercard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HovercardContextsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HovercardContextsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("octicon")
		e.Str(s.Octicon)
	}
}

var jsonFieldsNameOfHovercardContextsItem = [2]string{
	0: "message",
	1: "octicon",
}

// Decode decodes HovercardContextsItem from json.
func (s *HovercardContextsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HovercardContextsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "octicon":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Octicon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"octicon\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HovercardContextsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHovercardContextsItem) {
					name = jsonFieldsNameOfHovercardContextsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HovercardContextsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HovercardContextsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Import) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Import) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vcs")
		s.Vcs.Encode(e)
	}
	{
		if s.UseLfs.Set {
			e.FieldStart("use_lfs")
			s.UseLfs.Encode(e)
		}
	}
	{
		e.FieldStart("vcs_url")
		e.Str(s.VcsURL)
	}
	{
		if s.SvcRoot.Set {
			e.FieldStart("svc_root")
			s.SvcRoot.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.FieldStart("tfvc_project")
			s.TfvcProject.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.StatusText.Set {
			e.FieldStart("status_text")
			s.StatusText.Encode(e)
		}
	}
	{
		if s.FailedStep.Set {
			e.FieldStart("failed_step")
			s.FailedStep.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.ImportPercent.Set {
			e.FieldStart("import_percent")
			s.ImportPercent.Encode(e)
		}
	}
	{
		if s.CommitCount.Set {
			e.FieldStart("commit_count")
			s.CommitCount.Encode(e)
		}
	}
	{
		if s.PushPercent.Set {
			e.FieldStart("push_percent")
			s.PushPercent.Encode(e)
		}
	}
	{
		if s.HasLargeFiles.Set {
			e.FieldStart("has_large_files")
			s.HasLargeFiles.Encode(e)
		}
	}
	{
		if s.LargeFilesSize.Set {
			e.FieldStart("large_files_size")
			s.LargeFilesSize.Encode(e)
		}
	}
	{
		if s.LargeFilesCount.Set {
			e.FieldStart("large_files_count")
			s.LargeFilesCount.Encode(e)
		}
	}
	{
		if s.ProjectChoices != nil {
			e.FieldStart("project_choices")
			e.ArrStart()
			for _, elem := range s.ProjectChoices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.AuthorsCount.Set {
			e.FieldStart("authors_count")
			s.AuthorsCount.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("authors_url")
		json.EncodeURI(e, s.AuthorsURL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.SvnRoot.Set {
			e.FieldStart("svn_root")
			s.SvnRoot.Encode(e)
		}
	}
}

var jsonFieldsNameOfImport = [23]string{
	0:  "vcs",
	1:  "use_lfs",
	2:  "vcs_url",
	3:  "svc_root",
	4:  "tfvc_project",
	5:  "status",
	6:  "status_text",
	7:  "failed_step",
	8:  "error_message",
	9:  "import_percent",
	10: "commit_count",
	11: "push_percent",
	12: "has_large_files",
	13: "large_files_size",
	14: "large_files_count",
	15: "project_choices",
	16: "message",
	17: "authors_count",
	18: "url",
	19: "html_url",
	20: "authors_url",
	21: "repository_url",
	22: "svn_root",
}

// Decode decodes Import from json.
func (s *Import) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Import to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "use_lfs":
			if err := func() error {
				s.UseLfs.Reset()
				if err := s.UseLfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_lfs\"")
			}
		case "vcs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VcsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_url\"")
			}
		case "svc_root":
			if err := func() error {
				s.SvcRoot.Reset()
				if err := s.SvcRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svc_root\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_text":
			if err := func() error {
				s.StatusText.Reset()
				if err := s.StatusText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_text\"")
			}
		case "failed_step":
			if err := func() error {
				s.FailedStep.Reset()
				if err := s.FailedStep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_step\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "import_percent":
			if err := func() error {
				s.ImportPercent.Reset()
				if err := s.ImportPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_percent\"")
			}
		case "commit_count":
			if err := func() error {
				s.CommitCount.Reset()
				if err := s.CommitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_count\"")
			}
		case "push_percent":
			if err := func() error {
				s.PushPercent.Reset()
				if err := s.PushPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push_percent\"")
			}
		case "has_large_files":
			if err := func() error {
				s.HasLargeFiles.Reset()
				if err := s.HasLargeFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_large_files\"")
			}
		case "large_files_size":
			if err := func() error {
				s.LargeFilesSize.Reset()
				if err := s.LargeFilesSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"large_files_size\"")
			}
		case "large_files_count":
			if err := func() error {
				s.LargeFilesCount.Reset()
				if err := s.LargeFilesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"large_files_count\"")
			}
		case "project_choices":
			if err := func() error {
				s.ProjectChoices = make([]ImportProjectChoicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ImportProjectChoicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProjectChoices = append(s.ProjectChoices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_choices\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "authors_count":
			if err := func() error {
				s.AuthorsCount.Reset()
				if err := s.AuthorsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authors_count\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "authors_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AuthorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authors_url\"")
			}
		case "repository_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "svn_root":
			if err := func() error {
				s.SvnRoot.Reset()
				if err := s.SvnRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_root\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Import")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100101,
		0b00000000,
		0b00111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImport) {
					name = jsonFieldsNameOfImport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Import) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Import) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ImportProjectChoicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ImportProjectChoicesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Vcs.Set {
			e.FieldStart("vcs")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.FieldStart("tfvc_project")
			s.TfvcProject.Encode(e)
		}
	}
	{
		if s.HumanName.Set {
			e.FieldStart("human_name")
			s.HumanName.Encode(e)
		}
	}
}

var jsonFieldsNameOfImportProjectChoicesItem = [3]string{
	0: "vcs",
	1: "tfvc_project",
	2: "human_name",
}

// Decode decodes ImportProjectChoicesItem from json.
func (s *ImportProjectChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportProjectChoicesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		case "human_name":
			if err := func() error {
				s.HumanName.Reset()
				if err := s.HumanName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImportProjectChoicesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportProjectChoicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportProjectChoicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportStatus as json.
func (s ImportStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ImportStatus from json.
func (s *ImportStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ImportStatus(v) {
	case ImportStatusAuth:
		*s = ImportStatusAuth
	case ImportStatusError:
		*s = ImportStatusError
	case ImportStatusNone:
		*s = ImportStatusNone
	case ImportStatusDetecting:
		*s = ImportStatusDetecting
	case ImportStatusChoose:
		*s = ImportStatusChoose
	case ImportStatusAuthFailed:
		*s = ImportStatusAuthFailed
	case ImportStatusImporting:
		*s = ImportStatusImporting
	case ImportStatusMapping:
		*s = ImportStatusMapping
	case ImportStatusWaitingToPush:
		*s = ImportStatusWaitingToPush
	case ImportStatusPushing:
		*s = ImportStatusPushing
	case ImportStatusComplete:
		*s = ImportStatusComplete
	case ImportStatusSetup:
		*s = ImportStatusSetup
	case ImportStatusUnknown:
		*s = ImportStatusUnknown
	case ImportStatusDetectionFoundMultiple:
		*s = ImportStatusDetectionFoundMultiple
	case ImportStatusDetectionFoundNothing:
		*s = ImportStatusDetectionFoundNothing
	case ImportStatusDetectionNeedsAuth:
		*s = ImportStatusDetectionNeedsAuth
	default:
		*s = ImportStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ImportStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstallationToken) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstallationToken) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("expires_at")
		e.Str(s.ExpiresAt)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.FieldStart("repository_selection")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.FieldStart("repositories")
			e.ArrStart()
			for _, elem := range s.Repositories {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.FieldStart("single_file")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.FieldStart("has_multiple_single_files")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.FieldStart("single_file_paths")
			e.ArrStart()
			for _, elem := range s.SingleFilePaths {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInstallationToken = [8]string{
	0: "token",
	1: "expires_at",
	2: "permissions",
	3: "repository_selection",
	4: "repositories",
	5: "single_file",
	6: "has_multiple_single_files",
	7: "single_file_paths",
}

// Decode decodes InstallationToken from json.
func (s *InstallationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallationToken to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExpiresAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "has_multiple_single_files":
			if err := func() error {
				s.HasMultipleSingleFiles.Reset()
				if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_multiple_single_files\"")
			}
		case "single_file_paths":
			if err := func() error {
				s.SingleFilePaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SingleFilePaths = append(s.SingleFilePaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_paths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallationToken")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallationToken) {
					name = jsonFieldsNameOfInstallationToken[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstallationToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallationToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (s InstallationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (s *InstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallationTokenRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallationTokenRepositorySelection(v) {
	case InstallationTokenRepositorySelectionAll:
		*s = InstallationTokenRepositorySelectionAll
	case InstallationTokenRepositorySelectionSelected:
		*s = InstallationTokenRepositorySelectionSelected
	default:
		*s = InstallationTokenRepositorySelection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstallationTokenRepositorySelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstallationTokenRepositorySelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Integration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Integration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("external_url")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.FieldStart("installations_count")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.FieldStart("webhook_secret")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.FieldStart("pem")
			s.Pem.Encode(e)
		}
	}
}

var jsonFieldsNameOfIntegration = [17]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
	12: "installations_count",
	13: "client_id",
	14: "client_secret",
	15: "webhook_secret",
	16: "pem",
}

// Decode decodes Integration from json.
func (s *Integration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Integration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "installations_count":
			if err := func() error {
				s.InstallationsCount.Reset()
				if err := s.InstallationsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installations_count\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		case "pem":
			if err := func() error {
				s.Pem.Reset()
				if err := s.Pem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Integration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIntegration) {
					name = jsonFieldsNameOfIntegration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Integration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Integration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntegrationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntegrationPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Issues.Set {
			e.FieldStart("issues")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			e.FieldStart("deployments")
			s.Deployments.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		e.Str(elem)
	}
}

var jsonFieldsNameOfIntegrationPermissions = [5]string{
	0: "issues",
	1: "checks",
	2: "metadata",
	3: "contents",
	4: "deployments",
}

// Decode decodes IntegrationPermissions from json.
func (s *IntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntegrationPermissions to nil")
	}
	s.AdditionalProps = map[string]string{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntegrationPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntegrationPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntegrationPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IntegrationPermissionsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IntegrationPermissionsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IntegrationPermissionsAdditional from json.
func (s *IntegrationPermissionsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntegrationPermissionsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntegrationPermissionsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IntegrationPermissionsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntegrationPermissionsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractionExpiry as json.
func (s InteractionExpiry) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionExpiry from json.
func (s *InteractionExpiry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionExpiry to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionExpiry(v) {
	case InteractionExpiryOneDay:
		*s = InteractionExpiryOneDay
	case InteractionExpiryThreeDays:
		*s = InteractionExpiryThreeDays
	case InteractionExpiryOneWeek:
		*s = InteractionExpiryOneWeek
	case InteractionExpiryOneMonth:
		*s = InteractionExpiryOneMonth
	case InteractionExpirySixMonths:
		*s = InteractionExpirySixMonths
	default:
		*s = InteractionExpiry(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractionExpiry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionExpiry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractionGroup as json.
func (s InteractionGroup) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionGroup from json.
func (s *InteractionGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionGroup to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionGroup(v) {
	case InteractionGroupExistingUsers:
		*s = InteractionGroupExistingUsers
	case InteractionGroupContributorsOnly:
		*s = InteractionGroupContributorsOnly
	case InteractionGroupCollaboratorsOnly:
		*s = InteractionGroupCollaboratorsOnly
	default:
		*s = InteractionGroup(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InteractionGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractionLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractionLimit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("limit")
		s.Limit.Encode(e)
	}
	{
		if s.Expiry.Set {
			e.FieldStart("expiry")
			s.Expiry.Encode(e)
		}
	}
}

var jsonFieldsNameOfInteractionLimit = [2]string{
	0: "limit",
	1: "expiry",
}

// Decode decodes InteractionLimit from json.
func (s *InteractionLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionLimit) {
					name = jsonFieldsNameOfInteractionLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractionLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InteractionLimitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InteractionLimitResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("limit")
		s.Limit.Encode(e)
	}
	{
		e.FieldStart("origin")
		e.Str(s.Origin)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
}

var jsonFieldsNameOfInteractionLimitResponse = [3]string{
	0: "limit",
	1: "origin",
	2: "expires_at",
}

// Decode decodes InteractionLimitResponse from json.
func (s *InteractionLimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionLimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "origin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Origin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionLimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionLimitResponse) {
					name = jsonFieldsNameOfInteractionLimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InteractionLimitResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InteractionLimitResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Issue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Issue) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.FieldStart("assignees")
			s.Assignees.Encode(e)
		}
	}
	{
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	{
		e.FieldStart("locked")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.FieldStart("active_lock_reason")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.FieldStart("pull_request")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.ClosedBy.Set {
			e.FieldStart("closed_by")
			s.ClosedBy.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.FieldStart("timeline_url")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssue = [32]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "repository_url",
	4:  "labels_url",
	5:  "comments_url",
	6:  "events_url",
	7:  "html_url",
	8:  "number",
	9:  "state",
	10: "title",
	11: "body",
	12: "user",
	13: "labels",
	14: "assignee",
	15: "assignees",
	16: "milestone",
	17: "locked",
	18: "active_lock_reason",
	19: "comments",
	20: "pull_request",
	21: "closed_at",
	22: "created_at",
	23: "updated_at",
	24: "closed_by",
	25: "body_html",
	26: "body_text",
	27: "timeline_url",
	28: "repository",
	29: "performed_via_github_app",
	30: "author_association",
	31: "reactions",
}

// Decode decodes Issue from json.
func (s *Issue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Issue to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.Labels = make([]IssueLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignee":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "locked":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_by":
			if err := func() error {
				s.ClosedBy.Reset()
				if err := s.ClosedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_by\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Issue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b01110111,
		0b11101011,
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssue) {
					name = jsonFieldsNameOfIssue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Issue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Issue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("issue_url")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueComment = [14]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "body",
	4:  "body_text",
	5:  "body_html",
	6:  "html_url",
	7:  "user",
	8:  "created_at",
	9:  "updated_at",
	10: "issue_url",
	11: "author_association",
	12: "performed_via_github_app",
	13: "reactions",
}

// Decode decodes IssueComment from json.
func (s *IssueComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "issue_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueComment) {
					name = jsonFieldsNameOfIssueComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("actor")
		s.Actor.Encode(e)
	}
	{
		e.FieldStart("event")
		e.Str(s.Event)
	}
	{
		e.FieldStart("commit_id")
		s.CommitID.Encode(e)
	}
	{
		e.FieldStart("commit_url")
		s.CommitURL.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Issue.Set {
			e.FieldStart("issue")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.FieldStart("assignee")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Assigner.Set {
			e.FieldStart("assigner")
			s.Assigner.Encode(e)
		}
	}
	{
		if s.ReviewRequester.Set {
			e.FieldStart("review_requester")
			s.ReviewRequester.Encode(e)
		}
	}
	{
		if s.RequestedReviewer.Set {
			e.FieldStart("requested_reviewer")
			s.RequestedReviewer.Encode(e)
		}
	}
	{
		if s.RequestedTeam.Set {
			e.FieldStart("requested_team")
			s.RequestedTeam.Encode(e)
		}
	}
	{
		if s.DismissedReview.Set {
			e.FieldStart("dismissed_review")
			s.DismissedReview.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.FieldStart("milestone")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.ProjectCard.Set {
			e.FieldStart("project_card")
			s.ProjectCard.Encode(e)
		}
	}
	{
		if s.Rename.Set {
			e.FieldStart("rename")
			s.Rename.Encode(e)
		}
	}
	{
		if s.AuthorAssociation.Set {
			e.FieldStart("author_association")
			s.AuthorAssociation.Encode(e)
		}
	}
	{
		if s.LockReason.Set {
			e.FieldStart("lock_reason")
			s.LockReason.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueEvent = [22]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "actor",
	4:  "event",
	5:  "commit_id",
	6:  "commit_url",
	7:  "created_at",
	8:  "issue",
	9:  "label",
	10: "assignee",
	11: "assigner",
	12: "review_requester",
	13: "requested_reviewer",
	14: "requested_team",
	15: "dismissed_review",
	16: "milestone",
	17: "project_card",
	18: "rename",
	19: "author_association",
	20: "lock_reason",
	21: "performed_via_github_app",
}

// Decode decodes IssueEvent from json.
func (s *IssueEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEvent to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "actor":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "commit_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "commit_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CommitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_url\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assigner":
			if err := func() error {
				s.Assigner.Reset()
				if err := s.Assigner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigner\"")
			}
		case "review_requester":
			if err := func() error {
				s.ReviewRequester.Reset()
				if err := s.ReviewRequester.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_requester\"")
			}
		case "requested_reviewer":
			if err := func() error {
				s.RequestedReviewer.Reset()
				if err := s.RequestedReviewer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewer\"")
			}
		case "requested_team":
			if err := func() error {
				s.RequestedTeam.Reset()
				if err := s.RequestedTeam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_team\"")
			}
		case "dismissed_review":
			if err := func() error {
				s.DismissedReview.Reset()
				if err := s.DismissedReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_review\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "project_card":
			if err := func() error {
				s.ProjectCard.Reset()
				if err := s.ProjectCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_card\"")
			}
		case "rename":
			if err := func() error {
				s.Rename.Reset()
				if err := s.Rename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rename\"")
			}
		case "author_association":
			if err := func() error {
				s.AuthorAssociation.Reset()
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "lock_reason":
			if err := func() error {
				s.LockReason.Reset()
				if err := s.LockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_reason\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEvent) {
					name = jsonFieldsNameOfIssueEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEventDismissedReview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEventDismissedReview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("review_id")
		e.Int(s.ReviewID)
	}
	{
		e.FieldStart("dismissal_message")
		s.DismissalMessage.Encode(e)
	}
	{
		if s.DismissalCommitID.Set {
			e.FieldStart("dismissal_commit_id")
			s.DismissalCommitID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueEventDismissedReview = [4]string{
	0: "state",
	1: "review_id",
	2: "dismissal_message",
	3: "dismissal_commit_id",
}

// Decode decodes IssueEventDismissedReview from json.
func (s *IssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventDismissedReview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ReviewID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_id\"")
			}
		case "dismissal_message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DismissalMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_message\"")
			}
		case "dismissal_commit_id":
			if err := func() error {
				s.DismissalCommitID.Reset()
				if err := s.DismissalCommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_commit_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventDismissedReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventDismissedReview) {
					name = jsonFieldsNameOfIssueEventDismissedReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEventDismissedReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEventDismissedReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEventLabel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEventLabel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("color")
		s.Color.Encode(e)
	}
}

var jsonFieldsNameOfIssueEventLabel = [2]string{
	0: "name",
	1: "color",
}

// Decode decodes IssueEventLabel from json.
func (s *IssueEventLabel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventLabel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventLabel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventLabel) {
					name = jsonFieldsNameOfIssueEventLabel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEventLabel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEventLabel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEventMilestone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEventMilestone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfIssueEventMilestone = [1]string{
	0: "title",
}

// Decode decodes IssueEventMilestone from json.
func (s *IssueEventMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventMilestone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventMilestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventMilestone) {
					name = jsonFieldsNameOfIssueEventMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEventMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEventMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEventProjectCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEventProjectCard) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("project_url")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.FieldStart("project_id")
		e.Int(s.ProjectID)
	}
	{
		e.FieldStart("column_name")
		e.Str(s.ColumnName)
	}
	{
		if s.PreviousColumnName.Set {
			e.FieldStart("previous_column_name")
			s.PreviousColumnName.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueEventProjectCard = [6]string{
	0: "url",
	1: "id",
	2: "project_url",
	3: "project_id",
	4: "column_name",
	5: "previous_column_name",
}

// Decode decodes IssueEventProjectCard from json.
func (s *IssueEventProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventProjectCard to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProjectID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "column_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ColumnName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_name\"")
			}
		case "previous_column_name":
			if err := func() error {
				s.PreviousColumnName.Reset()
				if err := s.PreviousColumnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_column_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventProjectCard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventProjectCard) {
					name = jsonFieldsNameOfIssueEventProjectCard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEventProjectCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEventProjectCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueEventRename) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueEventRename) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
}

var jsonFieldsNameOfIssueEventRename = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes IssueEventRename from json.
func (s *IssueEventRename) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventRename to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventRename")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventRename) {
					name = jsonFieldsNameOfIssueEventRename[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueEventRename) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueEventRename) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueLabelsItem as json.
func (s IssueLabelsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssueLabelsItem:
		e.Str(s.String)
	case IssueLabelsItem1IssueLabelsItem:
		s.IssueLabelsItem1.Encode(e)
	}
}

// Decode decodes IssueLabelsItem from json.
func (s *IssueLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.IssueLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssueLabelsItem1IssueLabelsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssueLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssueLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueLabelsItem1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueLabelsItem1) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueLabelsItem1 = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes IssueLabelsItem1 from json.
func (s *IssueLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueLabelsItem1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueLabelsItem1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueLabelsItem1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuePullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuePullRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MergedAt.Set {
			e.FieldStart("merged_at")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("diff_url")
		s.DiffURL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("patch_url")
		s.PatchURL.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
}

var jsonFieldsNameOfIssuePullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssuePullRequest from json.
func (s *IssuePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuePullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuePullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuePullRequest) {
					name = jsonFieldsNameOfIssuePullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuePullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuePullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("locked")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.FieldStart("active_lock_reason")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		if s.Assignees.Set {
			e.FieldStart("assignees")
			s.Assignees.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	{
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.PullRequest.Set {
			e.FieldStart("pull_request")
			s.PullRequest.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.FieldStart("timeline_url")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueSearchResultItem = [33]string{
	0:  "url",
	1:  "repository_url",
	2:  "labels_url",
	3:  "comments_url",
	4:  "events_url",
	5:  "html_url",
	6:  "id",
	7:  "node_id",
	8:  "number",
	9:  "title",
	10: "locked",
	11: "active_lock_reason",
	12: "assignees",
	13: "user",
	14: "labels",
	15: "state",
	16: "assignee",
	17: "milestone",
	18: "comments",
	19: "created_at",
	20: "updated_at",
	21: "closed_at",
	22: "text_matches",
	23: "pull_request",
	24: "body",
	25: "score",
	26: "author_association",
	27: "draft",
	28: "repository",
	29: "body_html",
	30: "body_text",
	31: "timeline_url",
	32: "performed_via_github_app",
}

// Decode decodes IssueSearchResultItem from json.
func (s *IssueSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItem to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Labels = make([]IssueSearchResultItemLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueSearchResultItemLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "assignee":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "score":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11100111,
		0b00111111,
		0b00000110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSearchResultItem) {
					name = jsonFieldsNameOfIssueSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueSearchResultItemLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueSearchResultItemLabelsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueSearchResultItemLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "color",
	5: "default",
	6: "description",
}

// Decode decodes IssueSearchResultItemLabelsItem from json.
func (s *IssueSearchResultItemLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItemLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItemLabelsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueSearchResultItemLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueSearchResultItemLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueSearchResultItemPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueSearchResultItemPullRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MergedAt.Set {
			e.FieldStart("merged_at")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("diff_url")
		s.DiffURL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("patch_url")
		s.PatchURL.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
}

var jsonFieldsNameOfIssueSearchResultItemPullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (s *IssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItemPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItemPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSearchResultItemPullRequest) {
					name = jsonFieldsNameOfIssueSearchResultItemPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueSearchResultItemPullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueSearchResultItemPullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.FieldStart("assignees")
			s.Assignees.Encode(e)
		}
	}
	{
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	{
		e.FieldStart("locked")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.FieldStart("active_lock_reason")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.FieldStart("pull_request")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.FieldStart("timeline_url")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.FieldStart("performed_via_github_app")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssueSimple = [30]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "repository_url",
	4:  "labels_url",
	5:  "comments_url",
	6:  "events_url",
	7:  "html_url",
	8:  "number",
	9:  "state",
	10: "title",
	11: "body",
	12: "user",
	13: "labels",
	14: "assignee",
	15: "assignees",
	16: "milestone",
	17: "locked",
	18: "active_lock_reason",
	19: "comments",
	20: "pull_request",
	21: "closed_at",
	22: "created_at",
	23: "updated_at",
	24: "author_association",
	25: "body_html",
	26: "body_text",
	27: "timeline_url",
	28: "repository",
	29: "performed_via_github_app",
}

// Decode decodes IssueSimple from json.
func (s *IssueSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSimple to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.Labels = make([]Label, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Label
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignee":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "locked":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b01110111,
		0b11101011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSimple) {
					name = jsonFieldsNameOfIssueSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssueSimplePullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssueSimplePullRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MergedAt.Set {
			e.FieldStart("merged_at")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("diff_url")
		s.DiffURL.Encode(e)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("patch_url")
		s.PatchURL.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
}

var jsonFieldsNameOfIssueSimplePullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssueSimplePullRequest from json.
func (s *IssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSimplePullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSimplePullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSimplePullRequest) {
					name = jsonFieldsNameOfIssueSimplePullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssueSimplePullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssueSimplePullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesAddAssigneesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesAddAssigneesReq) encodeFields(e *jx.Encoder) {
	{
		if s.Assignees != nil {
			e.FieldStart("assignees")
			e.ArrStart()
			for _, elem := range s.Assignees {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIssuesAddAssigneesReq = [1]string{
	0: "assignees",
}

// Decode decodes IssuesAddAssigneesReq from json.
func (s *IssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesAddAssigneesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			if err := func() error {
				s.Assignees = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesAddAssigneesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesAddAssigneesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesAddAssigneesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateCommentForbidden as json.
func (s *IssuesCreateCommentForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentForbidden from json.
func (s *IssuesCreateCommentForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateCommentForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateCommentForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateCommentGone as json.
func (s *IssuesCreateCommentGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentGone from json.
func (s *IssuesCreateCommentGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateCommentGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateCommentGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateCommentNotFound as json.
func (s *IssuesCreateCommentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentNotFound from json.
func (s *IssuesCreateCommentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateCommentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateCommentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesCreateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesCreateCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfIssuesCreateCommentReq = [1]string{
	0: "body",
}

// Decode decodes IssuesCreateCommentReq from json.
func (s *IssuesCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateCommentReq) {
					name = jsonFieldsNameOfIssuesCreateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateForbidden as json.
func (s *IssuesCreateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateForbidden from json.
func (s *IssuesCreateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateGone as json.
func (s *IssuesCreateGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateGone from json.
func (s *IssuesCreateGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesCreateLabelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesCreateLabelReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssuesCreateLabelReq = [3]string{
	0: "name",
	1: "color",
	2: "description",
}

// Decode decodes IssuesCreateLabelReq from json.
func (s *IssuesCreateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateLabelReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateLabelReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateLabelReq) {
					name = jsonFieldsNameOfIssuesCreateLabelReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateLabelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateLabelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesCreateMilestoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesCreateMilestoneReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			e.FieldStart("due_on")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfIssuesCreateMilestoneReq = [4]string{
	0: "title",
	1: "state",
	2: "description",
	3: "due_on",
}

// Decode decodes IssuesCreateMilestoneReq from json.
func (s *IssuesCreateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateMilestoneReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "due_on":
			if err := func() error {
				s.DueOn.Reset()
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateMilestoneReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateMilestoneReq) {
					name = jsonFieldsNameOfIssuesCreateMilestoneReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateMilestoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateMilestoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (s IssuesCreateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (s *IssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateMilestoneReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesCreateMilestoneReqState(v) {
	case IssuesCreateMilestoneReqStateOpen:
		*s = IssuesCreateMilestoneReqStateOpen
	case IssuesCreateMilestoneReqStateClosed:
		*s = IssuesCreateMilestoneReqStateClosed
	default:
		*s = IssuesCreateMilestoneReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesCreateMilestoneReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateMilestoneReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateNotFound as json.
func (s *IssuesCreateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateNotFound from json.
func (s *IssuesCreateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesCreateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.FieldStart("assignee")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.FieldStart("milestone")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			e.FieldStart("labels")
			e.ArrStart()
			for _, elem := range s.Labels {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			e.FieldStart("assignees")
			e.ArrStart()
			for _, elem := range s.Assignees {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIssuesCreateReq = [6]string{
	0: "title",
	1: "body",
	2: "assignee",
	3: "milestone",
	4: "labels",
	5: "assignees",
}

// Decode decodes IssuesCreateReq from json.
func (s *IssuesCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "labels":
			if err := func() error {
				s.Labels = make([]IssuesCreateReqLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssuesCreateReqLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateReq) {
					name = jsonFieldsNameOfIssuesCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateReqLabelsItem as json.
func (s IssuesCreateReqLabelsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesCreateReqLabelsItem:
		e.Str(s.String)
	case IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem:
		s.IssuesCreateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesCreateReqLabelsItem from json.
func (s *IssuesCreateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.IssuesCreateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesCreateReqLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateReqLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesCreateReqLabelsItem1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesCreateReqLabelsItem1) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssuesCreateReqLabelsItem1 = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "color",
}

// Decode decodes IssuesCreateReqLabelsItem1 from json.
func (s *IssuesCreateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateReqLabelsItem1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesCreateReqLabelsItem1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateReqLabelsItem1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateReqMilestone as json.
func (s IssuesCreateReqMilestone) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesCreateReqMilestone:
		e.Str(s.String)
	case IntIssuesCreateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqMilestone from json.
func (s *IssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqMilestone to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqMilestone
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesCreateReqMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateReqMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateReqTitle as json.
func (s IssuesCreateReqTitle) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesCreateReqTitle:
		e.Str(s.String)
	case IntIssuesCreateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqTitle from json.
func (s *IssuesCreateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqTitle to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqTitle
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesCreateReqTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesCreateReqTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetEventForbidden as json.
func (s *IssuesGetEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventForbidden from json.
func (s *IssuesGetEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetEventGone as json.
func (s *IssuesGetEventGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventGone from json.
func (s *IssuesGetEventGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetEventGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetEventGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetEventNotFound as json.
func (s *IssuesGetEventNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventNotFound from json.
func (s *IssuesGetEventNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetEventNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetEventNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetGone as json.
func (s *IssuesGetGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetGone from json.
func (s *IssuesGetGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetMovedPermanently as json.
func (s *IssuesGetMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetMovedPermanently from json.
func (s *IssuesGetMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesGetNotFound as json.
func (s *IssuesGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesGetNotFound from json.
func (s *IssuesGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesListCommentsGone as json.
func (s *IssuesListCommentsGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsGone from json.
func (s *IssuesListCommentsGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesListCommentsGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesListCommentsGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesListCommentsNotFound as json.
func (s *IssuesListCommentsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsNotFound from json.
func (s *IssuesListCommentsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesListCommentsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesListCommentsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesListForRepoMovedPermanently as json.
func (s *IssuesListForRepoMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoMovedPermanently from json.
func (s *IssuesListForRepoMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForRepoMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesListForRepoMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesListForRepoMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesListForRepoNotFound as json.
func (s *IssuesListForRepoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoNotFound from json.
func (s *IssuesListForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForRepoNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesListForRepoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesListForRepoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockForbidden as json.
func (s *IssuesLockForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesLockForbidden from json.
func (s *IssuesLockForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesLockForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesLockForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockGone as json.
func (s *IssuesLockGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesLockGone from json.
func (s *IssuesLockGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesLockGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesLockGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockNotFound as json.
func (s *IssuesLockNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesLockNotFound from json.
func (s *IssuesLockNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesLockNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesLockNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesLockReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesLockReq) encodeFields(e *jx.Encoder) {
	{
		if s.LockReason.Set {
			e.FieldStart("lock_reason")
			s.LockReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssuesLockReq = [1]string{
	0: "lock_reason",
}

// Decode decodes IssuesLockReq from json.
func (s *IssuesLockReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_reason":
			if err := func() error {
				s.LockReason.Reset()
				if err := s.LockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesLockReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesLockReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesLockReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockReqLockReason as json.
func (s IssuesLockReqLockReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesLockReqLockReason from json.
func (s *IssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockReqLockReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesLockReqLockReason(v) {
	case IssuesLockReqLockReasonOffTopic:
		*s = IssuesLockReqLockReasonOffTopic
	case IssuesLockReqLockReasonTooHeated:
		*s = IssuesLockReqLockReasonTooHeated
	case IssuesLockReqLockReasonResolved:
		*s = IssuesLockReqLockReasonResolved
	case IssuesLockReqLockReasonSpam:
		*s = IssuesLockReqLockReasonSpam
	default:
		*s = IssuesLockReqLockReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesLockReqLockReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesLockReqLockReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesRemoveAssigneesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesRemoveAssigneesReq) encodeFields(e *jx.Encoder) {
	{
		if s.Assignees != nil {
			e.FieldStart("assignees")
			e.ArrStart()
			for _, elem := range s.Assignees {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIssuesRemoveAssigneesReq = [1]string{
	0: "assignees",
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (s *IssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveAssigneesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			if err := func() error {
				s.Assignees = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesRemoveAssigneesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesRemoveAssigneesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesRemoveAssigneesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesRemoveLabelGone as json.
func (s *IssuesRemoveLabelGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelGone from json.
func (s *IssuesRemoveLabelGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesRemoveLabelGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesRemoveLabelGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesRemoveLabelNotFound as json.
func (s *IssuesRemoveLabelNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelNotFound from json.
func (s *IssuesRemoveLabelNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesRemoveLabelNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesRemoveLabelNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesRemoveLabelOKApplicationJSON as json.
func (s IssuesRemoveLabelOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Label(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesRemoveLabelOKApplicationJSON from json.
func (s *IssuesRemoveLabelOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelOKApplicationJSON to nil")
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = make([]Label, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesRemoveLabelOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesRemoveLabelOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUnlockForbidden as json.
func (s *IssuesUnlockForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockForbidden from json.
func (s *IssuesUnlockForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUnlockForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUnlockForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUnlockForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUnlockNotFound as json.
func (s *IssuesUnlockNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockNotFound from json.
func (s *IssuesUnlockNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUnlockNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUnlockNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUnlockNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesUpdateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesUpdateCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfIssuesUpdateCommentReq = [1]string{
	0: "body",
}

// Decode decodes IssuesUpdateCommentReq from json.
func (s *IssuesUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesUpdateCommentReq) {
					name = jsonFieldsNameOfIssuesUpdateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateForbidden as json.
func (s *IssuesUpdateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateForbidden from json.
func (s *IssuesUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateGone as json.
func (s *IssuesUpdateGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateGone from json.
func (s *IssuesUpdateGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesUpdateLabelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesUpdateLabelReq) encodeFields(e *jx.Encoder) {
	{
		if s.NewName.Set {
			e.FieldStart("new_name")
			s.NewName.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssuesUpdateLabelReq = [3]string{
	0: "new_name",
	1: "color",
	2: "description",
}

// Decode decodes IssuesUpdateLabelReq from json.
func (s *IssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateLabelReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			if err := func() error {
				s.NewName.Reset()
				if err := s.NewName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateLabelReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateLabelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateLabelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesUpdateMilestoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesUpdateMilestoneReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			e.FieldStart("due_on")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfIssuesUpdateMilestoneReq = [4]string{
	0: "title",
	1: "state",
	2: "description",
	3: "due_on",
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (s *IssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateMilestoneReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "due_on":
			if err := func() error {
				s.DueOn.Reset()
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateMilestoneReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateMilestoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateMilestoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (s IssuesUpdateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (s *IssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateMilestoneReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateMilestoneReqState(v) {
	case IssuesUpdateMilestoneReqStateOpen:
		*s = IssuesUpdateMilestoneReqStateOpen
	case IssuesUpdateMilestoneReqStateClosed:
		*s = IssuesUpdateMilestoneReqStateClosed
	default:
		*s = IssuesUpdateMilestoneReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesUpdateMilestoneReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateMilestoneReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateMovedPermanently as json.
func (s *IssuesUpdateMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateMovedPermanently from json.
func (s *IssuesUpdateMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateNotFound as json.
func (s *IssuesUpdateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateNotFound from json.
func (s *IssuesUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.FieldStart("assignee")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.FieldStart("milestone")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			e.FieldStart("labels")
			e.ArrStart()
			for _, elem := range s.Labels {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			e.FieldStart("assignees")
			e.ArrStart()
			for _, elem := range s.Assignees {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIssuesUpdateReq = [7]string{
	0: "title",
	1: "body",
	2: "assignee",
	3: "state",
	4: "milestone",
	5: "labels",
	6: "assignees",
}

// Decode decodes IssuesUpdateReq from json.
func (s *IssuesUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "labels":
			if err := func() error {
				s.Labels = make([]IssuesUpdateReqLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssuesUpdateReqLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqLabelsItem as json.
func (s IssuesUpdateReqLabelsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesUpdateReqLabelsItem:
		e.Str(s.String)
	case IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem:
		s.IssuesUpdateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesUpdateReqLabelsItem from json.
func (s *IssuesUpdateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.IssuesUpdateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesUpdateReqLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReqLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IssuesUpdateReqLabelsItem1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IssuesUpdateReqLabelsItem1) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
}

var jsonFieldsNameOfIssuesUpdateReqLabelsItem1 = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "color",
}

// Decode decodes IssuesUpdateReqLabelsItem1 from json.
func (s *IssuesUpdateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateReqLabelsItem1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IssuesUpdateReqLabelsItem1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReqLabelsItem1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (s IssuesUpdateReqMilestone) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesUpdateReqMilestone:
		e.Str(s.String)
	case IntIssuesUpdateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (s *IssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqMilestone to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqMilestone
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesUpdateReqMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReqMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqState as json.
func (s IssuesUpdateReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateReqState from json.
func (s *IssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateReqState(v) {
	case IssuesUpdateReqStateOpen:
		*s = IssuesUpdateReqStateOpen
	case IssuesUpdateReqStateClosed:
		*s = IssuesUpdateReqStateClosed
	default:
		*s = IssuesUpdateReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesUpdateReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqTitle as json.
func (s IssuesUpdateReqTitle) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringIssuesUpdateReqTitle:
		e.Str(s.String)
	case IntIssuesUpdateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqTitle from json.
func (s *IssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqTitle to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqTitle
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IssuesUpdateReqTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IssuesUpdateReqTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Job) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Job) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("run_id")
		e.Int(s.RunID)
	}
	{
		e.FieldStart("run_url")
		e.Str(s.RunURL)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("head_sha")
		e.Str(s.HeadSha)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("conclusion")
		s.Conclusion.Encode(e)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Steps != nil {
			e.FieldStart("steps")
			e.ArrStart()
			for _, elem := range s.Steps {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("check_run_url")
		e.Str(s.CheckRunURL)
	}
}

var jsonFieldsNameOfJob = [14]string{
	0:  "id",
	1:  "run_id",
	2:  "run_url",
	3:  "node_id",
	4:  "head_sha",
	5:  "url",
	6:  "html_url",
	7:  "status",
	8:  "conclusion",
	9:  "started_at",
	10: "completed_at",
	11: "name",
	12: "steps",
	13: "check_run_url",
}

// Decode decodes Job from json.
func (s *Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Job to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "run_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RunID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_id\"")
			}
		case "run_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "started_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "steps":
			if err := func() error {
				s.Steps = make([]JobStepsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JobStepsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Steps = append(s.Steps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"steps\"")
			}
		case "check_run_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CheckRunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_run_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Job")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJob) {
					name = jsonFieldsNameOfJob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Job) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Job) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobStatus as json.
func (s JobStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobStatus from json.
func (s *JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStatus(v) {
	case JobStatusQueued:
		*s = JobStatusQueued
	case JobStatusInProgress:
		*s = JobStatusInProgress
	case JobStatusCompleted:
		*s = JobStatusCompleted
	default:
		*s = JobStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobStepsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobStepsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("conclusion")
		s.Conclusion.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfJobStepsItem = [6]string{
	0: "status",
	1: "conclusion",
	2: "name",
	3: "number",
	4: "started_at",
	5: "completed_at",
}

// Decode decodes JobStepsItem from json.
func (s *JobStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStepsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobStepsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobStepsItem) {
					name = jsonFieldsNameOfJobStepsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobStepsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobStepsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobStepsItemStatus as json.
func (s JobStepsItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobStepsItemStatus from json.
func (s *JobStepsItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStepsItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStepsItemStatus(v) {
	case JobStepsItemStatusQueued:
		*s = JobStepsItemStatusQueued
	case JobStepsItemStatusInProgress:
		*s = JobStepsItemStatusInProgress
	case JobStepsItemStatusCompleted:
		*s = JobStepsItemStatusCompleted
	default:
		*s = JobStepsItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JobStepsItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobStepsItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Key) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Key) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		e.FieldStart("read_only")
		e.Bool(s.ReadOnly)
	}
}

var jsonFieldsNameOfKey = [7]string{
	0: "key",
	1: "id",
	2: "url",
	3: "title",
	4: "created_at",
	5: "verified",
	6: "read_only",
}

// Decode decodes Key from json.
func (s *Key) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Key to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "read_only":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Key")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKey) {
					name = jsonFieldsNameOfKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Key) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Key) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeySimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeySimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
}

var jsonFieldsNameOfKeySimple = [2]string{
	0: "id",
	1: "key",
}

// Decode decodes KeySimple from json.
func (s *KeySimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeySimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeySimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeySimple) {
					name = jsonFieldsNameOfKeySimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeySimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeySimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Label) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Label) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("color")
		e.Str(s.Color)
	}
	{
		e.FieldStart("default")
		e.Bool(s.Default)
	}
}

var jsonFieldsNameOfLabel = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes Label from json.
func (s *Label) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Label to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Color = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Label")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabel) {
					name = jsonFieldsNameOfLabel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Label) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Label) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabelSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabelSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("color")
		e.Str(s.Color)
	}
	{
		e.FieldStart("default")
		e.Bool(s.Default)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
}

var jsonFieldsNameOfLabelSearchResultItem = [9]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "color",
	5: "default",
	6: "description",
	7: "score",
	8: "text_matches",
}

// Decode decodes LabelSearchResultItem from json.
func (s *LabelSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabelSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Color = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabelSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabelSearchResultItem) {
					name = jsonFieldsNameOfLabelSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabelSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabelSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Language) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Language) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes Language from json.
func (s *Language) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Language to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Language")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Language) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Language) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *License) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *License) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("implementation")
		e.Str(s.Implementation)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitations")
		e.ArrStart()
		for _, elem := range s.Limitations {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
}

var jsonFieldsNameOfLicense = [13]string{
	0:  "key",
	1:  "name",
	2:  "spdx_id",
	3:  "url",
	4:  "node_id",
	5:  "html_url",
	6:  "description",
	7:  "implementation",
	8:  "permissions",
	9:  "conditions",
	10: "limitations",
	11: "body",
	12: "featured",
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode License to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "implementation":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Implementation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implementation\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Permissions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "conditions":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Conditions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "limitations":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Limitations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Limitations = append(s.Limitations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitations\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "featured":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode License")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicense) {
					name = jsonFieldsNameOfLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *License) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *License) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	{
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}
	{
		e.FieldStart("download_url")
		s.DownloadURL.Encode(e)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("encoding")
		e.Str(s.Encoding)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
}

var jsonFieldsNameOfLicenseContent = [13]string{
	0:  "name",
	1:  "path",
	2:  "sha",
	3:  "size",
	4:  "url",
	5:  "html_url",
	6:  "git_url",
	7:  "download_url",
	8:  "type",
	9:  "content",
	10: "encoding",
	11: "_links",
	12: "license",
}

// Decode decodes LicenseContent from json.
func (s *LicenseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseContent to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "git_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "download_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "content":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "license":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseContent) {
					name = jsonFieldsNameOfLicenseContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseContentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseContentLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("git")
		s.Git.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("self")
		json.EncodeURI(e, s.Self)
	}
}

var jsonFieldsNameOfLicenseContentLinks = [3]string{
	0: "git",
	1: "html",
	2: "self",
}

// Decode decodes LicenseContentLinks from json.
func (s *LicenseContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseContentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseContentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseContentLinks) {
					name = jsonFieldsNameOfLicenseContentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseContentLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseContentLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicenseSimple = [6]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
	5: "html_url",
}

// Decode decodes LicenseSimple from json.
func (s *LicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseSimple) {
					name = jsonFieldsNameOfLicenseSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicensesGetAllCommonlyUsedOKApplicationJSON as json.
func (s LicensesGetAllCommonlyUsedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LicenseSimple(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LicensesGetAllCommonlyUsedOKApplicationJSON from json.
func (s *LicensesGetAllCommonlyUsedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetAllCommonlyUsedOKApplicationJSON to nil")
	}
	var unwrapped []LicenseSimple
	if err := func() error {
		unwrapped = make([]LicenseSimple, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LicenseSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetAllCommonlyUsedOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LicensesGetAllCommonlyUsedOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensesGetAllCommonlyUsedOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicensesGetForbidden as json.
func (s *LicensesGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes LicensesGetForbidden from json.
func (s *LicensesGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicensesGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensesGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LicensesGetNotFound as json.
func (s *LicensesGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes LicensesGetNotFound from json.
func (s *LicensesGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicensesGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicensesGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Link) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Link) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		e.Str(s.Href)
	}
}

var jsonFieldsNameOfLink = [1]string{
	0: "href",
}

// Decode decodes Link from json.
func (s *Link) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Link to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Link")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLink) {
					name = jsonFieldsNameOfLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Link) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Link) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkWithType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkWithType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		e.Str(s.Href)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfLinkWithType = [2]string{
	0: "href",
	1: "type",
}

// Decode decodes LinkWithType from json.
func (s *LinkWithType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkWithType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkWithType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkWithType) {
					name = jsonFieldsNameOfLinkWithType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkWithType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkWithType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarkdownRenderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarkdownRenderReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfMarkdownRenderReq = [3]string{
	0: "text",
	1: "mode",
	2: "context",
}

// Decode decodes MarkdownRenderReq from json.
func (s *MarkdownRenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarkdownRenderReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarkdownRenderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarkdownRenderReq) {
					name = jsonFieldsNameOfMarkdownRenderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarkdownRenderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarkdownRenderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MarkdownRenderReqMode as json.
func (s MarkdownRenderReqMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MarkdownRenderReqMode from json.
func (s *MarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarkdownRenderReqMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MarkdownRenderReqMode(v) {
	case MarkdownRenderReqModeMarkdown:
		*s = MarkdownRenderReqModeMarkdown
	case MarkdownRenderReqModeGfm:
		*s = MarkdownRenderReqModeGfm
	default:
		*s = MarkdownRenderReqMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MarkdownRenderReqMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarkdownRenderReqMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarketplaceAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarketplaceAccount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.FieldStart("organization_billing_email")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
}

var jsonFieldsNameOfMarketplaceAccount = [7]string{
	0: "url",
	1: "id",
	2: "type",
	3: "node_id",
	4: "login",
	5: "email",
	6: "organization_billing_email",
}

// Decode decodes MarketplaceAccount from json.
func (s *MarketplaceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplaceAccount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "organization_billing_email":
			if err := func() error {
				s.OrganizationBillingEmail.Reset()
				if err := s.OrganizationBillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_billing_email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplaceAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplaceAccount) {
					name = jsonFieldsNameOfMarketplaceAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarketplaceAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarketplaceAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarketplaceListingPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarketplaceListingPlan) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("accounts_url")
		json.EncodeURI(e, s.AccountsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("monthly_price_in_cents")
		e.Int(s.MonthlyPriceInCents)
	}
	{
		e.FieldStart("yearly_price_in_cents")
		e.Int(s.YearlyPriceInCents)
	}
	{
		e.FieldStart("price_model")
		e.Str(s.PriceModel)
	}
	{
		e.FieldStart("has_free_trial")
		e.Bool(s.HasFreeTrial)
	}
	{
		e.FieldStart("unit_name")
		s.UnitName.Encode(e)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("bullets")
		e.ArrStart()
		for _, elem := range s.Bullets {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMarketplaceListingPlan = [13]string{
	0:  "url",
	1:  "accounts_url",
	2:  "id",
	3:  "number",
	4:  "name",
	5:  "description",
	6:  "monthly_price_in_cents",
	7:  "yearly_price_in_cents",
	8:  "price_model",
	9:  "has_free_trial",
	10: "unit_name",
	11: "state",
	12: "bullets",
}

// Decode decodes MarketplaceListingPlan from json.
func (s *MarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplaceListingPlan to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "accounts_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AccountsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accounts_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "monthly_price_in_cents":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MonthlyPriceInCents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthly_price_in_cents\"")
			}
		case "yearly_price_in_cents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.YearlyPriceInCents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yearly_price_in_cents\"")
			}
		case "price_model":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PriceModel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_model\"")
			}
		case "has_free_trial":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasFreeTrial = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_free_trial\"")
			}
		case "unit_name":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.UnitName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_name\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bullets":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Bullets = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Bullets = append(s.Bullets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bullets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplaceListingPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplaceListingPlan) {
					name = jsonFieldsNameOfMarketplaceListingPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarketplaceListingPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarketplaceListingPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarketplacePurchase) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.FieldStart("organization_billing_email")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.MarketplacePendingChange.Set {
			e.FieldStart("marketplace_pending_change")
			s.MarketplacePendingChange.Encode(e)
		}
	}
	{
		e.FieldStart("marketplace_purchase")
		s.MarketplacePurchase.Encode(e)
	}
}

var jsonFieldsNameOfMarketplacePurchase = [8]string{
	0: "url",
	1: "type",
	2: "id",
	3: "login",
	4: "organization_billing_email",
	5: "email",
	6: "marketplace_pending_change",
	7: "marketplace_purchase",
}

// Decode decodes MarketplacePurchase from json.
func (s *MarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organization_billing_email":
			if err := func() error {
				s.OrganizationBillingEmail.Reset()
				if err := s.OrganizationBillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_billing_email\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "marketplace_pending_change":
			if err := func() error {
				s.MarketplacePendingChange.Reset()
				if err := s.MarketplacePendingChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"marketplace_pending_change\"")
			}
		case "marketplace_purchase":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.MarketplacePurchase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"marketplace_purchase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplacePurchase) {
					name = jsonFieldsNameOfMarketplacePurchase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarketplacePurchase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarketplacePurchase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarketplacePurchaseMarketplacePendingChange) encodeFields(e *jx.Encoder) {
	{
		if s.IsInstalled.Set {
			e.FieldStart("is_installed")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.EffectiveDate.Set {
			e.FieldStart("effective_date")
			s.EffectiveDate.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			e.FieldStart("unit_count")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
}

var jsonFieldsNameOfMarketplacePurchaseMarketplacePendingChange = [5]string{
	0: "is_installed",
	1: "effective_date",
	2: "unit_count",
	3: "id",
	4: "plan",
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (s *MarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchaseMarketplacePendingChange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_installed":
			if err := func() error {
				s.IsInstalled.Reset()
				if err := s.IsInstalled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_installed\"")
			}
		case "effective_date":
			if err := func() error {
				s.EffectiveDate.Reset()
				if err := s.EffectiveDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_date\"")
			}
		case "unit_count":
			if err := func() error {
				s.UnitCount.Reset()
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchaseMarketplacePendingChange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarketplacePurchaseMarketplacePendingChange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarketplacePurchaseMarketplacePendingChange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MarketplacePurchaseMarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MarketplacePurchaseMarketplacePurchase) encodeFields(e *jx.Encoder) {
	{
		if s.BillingCycle.Set {
			e.FieldStart("billing_cycle")
			s.BillingCycle.Encode(e)
		}
	}
	{
		if s.NextBillingDate.Set {
			e.FieldStart("next_billing_date")
			s.NextBillingDate.Encode(e)
		}
	}
	{
		if s.IsInstalled.Set {
			e.FieldStart("is_installed")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			e.FieldStart("unit_count")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.OnFreeTrial.Set {
			e.FieldStart("on_free_trial")
			s.OnFreeTrial.Encode(e)
		}
	}
	{
		if s.FreeTrialEndsOn.Set {
			e.FieldStart("free_trial_ends_on")
			s.FreeTrialEndsOn.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
}

var jsonFieldsNameOfMarketplacePurchaseMarketplacePurchase = [8]string{
	0: "billing_cycle",
	1: "next_billing_date",
	2: "is_installed",
	3: "unit_count",
	4: "on_free_trial",
	5: "free_trial_ends_on",
	6: "updated_at",
	7: "plan",
}

// Decode decodes MarketplacePurchaseMarketplacePurchase from json.
func (s *MarketplacePurchaseMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchaseMarketplacePurchase to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			if err := func() error {
				s.BillingCycle.Reset()
				if err := s.BillingCycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_cycle\"")
			}
		case "next_billing_date":
			if err := func() error {
				s.NextBillingDate.Reset()
				if err := s.NextBillingDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_billing_date\"")
			}
		case "is_installed":
			if err := func() error {
				s.IsInstalled.Reset()
				if err := s.IsInstalled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_installed\"")
			}
		case "unit_count":
			if err := func() error {
				s.UnitCount.Reset()
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "on_free_trial":
			if err := func() error {
				s.OnFreeTrial.Reset()
				if err := s.OnFreeTrial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_free_trial\"")
			}
		case "free_trial_ends_on":
			if err := func() error {
				s.FreeTrialEndsOn.Reset()
				if err := s.FreeTrialEndsOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_trial_ends_on\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchaseMarketplacePurchase")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MarketplacePurchaseMarketplacePurchase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MarketplacePurchaseMarketplacePurchase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MergedUpstream) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MergedUpstream) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.MergeType.Set {
			e.FieldStart("merge_type")
			s.MergeType.Encode(e)
		}
	}
	{
		if s.BaseBranch.Set {
			e.FieldStart("base_branch")
			s.BaseBranch.Encode(e)
		}
	}
}

var jsonFieldsNameOfMergedUpstream = [3]string{
	0: "message",
	1: "merge_type",
	2: "base_branch",
}

// Decode decodes MergedUpstream from json.
func (s *MergedUpstream) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MergedUpstream to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "merge_type":
			if err := func() error {
				s.MergeType.Reset()
				if err := s.MergeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_type\"")
			}
		case "base_branch":
			if err := func() error {
				s.BaseBranch.Reset()
				if err := s.BaseBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MergedUpstream")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MergedUpstream) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MergedUpstream) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MergedUpstreamMergeType as json.
func (s MergedUpstreamMergeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MergedUpstreamMergeType from json.
func (s *MergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MergedUpstreamMergeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MergedUpstreamMergeType(v) {
	case MergedUpstreamMergeTypeMerge:
		*s = MergedUpstreamMergeTypeMerge
	case MergedUpstreamMergeTypeFastForward:
		*s = MergedUpstreamMergeTypeFastForward
	case MergedUpstreamMergeTypeNone:
		*s = MergedUpstreamMergeTypeNone
	default:
		*s = MergedUpstreamMergeType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MergedUpstreamMergeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MergedUpstreamMergeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetaRootOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetaRootOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current_user_url")
		e.Str(s.CurrentUserURL)
	}
	{
		e.FieldStart("current_user_authorizations_html_url")
		e.Str(s.CurrentUserAuthorizationsHTMLURL)
	}
	{
		e.FieldStart("authorizations_url")
		e.Str(s.AuthorizationsURL)
	}
	{
		e.FieldStart("code_search_url")
		e.Str(s.CodeSearchURL)
	}
	{
		e.FieldStart("commit_search_url")
		e.Str(s.CommitSearchURL)
	}
	{
		e.FieldStart("emails_url")
		e.Str(s.EmailsURL)
	}
	{
		e.FieldStart("emojis_url")
		e.Str(s.EmojisURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("feeds_url")
		e.Str(s.FeedsURL)
	}
	{
		e.FieldStart("followers_url")
		e.Str(s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("hub_url")
		e.Str(s.HubURL)
	}
	{
		e.FieldStart("issue_search_url")
		e.Str(s.IssueSearchURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("label_search_url")
		e.Str(s.LabelSearchURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("organization_url")
		e.Str(s.OrganizationURL)
	}
	{
		e.FieldStart("organization_repositories_url")
		e.Str(s.OrganizationRepositoriesURL)
	}
	{
		e.FieldStart("organization_teams_url")
		e.Str(s.OrganizationTeamsURL)
	}
	{
		e.FieldStart("public_gists_url")
		e.Str(s.PublicGistsURL)
	}
	{
		e.FieldStart("rate_limit_url")
		e.Str(s.RateLimitURL)
	}
	{
		e.FieldStart("repository_url")
		e.Str(s.RepositoryURL)
	}
	{
		e.FieldStart("repository_search_url")
		e.Str(s.RepositorySearchURL)
	}
	{
		e.FieldStart("current_user_repositories_url")
		e.Str(s.CurrentUserRepositoriesURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("starred_gists_url")
		e.Str(s.StarredGistsURL)
	}
	{
		if s.TopicSearchURL.Set {
			e.FieldStart("topic_search_url")
			s.TopicSearchURL.Encode(e)
		}
	}
	{
		e.FieldStart("user_url")
		e.Str(s.UserURL)
	}
	{
		e.FieldStart("user_organizations_url")
		e.Str(s.UserOrganizationsURL)
	}
	{
		e.FieldStart("user_repositories_url")
		e.Str(s.UserRepositoriesURL)
	}
	{
		e.FieldStart("user_search_url")
		e.Str(s.UserSearchURL)
	}
}

var jsonFieldsNameOfMetaRootOK = [33]string{
	0:  "current_user_url",
	1:  "current_user_authorizations_html_url",
	2:  "authorizations_url",
	3:  "code_search_url",
	4:  "commit_search_url",
	5:  "emails_url",
	6:  "emojis_url",
	7:  "events_url",
	8:  "feeds_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "hub_url",
	13: "issue_search_url",
	14: "issues_url",
	15: "keys_url",
	16: "label_search_url",
	17: "notifications_url",
	18: "organization_url",
	19: "organization_repositories_url",
	20: "organization_teams_url",
	21: "public_gists_url",
	22: "rate_limit_url",
	23: "repository_url",
	24: "repository_search_url",
	25: "current_user_repositories_url",
	26: "starred_url",
	27: "starred_gists_url",
	28: "topic_search_url",
	29: "user_url",
	30: "user_organizations_url",
	31: "user_repositories_url",
	32: "user_search_url",
}

// Decode decodes MetaRootOK from json.
func (s *MetaRootOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetaRootOK to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_user_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_url\"")
			}
		case "current_user_authorizations_html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserAuthorizationsHTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_authorizations_html_url\"")
			}
		case "authorizations_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AuthorizationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizations_url\"")
			}
		case "code_search_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CodeSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_search_url\"")
			}
		case "commit_search_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_search_url\"")
			}
		case "emails_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.EmailsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails_url\"")
			}
		case "emojis_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EmojisURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emojis_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "feeds_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FeedsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feeds_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FollowersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "hub_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HubURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hub_url\"")
			}
		case "issue_search_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_search_url\"")
			}
		case "issues_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "label_search_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label_search_url\"")
			}
		case "notifications_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "organization_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrganizationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_url\"")
			}
		case "organization_repositories_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.OrganizationRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_repositories_url\"")
			}
		case "organization_teams_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OrganizationTeamsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_teams_url\"")
			}
		case "public_gists_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PublicGistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists_url\"")
			}
		case "rate_limit_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RateLimitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_url\"")
			}
		case "repository_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RepositoryURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "repository_search_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RepositorySearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_search_url\"")
			}
		case "current_user_repositories_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_repositories_url\"")
			}
		case "starred_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "starred_gists_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.StarredGistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_gists_url\"")
			}
		case "topic_search_url":
			if err := func() error {
				s.TopicSearchURL.Reset()
				if err := s.TopicSearchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_search_url\"")
			}
		case "user_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_url\"")
			}
		case "user_organizations_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserOrganizationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_organizations_url\"")
			}
		case "user_repositories_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UserRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_repositories_url\"")
			}
		case "user_search_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_search_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetaRootOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMetaRootOK) {
					name = jsonFieldsNameOfMetaRootOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetaRootOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetaRootOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Migration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Migration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("guid")
		e.Str(s.GUID)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("lock_repositories")
		e.Bool(s.LockRepositories)
	}
	{
		e.FieldStart("exclude_metadata")
		e.Bool(s.ExcludeMetadata)
	}
	{
		e.FieldStart("exclude_git_data")
		e.Bool(s.ExcludeGitData)
	}
	{
		e.FieldStart("exclude_attachments")
		e.Bool(s.ExcludeAttachments)
	}
	{
		e.FieldStart("exclude_releases")
		e.Bool(s.ExcludeReleases)
	}
	{
		e.FieldStart("exclude_owner_projects")
		e.Bool(s.ExcludeOwnerProjects)
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.ArchiveURL.Set {
			e.FieldStart("archive_url")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.FieldStart("exclude")
			e.ArrStart()
			for _, elem := range s.Exclude {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMigration = [17]string{
	0:  "id",
	1:  "owner",
	2:  "guid",
	3:  "state",
	4:  "lock_repositories",
	5:  "exclude_metadata",
	6:  "exclude_git_data",
	7:  "exclude_attachments",
	8:  "exclude_releases",
	9:  "exclude_owner_projects",
	10: "repositories",
	11: "url",
	12: "created_at",
	13: "updated_at",
	14: "node_id",
	15: "archive_url",
	16: "exclude",
}

// Decode decodes Migration from json.
func (s *Migration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Migration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "lock_repositories":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.LockRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeMetadata = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_metadata\"")
			}
		case "exclude_git_data":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeGitData = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_git_data\"")
			}
		case "exclude_attachments":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeAttachments = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeReleases = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeOwnerProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "repositories":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Repositories = make([]Repository, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Migration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigration) {
					name = jsonFieldsNameOfMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Migration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Migration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserForbidden as json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserForbidden from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserNotFound as json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserNotFound from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserUnauthorized as json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserUnauthorized from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsDeleteArchiveForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserForbidden as json.
func (s *MigrationsGetArchiveForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserForbidden from json.
func (s *MigrationsGetArchiveForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsGetArchiveForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetArchiveForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserUnauthorized as json.
func (s *MigrationsGetArchiveForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserUnauthorized from json.
func (s *MigrationsGetArchiveForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsGetArchiveForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetArchiveForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetCommitAuthorsOKApplicationJSON as json.
func (s MigrationsGetCommitAuthorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PorterAuthor(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MigrationsGetCommitAuthorsOKApplicationJSON from json.
func (s *MigrationsGetCommitAuthorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetCommitAuthorsOKApplicationJSON to nil")
	}
	var unwrapped []PorterAuthor
	if err := func() error {
		unwrapped = make([]PorterAuthor, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PorterAuthor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetCommitAuthorsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MigrationsGetCommitAuthorsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetCommitAuthorsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserForbidden as json.
func (s *MigrationsGetStatusForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserForbidden from json.
func (s *MigrationsGetStatusForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsGetStatusForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetStatusForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserNotFound as json.
func (s *MigrationsGetStatusForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserNotFound from json.
func (s *MigrationsGetStatusForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsGetStatusForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetStatusForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserUnauthorized as json.
func (s *MigrationsGetStatusForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserUnauthorized from json.
func (s *MigrationsGetStatusForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsGetStatusForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsGetStatusForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsListForAuthenticatedUserForbidden as json.
func (s *MigrationsListForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserForbidden from json.
func (s *MigrationsListForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsListForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsListForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsListForAuthenticatedUserUnauthorized as json.
func (s *MigrationsListForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserUnauthorized from json.
func (s *MigrationsListForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsListForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsListForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsMapCommitAuthorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsMapCommitAuthorReq) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfMigrationsMapCommitAuthorReq = [2]string{
	0: "email",
	1: "name",
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (s *MigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsMapCommitAuthorReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsMapCommitAuthorReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsMapCommitAuthorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsMapCommitAuthorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsSetLfsPreferenceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsSetLfsPreferenceReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("use_lfs")
		s.UseLfs.Encode(e)
	}
}

var jsonFieldsNameOfMigrationsSetLfsPreferenceReq = [1]string{
	0: "use_lfs",
}

// Decode decodes MigrationsSetLfsPreferenceReq from json.
func (s *MigrationsSetLfsPreferenceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsSetLfsPreferenceReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "use_lfs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.UseLfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_lfs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsSetLfsPreferenceReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsSetLfsPreferenceReq) {
					name = jsonFieldsNameOfMigrationsSetLfsPreferenceReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsSetLfsPreferenceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsSetLfsPreferenceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsSetLfsPreferenceReqUseLfs as json.
func (s MigrationsSetLfsPreferenceReqUseLfs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsSetLfsPreferenceReqUseLfs from json.
func (s *MigrationsSetLfsPreferenceReqUseLfs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsSetLfsPreferenceReqUseLfs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsSetLfsPreferenceReqUseLfs(v) {
	case MigrationsSetLfsPreferenceReqUseLfsOptIn:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptIn
	case MigrationsSetLfsPreferenceReqUseLfsOptOut:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptOut
	default:
		*s = MigrationsSetLfsPreferenceReqUseLfs(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MigrationsSetLfsPreferenceReqUseLfs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsSetLfsPreferenceReqUseLfs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartForAuthenticatedUserForbidden as json.
func (s *MigrationsStartForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserForbidden from json.
func (s *MigrationsStartForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsStartForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsStartForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsStartForAuthenticatedUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.LockRepositories.Set {
			e.FieldStart("lock_repositories")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			e.FieldStart("exclude_attachments")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			e.FieldStart("exclude_releases")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			e.FieldStart("exclude_owner_projects")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.FieldStart("exclude")
			e.ArrStart()
			for _, elem := range s.Exclude {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq = [6]string{
	0: "lock_repositories",
	1: "exclude_attachments",
	2: "exclude_releases",
	3: "exclude_owner_projects",
	4: "exclude",
	5: "repositories",
}

// Decode decodes MigrationsStartForAuthenticatedUserReq from json.
func (s *MigrationsStartForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_repositories":
			if err := func() error {
				s.LockRepositories.Reset()
				if err := s.LockRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_attachments":
			if err := func() error {
				s.ExcludeAttachments.Reset()
				if err := s.ExcludeAttachments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			if err := func() error {
				s.ExcludeReleases.Reset()
				if err := s.ExcludeReleases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			if err := func() error {
				s.ExcludeOwnerProjects.Reset()
				if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = make([]MigrationsStartForAuthenticatedUserReqExcludeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MigrationsStartForAuthenticatedUserReqExcludeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Repositories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq) {
					name = jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsStartForAuthenticatedUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForAuthenticatedUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartForAuthenticatedUserReqExcludeItem as json.
func (s MigrationsStartForAuthenticatedUserReqExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForAuthenticatedUserReqExcludeItem from json.
func (s *MigrationsStartForAuthenticatedUserReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserReqExcludeItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForAuthenticatedUserReqExcludeItem(v) {
	case MigrationsStartForAuthenticatedUserReqExcludeItemRepositories:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItemRepositories
	default:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MigrationsStartForAuthenticatedUserReqExcludeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForAuthenticatedUserReqExcludeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartForAuthenticatedUserUnauthorized as json.
func (s *MigrationsStartForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserUnauthorized from json.
func (s *MigrationsStartForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsStartForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsStartForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsStartForOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.LockRepositories.Set {
			e.FieldStart("lock_repositories")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			e.FieldStart("exclude_attachments")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			e.FieldStart("exclude_releases")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			e.FieldStart("exclude_owner_projects")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.FieldStart("exclude")
			e.ArrStart()
			for _, elem := range s.Exclude {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMigrationsStartForOrgReq = [6]string{
	0: "repositories",
	1: "lock_repositories",
	2: "exclude_attachments",
	3: "exclude_releases",
	4: "exclude_owner_projects",
	5: "exclude",
}

// Decode decodes MigrationsStartForOrgReq from json.
func (s *MigrationsStartForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForOrgReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Repositories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "lock_repositories":
			if err := func() error {
				s.LockRepositories.Reset()
				if err := s.LockRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_attachments":
			if err := func() error {
				s.ExcludeAttachments.Reset()
				if err := s.ExcludeAttachments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			if err := func() error {
				s.ExcludeReleases.Reset()
				if err := s.ExcludeReleases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			if err := func() error {
				s.ExcludeOwnerProjects.Reset()
				if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = make([]MigrationsStartForOrgReqExcludeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MigrationsStartForOrgReqExcludeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartForOrgReq) {
					name = jsonFieldsNameOfMigrationsStartForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsStartForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartForOrgReqExcludeItem as json.
func (s MigrationsStartForOrgReqExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForOrgReqExcludeItem from json.
func (s *MigrationsStartForOrgReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForOrgReqExcludeItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForOrgReqExcludeItem(v) {
	case MigrationsStartForOrgReqExcludeItemRepositories:
		*s = MigrationsStartForOrgReqExcludeItemRepositories
	default:
		*s = MigrationsStartForOrgReqExcludeItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MigrationsStartForOrgReqExcludeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartForOrgReqExcludeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsStartImportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsStartImportReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vcs_url")
		e.Str(s.VcsURL)
	}
	{
		if s.Vcs.Set {
			e.FieldStart("vcs")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.VcsUsername.Set {
			e.FieldStart("vcs_username")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			e.FieldStart("vcs_password")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.FieldStart("tfvc_project")
			s.TfvcProject.Encode(e)
		}
	}
}

var jsonFieldsNameOfMigrationsStartImportReq = [5]string{
	0: "vcs_url",
	1: "vcs",
	2: "vcs_username",
	3: "vcs_password",
	4: "tfvc_project",
}

// Decode decodes MigrationsStartImportReq from json.
func (s *MigrationsStartImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartImportReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VcsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_url\"")
			}
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "vcs_username":
			if err := func() error {
				s.VcsUsername.Reset()
				if err := s.VcsUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_username\"")
			}
		case "vcs_password":
			if err := func() error {
				s.VcsPassword.Reset()
				if err := s.VcsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_password\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartImportReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartImportReq) {
					name = jsonFieldsNameOfMigrationsStartImportReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsStartImportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartImportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (s MigrationsStartImportReqVcs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (s *MigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartImportReqVcs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartImportReqVcs(v) {
	case MigrationsStartImportReqVcsSubversion:
		*s = MigrationsStartImportReqVcsSubversion
	case MigrationsStartImportReqVcsGit:
		*s = MigrationsStartImportReqVcsGit
	case MigrationsStartImportReqVcsMercurial:
		*s = MigrationsStartImportReqVcsMercurial
	case MigrationsStartImportReqVcsTfvc:
		*s = MigrationsStartImportReqVcsTfvc
	default:
		*s = MigrationsStartImportReqVcs(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MigrationsStartImportReqVcs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsStartImportReqVcs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserForbidden as json.
func (s *MigrationsUnlockRepoForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserForbidden from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserNotFound as json.
func (s *MigrationsUnlockRepoForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserNotFound from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserUnauthorized as json.
func (s *MigrationsUnlockRepoForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserUnauthorized from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsUnlockRepoForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MigrationsUpdateImportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MigrationsUpdateImportReq) encodeFields(e *jx.Encoder) {
	{
		if s.VcsUsername.Set {
			e.FieldStart("vcs_username")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			e.FieldStart("vcs_password")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.Vcs.Set {
			e.FieldStart("vcs")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.FieldStart("tfvc_project")
			s.TfvcProject.Encode(e)
		}
	}
}

var jsonFieldsNameOfMigrationsUpdateImportReq = [4]string{
	0: "vcs_username",
	1: "vcs_password",
	2: "vcs",
	3: "tfvc_project",
}

// Decode decodes MigrationsUpdateImportReq from json.
func (s *MigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUpdateImportReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_username":
			if err := func() error {
				s.VcsUsername.Reset()
				if err := s.VcsUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_username\"")
			}
		case "vcs_password":
			if err := func() error {
				s.VcsPassword.Reset()
				if err := s.VcsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_password\"")
			}
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsUpdateImportReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MigrationsUpdateImportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MigrationsUpdateImportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Milestone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Milestone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("labels_url")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("closed_issues")
		e.Int(s.ClosedIssues)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("due_on")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
}

var jsonFieldsNameOfMilestone = [16]string{
	0:  "url",
	1:  "html_url",
	2:  "labels_url",
	3:  "id",
	4:  "node_id",
	5:  "number",
	6:  "state",
	7:  "title",
	8:  "description",
	9:  "creator",
	10: "open_issues",
	11: "closed_issues",
	12: "created_at",
	13: "updated_at",
	14: "closed_at",
	15: "due_on",
}

// Decode decodes Milestone from json.
func (s *Milestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Milestone to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LabelsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "open_issues":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "closed_issues":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ClosedIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_issues\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "due_on":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Milestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMilestone) {
					name = jsonFieldsNameOfMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Milestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Milestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MilestoneState as json.
func (s MilestoneState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MilestoneState from json.
func (s *MilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MilestoneState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MilestoneState(v) {
	case MilestoneStateOpen:
		*s = MilestoneStateOpen
	case MilestoneStateClosed:
		*s = MilestoneStateClosed
	default:
		*s = MilestoneState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MilestoneState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MilestoneState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MinimalRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MinimalRepository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.FieldStart("git_url")
			s.GitURL.Encode(e)
		}
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.FieldStart("ssh_url")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.FieldStart("clone_url")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.FieldStart("mirror_url")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.FieldStart("svn_url")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.FieldStart("forks_count")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.FieldStart("stargazers_count")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.FieldStart("watchers_count")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.FieldStart("default_branch")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.FieldStart("open_issues_count")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.FieldStart("has_pages")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.FieldStart("has_downloads")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.FieldStart("disabled")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.FieldStart("pushed_at")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.FieldStart("code_of_conduct")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.FieldStart("forks")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.FieldStart("open_issues")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.FieldStart("watchers")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfMinimalRepository = [84]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "template_repository",
	74: "temp_clone_token",
	75: "delete_branch_on_merge",
	76: "subscribers_count",
	77: "network_count",
	78: "code_of_conduct",
	79: "license",
	80: "forks",
	81: "open_issues",
	82: "watchers",
	83: "allow_forking",
}

// Decode decodes MinimalRepository from json.
func (s *MinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepository to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			if err := func() error {
				s.OpenIssues.Reset()
				if err := s.OpenIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			if err := func() error {
				s.Watchers.Reset()
				if err := s.Watchers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11110111,
		0b01111111,
		0b01111111,
		0b00000010,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMinimalRepository) {
					name = jsonFieldsNameOfMinimalRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MinimalRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MinimalRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MinimalRepositoryLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MinimalRepositoryLicense) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			e.FieldStart("spdx_id")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfMinimalRepositoryLicense = [5]string{
	0: "key",
	1: "name",
	2: "spdx_id",
	3: "url",
	4: "node_id",
}

// Decode decodes MinimalRepositoryLicense from json.
func (s *MinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepositoryLicense to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			if err := func() error {
				s.SpdxID.Reset()
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepositoryLicense")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MinimalRepositoryLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MinimalRepositoryLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MinimalRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			e.FieldStart("push")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			e.FieldStart("pull")
			s.Pull.Encode(e)
		}
	}
}

var jsonFieldsNameOfMinimalRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes MinimalRepositoryPermissions from json.
func (s *MinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepositoryPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MinimalRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MinimalRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoMerge as json.
func (o NilAutoMerge) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoMerge from json.
func (o *NilAutoMerge) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilAutoMerge to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AutoMerge
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilAutoMerge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilAutoMerge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o NilBool) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *NilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckRunCheckSuite as json.
func (o NilCheckRunCheckSuite) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CheckRunCheckSuite from json.
func (o *NilCheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckRunCheckSuite to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CheckRunCheckSuite
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCheckRunCheckSuite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCheckRunCheckSuite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckRunConclusion as json.
func (o NilCheckRunConclusion) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckRunConclusion from json.
func (o *NilCheckRunConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckRunConclusion to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CheckRunConclusion
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCheckRunConclusion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCheckRunConclusion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckSuiteConclusion as json.
func (o NilCheckSuiteConclusion) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteConclusion from json.
func (o *NilCheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckSuiteConclusion to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CheckSuiteConclusion
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCheckSuiteConclusion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCheckSuiteConclusion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckSuiteStatus as json.
func (o NilCheckSuiteStatus) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteStatus from json.
func (o *NilCheckSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckSuiteStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CheckSuiteStatus
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCheckSuiteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCheckSuiteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertClassification as json.
func (o NilCodeScanningAlertClassification) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertClassification from json.
func (o *NilCodeScanningAlertClassification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCodeScanningAlertClassification to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertClassification
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCodeScanningAlertClassification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCodeScanningAlertClassification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (o NilCodeScanningAlertDismissedAt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (o *NilCodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCodeScanningAlertDismissedAt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertDismissedAt
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCodeScanningAlertDismissedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCodeScanningAlertDismissedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o NilCodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *NilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCodeScanningAlertDismissedReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCodeScanningAlertDismissedReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCodeScanningAlertDismissedReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FileCommitContent as json.
func (o NilFileCommitContent) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContent from json.
func (o *NilFileCommitContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFileCommitContent to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v FileCommitContent
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFileCommitContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFileCommitContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistSimpleFilesItem as json.
func (o NilGistSimpleFilesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleFilesItem from json.
func (o *NilGistSimpleFilesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGistSimpleFilesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GistSimpleFilesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGistSimpleFilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGistSimpleFilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HookDeliveryRequestHeaders as json.
func (o NilHookDeliveryRequestHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryRequestHeaders from json.
func (o *NilHookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryRequestHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v HookDeliveryRequestHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(HookDeliveryRequestHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilHookDeliveryRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilHookDeliveryRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HookDeliveryRequestPayload as json.
func (o NilHookDeliveryRequestPayload) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryRequestPayload from json.
func (o *NilHookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryRequestPayload to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v HookDeliveryRequestPayload
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(HookDeliveryRequestPayload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilHookDeliveryRequestPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilHookDeliveryRequestPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HookDeliveryResponseHeaders as json.
func (o NilHookDeliveryResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryResponseHeaders from json.
func (o *NilHookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v HookDeliveryResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(HookDeliveryResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilHookDeliveryResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilHookDeliveryResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableCodeOfConductSimple as json.
func (o NilNullableCodeOfConductSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCodeOfConductSimple from json.
func (o *NilNullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableCodeOfConductSimple to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableCodeOfConductSimple
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableCodeOfConductSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableCodeOfConductSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableCommunityHealthFile as json.
func (o NilNullableCommunityHealthFile) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCommunityHealthFile from json.
func (o *NilNullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableCommunityHealthFile to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableCommunityHealthFile
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableCommunityHealthFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableCommunityHealthFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableGitUser as json.
func (o NilNullableGitUser) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableGitUser from json.
func (o *NilNullableGitUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableGitUser to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableGitUser
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableGitUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableGitUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableIntegration as json.
func (o NilNullableIntegration) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *NilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableIntegration to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableIntegration
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableLicenseSimple as json.
func (o NilNullableLicenseSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableLicenseSimple from json.
func (o *NilNullableLicenseSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableLicenseSimple to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableLicenseSimple
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableLicenseSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableLicenseSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableMilestone as json.
func (o NilNullableMilestone) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMilestone from json.
func (o *NilNullableMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableMilestone to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableMilestone
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableSimpleCommit as json.
func (o NilNullableSimpleCommit) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommit from json.
func (o *NilNullableSimpleCommit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommit to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableSimpleCommit
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableSimpleCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableSimpleCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableSimpleCommitAuthor as json.
func (o NilNullableSimpleCommitAuthor) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (o *NilNullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommitAuthor to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableSimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableSimpleCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableSimpleCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableSimpleCommitCommitter as json.
func (o NilNullableSimpleCommitCommitter) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (o *NilNullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommitCommitter to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableSimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableSimpleCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableSimpleCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableSimpleUser as json.
func (o NilNullableSimpleUser) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *NilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleUser to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableSimpleUser
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableSimpleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableSimpleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableTeamSimple as json.
func (o NilNullableTeamSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *NilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableTeamSimple to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableTeamSimple
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilNullableTeamSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilNullableTeamSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageStatus as json.
func (o NilPageStatus) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageStatus from json.
func (o *NilPageStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPageStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PageStatus
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilPageStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilPageStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestHeadRepo as json.
func (o NilPullRequestHeadRepo) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepo from json.
func (o *NilPullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPullRequestHeadRepo to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PullRequestHeadRepo
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilPullRequestHeadRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilPullRequestHeadRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestHeadRepoLicense as json.
func (o NilPullRequestHeadRepoLicense) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (o *NilPullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPullRequestHeadRepoLicense to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PullRequestHeadRepoLicense
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilPullRequestHeadRepoLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilPullRequestHeadRepoLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreatePagesSiteReq as json.
func (o NilReposCreatePagesSiteReq) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreatePagesSiteReq from json.
func (o *NilReposCreatePagesSiteReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposCreatePagesSiteReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposCreatePagesSiteReq
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReposCreatePagesSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReposCreatePagesSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews as json.
func (o NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (o *NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposUpdateBranchProtectionReqRequiredPullRequestReviews
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredStatusChecks as json.
func (o NilReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (o *NilReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredStatusChecks to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposUpdateBranchProtectionReqRequiredStatusChecks
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReposUpdateBranchProtectionReqRequiredStatusChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReposUpdateBranchProtectionReqRequiredStatusChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionReqRestrictions as json.
func (o NilReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (o *NilReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRestrictions to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposUpdateBranchProtectionReqRestrictions
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReposUpdateBranchProtectionReqRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReposUpdateBranchProtectionReqRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SimpleCommitAuthor as json.
func (o NilSimpleCommitAuthor) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitAuthor from json.
func (o *NilSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilSimpleCommitAuthor to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilSimpleCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilSimpleCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SimpleCommitCommitter as json.
func (o NilSimpleCommitCommitter) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitCommitter from json.
func (o *NilSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilSimpleCommitCommitter to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilSimpleCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilSimpleCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o NilURI) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableCodeOfConductSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableCodeOfConductSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
}

var jsonFieldsNameOfNullableCodeOfConductSimple = [4]string{
	0: "url",
	1: "key",
	2: "name",
	3: "html_url",
}

// Decode decodes NullableCodeOfConductSimple from json.
func (s *NullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableCodeOfConductSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableCodeOfConductSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableCodeOfConductSimple) {
					name = jsonFieldsNameOfNullableCodeOfConductSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableCodeOfConductSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableCodeOfConductSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableCommunityHealthFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableCommunityHealthFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
}

var jsonFieldsNameOfNullableCommunityHealthFile = [2]string{
	0: "url",
	1: "html_url",
}

// Decode decodes NullableCommunityHealthFile from json.
func (s *NullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableCommunityHealthFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableCommunityHealthFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableCommunityHealthFile) {
					name = jsonFieldsNameOfNullableCommunityHealthFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableCommunityHealthFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableCommunityHealthFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableGitUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableGitUser) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableGitUser = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes NullableGitUser from json.
func (s *NullableGitUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableGitUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableGitUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableGitUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableGitUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableIntegration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableIntegration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("external_url")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.FieldStart("installations_count")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.FieldStart("webhook_secret")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.FieldStart("pem")
			s.Pem.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableIntegration = [17]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
	12: "installations_count",
	13: "client_id",
	14: "client_secret",
	15: "webhook_secret",
	16: "pem",
}

// Decode decodes NullableIntegration from json.
func (s *NullableIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableIntegration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "installations_count":
			if err := func() error {
				s.InstallationsCount.Reset()
				if err := s.InstallationsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installations_count\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		case "pem":
			if err := func() error {
				s.Pem.Reset()
				if err := s.Pem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableIntegration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableIntegration) {
					name = jsonFieldsNameOfNullableIntegration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableIntegrationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableIntegrationPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Issues.Set {
			e.FieldStart("issues")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			e.FieldStart("checks")
			s.Checks.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			e.FieldStart("deployments")
			s.Deployments.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		e.Str(elem)
	}
}

var jsonFieldsNameOfNullableIntegrationPermissions = [5]string{
	0: "issues",
	1: "checks",
	2: "metadata",
	3: "contents",
	4: "deployments",
}

// Decode decodes NullableIntegrationPermissions from json.
func (s *NullableIntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableIntegrationPermissions to nil")
	}
	s.AdditionalProps = map[string]string{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableIntegrationPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableIntegrationPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableIntegrationPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NullableIntegrationPermissionsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NullableIntegrationPermissionsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NullableIntegrationPermissionsAdditional from json.
func (s *NullableIntegrationPermissionsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableIntegrationPermissionsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableIntegrationPermissionsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NullableIntegrationPermissionsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableIntegrationPermissionsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableLicenseSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableLicenseSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableLicenseSimple = [6]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
	5: "html_url",
}

// Decode decodes NullableLicenseSimple from json.
func (s *NullableLicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableLicenseSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableLicenseSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableLicenseSimple) {
					name = jsonFieldsNameOfNullableLicenseSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableLicenseSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableLicenseSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableMilestone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableMilestone) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("labels_url")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("closed_issues")
		e.Int(s.ClosedIssues)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("due_on")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
}

var jsonFieldsNameOfNullableMilestone = [16]string{
	0:  "url",
	1:  "html_url",
	2:  "labels_url",
	3:  "id",
	4:  "node_id",
	5:  "number",
	6:  "state",
	7:  "title",
	8:  "description",
	9:  "creator",
	10: "open_issues",
	11: "closed_issues",
	12: "created_at",
	13: "updated_at",
	14: "closed_at",
	15: "due_on",
}

// Decode decodes NullableMilestone from json.
func (s *NullableMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMilestone to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LabelsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "open_issues":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "closed_issues":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ClosedIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_issues\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "due_on":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMilestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableMilestone) {
					name = jsonFieldsNameOfNullableMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableMilestoneState as json.
func (s NullableMilestoneState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NullableMilestoneState from json.
func (s *NullableMilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMilestoneState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableMilestoneState(v) {
	case NullableMilestoneStateOpen:
		*s = NullableMilestoneStateOpen
	case NullableMilestoneStateClosed:
		*s = NullableMilestoneStateClosed
	default:
		*s = NullableMilestoneState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NullableMilestoneState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableMilestoneState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableMinimalRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableMinimalRepository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.FieldStart("git_url")
			s.GitURL.Encode(e)
		}
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.FieldStart("ssh_url")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.FieldStart("clone_url")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.FieldStart("mirror_url")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.FieldStart("svn_url")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.FieldStart("forks_count")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.FieldStart("stargazers_count")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.FieldStart("watchers_count")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.FieldStart("default_branch")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.FieldStart("open_issues_count")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.FieldStart("has_pages")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.FieldStart("has_downloads")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.FieldStart("disabled")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.FieldStart("pushed_at")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.FieldStart("code_of_conduct")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.FieldStart("forks")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.FieldStart("open_issues")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.FieldStart("watchers")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableMinimalRepository = [84]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "template_repository",
	74: "temp_clone_token",
	75: "delete_branch_on_merge",
	76: "subscribers_count",
	77: "network_count",
	78: "code_of_conduct",
	79: "license",
	80: "forks",
	81: "open_issues",
	82: "watchers",
	83: "allow_forking",
}

// Decode decodes NullableMinimalRepository from json.
func (s *NullableMinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepository to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			if err := func() error {
				s.OpenIssues.Reset()
				if err := s.OpenIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			if err := func() error {
				s.Watchers.Reset()
				if err := s.Watchers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11110111,
		0b01111111,
		0b01111111,
		0b00000010,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableMinimalRepository) {
					name = jsonFieldsNameOfNullableMinimalRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableMinimalRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableMinimalRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableMinimalRepositoryLicense) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			e.FieldStart("spdx_id")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableMinimalRepositoryLicense = [5]string{
	0: "key",
	1: "name",
	2: "spdx_id",
	3: "url",
	4: "node_id",
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (s *NullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepositoryLicense to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			if err := func() error {
				s.SpdxID.Reset()
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepositoryLicense")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableMinimalRepositoryLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableMinimalRepositoryLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableMinimalRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			e.FieldStart("push")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			e.FieldStart("pull")
			s.Pull.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableMinimalRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (s *NullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepositoryPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableMinimalRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableMinimalRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableRepository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.FieldStart("starred_at")
			s.StarredAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableRepository = [90]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "organization",
	6:  "forks",
	7:  "permissions",
	8:  "owner",
	9:  "private",
	10: "html_url",
	11: "description",
	12: "fork",
	13: "url",
	14: "archive_url",
	15: "assignees_url",
	16: "blobs_url",
	17: "branches_url",
	18: "collaborators_url",
	19: "comments_url",
	20: "commits_url",
	21: "compare_url",
	22: "contents_url",
	23: "contributors_url",
	24: "deployments_url",
	25: "downloads_url",
	26: "events_url",
	27: "forks_url",
	28: "git_commits_url",
	29: "git_refs_url",
	30: "git_tags_url",
	31: "git_url",
	32: "issue_comment_url",
	33: "issue_events_url",
	34: "issues_url",
	35: "keys_url",
	36: "labels_url",
	37: "languages_url",
	38: "merges_url",
	39: "milestones_url",
	40: "notifications_url",
	41: "pulls_url",
	42: "releases_url",
	43: "ssh_url",
	44: "stargazers_url",
	45: "statuses_url",
	46: "subscribers_url",
	47: "subscription_url",
	48: "tags_url",
	49: "teams_url",
	50: "trees_url",
	51: "clone_url",
	52: "mirror_url",
	53: "hooks_url",
	54: "svn_url",
	55: "homepage",
	56: "language",
	57: "forks_count",
	58: "stargazers_count",
	59: "watchers_count",
	60: "size",
	61: "default_branch",
	62: "open_issues_count",
	63: "is_template",
	64: "topics",
	65: "has_issues",
	66: "has_projects",
	67: "has_wiki",
	68: "has_pages",
	69: "has_downloads",
	70: "archived",
	71: "disabled",
	72: "visibility",
	73: "pushed_at",
	74: "created_at",
	75: "updated_at",
	76: "allow_rebase_merge",
	77: "template_repository",
	78: "temp_clone_token",
	79: "allow_squash_merge",
	80: "allow_auto_merge",
	81: "delete_branch_on_merge",
	82: "allow_merge_commit",
	83: "allow_forking",
	84: "subscribers_count",
	85: "network_count",
	86: "open_issues",
	87: "watchers",
	88: "master_branch",
	89: "starred_at",
}

// Decode decodes NullableRepository from json.
func (s *NullableRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b01011111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
		0b11111110,
		0b00001110,
		0b11000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableRepository) {
					name = jsonFieldsNameOfNullableRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes NullableRepositoryPermissions from json.
func (s *NullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableRepositoryPermissions) {
					name = jsonFieldsNameOfNullableRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableRepositoryTemplateRepository) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			e.FieldStart("full_name")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			e.FieldStart("fork")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			e.FieldStart("archive_url")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			e.FieldStart("assignees_url")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			e.FieldStart("blobs_url")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			e.FieldStart("branches_url")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			e.FieldStart("collaborators_url")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			e.FieldStart("comments_url")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			e.FieldStart("commits_url")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			e.FieldStart("compare_url")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			e.FieldStart("contents_url")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			e.FieldStart("contributors_url")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			e.FieldStart("deployments_url")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			e.FieldStart("downloads_url")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			e.FieldStart("forks_url")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			e.FieldStart("git_commits_url")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			e.FieldStart("git_refs_url")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			e.FieldStart("git_tags_url")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			e.FieldStart("git_url")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			e.FieldStart("issue_comment_url")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			e.FieldStart("issue_events_url")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			e.FieldStart("keys_url")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			e.FieldStart("labels_url")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			e.FieldStart("languages_url")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			e.FieldStart("merges_url")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			e.FieldStart("milestones_url")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			e.FieldStart("notifications_url")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			e.FieldStart("pulls_url")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			e.FieldStart("releases_url")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			e.FieldStart("ssh_url")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			e.FieldStart("stargazers_url")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			e.FieldStart("statuses_url")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			e.FieldStart("subscribers_url")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			e.FieldStart("subscription_url")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			e.FieldStart("tags_url")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			e.FieldStart("teams_url")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			e.FieldStart("trees_url")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			e.FieldStart("clone_url")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.FieldStart("mirror_url")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			e.FieldStart("hooks_url")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			e.FieldStart("svn_url")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.FieldStart("forks_count")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.FieldStart("stargazers_count")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.FieldStart("watchers_count")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.FieldStart("default_branch")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.FieldStart("open_issues_count")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.FieldStart("has_pages")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.FieldStart("has_downloads")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.FieldStart("disabled")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.FieldStart("pushed_at")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableRepositoryTemplateRepository = [81]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "temp_clone_token",
	75: "allow_squash_merge",
	76: "allow_auto_merge",
	77: "delete_branch_on_merge",
	78: "allow_merge_commit",
	79: "subscribers_count",
	80: "network_count",
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (s *NullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepository to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			if err := func() error {
				s.Fork.Reset()
				if err := s.Fork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			if err := func() error {
				s.AssigneesURL.Reset()
				if err := s.AssigneesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			if err := func() error {
				s.BlobsURL.Reset()
				if err := s.BlobsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			if err := func() error {
				s.BranchesURL.Reset()
				if err := s.BranchesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			if err := func() error {
				s.CollaboratorsURL.Reset()
				if err := s.CollaboratorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			if err := func() error {
				s.CompareURL.Reset()
				if err := s.CompareURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			if err := func() error {
				s.ContributorsURL.Reset()
				if err := s.ContributorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			if err := func() error {
				s.DeploymentsURL.Reset()
				if err := s.DeploymentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			if err := func() error {
				s.DownloadsURL.Reset()
				if err := s.DownloadsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			if err := func() error {
				s.GitCommitsURL.Reset()
				if err := s.GitCommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			if err := func() error {
				s.GitRefsURL.Reset()
				if err := s.GitRefsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			if err := func() error {
				s.GitTagsURL.Reset()
				if err := s.GitTagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			if err := func() error {
				s.IssueCommentURL.Reset()
				if err := s.IssueCommentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			if err := func() error {
				s.IssueEventsURL.Reset()
				if err := s.IssueEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			if err := func() error {
				s.KeysURL.Reset()
				if err := s.KeysURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			if err := func() error {
				s.LabelsURL.Reset()
				if err := s.LabelsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			if err := func() error {
				s.LanguagesURL.Reset()
				if err := s.LanguagesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			if err := func() error {
				s.MergesURL.Reset()
				if err := s.MergesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			if err := func() error {
				s.MilestonesURL.Reset()
				if err := s.MilestonesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			if err := func() error {
				s.NotificationsURL.Reset()
				if err := s.NotificationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			if err := func() error {
				s.PullsURL.Reset()
				if err := s.PullsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			if err := func() error {
				s.ReleasesURL.Reset()
				if err := s.ReleasesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			if err := func() error {
				s.StargazersURL.Reset()
				if err := s.StargazersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			if err := func() error {
				s.StatusesURL.Reset()
				if err := s.StatusesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			if err := func() error {
				s.SubscribersURL.Reset()
				if err := s.SubscribersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			if err := func() error {
				s.TagsURL.Reset()
				if err := s.TagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			if err := func() error {
				s.TreesURL.Reset()
				if err := s.TreesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepository")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableRepositoryTemplateRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableRepositoryTemplateRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableRepositoryTemplateRepositoryOwner) encodeFields(e *jx.Encoder) {
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			e.FieldStart("gravatar_id")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			e.FieldStart("followers_url")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			e.FieldStart("following_url")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			e.FieldStart("gists_url")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			e.FieldStart("starred_url")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			e.FieldStart("subscriptions_url")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			e.FieldStart("organizations_url")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			e.FieldStart("repos_url")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			e.FieldStart("received_events_url")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			e.FieldStart("site_admin")
			s.SiteAdmin.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableRepositoryTemplateRepositoryOwner = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (s *NullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepositoryOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepositoryOwner")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableRepositoryTemplateRepositoryOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableRepositoryTemplateRepositoryOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableRepositoryTemplateRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			e.FieldStart("push")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			e.FieldStart("pull")
			s.Pull.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableRepositoryTemplateRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (s *NullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepositoryPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableRepositoryTemplateRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableRepositoryTemplateRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableScopedInstallation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableScopedInstallation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		e.FieldStart("repository_selection")
		s.RepositorySelection.Encode(e)
	}
	{
		e.FieldStart("single_file_name")
		s.SingleFileName.Encode(e)
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.FieldStart("has_multiple_single_files")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.FieldStart("single_file_paths")
			e.ArrStart()
			for _, elem := range s.SingleFilePaths {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("repositories_url")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.FieldStart("account")
		s.Account.Encode(e)
	}
}

var jsonFieldsNameOfNullableScopedInstallation = [7]string{
	0: "permissions",
	1: "repository_selection",
	2: "single_file_name",
	3: "has_multiple_single_files",
	4: "single_file_paths",
	5: "repositories_url",
	6: "account",
}

// Decode decodes NullableScopedInstallation from json.
func (s *NullableScopedInstallation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableScopedInstallation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repository_selection":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "single_file_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SingleFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_name\"")
			}
		case "has_multiple_single_files":
			if err := func() error {
				s.HasMultipleSingleFiles.Reset()
				if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_multiple_single_files\"")
			}
		case "single_file_paths":
			if err := func() error {
				s.SingleFilePaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SingleFilePaths = append(s.SingleFilePaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_paths\"")
			}
		case "repositories_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableScopedInstallation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableScopedInstallation) {
					name = jsonFieldsNameOfNullableScopedInstallation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableScopedInstallation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableScopedInstallation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableScopedInstallationRepositorySelection as json.
func (s NullableScopedInstallationRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NullableScopedInstallationRepositorySelection from json.
func (s *NullableScopedInstallationRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableScopedInstallationRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableScopedInstallationRepositorySelection(v) {
	case NullableScopedInstallationRepositorySelectionAll:
		*s = NullableScopedInstallationRepositorySelectionAll
	case NullableScopedInstallationRepositorySelectionSelected:
		*s = NullableScopedInstallationRepositorySelectionSelected
	default:
		*s = NullableScopedInstallationRepositorySelection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NullableScopedInstallationRepositorySelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableScopedInstallationRepositorySelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableSimpleCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableSimpleCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("tree_id")
		e.Str(s.TreeID)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
}

var jsonFieldsNameOfNullableSimpleCommit = [6]string{
	0: "id",
	1: "tree_id",
	2: "message",
	3: "timestamp",
	4: "author",
	5: "committer",
}

// Decode decodes NullableSimpleCommit from json.
func (s *NullableSimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tree_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommit) {
					name = jsonFieldsNameOfNullableSimpleCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableSimpleCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableSimpleCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableSimpleCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableSimpleCommitAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfNullableSimpleCommitAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (s *NullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommitAuthor) {
					name = jsonFieldsNameOfNullableSimpleCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableSimpleCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableSimpleCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableSimpleCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableSimpleCommitCommitter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfNullableSimpleCommitCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (s *NullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommitCommitter) {
					name = jsonFieldsNameOfNullableSimpleCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableSimpleCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableSimpleCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableSimpleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableSimpleUser) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.FieldStart("starred_at")
			s.StarredAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableSimpleUser = [21]string{
	0:  "name",
	1:  "email",
	2:  "login",
	3:  "id",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "starred_at",
}

// Decode decodes NullableSimpleUser from json.
func (s *NullableSimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111100,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleUser) {
					name = jsonFieldsNameOfNullableSimpleUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableSimpleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableSimpleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NullableTeamSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NullableTeamSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("permission")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("repositories_url")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.FieldStart("ldap_dn")
			s.LdapDn.Encode(e)
		}
	}
}

var jsonFieldsNameOfNullableTeamSimple = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "members_url",
	4:  "name",
	5:  "description",
	6:  "permission",
	7:  "privacy",
	8:  "html_url",
	9:  "repositories_url",
	10: "slug",
	11: "ldap_dn",
}

// Decode decodes NullableTeamSimple from json.
func (s *NullableTeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableTeamSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "members_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "slug":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableTeamSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableTeamSimple) {
					name = jsonFieldsNameOfNullableTeamSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NullableTeamSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NullableTeamSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationForbidden as json.
func (s *OAuthAuthorizationsCreateAuthorizationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationForbidden from json.
func (s *OAuthAuthorizationsCreateAuthorizationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsCreateAuthorizationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsCreateAuthorizationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationGone as json.
func (s *OAuthAuthorizationsCreateAuthorizationGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationGone from json.
func (s *OAuthAuthorizationsCreateAuthorizationGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsCreateAuthorizationGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsCreateAuthorizationGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthAuthorizationsCreateAuthorizationReq) encodeFields(e *jx.Encoder) {
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.FieldStart("note_url")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.FieldStart("client_id")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.FieldStart("client_secret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuthAuthorizationsCreateAuthorizationReq = [6]string{
	0: "scopes",
	1: "note",
	2: "note_url",
	3: "client_id",
	4: "client_secret",
	5: "fingerprint",
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (s *OAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsCreateAuthorizationReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsCreateAuthorizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsCreateAuthorizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationUnauthorized as json.
func (s *OAuthAuthorizationsCreateAuthorizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationUnauthorized from json.
func (s *OAuthAuthorizationsCreateAuthorizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsCreateAuthorizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsCreateAuthorizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationForbidden as json.
func (s *OAuthAuthorizationsDeleteAuthorizationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationForbidden from json.
func (s *OAuthAuthorizationsDeleteAuthorizationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsDeleteAuthorizationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsDeleteAuthorizationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationUnauthorized as json.
func (s *OAuthAuthorizationsDeleteAuthorizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationUnauthorized from json.
func (s *OAuthAuthorizationsDeleteAuthorizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsDeleteAuthorizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsDeleteAuthorizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsDeleteGrantForbidden as json.
func (s *OAuthAuthorizationsDeleteGrantForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantForbidden from json.
func (s *OAuthAuthorizationsDeleteGrantForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteGrantForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsDeleteGrantForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsDeleteGrantForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsDeleteGrantUnauthorized as json.
func (s *OAuthAuthorizationsDeleteGrantUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantUnauthorized from json.
func (s *OAuthAuthorizationsDeleteGrantUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteGrantUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsDeleteGrantUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsDeleteGrantUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetAuthorizationForbidden as json.
func (s *OAuthAuthorizationsGetAuthorizationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationForbidden from json.
func (s *OAuthAuthorizationsGetAuthorizationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetAuthorizationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetAuthorizationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetAuthorizationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetAuthorizationUnauthorized as json.
func (s *OAuthAuthorizationsGetAuthorizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationUnauthorized from json.
func (s *OAuthAuthorizationsGetAuthorizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetAuthorizationUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetAuthorizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetAuthorizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetGrantForbidden as json.
func (s *OAuthAuthorizationsGetGrantForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantForbidden from json.
func (s *OAuthAuthorizationsGetGrantForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetGrantForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetGrantForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetGrantForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetGrantUnauthorized as json.
func (s *OAuthAuthorizationsGetGrantUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantUnauthorized from json.
func (s *OAuthAuthorizationsGetGrantUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetGrantUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetGrantUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetGrantUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_secret")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.FieldStart("note_url")
			s.NoteURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq = [4]string{
	0: "client_secret",
	1: "scopes",
	2: "note",
	3: "note_url",
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) {
					name = jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden as json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_secret")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.FieldStart("note_url")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq = [5]string{
	0: "client_secret",
	1: "scopes",
	2: "note",
	3: "note_url",
	4: "fingerprint",
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq) {
					name = jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized as json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListAuthorizationsForbidden as json.
func (s *OAuthAuthorizationsListAuthorizationsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsForbidden from json.
func (s *OAuthAuthorizationsListAuthorizationsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListAuthorizationsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListAuthorizationsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListAuthorizationsNotFound as json.
func (s *OAuthAuthorizationsListAuthorizationsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsNotFound from json.
func (s *OAuthAuthorizationsListAuthorizationsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListAuthorizationsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListAuthorizationsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListAuthorizationsUnauthorized as json.
func (s *OAuthAuthorizationsListAuthorizationsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsUnauthorized from json.
func (s *OAuthAuthorizationsListAuthorizationsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListAuthorizationsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListAuthorizationsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListGrantsForbidden as json.
func (s *OAuthAuthorizationsListGrantsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsForbidden from json.
func (s *OAuthAuthorizationsListGrantsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListGrantsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListGrantsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListGrantsNotFound as json.
func (s *OAuthAuthorizationsListGrantsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsNotFound from json.
func (s *OAuthAuthorizationsListGrantsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListGrantsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListGrantsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsListGrantsUnauthorized as json.
func (s *OAuthAuthorizationsListGrantsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsUnauthorized from json.
func (s *OAuthAuthorizationsListGrantsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsListGrantsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsListGrantsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) encodeFields(e *jx.Encoder) {
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.AddScopes != nil {
			e.FieldStart("add_scopes")
			e.ArrStart()
			for _, elem := range s.AddScopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveScopes != nil {
			e.FieldStart("remove_scopes")
			e.ArrStart()
			for _, elem := range s.RemoveScopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.FieldStart("note_url")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuthAuthorizationsUpdateAuthorizationReq = [6]string{
	0: "scopes",
	1: "add_scopes",
	2: "remove_scopes",
	3: "note",
	4: "note_url",
	5: "fingerprint",
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsUpdateAuthorizationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "add_scopes":
			if err := func() error {
				s.AddScopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddScopes = append(s.AddScopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_scopes\"")
			}
		case "remove_scopes":
			if err := func() error {
				s.RemoveScopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveScopes = append(s.RemoveScopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsUpdateAuthorizationReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIOverviewSSHKeyFingerprints as json.
func (o OptAPIOverviewSSHKeyFingerprints) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (o *OptAPIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIOverviewSSHKeyFingerprints to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIOverviewSSHKeyFingerprints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIOverviewSSHKeyFingerprints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityMarkNotificationsAsReadReq as json.
func (o OptActivityMarkNotificationsAsReadReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (o *OptActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivityMarkNotificationsAsReadReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivityMarkNotificationsAsReadReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivityMarkNotificationsAsReadReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivityMarkRepoNotificationsAsReadReq as json.
func (o OptActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (o *OptActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivityMarkRepoNotificationsAsReadReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivityMarkRepoNotificationsAsReadReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivityMarkRepoNotificationsAsReadReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivitySetRepoSubscriptionReq as json.
func (o OptActivitySetRepoSubscriptionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (o *OptActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivitySetRepoSubscriptionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivitySetRepoSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivitySetRepoSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivitySetThreadSubscriptionReq as json.
func (o OptActivitySetThreadSubscriptionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (o *OptActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivitySetThreadSubscriptionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivitySetThreadSubscriptionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivitySetThreadSubscriptionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Actor as json.
func (o OptActor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Actor from json.
func (o *OptActor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertCreatedAt as json.
func (o OptAlertCreatedAt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertCreatedAt from json.
func (o *OptAlertCreatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertCreatedAt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertCreatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertCreatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertHTMLURL as json.
func (o OptAlertHTMLURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertHTMLURL from json.
func (o *OptAlertHTMLURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertHTMLURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertHTMLURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertHTMLURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertNumber as json.
func (o OptAlertNumber) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertNumber from json.
func (o *OptAlertNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertNumber to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertNumber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertNumber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertURL as json.
func (o OptAlertURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertURL from json.
func (o *OptAlertURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AllowedActions as json.
func (o OptAllowedActions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AllowedActions from json.
func (o *OptAllowedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAllowedActions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAllowedActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAllowedActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissions as json.
func (o OptAppPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppPermissions from json.
func (o *OptAppPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsActions as json.
func (o OptAppPermissionsActions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsActions from json.
func (o *OptAppPermissionsActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsActions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsAdministration as json.
func (o OptAppPermissionsAdministration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsAdministration from json.
func (o *OptAppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsAdministration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsAdministration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsAdministration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsChecks as json.
func (o OptAppPermissionsChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsChecks from json.
func (o *OptAppPermissionsChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsChecks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsContentReferences as json.
func (o OptAppPermissionsContentReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContentReferences from json.
func (o *OptAppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsContentReferences to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsContentReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsContentReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsContents as json.
func (o OptAppPermissionsContents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContents from json.
func (o *OptAppPermissionsContents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsContents to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsContents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsContents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsDeployments as json.
func (o OptAppPermissionsDeployments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsDeployments from json.
func (o *OptAppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsDeployments to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsDeployments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsDeployments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsEnvironments as json.
func (o OptAppPermissionsEnvironments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsEnvironments from json.
func (o *OptAppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsEnvironments to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsEnvironments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsEnvironments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsIssues as json.
func (o OptAppPermissionsIssues) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsIssues from json.
func (o *OptAppPermissionsIssues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsIssues to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsIssues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsIssues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsMembers as json.
func (o OptAppPermissionsMembers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMembers from json.
func (o *OptAppPermissionsMembers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsMembers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsMembers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsMembers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsMetadata as json.
func (o OptAppPermissionsMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMetadata from json.
func (o *OptAppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (o OptAppPermissionsOrganizationAdministration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (o *OptAppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationAdministration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationAdministration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationAdministration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (o OptAppPermissionsOrganizationHooks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (o *OptAppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationHooks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationHooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationHooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (o OptAppPermissionsOrganizationPackages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (o *OptAppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationPackages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (o OptAppPermissionsOrganizationPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (o *OptAppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (o OptAppPermissionsOrganizationProjects) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (o *OptAppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationProjects to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationProjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationProjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (o OptAppPermissionsOrganizationSecrets) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (o *OptAppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationSecrets to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (o OptAppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (o *OptAppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationSelfHostedRunners to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationSelfHostedRunners) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationSelfHostedRunners) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (o OptAppPermissionsOrganizationUserBlocking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (o *OptAppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationUserBlocking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsOrganizationUserBlocking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsOrganizationUserBlocking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPackages as json.
func (o OptAppPermissionsPackages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPackages from json.
func (o *OptAppPermissionsPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPackages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsPackages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsPackages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPages as json.
func (o OptAppPermissionsPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPages from json.
func (o *OptAppPermissionsPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsPullRequests as json.
func (o OptAppPermissionsPullRequests) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPullRequests from json.
func (o *OptAppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPullRequests to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsPullRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsPullRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (o OptAppPermissionsRepositoryHooks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (o *OptAppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsRepositoryHooks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsRepositoryHooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsRepositoryHooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (o OptAppPermissionsRepositoryProjects) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (o *OptAppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsRepositoryProjects to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsRepositoryProjects) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsRepositoryProjects) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (o OptAppPermissionsSecretScanningAlerts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (o *OptAppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecretScanningAlerts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsSecretScanningAlerts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsSecretScanningAlerts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecrets as json.
func (o OptAppPermissionsSecrets) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecrets from json.
func (o *OptAppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecrets to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (o OptAppPermissionsSecurityEvents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (o *OptAppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecurityEvents to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsSecurityEvents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsSecurityEvents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsSingleFile as json.
func (o OptAppPermissionsSingleFile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSingleFile from json.
func (o *OptAppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSingleFile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsSingleFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsSingleFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsStatuses as json.
func (o OptAppPermissionsStatuses) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsStatuses from json.
func (o *OptAppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsStatuses to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsStatuses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsStatuses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (o OptAppPermissionsTeamDiscussions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (o *OptAppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsTeamDiscussions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsTeamDiscussions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsTeamDiscussions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (o OptAppPermissionsVulnerabilityAlerts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (o *OptAppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsVulnerabilityAlerts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsVulnerabilityAlerts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsVulnerabilityAlerts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppPermissionsWorkflows as json.
func (o OptAppPermissionsWorkflows) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsWorkflows from json.
func (o *OptAppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsWorkflows to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppPermissionsWorkflows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppPermissionsWorkflows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsCreateInstallationAccessTokenReq as json.
func (o OptAppsCreateInstallationAccessTokenReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (o *OptAppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppsCreateInstallationAccessTokenReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppsCreateInstallationAccessTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppsCreateInstallationAccessTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppsUpdateWebhookConfigForAppReq as json.
func (o OptAppsUpdateWebhookConfigForAppReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (o *OptAppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppsUpdateWebhookConfigForAppReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAppsUpdateWebhookConfigForAppReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAppsUpdateWebhookConfigForAppReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditLogEventActorLocation as json.
func (o OptAuditLogEventActorLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventActorLocation from json.
func (o *OptAuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditLogEventActorLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuditLogEventActorLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuditLogEventActorLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditLogEventData as json.
func (o OptAuditLogEventData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventData from json.
func (o *OptAuditLogEventData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditLogEventData to nil")
	}
	o.Set = true
	o.Value = make(AuditLogEventData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuditLogEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuditLogEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (o OptAuthenticationTokenRepositorySelection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (o *OptAuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthenticationTokenRepositorySelection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuthenticationTokenRepositorySelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuthenticationTokenRepositorySelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthorAssociation as json.
func (o OptAuthorAssociation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AuthorAssociation from json.
func (o *OptAuthorAssociation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthorAssociation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuthorAssociation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuthorAssociation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtection as json.
func (o OptBranchProtection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtection from json.
func (o *OptBranchProtection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionAllowDeletions as json.
func (o OptBranchProtectionAllowDeletions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (o *OptBranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionAllowDeletions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionAllowDeletions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionAllowDeletions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionAllowForcePushes as json.
func (o OptBranchProtectionAllowForcePushes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (o *OptBranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionAllowForcePushes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionAllowForcePushes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionAllowForcePushes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionRequiredConversationResolution as json.
func (o OptBranchProtectionRequiredConversationResolution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (o *OptBranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredConversationResolution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionRequiredConversationResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionRequiredConversationResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionRequiredLinearHistory as json.
func (o OptBranchProtectionRequiredLinearHistory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (o *OptBranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredLinearHistory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionRequiredLinearHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionRequiredLinearHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionRequiredSignatures as json.
func (o OptBranchProtectionRequiredSignatures) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (o *OptBranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredSignatures to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionRequiredSignatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionRequiredSignatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchProtectionRequiredStatusChecks as json.
func (o OptBranchProtectionRequiredStatusChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (o *OptBranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredStatusChecks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchProtectionRequiredStatusChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchProtectionRequiredStatusChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchRestrictionPolicy as json.
func (o OptBranchRestrictionPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicy from json.
func (o *OptBranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchRestrictionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchRestrictionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchRestrictionPolicyAppsItemOwner as json.
func (o OptBranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (o *OptBranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicyAppsItemOwner to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchRestrictionPolicyAppsItemOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchRestrictionPolicyAppsItemOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchRestrictionPolicyAppsItemPermissions as json.
func (o OptBranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (o *OptBranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicyAppsItemPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBranchRestrictionPolicyAppsItemPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBranchRestrictionPolicyAppsItemPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeOfConduct as json.
func (o OptCodeOfConduct) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeOfConduct from json.
func (o *OptCodeOfConduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeOfConduct to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeOfConduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeOfConduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeOfConductSimple as json.
func (o OptCodeOfConductSimple) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeOfConductSimple from json.
func (o *OptCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeOfConductSimple to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeOfConductSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeOfConductSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (o OptCodeScanningAlertEnvironment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (o *OptCodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertEnvironment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAlertEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAlertEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertInstanceMessage as json.
func (o OptCodeScanningAlertInstanceMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (o *OptCodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertInstanceMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAlertInstanceMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAlertInstanceMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertLocation as json.
func (o OptCodeScanningAlertLocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertLocation from json.
func (o *OptCodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertLocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAlertLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAlertLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertState as json.
func (o OptCodeScanningAlertState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertState from json.
func (o *OptCodeScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAlertState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAlertState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (o OptCodeScanningAnalysisAnalysisKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (o *OptCodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisAnalysisKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAnalysisAnalysisKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAnalysisAnalysisKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (o OptCodeScanningAnalysisCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (o *OptCodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAnalysisCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAnalysisCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (o OptCodeScanningAnalysisSarifID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (o *OptCodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisSarifID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAnalysisSarifID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAnalysisSarifID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (o OptCodeScanningAnalysisToolName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (o *OptCodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisToolName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningAnalysisToolName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningAnalysisToolName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningRef as json.
func (o OptCodeScanningRef) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningRef from json.
func (o *OptCodeScanningRef) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningRef to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningRef) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningRef) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (o OptCodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (o *OptCodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningSarifsStatusProcessingStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCodeScanningSarifsStatusProcessingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCodeScanningSarifsStatusProcessingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CollaboratorPermissions as json.
func (o OptCollaboratorPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollaboratorPermissions from json.
func (o *OptCollaboratorPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollaboratorPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCollaboratorPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCollaboratorPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommitStats as json.
func (o OptCommitStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CommitStats from json.
func (o *OptCommitStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCommitStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCommitStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCommitStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DeploymentSimple as json.
func (o OptDeploymentSimple) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentSimple from json.
func (o *OptDeploymentSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeploymentSimple to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeploymentSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeploymentSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (o OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (o *OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileCommitCommitAuthor as json.
func (o OptFileCommitCommitAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitAuthor from json.
func (o *OptFileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitAuthor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileCommitCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileCommitCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileCommitCommitCommitter as json.
func (o OptFileCommitCommitCommitter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitCommitter from json.
func (o *OptFileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitCommitter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileCommitCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileCommitCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileCommitCommitTree as json.
func (o OptFileCommitCommitTree) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitTree from json.
func (o *OptFileCommitCommitTree) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitTree to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileCommitCommitTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileCommitCommitTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileCommitCommitVerification as json.
func (o OptFileCommitCommitVerification) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitVerification from json.
func (o *OptFileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitVerification to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileCommitCommitVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileCommitCommitVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileCommitContentLinks as json.
func (o OptFileCommitContentLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContentLinks from json.
func (o *OptFileCommitContentLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitContentLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileCommitContentLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileCommitContentLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForbiddenGistBlock as json.
func (o OptForbiddenGistBlock) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForbiddenGistBlock from json.
func (o *OptForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForbiddenGistBlock to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForbiddenGistBlock) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForbiddenGistBlock) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositoryPermissions as json.
func (o OptFullRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositoryPermissions from json.
func (o *OptFullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFullRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFullRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurity as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFullRepositorySecurityAndAnalysisAdvancedSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFullRepositorySecurityAndAnalysisAdvancedSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanning as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanning to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFullRepositorySecurityAndAnalysisSecretScanning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFullRepositorySecurityAndAnalysisSecretScanning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanningStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFullRepositorySecurityAndAnalysisSecretScanningStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFullRepositorySecurityAndAnalysisSecretScanningStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistHistoryChangeStatus as json.
func (o OptGistHistoryChangeStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistHistoryChangeStatus from json.
func (o *OptGistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistHistoryChangeStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGistHistoryChangeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGistHistoryChangeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistSimpleFiles as json.
func (o OptGistSimpleFiles) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleFiles from json.
func (o *OptGistSimpleFiles) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistSimpleFiles to nil")
	}
	o.Set = true
	o.Value = make(GistSimpleFiles)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGistSimpleFiles) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGistSimpleFiles) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistsCreateReqPublic as json.
func (o OptGistsCreateReqPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistsCreateReqPublic from json.
func (o *OptGistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistsCreateReqPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGistsCreateReqPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGistsCreateReqPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateCommitReqAuthor as json.
func (o OptGitCreateCommitReqAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (o *OptGitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateCommitReqAuthor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGitCreateCommitReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGitCreateCommitReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateCommitReqCommitter as json.
func (o OptGitCreateCommitReqCommitter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (o *OptGitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateCommitReqCommitter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGitCreateCommitReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGitCreateCommitReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTagReqTagger as json.
func (o OptGitCreateTagReqTagger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateTagReqTagger from json.
func (o *OptGitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTagReqTagger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGitCreateTagReqTagger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGitCreateTagReqTagger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (o OptGitCreateTreeReqTreeItemMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (o *OptGitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTreeReqTreeItemMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGitCreateTreeReqTreeItemMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGitCreateTreeReqTreeItemMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (o OptGitCreateTreeReqTreeItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (o *OptGitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTreeReqTreeItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGitCreateTreeReqTreeItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGitCreateTreeReqTreeItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (o OptInstallationTokenRepositorySelection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (o *OptInstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstallationTokenRepositorySelection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstallationTokenRepositorySelection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstallationTokenRepositorySelection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InteractionExpiry as json.
func (o OptInteractionExpiry) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InteractionExpiry from json.
func (o *OptInteractionExpiry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInteractionExpiry to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInteractionExpiry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInteractionExpiry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueComment as json.
func (o OptIssueComment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueComment from json.
func (o *OptIssueComment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueComment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueEventDismissedReview as json.
func (o OptIssueEventDismissedReview) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventDismissedReview from json.
func (o *OptIssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventDismissedReview to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueEventDismissedReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueEventDismissedReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueEventLabel as json.
func (o OptIssueEventLabel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventLabel from json.
func (o *OptIssueEventLabel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventLabel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueEventLabel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueEventLabel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueEventMilestone as json.
func (o OptIssueEventMilestone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventMilestone from json.
func (o *OptIssueEventMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventMilestone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueEventMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueEventMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueEventProjectCard as json.
func (o OptIssueEventProjectCard) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventProjectCard from json.
func (o *OptIssueEventProjectCard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventProjectCard to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueEventProjectCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueEventProjectCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueEventRename as json.
func (o OptIssueEventRename) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventRename from json.
func (o *OptIssueEventRename) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventRename to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueEventRename) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueEventRename) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuePullRequest as json.
func (o OptIssuePullRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuePullRequest from json.
func (o *OptIssuePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuePullRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuePullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuePullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueSearchResultItemPullRequest as json.
func (o OptIssueSearchResultItemPullRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (o *OptIssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSearchResultItemPullRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueSearchResultItemPullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueSearchResultItemPullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueSimple as json.
func (o OptIssueSimple) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSimple from json.
func (o *OptIssueSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSimple to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssueSimplePullRequest as json.
func (o OptIssueSimplePullRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSimplePullRequest from json.
func (o *OptIssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSimplePullRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssueSimplePullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssueSimplePullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesAddAssigneesReq as json.
func (o OptIssuesAddAssigneesReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesAddAssigneesReq from json.
func (o *OptIssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesAddAssigneesReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesAddAssigneesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesAddAssigneesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (o OptIssuesCreateMilestoneReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (o *OptIssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesCreateMilestoneReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesCreateMilestoneReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesCreateMilestoneReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockReqLockReason as json.
func (o OptIssuesLockReqLockReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesLockReqLockReason from json.
func (o *OptIssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesLockReqLockReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesLockReqLockReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesLockReqLockReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesRemoveAssigneesReq as json.
func (o OptIssuesRemoveAssigneesReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (o *OptIssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesRemoveAssigneesReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesRemoveAssigneesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesRemoveAssigneesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateLabelReq as json.
func (o OptIssuesUpdateLabelReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateLabelReq from json.
func (o *OptIssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateLabelReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesUpdateLabelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesUpdateLabelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateMilestoneReq as json.
func (o OptIssuesUpdateMilestoneReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (o *OptIssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateMilestoneReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesUpdateMilestoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesUpdateMilestoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (o OptIssuesUpdateMilestoneReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (o *OptIssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateMilestoneReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesUpdateMilestoneReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesUpdateMilestoneReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReq as json.
func (o OptIssuesUpdateReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReq from json.
func (o *OptIssuesUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqState as json.
func (o OptIssuesUpdateReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateReqState from json.
func (o *OptIssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIssuesUpdateReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIssuesUpdateReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinkWithType as json.
func (o OptLinkWithType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinkWithType from json.
func (o *OptLinkWithType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinkWithType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinkWithType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinkWithType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MarkdownRenderReqMode as json.
func (o OptMarkdownRenderReqMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MarkdownRenderReqMode from json.
func (o *OptMarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMarkdownRenderReqMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMarkdownRenderReqMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMarkdownRenderReqMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MarketplaceListingPlan as json.
func (o OptMarketplaceListingPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplaceListingPlan from json.
func (o *OptMarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMarketplaceListingPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMarketplaceListingPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMarketplaceListingPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MergedUpstreamMergeType as json.
func (o OptMergedUpstreamMergeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MergedUpstreamMergeType from json.
func (o *OptMergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMergedUpstreamMergeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMergedUpstreamMergeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMergedUpstreamMergeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsMapCommitAuthorReq as json.
func (o OptMigrationsMapCommitAuthorReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (o *OptMigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMigrationsMapCommitAuthorReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMigrationsMapCommitAuthorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMigrationsMapCommitAuthorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (o OptMigrationsStartImportReqVcs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (o *OptMigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMigrationsStartImportReqVcs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMigrationsStartImportReqVcs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMigrationsStartImportReqVcs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MinimalRepository as json.
func (o OptMinimalRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepository from json.
func (o *OptMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMinimalRepository to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMinimalRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMinimalRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MinimalRepositoryPermissions as json.
func (o OptMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryPermissions from json.
func (o *OptMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMinimalRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMinimalRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMinimalRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o OptNilCodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *OptNilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertDismissedReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAlertDismissedReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAlertDismissedReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (o OptNilCodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (o *OptNilCodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSecuritySeverityLevel to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertRuleSecuritySeverityLevel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAlertRuleSecuritySeverityLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAlertRuleSecuritySeverityLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (o OptNilCodeScanningAlertRuleSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (o *OptNilCodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSeverity to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertRuleSeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAlertRuleSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAlertRuleSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (o OptNilCodeScanningAlertRuleSummarySeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (o *OptNilCodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSummarySeverity to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAlertRuleSummarySeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAlertRuleSummarySeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAlertRuleSummarySeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (o OptNilCodeScanningAnalysisToolGUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (o *OptNilCodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAnalysisToolGUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAnalysisToolGUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAnalysisToolGUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAnalysisToolGUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (o OptNilCodeScanningAnalysisToolVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (o *OptNilCodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAnalysisToolVersion to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CodeScanningAnalysisToolVersion
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCodeScanningAnalysisToolVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCodeScanningAnalysisToolVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FullRepositorySecurityAndAnalysis as json.
func (o OptNilFullRepositorySecurityAndAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (o *OptNilFullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFullRepositorySecurityAndAnalysis to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v FullRepositorySecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFullRepositorySecurityAndAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFullRepositorySecurityAndAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []GistHistory as json.
func (o OptNilGistHistoryArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []GistHistory from json.
func (o *OptNilGistHistoryArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistHistoryArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []GistHistory
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]GistHistory, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem GistHistory
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGistHistoryArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGistHistoryArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GistSimpleForkOf as json.
func (o OptNilGistSimpleForkOf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleForkOf from json.
func (o *OptNilGistSimpleForkOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistSimpleForkOf to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GistSimpleForkOf
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGistSimpleForkOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGistSimpleForkOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []GistSimpleForksItem as json.
func (o OptNilGistSimpleForksItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []GistSimpleForksItem from json.
func (o *OptNilGistSimpleForksItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistSimpleForksItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []GistSimpleForksItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]GistSimpleForksItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem GistSimpleForksItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGistSimpleForksItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGistSimpleForksItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesCreateReqMilestone as json.
func (o OptNilIssuesCreateReqMilestone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesCreateReqMilestone from json.
func (o *OptNilIssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesCreateReqMilestone to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IssuesCreateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIssuesCreateReqMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIssuesCreateReqMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesLockReq as json.
func (o OptNilIssuesLockReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesLockReq from json.
func (o *OptNilIssuesLockReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesLockReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IssuesLockReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIssuesLockReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIssuesLockReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (o OptNilIssuesUpdateReqMilestone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (o *OptNilIssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesUpdateReqMilestone to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IssuesUpdateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIssuesUpdateReqMilestone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIssuesUpdateReqMilestone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IssuesUpdateReqTitle as json.
func (o OptNilIssuesUpdateReqTitle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReqTitle from json.
func (o *OptNilIssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesUpdateReqTitle to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IssuesUpdateReqTitle
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIssuesUpdateReqTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIssuesUpdateReqTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MarketplacePurchaseMarketplacePendingChange as json.
func (o OptNilMarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (o *OptNilMarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilMarketplacePurchaseMarketplacePendingChange to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v MarketplacePurchaseMarketplacePendingChange
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilMarketplacePurchaseMarketplacePendingChange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilMarketplacePurchaseMarketplacePendingChange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MigrationsUpdateImportReq as json.
func (o OptNilMigrationsUpdateImportReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MigrationsUpdateImportReq from json.
func (o *OptNilMigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilMigrationsUpdateImportReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v MigrationsUpdateImportReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilMigrationsUpdateImportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilMigrationsUpdateImportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MinimalRepositoryLicense as json.
func (o OptNilMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryLicense from json.
func (o *OptNilMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilMinimalRepositoryLicense to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v MinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilMinimalRepositoryLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilMinimalRepositoryLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableIntegration as json.
func (o OptNilNullableIntegration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *OptNilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableIntegration to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableIntegration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableMinimalRepository as json.
func (o OptNilNullableMinimalRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepository from json.
func (o *OptNilNullableMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableMinimalRepository to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableMinimalRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableMinimalRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableMinimalRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableMinimalRepositoryLicense as json.
func (o OptNilNullableMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (o *OptNilNullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableMinimalRepositoryLicense to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableMinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableMinimalRepositoryLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableMinimalRepositoryLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableRepository as json.
func (o OptNilNullableRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepository from json.
func (o *OptNilNullableRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableRepository to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableRepositoryTemplateRepository as json.
func (o OptNilNullableRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (o *OptNilNullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableRepositoryTemplateRepository to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableRepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableRepositoryTemplateRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableRepositoryTemplateRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableScopedInstallation as json.
func (o OptNilNullableScopedInstallation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableScopedInstallation from json.
func (o *OptNilNullableScopedInstallation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableScopedInstallation to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableScopedInstallation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableScopedInstallation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableScopedInstallation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableSimpleUser as json.
func (o OptNilNullableSimpleUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *OptNilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableSimpleUser to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableSimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableSimpleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableSimpleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableTeamSimple as json.
func (o OptNilNullableTeamSimple) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *OptNilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableTeamSimple to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NullableTeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNullableTeamSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNullableTeamSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageProtectedDomainState as json.
func (o OptNilPageProtectedDomainState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageProtectedDomainState from json.
func (o *OptNilPageProtectedDomainState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPageProtectedDomainState to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PageProtectedDomainState
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPageProtectedDomainState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPageProtectedDomainState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PagesHealthCheckAltDomain as json.
func (o OptNilPagesHealthCheckAltDomain) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (o *OptNilPagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPagesHealthCheckAltDomain to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PagesHealthCheckAltDomain
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPagesHealthCheckAltDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPagesHealthCheckAltDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorReq as json.
func (o OptNilProjectsAddCollaboratorReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (o *OptNilProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectsAddCollaboratorReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectsAddCollaboratorReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectsAddCollaboratorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectsAddCollaboratorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (o OptNilPullRequestReviewCommentStartSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (o *OptNilPullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPullRequestReviewCommentStartSide to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PullRequestReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPullRequestReviewCommentStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPullRequestReviewCommentStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsMergeReq as json.
func (o OptNilPullsMergeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsMergeReq from json.
func (o *OptNilPullsMergeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPullsMergeReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PullsMergeReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPullsMergeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPullsMergeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsUpdateBranchReq as json.
func (o OptNilPullsUpdateBranchReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateBranchReq from json.
func (o *OptNilPullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPullsUpdateBranchReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PullsUpdateBranchReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPullsUpdateBranchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPullsUpdateBranchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForkReq as json.
func (o OptNilReposCreateForkReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateForkReq from json.
func (o *OptNilReposCreateForkReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReposCreateForkReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposCreateForkReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReposCreateForkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReposCreateForkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateWebhookReq as json.
func (o OptNilReposCreateWebhookReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReq from json.
func (o *OptNilReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReposCreateWebhookReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposCreateWebhookReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReposCreateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReposCreateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReqSecurityAndAnalysis as json.
func (o OptNilReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (o *OptNilReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReposUpdateReqSecurityAndAnalysis to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReposUpdateReqSecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReposUpdateReqSecurityAndAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReposUpdateReqSecurityAndAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepositoryTemplateRepository as json.
func (o OptNilRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepository from json.
func (o *OptNilRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRepositoryTemplateRepository to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRepositoryTemplateRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRepositoryTemplateRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReviewCommentStartSide as json.
func (o OptNilReviewCommentStartSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentStartSide from json.
func (o *OptNilReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReviewCommentStartSide to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReviewCommentStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReviewCommentStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretScanningAlertResolution as json.
func (o OptNilSecretScanningAlertResolution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertResolution from json.
func (o *OptNilSecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSecretScanningAlertResolution to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SecretScanningAlertResolution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSecretScanningAlertResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSecretScanningAlertResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SimpleUser as json.
func (o OptNilSimpleUserArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SimpleUser from json.
func (o *OptNilSimpleUserArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSimpleUserArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SimpleUser, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SimpleUser
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSimpleUserArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSimpleUserArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Team as json.
func (o OptNilTeamArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Team from json.
func (o *OptNilTeamArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTeamArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Team
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Team, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Team
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTeamArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTeamArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []TeamSimple as json.
func (o OptNilTeamSimpleArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []TeamSimple from json.
func (o *OptNilTeamSimpleArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTeamSimpleArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []TeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]TeamSimple, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem TeamSimple
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTeamSimpleArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTeamSimpleArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReq as json.
func (o OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (o *OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TeamsAddOrUpdateProjectPermissionsInOrgReq
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []TopicSearchResultItemAliasesItem as json.
func (o OptNilTopicSearchResultItemAliasesItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []TopicSearchResultItemAliasesItem from json.
func (o *OptNilTopicSearchResultItemAliasesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTopicSearchResultItemAliasesItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []TopicSearchResultItemAliasesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]TopicSearchResultItemAliasesItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem TopicSearchResultItemAliasesItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTopicSearchResultItemAliasesItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTopicSearchResultItemAliasesItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []TopicSearchResultItemRelatedItem as json.
func (o OptNilTopicSearchResultItemRelatedItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []TopicSearchResultItemRelatedItem from json.
func (o *OptNilTopicSearchResultItemRelatedItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTopicSearchResultItemRelatedItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []TopicSearchResultItemRelatedItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]TopicSearchResultItemRelatedItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem TopicSearchResultItemRelatedItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTopicSearchResultItemRelatedItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTopicSearchResultItemRelatedItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableMinimalRepositoryPermissions as json.
func (o OptNullableMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (o *OptNullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableMinimalRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNullableMinimalRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNullableMinimalRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableRepositoryPermissions as json.
func (o OptNullableRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryPermissions from json.
func (o *OptNullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNullableRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNullableRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableRepositoryTemplateRepositoryOwner as json.
func (o OptNullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (o *OptNullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryTemplateRepositoryOwner to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNullableRepositoryTemplateRepositoryOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNullableRepositoryTemplateRepositoryOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NullableRepositoryTemplateRepositoryPermissions as json.
func (o OptNullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (o *OptNullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryTemplateRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNullableRepositoryTemplateRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNullableRepositoryTemplateRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationReq as json.
func (o OptOAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOAuthAuthorizationsCreateAuthorizationReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOAuthAuthorizationsCreateAuthorizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOAuthAuthorizationsCreateAuthorizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthAuthorizationsUpdateAuthorizationReq as json.
func (o OptOAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOAuthAuthorizationsUpdateAuthorizationReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOAuthAuthorizationsUpdateAuthorizationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOAuthAuthorizationsUpdateAuthorizationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgMembershipPermissions as json.
func (o OptOrgMembershipPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgMembershipPermissions from json.
func (o *OptOrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgMembershipPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgMembershipPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgMembershipPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganizationFullPlan as json.
func (o OptOrganizationFullPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrganizationFullPlan from json.
func (o *OptOrganizationFullPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganizationFullPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganizationFullPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganizationFullPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsCreateInvitationReq as json.
func (o OptOrgsCreateInvitationReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsCreateInvitationReq from json.
func (o *OptOrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsCreateInvitationReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsCreateInvitationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsCreateInvitationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (o OptOrgsCreateInvitationReqRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (o *OptOrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsCreateInvitationReqRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsCreateInvitationReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsCreateInvitationReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsSetMembershipForUserReq as json.
func (o OptOrgsSetMembershipForUserReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (o *OptOrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsSetMembershipForUserReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsSetMembershipForUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsSetMembershipForUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (o OptOrgsSetMembershipForUserReqRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (o *OptOrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsSetMembershipForUserReqRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsSetMembershipForUserReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsSetMembershipForUserReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateWebhookConfigForOrgReq as json.
func (o OptOrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (o *OptOrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookConfigForOrgReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsUpdateWebhookConfigForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsUpdateWebhookConfigForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateWebhookReq as json.
func (o OptOrgsUpdateWebhookReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (o *OptOrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsUpdateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsUpdateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateWebhookReqConfig as json.
func (o OptOrgsUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (o *OptOrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookReqConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrgsUpdateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrgsUpdateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageVersionMetadata as json.
func (o OptPackageVersionMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadata from json.
func (o *OptPackageVersionMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPackageVersionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPackageVersionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageVersionMetadataContainer as json.
func (o OptPackageVersionMetadataContainer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataContainer from json.
func (o *OptPackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadataContainer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPackageVersionMetadataContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPackageVersionMetadataContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageVersionMetadataDocker as json.
func (o OptPackageVersionMetadataDocker) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataDocker from json.
func (o *OptPackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadataDocker to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPackageVersionMetadataDocker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPackageVersionMetadataDocker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PagesHTTPSCertificate as json.
func (o OptPagesHTTPSCertificate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHTTPSCertificate from json.
func (o *OptPagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesHTTPSCertificate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPagesHTTPSCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPagesHTTPSCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PagesHealthCheckDomain as json.
func (o OptPagesHealthCheckDomain) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckDomain from json.
func (o *OptPagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesHealthCheckDomain to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPagesHealthCheckDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPagesHealthCheckDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PagesSourceHash as json.
func (o OptPagesSourceHash) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesSourceHash from json.
func (o *OptPagesSourceHash) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesSourceHash to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPagesSourceHash) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPagesSourceHash) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PrivateUserPlan as json.
func (o OptPrivateUserPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PrivateUserPlan from json.
func (o *OptPrivateUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPrivateUserPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPrivateUserPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPrivateUserPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectOrganizationPermission as json.
func (o OptProjectOrganizationPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectOrganizationPermission from json.
func (o *OptProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectOrganizationPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectOrganizationPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectOrganizationPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (o OptProjectsAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (o *OptProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsAddCollaboratorReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectsAddCollaboratorReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectsAddCollaboratorReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateCardReq as json.
func (o OptProjectsUpdateCardReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateCardReq from json.
func (o *OptProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateCardReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectsUpdateCardReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectsUpdateCardReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateReq as json.
func (o OptProjectsUpdateReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateReq from json.
func (o *OptProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectsUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectsUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (o OptProjectsUpdateReqOrganizationPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (o *OptProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateReqOrganizationPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectsUpdateReqOrganizationPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectsUpdateReqOrganizationPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchAdminEnforced as json.
func (o OptProtectedBranchAdminEnforced) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (o *OptProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAdminEnforced to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchAdminEnforced) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchAdminEnforced) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchAllowDeletions as json.
func (o OptProtectedBranchAllowDeletions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (o *OptProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAllowDeletions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchAllowDeletions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchAllowDeletions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchAllowForcePushes as json.
func (o OptProtectedBranchAllowForcePushes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (o *OptProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAllowForcePushes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchAllowForcePushes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchAllowForcePushes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchEnforceAdmins as json.
func (o OptProtectedBranchEnforceAdmins) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (o *OptProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchEnforceAdmins to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchEnforceAdmins) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchEnforceAdmins) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchPullRequestReview as json.
func (o OptProtectedBranchPullRequestReview) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (o *OptProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchPullRequestReview to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchPullRequestReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchPullRequestReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchPullRequestReviewDismissalRestrictions as json.
func (o OptProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (o *OptProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchPullRequestReviewDismissalRestrictions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchPullRequestReviewDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchPullRequestReviewDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchRequiredConversationResolution as json.
func (o OptProtectedBranchRequiredConversationResolution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (o *OptProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredConversationResolution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchRequiredConversationResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchRequiredConversationResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchRequiredLinearHistory as json.
func (o OptProtectedBranchRequiredLinearHistory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (o *OptProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredLinearHistory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchRequiredLinearHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchRequiredLinearHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchRequiredPullRequestReviews as json.
func (o OptProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (o *OptProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredPullRequestReviews to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchRequiredPullRequestReviews) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchRequiredPullRequestReviews) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProtectedBranchRequiredSignatures as json.
func (o OptProtectedBranchRequiredSignatures) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (o *OptProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredSignatures to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProtectedBranchRequiredSignatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProtectedBranchRequiredSignatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicUser as json.
func (o OptPublicUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicUser from json.
func (o *OptPublicUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicUserPlan as json.
func (o OptPublicUserPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicUserPlan from json.
func (o *OptPublicUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicUserPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicUserPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicUserPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestBaseRepoPermissions as json.
func (o OptPullRequestBaseRepoPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (o *OptPullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestBaseRepoPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullRequestBaseRepoPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullRequestBaseRepoPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestHeadRepoPermissions as json.
func (o OptPullRequestHeadRepoPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (o *OptPullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestHeadRepoPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullRequestHeadRepoPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullRequestHeadRepoPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestReviewCommentSide as json.
func (o OptPullRequestReviewCommentSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (o *OptPullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestReviewCommentSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullRequestReviewCommentSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullRequestReviewCommentSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (o OptPullsCreateReviewCommentReqSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (o *OptPullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewCommentReqSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsCreateReviewCommentReqSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsCreateReviewCommentReqSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (o OptPullsCreateReviewCommentReqStartSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (o *OptPullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewCommentReqStartSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsCreateReviewCommentReqStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsCreateReviewCommentReqStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewReq as json.
func (o OptPullsCreateReviewReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsCreateReviewReq from json.
func (o *OptPullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsCreateReviewReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsCreateReviewReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (o OptPullsCreateReviewReqEvent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (o *OptPullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewReqEvent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsCreateReviewReqEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsCreateReviewReqEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (o OptPullsMergeReqMergeMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (o *OptPullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsMergeReqMergeMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsMergeReqMergeMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsMergeReqMergeMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsUpdateReq as json.
func (o OptPullsUpdateReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateReq from json.
func (o *OptPullsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsUpdateReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsUpdateReqState as json.
func (o OptPullsUpdateReqState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsUpdateReqState from json.
func (o *OptPullsUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsUpdateReqState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPullsUpdateReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPullsUpdateReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RateLimit as json.
func (o OptRateLimit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimit from json.
func (o *OptRateLimit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRateLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRateLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionRollup as json.
func (o OptReactionRollup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReactionRollup from json.
func (o *OptReactionRollup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReactionRollup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReactionRollup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReactionRollup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepoSearchResultItemPermissions as json.
func (o OptRepoSearchResultItemPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (o *OptRepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepoSearchResultItemPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRepoSearchResultItemPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRepoSearchResultItemPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (o OptReposAddAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (o *OptReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddAppAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddCollaboratorReq as json.
func (o OptReposAddCollaboratorReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddCollaboratorReq from json.
func (o *OptReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddCollaboratorReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddCollaboratorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddCollaboratorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (o OptReposAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (o *OptReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddCollaboratorReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddCollaboratorReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddCollaboratorReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (o OptReposAddStatusCheckContextsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (o *OptReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddStatusCheckContextsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (o OptReposAddTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (o *OptReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddTeamAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (o OptReposAddUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (o *OptReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddUserAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposAddUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposAddUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (o OptReposCreateDeploymentReqPayload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (o *OptReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDeploymentReqPayload to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateDeploymentReqPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateDeploymentReqPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (o OptReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (o *OptReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDeploymentStatusReqEnvironment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateDeploymentStatusReqEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateDeploymentStatusReqEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDispatchEventReqClientPayload as json.
func (o OptReposCreateDispatchEventReqClientPayload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (o *OptReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDispatchEventReqClientPayload to nil")
	}
	o.Set = true
	o.Value = make(ReposCreateDispatchEventReqClientPayload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateDispatchEventReqClientPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateDispatchEventReqClientPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (o OptReposCreateInOrgReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (o *OptReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateInOrgReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateInOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateInOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsReqAuthor as json.
func (o OptReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (o *OptReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateOrUpdateFileContentsReqAuthor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateOrUpdateFileContentsReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateOrUpdateFileContentsReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsReqCommitter as json.
func (o OptReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (o *OptReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateOrUpdateFileContentsReqCommitter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateOrUpdateFileContentsReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateOrUpdateFileContentsReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (o OptReposCreatePagesSiteReqSourcePath) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (o *OptReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreatePagesSiteReqSourcePath to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreatePagesSiteReqSourcePath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreatePagesSiteReqSourcePath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateWebhookReqConfig as json.
func (o OptReposCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (o *OptReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateWebhookReqConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposCreateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposCreateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteFileReqAuthor as json.
func (o OptReposDeleteFileReqAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (o *OptReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposDeleteFileReqAuthor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposDeleteFileReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposDeleteFileReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteFileReqCommitter as json.
func (o OptReposDeleteFileReqCommitter) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (o *OptReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposDeleteFileReqCommitter to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposDeleteFileReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposDeleteFileReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (o OptReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (o *OptReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveAppAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposRemoveAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposRemoveAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (o OptReposRemoveStatusCheckContextsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (o *OptReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveStatusCheckContextsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposRemoveStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposRemoveStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (o OptReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (o *OptReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveTeamAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposRemoveTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposRemoveTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (o OptReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (o *OptReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveUserAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposRemoveUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposRemoveUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRenameBranchReq as json.
func (o OptReposRenameBranchReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRenameBranchReq from json.
func (o *OptReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRenameBranchReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposRenameBranchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposRenameBranchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (o OptReposSetAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (o *OptReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetAppAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposSetAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposSetAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (o OptReposSetStatusCheckContextsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (o *OptReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetStatusCheckContextsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposSetStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposSetStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (o OptReposSetTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (o *OptReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetTeamAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposSetTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposSetTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (o OptReposSetUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (o *OptReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetUserAccessRestrictionsReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposSetUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposSetUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateInvitationReq as json.
func (o OptReposUpdateInvitationReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateInvitationReq from json.
func (o *OptReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateInvitationReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateInvitationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateInvitationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (o OptReposUpdateInvitationReqPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (o *OptReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateInvitationReqPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateInvitationReqPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateInvitationReqPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReq as json.
func (o OptReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (o *OptReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdatePullRequestReviewProtectionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdatePullRequestReviewProtectionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions as json.
func (o OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (o *OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReleaseAssetReq as json.
func (o OptReposUpdateReleaseAssetReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (o *OptReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReleaseAssetReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReleaseAssetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReleaseAssetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReleaseReq as json.
func (o OptReposUpdateReleaseReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseReq from json.
func (o *OptReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReleaseReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReleaseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReleaseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReq as json.
func (o OptReposUpdateReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReq from json.
func (o *OptReposUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity as json.
func (o OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (o *OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisSecretScanning as json.
func (o OptReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (o *OptReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisSecretScanning to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReqSecurityAndAnalysisSecretScanning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReqSecurityAndAnalysisSecretScanning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReqVisibility as json.
func (o OptReposUpdateReqVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (o *OptReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateStatusCheckProtectionReq as json.
func (o OptReposUpdateStatusCheckProtectionReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (o *OptReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateStatusCheckProtectionReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateStatusCheckProtectionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateStatusCheckProtectionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateWebhookConfigForRepoReq as json.
func (o OptReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (o *OptReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookConfigForRepoReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateWebhookConfigForRepoReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateWebhookConfigForRepoReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateWebhookReq as json.
func (o OptReposUpdateWebhookReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReq from json.
func (o *OptReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateWebhookReqConfig as json.
func (o OptReposUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (o *OptReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookReqConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReposUpdateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReposUpdateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Repository as json.
func (o OptRepository) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Repository from json.
func (o *OptRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepository to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepositoryPermissions as json.
func (o OptRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryPermissions from json.
func (o *OptRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepositoryTemplateRepositoryOwner as json.
func (o OptRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (o *OptRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryTemplateRepositoryOwner to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRepositoryTemplateRepositoryOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRepositoryTemplateRepositoryOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepositoryTemplateRepositoryPermissions as json.
func (o OptRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (o *OptRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryTemplateRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRepositoryTemplateRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRepositoryTemplateRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReviewCommentSide as json.
func (o OptReviewCommentSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentSide from json.
func (o *OptReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReviewCommentSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReviewCommentSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReviewCommentSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunnerLabelsItemType as json.
func (o OptRunnerLabelsItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RunnerLabelsItemType from json.
func (o *OptRunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRunnerLabelsItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRunnerLabelsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRunnerLabelsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimEnterpriseGroupMeta as json.
func (o OptScimEnterpriseGroupMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (o *OptScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseGroupMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimEnterpriseGroupMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimEnterpriseGroupMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimEnterpriseUserMeta as json.
func (o OptScimEnterpriseUserMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (o *OptScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseUserMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimEnterpriseUserMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimEnterpriseUserMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimEnterpriseUserName as json.
func (o OptScimEnterpriseUserName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserName from json.
func (o *OptScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseUserName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimEnterpriseUserName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimEnterpriseUserName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimGroupListEnterpriseResourcesItemMeta as json.
func (o OptScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (o *OptScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimGroupListEnterpriseResourcesItemMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimGroupListEnterpriseResourcesItemMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimGroupListEnterpriseResourcesItemMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimUserListEnterpriseResourcesItemMeta as json.
func (o OptScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (o *OptScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimUserListEnterpriseResourcesItemMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimUserListEnterpriseResourcesItemMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimUserListEnterpriseResourcesItemMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimUserListEnterpriseResourcesItemName as json.
func (o OptScimUserListEnterpriseResourcesItemName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (o *OptScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimUserListEnterpriseResourcesItemName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScimUserListEnterpriseResourcesItemName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScimUserListEnterpriseResourcesItemName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretScanningAlertState as json.
func (o OptSecretScanningAlertState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertState from json.
func (o *OptSecretScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecretScanningAlertState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecretScanningAlertState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecretScanningAlertState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectedActions as json.
func (o OptSelectedActions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SelectedActions from json.
func (o *OptSelectedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectedActions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSelectedActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSelectedActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectedActionsURL as json.
func (o OptSelectedActionsURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SelectedActionsURL from json.
func (o *OptSelectedActionsURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectedActionsURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSelectedActionsURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSelectedActionsURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SimpleUser as json.
func (o OptSimpleUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleUser from json.
func (o *OptSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSimpleUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSimpleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSimpleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StatusCheckPolicy as json.
func (o OptStatusCheckPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StatusCheckPolicy from json.
func (o *OptStatusCheckPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStatusCheckPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStatusCheckPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStatusCheckPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Team as json.
func (o OptTeam) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Team from json.
func (o *OptTeam) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeam to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeam) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeam) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamFullPrivacy as json.
func (o OptTeamFullPrivacy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamFullPrivacy from json.
func (o *OptTeamFullPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamFullPrivacy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamFullPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamFullPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamPermissions as json.
func (o OptTeamPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamPermissions from json.
func (o *OptTeamPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamRepositoryPermissions as json.
func (o OptTeamRepositoryPermissions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamRepositoryPermissions from json.
func (o *OptTeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamRepositoryPermissions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateMembershipForUserInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateMembershipForUserInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReqRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateMembershipForUserLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateMembershipForUserLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReqRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateProjectPermissionsLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateProjectPermissionsLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateRepoPermissionsInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateRepoPermissionsInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateRepoPermissionsLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateRepoPermissionsLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsCreateReqPermission as json.
func (o OptTeamsCreateReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPermission from json.
func (o *OptTeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsCreateReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsCreateReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsCreateReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (o OptTeamsCreateReqPrivacy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (o *OptTeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsCreateReqPrivacy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsCreateReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsCreateReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateDiscussionInOrgReq as json.
func (o OptTeamsUpdateDiscussionInOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (o *OptTeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateDiscussionInOrgReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateDiscussionInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateDiscussionInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateDiscussionLegacyReq as json.
func (o OptTeamsUpdateDiscussionLegacyReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (o *OptTeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateDiscussionLegacyReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateDiscussionLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateDiscussionLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateInOrgReq as json.
func (o OptTeamsUpdateInOrgReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (o *OptTeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (o OptTeamsUpdateInOrgReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (o *OptTeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (o OptTeamsUpdateInOrgReqPrivacy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (o *OptTeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReqPrivacy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateInOrgReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateInOrgReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (o OptTeamsUpdateLegacyReqPermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (o *OptTeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateLegacyReqPermission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (o OptTeamsUpdateLegacyReqPrivacy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (o *OptTeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateLegacyReqPrivacy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamsUpdateLegacyReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamsUpdateLegacyReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TopicSearchResultItemAliasesItemTopicRelation as json.
func (o OptTopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (o *OptTopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTopicSearchResultItemAliasesItemTopicRelation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTopicSearchResultItemAliasesItemTopicRelation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTopicSearchResultItemAliasesItemTopicRelation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TopicSearchResultItemRelatedItemTopicRelation as json.
func (o OptTopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (o *OptTopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTopicSearchResultItemRelatedItemTopicRelation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTopicSearchResultItemRelatedItemTopicRelation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTopicSearchResultItemRelatedItemTopicRelation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (o OptUsersAddEmailForAuthenticatedReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (o *OptUsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersAddEmailForAuthenticatedReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsersAddEmailForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsersAddEmailForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (o OptUsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (o *OptUsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersDeleteEmailForAuthenticatedReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsersDeleteEmailForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsersDeleteEmailForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUpdateAuthenticatedReq as json.
func (o OptUsersUpdateAuthenticatedReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (o *OptUsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersUpdateAuthenticatedReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsersUpdateAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsersUpdateAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (o OptValidationErrorErrorsItemValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (o *OptValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationErrorErrorsItemValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidationErrorErrorsItemValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidationErrorErrorsItemValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Verification as json.
func (o OptVerification) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Verification from json.
func (o *OptVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerification to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigContentType as json.
func (o OptWebhookConfigContentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigContentType from json.
func (o *OptWebhookConfigContentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigContentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookConfigContentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookConfigContentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (o OptWebhookConfigInsecureSsl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (o *OptWebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigInsecureSsl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookConfigInsecureSsl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookConfigInsecureSsl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigSecret as json.
func (o OptWebhookConfigSecret) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigSecret from json.
func (o *OptWebhookConfigSecret) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigSecret to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookConfigSecret) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookConfigSecret) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigURL as json.
func (o OptWebhookConfigURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigURL from json.
func (o *OptWebhookConfigURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookConfigURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookConfigURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowRunUsageBillableMACOS as json.
func (o OptWorkflowRunUsageBillableMACOS) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (o *OptWorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableMACOS to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowRunUsageBillableMACOS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowRunUsageBillableMACOS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowRunUsageBillableUBUNTU as json.
func (o OptWorkflowRunUsageBillableUBUNTU) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (o *OptWorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableUBUNTU to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowRunUsageBillableUBUNTU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowRunUsageBillableUBUNTU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowRunUsageBillableWINDOWS as json.
func (o OptWorkflowRunUsageBillableWINDOWS) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (o *OptWorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableWINDOWS to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowRunUsageBillableWINDOWS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowRunUsageBillableWINDOWS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgHook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgHook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("ping_url")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.FieldStart("deliveries_url")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("active")
		e.Bool(s.Active)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfOrgHook = [11]string{
	0:  "id",
	1:  "url",
	2:  "ping_url",
	3:  "deliveries_url",
	4:  "name",
	5:  "events",
	6:  "active",
	7:  "config",
	8:  "updated_at",
	9:  "created_at",
	10: "type",
}

// Decode decodes OrgHook from json.
func (s *OrgHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgHook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "ping_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PingURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ping_url\"")
			}
		case "deliveries_url":
			if err := func() error {
				s.DeliveriesURL.Reset()
				if err := s.DeliveriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deliveries_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgHook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgHook) {
					name = jsonFieldsNameOfOrgHook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgHookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgHookConfig) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgHookConfig = [4]string{
	0: "url",
	1: "insecure_ssl",
	2: "content_type",
	3: "secret",
}

// Decode decodes OrgHookConfig from json.
func (s *OrgHookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgHookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgHookConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgHookConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgHookConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgMembership) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgMembership) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("organization_url")
		json.EncodeURI(e, s.OrganizationURL)
	}
	{
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgMembership = [7]string{
	0: "url",
	1: "state",
	2: "role",
	3: "organization_url",
	4: "organization",
	5: "user",
	6: "permissions",
}

// Decode decodes OrgMembership from json.
func (s *OrgMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembership to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "organization_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_url\"")
			}
		case "organization":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgMembership")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgMembership) {
					name = jsonFieldsNameOfOrgMembership[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgMembership) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgMembership) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgMembershipPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgMembershipPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("can_create_repository")
		e.Bool(s.CanCreateRepository)
	}
}

var jsonFieldsNameOfOrgMembershipPermissions = [1]string{
	0: "can_create_repository",
}

// Decode decodes OrgMembershipPermissions from json.
func (s *OrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_create_repository":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanCreateRepository = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_create_repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgMembershipPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgMembershipPermissions) {
					name = jsonFieldsNameOfOrgMembershipPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgMembershipPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgMembershipPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgMembershipRole as json.
func (s OrgMembershipRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipRole from json.
func (s *OrgMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipRole(v) {
	case OrgMembershipRoleAdmin:
		*s = OrgMembershipRoleAdmin
	case OrgMembershipRoleMember:
		*s = OrgMembershipRoleMember
	case OrgMembershipRoleBillingManager:
		*s = OrgMembershipRoleBillingManager
	default:
		*s = OrgMembershipRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgMembershipRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgMembershipRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgMembershipState as json.
func (s OrgMembershipState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipState from json.
func (s *OrgMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipState(v) {
	case OrgMembershipStateActive:
		*s = OrgMembershipStateActive
	case OrgMembershipStatePending:
		*s = OrgMembershipStatePending
	default:
		*s = OrgMembershipState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgMembershipState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgMembershipState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationActionsSecret) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationActionsSecret) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.FieldStart("selected_repositories_url")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrganizationActionsSecret = [5]string{
	0: "name",
	1: "created_at",
	2: "updated_at",
	3: "visibility",
	4: "selected_repositories_url",
}

// Decode decodes OrganizationActionsSecret from json.
func (s *OrganizationActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationActionsSecret to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationActionsSecret")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationActionsSecret) {
					name = jsonFieldsNameOfOrganizationActionsSecret[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationActionsSecret) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationActionsSecret) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganizationActionsSecretVisibility as json.
func (s OrganizationActionsSecretVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrganizationActionsSecretVisibility from json.
func (s *OrganizationActionsSecretVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationActionsSecretVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrganizationActionsSecretVisibility(v) {
	case OrganizationActionsSecretVisibilityAll:
		*s = OrganizationActionsSecretVisibilityAll
	case OrganizationActionsSecretVisibilityPrivate:
		*s = OrganizationActionsSecretVisibilityPrivate
	case OrganizationActionsSecretVisibilitySelected:
		*s = OrganizationActionsSecretVisibilitySelected
	default:
		*s = OrganizationActionsSecretVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrganizationActionsSecretVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationActionsSecretVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationFull) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("hooks_url")
		e.Str(s.HooksURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("public_members_url")
		e.Str(s.PublicMembersURL)
	}
	{
		e.FieldStart("avatar_url")
		e.Str(s.AvatarURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.FieldStart("company")
			s.Company.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.FieldStart("blog")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.IsVerified.Set {
			e.FieldStart("is_verified")
			s.IsVerified.Encode(e)
		}
	}
	{
		e.FieldStart("has_organization_projects")
		e.Bool(s.HasOrganizationProjects)
	}
	{
		e.FieldStart("has_repository_projects")
		e.Bool(s.HasRepositoryProjects)
	}
	{
		e.FieldStart("public_repos")
		e.Int(s.PublicRepos)
	}
	{
		e.FieldStart("public_gists")
		e.Int(s.PublicGists)
	}
	{
		e.FieldStart("followers")
		e.Int(s.Followers)
	}
	{
		e.FieldStart("following")
		e.Int(s.Following)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.TotalPrivateRepos.Set {
			e.FieldStart("total_private_repos")
			s.TotalPrivateRepos.Encode(e)
		}
	}
	{
		if s.OwnedPrivateRepos.Set {
			e.FieldStart("owned_private_repos")
			s.OwnedPrivateRepos.Encode(e)
		}
	}
	{
		if s.PrivateGists.Set {
			e.FieldStart("private_gists")
			s.PrivateGists.Encode(e)
		}
	}
	{
		if s.DiskUsage.Set {
			e.FieldStart("disk_usage")
			s.DiskUsage.Encode(e)
		}
	}
	{
		if s.Collaborators.Set {
			e.FieldStart("collaborators")
			s.Collaborators.Encode(e)
		}
	}
	{
		if s.BillingEmail.Set {
			e.FieldStart("billing_email")
			s.BillingEmail.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.DefaultRepositoryPermission.Set {
			e.FieldStart("default_repository_permission")
			s.DefaultRepositoryPermission.Encode(e)
		}
	}
	{
		if s.MembersCanCreateRepositories.Set {
			e.FieldStart("members_can_create_repositories")
			s.MembersCanCreateRepositories.Encode(e)
		}
	}
	{
		if s.TwoFactorRequirementEnabled.Set {
			e.FieldStart("two_factor_requirement_enabled")
			s.TwoFactorRequirementEnabled.Encode(e)
		}
	}
	{
		if s.MembersAllowedRepositoryCreationType.Set {
			e.FieldStart("members_allowed_repository_creation_type")
			s.MembersAllowedRepositoryCreationType.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicRepositories.Set {
			e.FieldStart("members_can_create_public_repositories")
			s.MembersCanCreatePublicRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivateRepositories.Set {
			e.FieldStart("members_can_create_private_repositories")
			s.MembersCanCreatePrivateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreateInternalRepositories.Set {
			e.FieldStart("members_can_create_internal_repositories")
			s.MembersCanCreateInternalRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePages.Set {
			e.FieldStart("members_can_create_pages")
			s.MembersCanCreatePages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicPages.Set {
			e.FieldStart("members_can_create_public_pages")
			s.MembersCanCreatePublicPages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivatePages.Set {
			e.FieldStart("members_can_create_private_pages")
			s.MembersCanCreatePrivatePages.Encode(e)
		}
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfOrganizationFull = [46]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
	12: "name",
	13: "company",
	14: "blog",
	15: "location",
	16: "email",
	17: "twitter_username",
	18: "is_verified",
	19: "has_organization_projects",
	20: "has_repository_projects",
	21: "public_repos",
	22: "public_gists",
	23: "followers",
	24: "following",
	25: "html_url",
	26: "created_at",
	27: "type",
	28: "total_private_repos",
	29: "owned_private_repos",
	30: "private_gists",
	31: "disk_usage",
	32: "collaborators",
	33: "billing_email",
	34: "plan",
	35: "default_repository_permission",
	36: "members_can_create_repositories",
	37: "two_factor_requirement_enabled",
	38: "members_allowed_repository_creation_type",
	39: "members_can_create_public_repositories",
	40: "members_can_create_private_repositories",
	41: "members_can_create_internal_repositories",
	42: "members_can_create_pages",
	43: "members_can_create_public_pages",
	44: "members_can_create_private_pages",
	45: "updated_at",
}

// Decode decodes OrganizationFull from json.
func (s *OrganizationFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationFull to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HooksURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PublicMembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AvatarURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "is_verified":
			if err := func() error {
				s.IsVerified.Reset()
				if err := s.IsVerified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_verified\"")
			}
		case "has_organization_projects":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasOrganizationProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_organization_projects\"")
			}
		case "has_repository_projects":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasRepositoryProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_repository_projects\"")
			}
		case "public_repos":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "html_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "type":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total_private_repos":
			if err := func() error {
				s.TotalPrivateRepos.Reset()
				if err := s.TotalPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			if err := func() error {
				s.OwnedPrivateRepos.Reset()
				if err := s.OwnedPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "private_gists":
			if err := func() error {
				s.PrivateGists.Reset()
				if err := s.PrivateGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "disk_usage":
			if err := func() error {
				s.DiskUsage.Reset()
				if err := s.DiskUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators.Reset()
				if err := s.Collaborators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "billing_email":
			if err := func() error {
				s.BillingEmail.Reset()
				if err := s.BillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_email\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "default_repository_permission":
			if err := func() error {
				s.DefaultRepositoryPermission.Reset()
				if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_repository_permission\"")
			}
		case "members_can_create_repositories":
			if err := func() error {
				s.MembersCanCreateRepositories.Reset()
				if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_repositories\"")
			}
		case "two_factor_requirement_enabled":
			if err := func() error {
				s.TwoFactorRequirementEnabled.Reset()
				if err := s.TwoFactorRequirementEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"two_factor_requirement_enabled\"")
			}
		case "members_allowed_repository_creation_type":
			if err := func() error {
				s.MembersAllowedRepositoryCreationType.Reset()
				if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_allowed_repository_creation_type\"")
			}
		case "members_can_create_public_repositories":
			if err := func() error {
				s.MembersCanCreatePublicRepositories.Reset()
				if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_repositories\"")
			}
		case "members_can_create_private_repositories":
			if err := func() error {
				s.MembersCanCreatePrivateRepositories.Reset()
				if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_repositories\"")
			}
		case "members_can_create_internal_repositories":
			if err := func() error {
				s.MembersCanCreateInternalRepositories.Reset()
				if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_internal_repositories\"")
			}
		case "members_can_create_pages":
			if err := func() error {
				s.MembersCanCreatePages.Reset()
				if err := s.MembersCanCreatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_pages\"")
			}
		case "members_can_create_public_pages":
			if err := func() error {
				s.MembersCanCreatePublicPages.Reset()
				if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_pages\"")
			}
		case "members_can_create_private_pages":
			if err := func() error {
				s.MembersCanCreatePrivatePages.Reset()
				if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_pages\"")
			}
		case "updated_at":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b00001111,
		0b11111000,
		0b00001111,
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationFull) {
					name = jsonFieldsNameOfOrganizationFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationFullPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationFullPlan) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("space")
		e.Int(s.Space)
	}
	{
		e.FieldStart("private_repos")
		e.Int(s.PrivateRepos)
	}
	{
		if s.FilledSeats.Set {
			e.FieldStart("filled_seats")
			s.FilledSeats.Encode(e)
		}
	}
	{
		if s.Seats.Set {
			e.FieldStart("seats")
			s.Seats.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrganizationFullPlan = [5]string{
	0: "name",
	1: "space",
	2: "private_repos",
	3: "filled_seats",
	4: "seats",
}

// Decode decodes OrganizationFullPlan from json.
func (s *OrganizationFullPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationFullPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		case "filled_seats":
			if err := func() error {
				s.FilledSeats.Reset()
				if err := s.FilledSeats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filled_seats\"")
			}
		case "seats":
			if err := func() error {
				s.Seats.Reset()
				if err := s.Seats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationFullPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationFullPlan) {
					name = jsonFieldsNameOfOrganizationFullPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationFullPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationFullPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationInvitation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationInvitation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		if s.FailedAt.Set {
			e.FieldStart("failed_at")
			s.FailedAt.Encode(e)
		}
	}
	{
		if s.FailedReason.Set {
			e.FieldStart("failed_reason")
			s.FailedReason.Encode(e)
		}
	}
	{
		e.FieldStart("inviter")
		s.Inviter.Encode(e)
	}
	{
		e.FieldStart("team_count")
		e.Int(s.TeamCount)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("invitation_teams_url")
		e.Str(s.InvitationTeamsURL)
	}
}

var jsonFieldsNameOfOrganizationInvitation = [11]string{
	0:  "id",
	1:  "login",
	2:  "email",
	3:  "role",
	4:  "created_at",
	5:  "failed_at",
	6:  "failed_reason",
	7:  "inviter",
	8:  "team_count",
	9:  "node_id",
	10: "invitation_teams_url",
}

// Decode decodes OrganizationInvitation from json.
func (s *OrganizationInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationInvitation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "failed_at":
			if err := func() error {
				s.FailedAt.Reset()
				if err := s.FailedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "failed_reason":
			if err := func() error {
				s.FailedReason.Reset()
				if err := s.FailedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_reason\"")
			}
		case "inviter":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Inviter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inviter\"")
			}
		case "team_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TeamCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_count\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "invitation_teams_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvitationTeamsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitation_teams_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationInvitation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationInvitation) {
					name = jsonFieldsNameOfOrganizationInvitation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationInvitation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationInvitation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationSecretScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationSecretScanningAlert) encodeFields(e *jx.Encoder) {
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			e.FieldStart("locations_url")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			e.FieldStart("resolution")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			e.FieldStart("resolved_at")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			e.FieldStart("resolved_by")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			e.FieldStart("secret_type")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrganizationSecretScanningAlert = [12]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "locations_url",
	5:  "state",
	6:  "resolution",
	7:  "resolved_at",
	8:  "resolved_by",
	9:  "secret_type",
	10: "secret",
	11: "repository",
}

// Decode decodes OrganizationSecretScanningAlert from json.
func (s *OrganizationSecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationSecretScanningAlert to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "locations_url":
			if err := func() error {
				s.LocationsURL.Reset()
				if err := s.LocationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locations_url\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		case "resolved_at":
			if err := func() error {
				s.ResolvedAt.Reset()
				if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_at\"")
			}
		case "resolved_by":
			if err := func() error {
				s.ResolvedBy.Reset()
				if err := s.ResolvedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_by\"")
			}
		case "secret_type":
			if err := func() error {
				s.SecretType.Reset()
				if err := s.SecretType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationSecretScanningAlert")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationSecretScanningAlert) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationSecretScanningAlert) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("hooks_url")
		e.Str(s.HooksURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("public_members_url")
		e.Str(s.PublicMembersURL)
	}
	{
		e.FieldStart("avatar_url")
		e.Str(s.AvatarURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
}

var jsonFieldsNameOfOrganizationSimple = [12]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
}

// Decode decodes OrganizationSimple from json.
func (s *OrganizationSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HooksURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PublicMembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AvatarURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationSimple) {
					name = jsonFieldsNameOfOrganizationSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfOrgsConvertMemberToOutsideCollaboratorAccepted = [0]string{}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorAccepted from json.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode OrgsConvertMemberToOutsideCollaboratorAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsCreateInvitationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsCreateInvitationReq) encodeFields(e *jx.Encoder) {
	{
		if s.InviteeID.Set {
			e.FieldStart("invitee_id")
			s.InviteeID.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.TeamIds != nil {
			e.FieldStart("team_ids")
			e.ArrStart()
			for _, elem := range s.TeamIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfOrgsCreateInvitationReq = [4]string{
	0: "invitee_id",
	1: "email",
	2: "role",
	3: "team_ids",
}

// Decode decodes OrgsCreateInvitationReq from json.
func (s *OrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateInvitationReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invitee_id":
			if err := func() error {
				s.InviteeID.Reset()
				if err := s.InviteeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitee_id\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "team_ids":
			if err := func() error {
				s.TeamIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.TeamIds = append(s.TeamIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateInvitationReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsCreateInvitationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsCreateInvitationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (s OrgsCreateInvitationReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (s *OrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateInvitationReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsCreateInvitationReqRole(v) {
	case OrgsCreateInvitationReqRoleAdmin:
		*s = OrgsCreateInvitationReqRoleAdmin
	case OrgsCreateInvitationReqRoleDirectMember:
		*s = OrgsCreateInvitationReqRoleDirectMember
	case OrgsCreateInvitationReqRoleBillingManager:
		*s = OrgsCreateInvitationReqRoleBillingManager
	default:
		*s = OrgsCreateInvitationReqRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgsCreateInvitationReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsCreateInvitationReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsCreateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsCreateWebhookReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsCreateWebhookReq = [4]string{
	0: "name",
	1: "config",
	2: "events",
	3: "active",
}

// Decode decodes OrgsCreateWebhookReq from json.
func (s *OrgsCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateWebhookReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateWebhookReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsCreateWebhookReq) {
					name = jsonFieldsNameOfOrgsCreateWebhookReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsCreateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsCreateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsCreateWebhookReqConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsCreateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "username",
	5: "password",
}

// Decode decodes OrgsCreateWebhookReqConfig from json.
func (s *OrgsCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsCreateWebhookReqConfig) {
					name = jsonFieldsNameOfOrgsCreateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsCreateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsCreateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserForbidden as json.
func (s *OrgsGetMembershipForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserForbidden from json.
func (s *OrgsGetMembershipForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsGetMembershipForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsGetMembershipForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserNotFound as json.
func (s *OrgsGetMembershipForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserNotFound from json.
func (s *OrgsGetMembershipForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsGetMembershipForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsGetMembershipForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsGetMembershipForUserForbidden as json.
func (s *OrgsGetMembershipForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserForbidden from json.
func (s *OrgsGetMembershipForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsGetMembershipForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsGetMembershipForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsGetMembershipForUserNotFound as json.
func (s *OrgsGetMembershipForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserNotFound from json.
func (s *OrgsGetMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsGetMembershipForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsGetMembershipForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListBlockedUsersOKApplicationJSON as json.
func (s OrgsListBlockedUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListBlockedUsersOKApplicationJSON from json.
func (s *OrgsListBlockedUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListBlockedUsersOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListBlockedUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgsListBlockedUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListBlockedUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListForAuthenticatedUserForbidden as json.
func (s *OrgsListForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserForbidden from json.
func (s *OrgsListForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsListForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListForAuthenticatedUserUnauthorized as json.
func (s *OrgsListForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserUnauthorized from json.
func (s *OrgsListForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsListForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserForbidden as json.
func (s *OrgsListMembershipsForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserForbidden from json.
func (s *OrgsListMembershipsForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembershipsForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsListMembershipsForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListMembershipsForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserUnauthorized as json.
func (s *OrgsListMembershipsForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserUnauthorized from json.
func (s *OrgsListMembershipsForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembershipsForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsListMembershipsForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListMembershipsForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsListWebhookDeliveriesOKApplicationJSON as json.
func (s OrgsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HookDeliveryItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhookDeliveriesOKApplicationJSON from json.
func (s *OrgsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = make([]HookDeliveryItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgsListWebhookDeliveriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsListWebhookDeliveriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsRemoveMembershipForUserForbidden as json.
func (s *OrgsRemoveMembershipForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserForbidden from json.
func (s *OrgsRemoveMembershipForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveMembershipForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsRemoveMembershipForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsRemoveMembershipForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsRemoveMembershipForUserNotFound as json.
func (s *OrgsRemoveMembershipForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserNotFound from json.
func (s *OrgsRemoveMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveMembershipForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsRemoveMembershipForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsRemoveMembershipForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsRemoveOutsideCollaboratorUnprocessableEntity = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes OrgsRemoveOutsideCollaboratorUnprocessableEntity from json.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveOutsideCollaboratorUnprocessableEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsRemoveOutsideCollaboratorUnprocessableEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsSetMembershipForUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsSetMembershipForUserReq) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsSetMembershipForUserReq = [1]string{
	0: "role",
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (s *OrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsSetMembershipForUserReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsSetMembershipForUserReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsSetMembershipForUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsSetMembershipForUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (s OrgsSetMembershipForUserReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (s *OrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsSetMembershipForUserReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsSetMembershipForUserReqRole(v) {
	case OrgsSetMembershipForUserReqRoleAdmin:
		*s = OrgsSetMembershipForUserReqRoleAdmin
	case OrgsSetMembershipForUserReqRoleMember:
		*s = OrgsSetMembershipForUserReqRoleMember
	default:
		*s = OrgsSetMembershipForUserReqRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgsSetMembershipForUserReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsSetMembershipForUserReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserForbidden as json.
func (s *OrgsUpdateMembershipForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserForbidden from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserNotFound as json.
func (s *OrgsUpdateMembershipForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserNotFound from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq = [1]string{
	0: "state",
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReq from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateMembershipForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq) {
					name = jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserReqState as json.
func (s OrgsUpdateMembershipForAuthenticatedUserReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReqState from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateMembershipForAuthenticatedUserReqState(v) {
	case OrgsUpdateMembershipForAuthenticatedUserReqStateActive:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqStateActive
	default:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrgsUpdateMembershipForAuthenticatedUserReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateMembershipForAuthenticatedUserReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsUpdateWebhookConfigForOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsUpdateWebhookConfigForOrgReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (s *OrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookConfigForOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookConfigForOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateWebhookConfigForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateWebhookConfigForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsUpdateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsUpdateWebhookReq) encodeFields(e *jx.Encoder) {
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsUpdateWebhookReq = [4]string{
	0: "config",
	1: "events",
	2: "active",
	3: "name",
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (s *OrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrgsUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrgsUpdateWebhookReqConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrgsUpdateWebhookReqConfig = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (s *OrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsUpdateWebhookReqConfig) {
					name = jsonFieldsNameOfOrgsUpdateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrgsUpdateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrgsUpdateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Package) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Package) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("package_type")
		s.PackageType.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		e.Str(s.HTMLURL)
	}
	{
		e.FieldStart("version_count")
		e.Int(s.VersionCount)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfPackage = [11]string{
	0:  "id",
	1:  "name",
	2:  "package_type",
	3:  "url",
	4:  "html_url",
	5:  "version_count",
	6:  "visibility",
	7:  "owner",
	8:  "repository",
	9:  "created_at",
	10: "updated_at",
}

// Decode decodes Package from json.
func (s *Package) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Package to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "package_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PackageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "version_count":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.VersionCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_count\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Package")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackage) {
					name = jsonFieldsNameOfPackage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Package) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Package) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagePackageType as json.
func (s PackagePackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagePackageType from json.
func (s *PackagePackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagePackageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagePackageType(v) {
	case PackagePackageTypeNpm:
		*s = PackagePackageTypeNpm
	case PackagePackageTypeMaven:
		*s = PackagePackageTypeMaven
	case PackagePackageTypeRubygems:
		*s = PackagePackageTypeRubygems
	case PackagePackageTypeDocker:
		*s = PackagePackageTypeDocker
	case PackagePackageTypeNuget:
		*s = PackagePackageTypeNuget
	case PackagePackageTypeContainer:
		*s = PackagePackageTypeContainer
	default:
		*s = PackagePackageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagePackageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagePackageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackageVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackageVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("package_html_url")
		e.Str(s.PackageHTMLURL)
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deleted_at")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfPackageVersion = [11]string{
	0:  "id",
	1:  "name",
	2:  "url",
	3:  "package_html_url",
	4:  "html_url",
	5:  "license",
	6:  "description",
	7:  "created_at",
	8:  "updated_at",
	9:  "deleted_at",
	10: "metadata",
}

// Decode decodes PackageVersion from json.
func (s *PackageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersion to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "package_html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PackageHTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_html_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "deleted_at":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_at\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersion) {
					name = jsonFieldsNameOfPackageVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackageVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackageVersionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackageVersionMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("package_type")
		s.PackageType.Encode(e)
	}
	{
		if s.Container.Set {
			e.FieldStart("container")
			s.Container.Encode(e)
		}
	}
	{
		if s.Docker.Set {
			e.FieldStart("docker")
			s.Docker.Encode(e)
		}
	}
}

var jsonFieldsNameOfPackageVersionMetadata = [3]string{
	0: "package_type",
	1: "container",
	2: "docker",
}

// Decode decodes PackageVersionMetadata from json.
func (s *PackageVersionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "package_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PackageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_type\"")
			}
		case "container":
			if err := func() error {
				s.Container.Reset()
				if err := s.Container.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "docker":
			if err := func() error {
				s.Docker.Reset()
				if err := s.Docker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"docker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersionMetadata) {
					name = jsonFieldsNameOfPackageVersionMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackageVersionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVersionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackageVersionMetadataContainer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackageVersionMetadataContainer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPackageVersionMetadataContainer = [1]string{
	0: "tags",
}

// Decode decodes PackageVersionMetadataContainer from json.
func (s *PackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataContainer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadataContainer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersionMetadataContainer) {
					name = jsonFieldsNameOfPackageVersionMetadataContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackageVersionMetadataContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVersionMetadataContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackageVersionMetadataDocker) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackageVersionMetadataDocker) encodeFields(e *jx.Encoder) {
	{
		if s.Tag != nil {
			e.FieldStart("tag")
			e.ArrStart()
			for _, elem := range s.Tag {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPackageVersionMetadataDocker = [1]string{
	0: "tag",
}

// Decode decodes PackageVersionMetadataDocker from json.
func (s *PackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataDocker to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			if err := func() error {
				s.Tag = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Tag = append(s.Tag, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadataDocker")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackageVersionMetadataDocker) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVersionMetadataDocker) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageVersionMetadataPackageType as json.
func (s PackageVersionMetadataPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackageVersionMetadataPackageType from json.
func (s *PackageVersionMetadataPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataPackageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVersionMetadataPackageType(v) {
	case PackageVersionMetadataPackageTypeNpm:
		*s = PackageVersionMetadataPackageTypeNpm
	case PackageVersionMetadataPackageTypeMaven:
		*s = PackageVersionMetadataPackageTypeMaven
	case PackageVersionMetadataPackageTypeRubygems:
		*s = PackageVersionMetadataPackageTypeRubygems
	case PackageVersionMetadataPackageTypeDocker:
		*s = PackageVersionMetadataPackageTypeDocker
	case PackageVersionMetadataPackageTypeNuget:
		*s = PackageVersionMetadataPackageTypeNuget
	case PackageVersionMetadataPackageTypeContainer:
		*s = PackageVersionMetadataPackageTypeContainer
	default:
		*s = PackageVersionMetadataPackageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackageVersionMetadataPackageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVersionMetadataPackageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackageVisibility as json.
func (s PackageVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackageVisibility from json.
func (s *PackageVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVisibility(v) {
	case PackageVisibilityPrivate:
		*s = PackageVisibilityPrivate
	case PackageVisibilityPublic:
		*s = PackageVisibilityPublic
	default:
		*s = PackageVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackageVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackageVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PackagesBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PackagesBillingUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_gigabytes_bandwidth_used")
		e.Int(s.TotalGigabytesBandwidthUsed)
	}
	{
		e.FieldStart("total_paid_gigabytes_bandwidth_used")
		e.Int(s.TotalPaidGigabytesBandwidthUsed)
	}
	{
		e.FieldStart("included_gigabytes_bandwidth")
		e.Int(s.IncludedGigabytesBandwidth)
	}
}

var jsonFieldsNameOfPackagesBillingUsage = [3]string{
	0: "total_gigabytes_bandwidth_used",
	1: "total_paid_gigabytes_bandwidth_used",
	2: "included_gigabytes_bandwidth",
}

// Decode decodes PackagesBillingUsage from json.
func (s *PackagesBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_gigabytes_bandwidth_used":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalGigabytesBandwidthUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_gigabytes_bandwidth_used\"")
			}
		case "total_paid_gigabytes_bandwidth_used":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPaidGigabytesBandwidthUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_paid_gigabytes_bandwidth_used\"")
			}
		case "included_gigabytes_bandwidth":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.IncludedGigabytesBandwidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"included_gigabytes_bandwidth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackagesBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackagesBillingUsage) {
					name = jsonFieldsNameOfPackagesBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesBillingUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesBillingUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserForbidden as json.
func (s *PackagesDeletePackageForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserForbidden from json.
func (s *PackagesDeletePackageForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserNotFound as json.
func (s *PackagesDeletePackageForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserNotFound from json.
func (s *PackagesDeletePackageForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserUnauthorized as json.
func (s *PackagesDeletePackageForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserUnauthorized from json.
func (s *PackagesDeletePackageForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForOrgForbidden as json.
func (s *PackagesDeletePackageForOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgForbidden from json.
func (s *PackagesDeletePackageForOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForOrgNotFound as json.
func (s *PackagesDeletePackageForOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgNotFound from json.
func (s *PackagesDeletePackageForOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForOrgUnauthorized as json.
func (s *PackagesDeletePackageForOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgUnauthorized from json.
func (s *PackagesDeletePackageForOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForUserForbidden as json.
func (s *PackagesDeletePackageForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserForbidden from json.
func (s *PackagesDeletePackageForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForUserNotFound as json.
func (s *PackagesDeletePackageForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserNotFound from json.
func (s *PackagesDeletePackageForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageForUserUnauthorized as json.
func (s *PackagesDeletePackageForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserUnauthorized from json.
func (s *PackagesDeletePackageForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserForbidden as json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserForbidden from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserNotFound as json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserNotFound from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserUnauthorized as json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserUnauthorized from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForOrgForbidden as json.
func (s *PackagesDeletePackageVersionForOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgForbidden from json.
func (s *PackagesDeletePackageVersionForOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForOrgNotFound as json.
func (s *PackagesDeletePackageVersionForOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgNotFound from json.
func (s *PackagesDeletePackageVersionForOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForOrgUnauthorized as json.
func (s *PackagesDeletePackageVersionForOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgUnauthorized from json.
func (s *PackagesDeletePackageVersionForOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForUserForbidden as json.
func (s *PackagesDeletePackageVersionForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserForbidden from json.
func (s *PackagesDeletePackageVersionForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForUserNotFound as json.
func (s *PackagesDeletePackageVersionForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserNotFound from json.
func (s *PackagesDeletePackageVersionForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesDeletePackageVersionForUserUnauthorized as json.
func (s *PackagesDeletePackageVersionForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserUnauthorized from json.
func (s *PackagesDeletePackageVersionForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesDeletePackageVersionForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesDeletePackageVersionForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = make([]PackageVersion, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = make([]PackageVersion, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = make([]PackageVersion, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized as json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForOrganizationForbidden as json.
func (s *PackagesListPackagesForOrganizationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationForbidden from json.
func (s *PackagesListPackagesForOrganizationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesListPackagesForOrganizationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForOrganizationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForOrganizationOKApplicationJSON as json.
func (s PackagesListPackagesForOrganizationOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Package(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForOrganizationOKApplicationJSON from json.
func (s *PackagesListPackagesForOrganizationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationOKApplicationJSON to nil")
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = make([]Package, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagesListPackagesForOrganizationOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForOrganizationOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForOrganizationUnauthorized as json.
func (s *PackagesListPackagesForOrganizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationUnauthorized from json.
func (s *PackagesListPackagesForOrganizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesListPackagesForOrganizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForOrganizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForUserForbidden as json.
func (s *PackagesListPackagesForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserForbidden from json.
func (s *PackagesListPackagesForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesListPackagesForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForUserOKApplicationJSON as json.
func (s PackagesListPackagesForUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Package(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForUserOKApplicationJSON from json.
func (s *PackagesListPackagesForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserOKApplicationJSON to nil")
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = make([]Package, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PackagesListPackagesForUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesListPackagesForUserUnauthorized as json.
func (s *PackagesListPackagesForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserUnauthorized from json.
func (s *PackagesListPackagesForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesListPackagesForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesListPackagesForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserForbidden as json.
func (s *PackagesRestorePackageForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserForbidden from json.
func (s *PackagesRestorePackageForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserNotFound as json.
func (s *PackagesRestorePackageForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserNotFound from json.
func (s *PackagesRestorePackageForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserUnauthorized as json.
func (s *PackagesRestorePackageForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserUnauthorized from json.
func (s *PackagesRestorePackageForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForOrgForbidden as json.
func (s *PackagesRestorePackageForOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgForbidden from json.
func (s *PackagesRestorePackageForOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForOrgNotFound as json.
func (s *PackagesRestorePackageForOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgNotFound from json.
func (s *PackagesRestorePackageForOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForOrgUnauthorized as json.
func (s *PackagesRestorePackageForOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgUnauthorized from json.
func (s *PackagesRestorePackageForOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForUserForbidden as json.
func (s *PackagesRestorePackageForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserForbidden from json.
func (s *PackagesRestorePackageForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForUserNotFound as json.
func (s *PackagesRestorePackageForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserNotFound from json.
func (s *PackagesRestorePackageForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageForUserUnauthorized as json.
func (s *PackagesRestorePackageForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserUnauthorized from json.
func (s *PackagesRestorePackageForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserForbidden as json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserForbidden from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserNotFound as json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserNotFound from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserUnauthorized as json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserUnauthorized from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForOrgForbidden as json.
func (s *PackagesRestorePackageVersionForOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgForbidden from json.
func (s *PackagesRestorePackageVersionForOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForOrgNotFound as json.
func (s *PackagesRestorePackageVersionForOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgNotFound from json.
func (s *PackagesRestorePackageVersionForOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForOrgUnauthorized as json.
func (s *PackagesRestorePackageVersionForOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgUnauthorized from json.
func (s *PackagesRestorePackageVersionForOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForUserForbidden as json.
func (s *PackagesRestorePackageVersionForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserForbidden from json.
func (s *PackagesRestorePackageVersionForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForUserNotFound as json.
func (s *PackagesRestorePackageVersionForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserNotFound from json.
func (s *PackagesRestorePackageVersionForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PackagesRestorePackageVersionForUserUnauthorized as json.
func (s *PackagesRestorePackageVersionForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserUnauthorized from json.
func (s *PackagesRestorePackageVersionForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PackagesRestorePackageVersionForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PackagesRestorePackageVersionForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Page) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Page) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("cname")
		s.Cname.Encode(e)
	}
	{
		if s.ProtectedDomainState.Set {
			e.FieldStart("protected_domain_state")
			s.ProtectedDomainState.Encode(e)
		}
	}
	{
		if s.PendingDomainUnverifiedAt.Set {
			e.FieldStart("pending_domain_unverified_at")
			s.PendingDomainUnverifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("custom_404")
		e.Bool(s.Custom404)
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
	{
		if s.HTTPSCertificate.Set {
			e.FieldStart("https_certificate")
			s.HTTPSCertificate.Encode(e)
		}
	}
	{
		if s.HTTPSEnforced.Set {
			e.FieldStart("https_enforced")
			s.HTTPSEnforced.Encode(e)
		}
	}
}

var jsonFieldsNameOfPage = [11]string{
	0:  "url",
	1:  "status",
	2:  "cname",
	3:  "protected_domain_state",
	4:  "pending_domain_unverified_at",
	5:  "custom_404",
	6:  "html_url",
	7:  "source",
	8:  "public",
	9:  "https_certificate",
	10: "https_enforced",
}

// Decode decodes Page from json.
func (s *Page) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Page to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "cname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Cname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cname\"")
			}
		case "protected_domain_state":
			if err := func() error {
				s.ProtectedDomainState.Reset()
				if err := s.ProtectedDomainState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected_domain_state\"")
			}
		case "pending_domain_unverified_at":
			if err := func() error {
				s.PendingDomainUnverifiedAt.Reset()
				if err := s.PendingDomainUnverifiedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_domain_unverified_at\"")
			}
		case "custom_404":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Custom404 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_404\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "https_certificate":
			if err := func() error {
				s.HTTPSCertificate.Reset()
				if err := s.HTTPSCertificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_certificate\"")
			}
		case "https_enforced":
			if err := func() error {
				s.HTTPSEnforced.Reset()
				if err := s.HTTPSEnforced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_enforced\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Page")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPage) {
					name = jsonFieldsNameOfPage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Page) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Page) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageBuild) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageBuild) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
	{
		e.FieldStart("pusher")
		s.Pusher.Encode(e)
	}
	{
		e.FieldStart("commit")
		e.Str(s.Commit)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfPageBuild = [8]string{
	0: "url",
	1: "status",
	2: "error",
	3: "pusher",
	4: "commit",
	5: "duration",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes PageBuild from json.
func (s *PageBuild) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuild to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "pusher":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Pusher.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pusher\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Commit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuild")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuild) {
					name = jsonFieldsNameOfPageBuild[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageBuild) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageBuild) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageBuildError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageBuildError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfPageBuildError = [1]string{
	0: "message",
}

// Decode decodes PageBuildError from json.
func (s *PageBuildError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuildError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuildError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuildError) {
					name = jsonFieldsNameOfPageBuildError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageBuildError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageBuildError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageBuildStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageBuildStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfPageBuildStatus = [2]string{
	0: "url",
	1: "status",
}

// Decode decodes PageBuildStatus from json.
func (s *PageBuildStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuildStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuildStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuildStatus) {
					name = jsonFieldsNameOfPageBuildStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageBuildStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageBuildStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageProtectedDomainState as json.
func (s PageProtectedDomainState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PageProtectedDomainState from json.
func (s *PageProtectedDomainState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageProtectedDomainState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageProtectedDomainState(v) {
	case PageProtectedDomainStatePending:
		*s = PageProtectedDomainStatePending
	case PageProtectedDomainStateVerified:
		*s = PageProtectedDomainStateVerified
	case PageProtectedDomainStateUnverified:
		*s = PageProtectedDomainStateUnverified
	default:
		*s = PageProtectedDomainState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PageProtectedDomainState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageProtectedDomainState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PageStatus as json.
func (s PageStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PageStatus from json.
func (s *PageStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageStatus(v) {
	case PageStatusBuilt:
		*s = PageStatusBuilt
	case PageStatusBuilding:
		*s = PageStatusBuilding
	case PageStatusErrored:
		*s = PageStatusErrored
	default:
		*s = PageStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PageStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PagesHTTPSCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PagesHTTPSCertificate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("domains")
		e.ArrStart()
		for _, elem := range s.Domains {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfPagesHTTPSCertificate = [4]string{
	0: "state",
	1: "description",
	2: "domains",
	3: "expires_at",
}

// Decode decodes PagesHTTPSCertificate from json.
func (s *PagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHTTPSCertificate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "domains":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Domains = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHTTPSCertificate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPagesHTTPSCertificate) {
					name = jsonFieldsNameOfPagesHTTPSCertificate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PagesHTTPSCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesHTTPSCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PagesHTTPSCertificateState as json.
func (s PagesHTTPSCertificateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PagesHTTPSCertificateState from json.
func (s *PagesHTTPSCertificateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHTTPSCertificateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PagesHTTPSCertificateState(v) {
	case PagesHTTPSCertificateStateNew:
		*s = PagesHTTPSCertificateStateNew
	case PagesHTTPSCertificateStateAuthorizationCreated:
		*s = PagesHTTPSCertificateStateAuthorizationCreated
	case PagesHTTPSCertificateStateAuthorizationPending:
		*s = PagesHTTPSCertificateStateAuthorizationPending
	case PagesHTTPSCertificateStateAuthorized:
		*s = PagesHTTPSCertificateStateAuthorized
	case PagesHTTPSCertificateStateAuthorizationRevoked:
		*s = PagesHTTPSCertificateStateAuthorizationRevoked
	case PagesHTTPSCertificateStateIssued:
		*s = PagesHTTPSCertificateStateIssued
	case PagesHTTPSCertificateStateUploaded:
		*s = PagesHTTPSCertificateStateUploaded
	case PagesHTTPSCertificateStateApproved:
		*s = PagesHTTPSCertificateStateApproved
	case PagesHTTPSCertificateStateErrored:
		*s = PagesHTTPSCertificateStateErrored
	case PagesHTTPSCertificateStateBadAuthz:
		*s = PagesHTTPSCertificateStateBadAuthz
	case PagesHTTPSCertificateStateDestroyPending:
		*s = PagesHTTPSCertificateStateDestroyPending
	case PagesHTTPSCertificateStateDNSChanged:
		*s = PagesHTTPSCertificateStateDNSChanged
	default:
		*s = PagesHTTPSCertificateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PagesHTTPSCertificateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesHTTPSCertificateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PagesHealthCheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PagesHealthCheck) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.AltDomain.Set {
			e.FieldStart("alt_domain")
			s.AltDomain.Encode(e)
		}
	}
}

var jsonFieldsNameOfPagesHealthCheck = [2]string{
	0: "domain",
	1: "alt_domain",
}

// Decode decodes PagesHealthCheck from json.
func (s *PagesHealthCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheck to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "alt_domain":
			if err := func() error {
				s.AltDomain.Reset()
				if err := s.AltDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alt_domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheck")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PagesHealthCheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesHealthCheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PagesHealthCheckAltDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PagesHealthCheckAltDomain) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			e.FieldStart("nameservers")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			e.FieldStart("dns_resolves")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			e.FieldStart("is_proxied")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			e.FieldStart("is_cloudflare_ip")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			e.FieldStart("is_fastly_ip")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			e.FieldStart("is_old_ip_address")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			e.FieldStart("is_a_record")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			e.FieldStart("has_cname_record")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			e.FieldStart("has_mx_records_present")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			e.FieldStart("is_valid_domain")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			e.FieldStart("is_apex_domain")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			e.FieldStart("should_be_a_record")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			e.FieldStart("is_cname_to_github_user_domain")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.FieldStart("is_cname_to_pages_dot_github_dot_com")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			e.FieldStart("is_cname_to_fastly")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			e.FieldStart("is_pointed_to_github_pages_ip")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			e.FieldStart("is_non_github_pages_ip_present")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			e.FieldStart("is_pages_domain")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			e.FieldStart("is_served_by_pages")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			e.FieldStart("is_valid")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			e.FieldStart("responds_to_https")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			e.FieldStart("enforces_https")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			e.FieldStart("https_error")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			e.FieldStart("is_https_eligible")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			e.FieldStart("caa_error")
			s.CaaError.Encode(e)
		}
	}
}

var jsonFieldsNameOfPagesHealthCheckAltDomain = [28]string{
	0:  "host",
	1:  "uri",
	2:  "nameservers",
	3:  "dns_resolves",
	4:  "is_proxied",
	5:  "is_cloudflare_ip",
	6:  "is_fastly_ip",
	7:  "is_old_ip_address",
	8:  "is_a_record",
	9:  "has_cname_record",
	10: "has_mx_records_present",
	11: "is_valid_domain",
	12: "is_apex_domain",
	13: "should_be_a_record",
	14: "is_cname_to_github_user_domain",
	15: "is_cname_to_pages_dot_github_dot_com",
	16: "is_cname_to_fastly",
	17: "is_pointed_to_github_pages_ip",
	18: "is_non_github_pages_ip_present",
	19: "is_pages_domain",
	20: "is_served_by_pages",
	21: "is_valid",
	22: "reason",
	23: "responds_to_https",
	24: "enforces_https",
	25: "https_error",
	26: "is_https_eligible",
	27: "caa_error",
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (s *PagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheckAltDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "nameservers":
			if err := func() error {
				s.Nameservers.Reset()
				if err := s.Nameservers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "dns_resolves":
			if err := func() error {
				s.DNSResolves.Reset()
				if err := s.DNSResolves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_resolves\"")
			}
		case "is_proxied":
			if err := func() error {
				s.IsProxied.Reset()
				if err := s.IsProxied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_proxied\"")
			}
		case "is_cloudflare_ip":
			if err := func() error {
				s.IsCloudflareIP.Reset()
				if err := s.IsCloudflareIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cloudflare_ip\"")
			}
		case "is_fastly_ip":
			if err := func() error {
				s.IsFastlyIP.Reset()
				if err := s.IsFastlyIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fastly_ip\"")
			}
		case "is_old_ip_address":
			if err := func() error {
				s.IsOldIPAddress.Reset()
				if err := s.IsOldIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_old_ip_address\"")
			}
		case "is_a_record":
			if err := func() error {
				s.IsARecord.Reset()
				if err := s.IsARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_a_record\"")
			}
		case "has_cname_record":
			if err := func() error {
				s.HasCnameRecord.Reset()
				if err := s.HasCnameRecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_cname_record\"")
			}
		case "has_mx_records_present":
			if err := func() error {
				s.HasMxRecordsPresent.Reset()
				if err := s.HasMxRecordsPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_mx_records_present\"")
			}
		case "is_valid_domain":
			if err := func() error {
				s.IsValidDomain.Reset()
				if err := s.IsValidDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid_domain\"")
			}
		case "is_apex_domain":
			if err := func() error {
				s.IsApexDomain.Reset()
				if err := s.IsApexDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_apex_domain\"")
			}
		case "should_be_a_record":
			if err := func() error {
				s.ShouldBeARecord.Reset()
				if err := s.ShouldBeARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_be_a_record\"")
			}
		case "is_cname_to_github_user_domain":
			if err := func() error {
				s.IsCnameToGithubUserDomain.Reset()
				if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_github_user_domain\"")
			}
		case "is_cname_to_pages_dot_github_dot_com":
			if err := func() error {
				s.IsCnameToPagesDotGithubDotCom.Reset()
				if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_pages_dot_github_dot_com\"")
			}
		case "is_cname_to_fastly":
			if err := func() error {
				s.IsCnameToFastly.Reset()
				if err := s.IsCnameToFastly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_fastly\"")
			}
		case "is_pointed_to_github_pages_ip":
			if err := func() error {
				s.IsPointedToGithubPagesIP.Reset()
				if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pointed_to_github_pages_ip\"")
			}
		case "is_non_github_pages_ip_present":
			if err := func() error {
				s.IsNonGithubPagesIPPresent.Reset()
				if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_non_github_pages_ip_present\"")
			}
		case "is_pages_domain":
			if err := func() error {
				s.IsPagesDomain.Reset()
				if err := s.IsPagesDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pages_domain\"")
			}
		case "is_served_by_pages":
			if err := func() error {
				s.IsServedByPages.Reset()
				if err := s.IsServedByPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_served_by_pages\"")
			}
		case "is_valid":
			if err := func() error {
				s.IsValid.Reset()
				if err := s.IsValid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "responds_to_https":
			if err := func() error {
				s.RespondsToHTTPS.Reset()
				if err := s.RespondsToHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responds_to_https\"")
			}
		case "enforces_https":
			if err := func() error {
				s.EnforcesHTTPS.Reset()
				if err := s.EnforcesHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforces_https\"")
			}
		case "https_error":
			if err := func() error {
				s.HTTPSError.Reset()
				if err := s.HTTPSError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_error\"")
			}
		case "is_https_eligible":
			if err := func() error {
				s.IsHTTPSEligible.Reset()
				if err := s.IsHTTPSEligible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_https_eligible\"")
			}
		case "caa_error":
			if err := func() error {
				s.CaaError.Reset()
				if err := s.CaaError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caa_error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheckAltDomain")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PagesHealthCheckAltDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesHealthCheckAltDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PagesHealthCheckDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PagesHealthCheckDomain) encodeFields(e *jx.Encoder) {
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			e.FieldStart("nameservers")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			e.FieldStart("dns_resolves")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			e.FieldStart("is_proxied")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			e.FieldStart("is_cloudflare_ip")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			e.FieldStart("is_fastly_ip")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			e.FieldStart("is_old_ip_address")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			e.FieldStart("is_a_record")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			e.FieldStart("has_cname_record")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			e.FieldStart("has_mx_records_present")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			e.FieldStart("is_valid_domain")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			e.FieldStart("is_apex_domain")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			e.FieldStart("should_be_a_record")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			e.FieldStart("is_cname_to_github_user_domain")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.FieldStart("is_cname_to_pages_dot_github_dot_com")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			e.FieldStart("is_cname_to_fastly")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			e.FieldStart("is_pointed_to_github_pages_ip")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			e.FieldStart("is_non_github_pages_ip_present")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			e.FieldStart("is_pages_domain")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			e.FieldStart("is_served_by_pages")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			e.FieldStart("is_valid")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			e.FieldStart("responds_to_https")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			e.FieldStart("enforces_https")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			e.FieldStart("https_error")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			e.FieldStart("is_https_eligible")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			e.FieldStart("caa_error")
			s.CaaError.Encode(e)
		}
	}
}

var jsonFieldsNameOfPagesHealthCheckDomain = [28]string{
	0:  "host",
	1:  "uri",
	2:  "nameservers",
	3:  "dns_resolves",
	4:  "is_proxied",
	5:  "is_cloudflare_ip",
	6:  "is_fastly_ip",
	7:  "is_old_ip_address",
	8:  "is_a_record",
	9:  "has_cname_record",
	10: "has_mx_records_present",
	11: "is_valid_domain",
	12: "is_apex_domain",
	13: "should_be_a_record",
	14: "is_cname_to_github_user_domain",
	15: "is_cname_to_pages_dot_github_dot_com",
	16: "is_cname_to_fastly",
	17: "is_pointed_to_github_pages_ip",
	18: "is_non_github_pages_ip_present",
	19: "is_pages_domain",
	20: "is_served_by_pages",
	21: "is_valid",
	22: "reason",
	23: "responds_to_https",
	24: "enforces_https",
	25: "https_error",
	26: "is_https_eligible",
	27: "caa_error",
}

// Decode decodes PagesHealthCheckDomain from json.
func (s *PagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheckDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "nameservers":
			if err := func() error {
				s.Nameservers.Reset()
				if err := s.Nameservers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "dns_resolves":
			if err := func() error {
				s.DNSResolves.Reset()
				if err := s.DNSResolves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_resolves\"")
			}
		case "is_proxied":
			if err := func() error {
				s.IsProxied.Reset()
				if err := s.IsProxied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_proxied\"")
			}
		case "is_cloudflare_ip":
			if err := func() error {
				s.IsCloudflareIP.Reset()
				if err := s.IsCloudflareIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cloudflare_ip\"")
			}
		case "is_fastly_ip":
			if err := func() error {
				s.IsFastlyIP.Reset()
				if err := s.IsFastlyIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fastly_ip\"")
			}
		case "is_old_ip_address":
			if err := func() error {
				s.IsOldIPAddress.Reset()
				if err := s.IsOldIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_old_ip_address\"")
			}
		case "is_a_record":
			if err := func() error {
				s.IsARecord.Reset()
				if err := s.IsARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_a_record\"")
			}
		case "has_cname_record":
			if err := func() error {
				s.HasCnameRecord.Reset()
				if err := s.HasCnameRecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_cname_record\"")
			}
		case "has_mx_records_present":
			if err := func() error {
				s.HasMxRecordsPresent.Reset()
				if err := s.HasMxRecordsPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_mx_records_present\"")
			}
		case "is_valid_domain":
			if err := func() error {
				s.IsValidDomain.Reset()
				if err := s.IsValidDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid_domain\"")
			}
		case "is_apex_domain":
			if err := func() error {
				s.IsApexDomain.Reset()
				if err := s.IsApexDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_apex_domain\"")
			}
		case "should_be_a_record":
			if err := func() error {
				s.ShouldBeARecord.Reset()
				if err := s.ShouldBeARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_be_a_record\"")
			}
		case "is_cname_to_github_user_domain":
			if err := func() error {
				s.IsCnameToGithubUserDomain.Reset()
				if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_github_user_domain\"")
			}
		case "is_cname_to_pages_dot_github_dot_com":
			if err := func() error {
				s.IsCnameToPagesDotGithubDotCom.Reset()
				if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_pages_dot_github_dot_com\"")
			}
		case "is_cname_to_fastly":
			if err := func() error {
				s.IsCnameToFastly.Reset()
				if err := s.IsCnameToFastly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_fastly\"")
			}
		case "is_pointed_to_github_pages_ip":
			if err := func() error {
				s.IsPointedToGithubPagesIP.Reset()
				if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pointed_to_github_pages_ip\"")
			}
		case "is_non_github_pages_ip_present":
			if err := func() error {
				s.IsNonGithubPagesIPPresent.Reset()
				if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_non_github_pages_ip_present\"")
			}
		case "is_pages_domain":
			if err := func() error {
				s.IsPagesDomain.Reset()
				if err := s.IsPagesDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pages_domain\"")
			}
		case "is_served_by_pages":
			if err := func() error {
				s.IsServedByPages.Reset()
				if err := s.IsServedByPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_served_by_pages\"")
			}
		case "is_valid":
			if err := func() error {
				s.IsValid.Reset()
				if err := s.IsValid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "responds_to_https":
			if err := func() error {
				s.RespondsToHTTPS.Reset()
				if err := s.RespondsToHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responds_to_https\"")
			}
		case "enforces_https":
			if err := func() error {
				s.EnforcesHTTPS.Reset()
				if err := s.EnforcesHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforces_https\"")
			}
		case "https_error":
			if err := func() error {
				s.HTTPSError.Reset()
				if err := s.HTTPSError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_error\"")
			}
		case "is_https_eligible":
			if err := func() error {
				s.IsHTTPSEligible.Reset()
				if err := s.IsHTTPSEligible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_https_eligible\"")
			}
		case "caa_error":
			if err := func() error {
				s.CaaError.Reset()
				if err := s.CaaError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caa_error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheckDomain")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PagesHealthCheckDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesHealthCheckDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PagesSourceHash) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PagesSourceHash) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("branch")
		e.Str(s.Branch)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfPagesSourceHash = [2]string{
	0: "branch",
	1: "path",
}

// Decode decodes PagesSourceHash from json.
func (s *PagesSourceHash) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesSourceHash to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesSourceHash")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPagesSourceHash) {
					name = jsonFieldsNameOfPagesSourceHash[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PagesSourceHash) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PagesSourceHash) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipationStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipationStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("all")
		e.ArrStart()
		for _, elem := range s.All {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("owner")
		e.ArrStart()
		for _, elem := range s.Owner {
			e.Int(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipationStats = [2]string{
	0: "all",
	1: "owner",
}

// Decode decodes ParticipationStats from json.
func (s *ParticipationStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipationStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "all":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.All = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.All = append(s.All, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"all\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Owner = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Owner = append(s.Owner, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipationStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipationStats) {
					name = jsonFieldsNameOfParticipationStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipationStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipationStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PorterAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PorterAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("remote_id")
		e.Str(s.RemoteID)
	}
	{
		e.FieldStart("remote_name")
		e.Str(s.RemoteName)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("import_url")
		json.EncodeURI(e, s.ImportURL)
	}
}

var jsonFieldsNameOfPorterAuthor = [7]string{
	0: "id",
	1: "remote_id",
	2: "remote_name",
	3: "email",
	4: "name",
	5: "url",
	6: "import_url",
}

// Decode decodes PorterAuthor from json.
func (s *PorterAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PorterAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "remote_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RemoteID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_id\"")
			}
		case "remote_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RemoteName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "import_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ImportURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PorterAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPorterAuthor) {
					name = jsonFieldsNameOfPorterAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PorterAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PorterAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PorterLargeFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PorterLargeFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref_name")
		e.Str(s.RefName)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("oid")
		e.Str(s.Oid)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
}

var jsonFieldsNameOfPorterLargeFile = [4]string{
	0: "ref_name",
	1: "path",
	2: "oid",
	3: "size",
}

// Decode decodes PorterLargeFile from json.
func (s *PorterLargeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PorterLargeFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RefName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref_name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "oid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Oid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oid\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PorterLargeFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPorterLargeFile) {
					name = jsonFieldsNameOfPorterLargeFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PorterLargeFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PorterLargeFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreviewHeaderMissing) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreviewHeaderMissing) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("documentation_url")
		e.Str(s.DocumentationURL)
	}
}

var jsonFieldsNameOfPreviewHeaderMissing = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PreviewHeaderMissing from json.
func (s *PreviewHeaderMissing) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreviewHeaderMissing to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreviewHeaderMissing")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreviewHeaderMissing) {
					name = jsonFieldsNameOfPreviewHeaderMissing[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreviewHeaderMissing) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreviewHeaderMissing) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrivateUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrivateUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	{
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hireable")
		s.Hireable.Encode(e)
	}
	{
		e.FieldStart("bio")
		s.Bio.Encode(e)
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.FieldStart("public_repos")
		e.Int(s.PublicRepos)
	}
	{
		e.FieldStart("public_gists")
		e.Int(s.PublicGists)
	}
	{
		e.FieldStart("followers")
		e.Int(s.Followers)
	}
	{
		e.FieldStart("following")
		e.Int(s.Following)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("private_gists")
		e.Int(s.PrivateGists)
	}
	{
		e.FieldStart("total_private_repos")
		e.Int(s.TotalPrivateRepos)
	}
	{
		e.FieldStart("owned_private_repos")
		e.Int(s.OwnedPrivateRepos)
	}
	{
		e.FieldStart("disk_usage")
		e.Int(s.DiskUsage)
	}
	{
		e.FieldStart("collaborators")
		e.Int(s.Collaborators)
	}
	{
		e.FieldStart("two_factor_authentication")
		e.Bool(s.TwoFactorAuthentication)
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.FieldStart("suspended_at")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BusinessPlus.Set {
			e.FieldStart("business_plus")
			s.BusinessPlus.Encode(e)
		}
	}
	{
		if s.LdapDn.Set {
			e.FieldStart("ldap_dn")
			s.LdapDn.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrivateUser = [42]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "name",
	19: "company",
	20: "blog",
	21: "location",
	22: "email",
	23: "hireable",
	24: "bio",
	25: "twitter_username",
	26: "public_repos",
	27: "public_gists",
	28: "followers",
	29: "following",
	30: "created_at",
	31: "updated_at",
	32: "private_gists",
	33: "total_private_repos",
	34: "owned_private_repos",
	35: "disk_usage",
	36: "collaborators",
	37: "two_factor_authentication",
	38: "plan",
	39: "suspended_at",
	40: "business_plus",
	41: "ldap_dn",
}

// Decode decodes PrivateUser from json.
func (s *PrivateUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateUser to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hireable":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "public_repos":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "private_gists":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.PrivateGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "total_private_repos":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OwnedPrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "disk_usage":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DiskUsage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "two_factor_authentication":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.TwoFactorAuthentication = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"two_factor_authentication\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		case "business_plus":
			if err := func() error {
				s.BusinessPlus.Reset()
				if err := s.BusinessPlus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_plus\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111101,
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrivateUser) {
					name = jsonFieldsNameOfPrivateUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrivateUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrivateUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrivateUserPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrivateUserPlan) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collaborators")
		e.Int(s.Collaborators)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("space")
		e.Int(s.Space)
	}
	{
		e.FieldStart("private_repos")
		e.Int(s.PrivateRepos)
	}
}

var jsonFieldsNameOfPrivateUserPlan = [4]string{
	0: "collaborators",
	1: "name",
	2: "space",
	3: "private_repos",
}

// Decode decodes PrivateUserPlan from json.
func (s *PrivateUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateUserPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateUserPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrivateUserPlan) {
					name = jsonFieldsNameOfPrivateUserPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrivateUserPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrivateUserPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Project) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Project) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("owner_url")
		json.EncodeURI(e, s.OwnerURL)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("columns_url")
		json.EncodeURI(e, s.ColumnsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.FieldStart("organization_permission")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
}

var jsonFieldsNameOfProject = [15]string{
	0:  "owner_url",
	1:  "url",
	2:  "html_url",
	3:  "columns_url",
	4:  "id",
	5:  "node_id",
	6:  "name",
	7:  "body",
	8:  "number",
	9:  "state",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "organization_permission",
	14: "private",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OwnerURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "columns_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ColumnsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProject) {
					name = jsonFieldsNameOfProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Project) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Project) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectCard) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectCard) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.ColumnName.Set {
			e.FieldStart("column_name")
			s.ColumnName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("column_url")
		json.EncodeURI(e, s.ColumnURL)
	}
	{
		if s.ContentURL.Set {
			e.FieldStart("content_url")
			s.ContentURL.Encode(e)
		}
	}
	{
		e.FieldStart("project_url")
		json.EncodeURI(e, s.ProjectURL)
	}
}

var jsonFieldsNameOfProjectCard = [13]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "note",
	4:  "creator",
	5:  "created_at",
	6:  "updated_at",
	7:  "archived",
	8:  "column_name",
	9:  "project_id",
	10: "column_url",
	11: "content_url",
	12: "project_url",
}

// Decode decodes ProjectCard from json.
func (s *ProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectCard to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "note":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "column_name":
			if err := func() error {
				s.ColumnName.Reset()
				if err := s.ColumnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "column_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ColumnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_url\"")
			}
		case "content_url":
			if err := func() error {
				s.ContentURL.Reset()
				if err := s.ContentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_url\"")
			}
		case "project_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectCard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectCard) {
					name = jsonFieldsNameOfProjectCard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectCard) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectCard) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectColumn) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectColumn) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("project_url")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.FieldStart("cards_url")
		json.EncodeURI(e, s.CardsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfProjectColumn = [8]string{
	0: "url",
	1: "project_url",
	2: "cards_url",
	3: "id",
	4: "node_id",
	5: "name",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes ProjectColumn from json.
func (s *ProjectColumn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectColumn to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "project_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		case "cards_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CardsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cards_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectColumn")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectColumn) {
					name = jsonFieldsNameOfProjectColumn[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectColumn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectColumn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectOrganizationPermission as json.
func (s ProjectOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectOrganizationPermission from json.
func (s *ProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectOrganizationPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectOrganizationPermission(v) {
	case ProjectOrganizationPermissionRead:
		*s = ProjectOrganizationPermissionRead
	case ProjectOrganizationPermissionWrite:
		*s = ProjectOrganizationPermissionWrite
	case ProjectOrganizationPermissionAdmin:
		*s = ProjectOrganizationPermissionAdmin
	case ProjectOrganizationPermissionNone:
		*s = ProjectOrganizationPermissionNone
	default:
		*s = ProjectOrganizationPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectOrganizationPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectOrganizationPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorForbidden as json.
func (s *ProjectsAddCollaboratorForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorForbidden from json.
func (s *ProjectsAddCollaboratorForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsAddCollaboratorForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsAddCollaboratorForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorNotFound as json.
func (s *ProjectsAddCollaboratorNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorNotFound from json.
func (s *ProjectsAddCollaboratorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsAddCollaboratorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsAddCollaboratorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsAddCollaboratorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsAddCollaboratorReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsAddCollaboratorReq = [1]string{
	0: "permission",
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (s *ProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsAddCollaboratorReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsAddCollaboratorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsAddCollaboratorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (s ProjectsAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (s *ProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsAddCollaboratorReqPermission(v) {
	case ProjectsAddCollaboratorReqPermissionRead:
		*s = ProjectsAddCollaboratorReqPermissionRead
	case ProjectsAddCollaboratorReqPermissionWrite:
		*s = ProjectsAddCollaboratorReqPermissionWrite
	case ProjectsAddCollaboratorReqPermissionAdmin:
		*s = ProjectsAddCollaboratorReqPermissionAdmin
	default:
		*s = ProjectsAddCollaboratorReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectsAddCollaboratorReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsAddCollaboratorReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsAddCollaboratorUnauthorized as json.
func (s *ProjectsAddCollaboratorUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorUnauthorized from json.
func (s *ProjectsAddCollaboratorUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsAddCollaboratorUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsAddCollaboratorUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateColumnForbidden as json.
func (s *ProjectsCreateColumnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnForbidden from json.
func (s *ProjectsCreateColumnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateColumnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateColumnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsCreateColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsCreateColumnReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfProjectsCreateColumnReq = [1]string{
	0: "name",
}

// Decode decodes ProjectsCreateColumnReq from json.
func (s *ProjectsCreateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateColumnReq) {
					name = jsonFieldsNameOfProjectsCreateColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateColumnReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateColumnReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateColumnUnauthorized as json.
func (s *ProjectsCreateColumnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnUnauthorized from json.
func (s *ProjectsCreateColumnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateColumnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateColumnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForAuthenticatedUserForbidden as json.
func (s *ProjectsCreateForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserForbidden from json.
func (s *ProjectsCreateForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsCreateForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsCreateForAuthenticatedUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForAuthenticatedUserReq from json.
func (s *ProjectsCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq) {
					name = jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForAuthenticatedUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForAuthenticatedUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForAuthenticatedUserUnauthorized as json.
func (s *ProjectsCreateForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserUnauthorized from json.
func (s *ProjectsCreateForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForOrgForbidden as json.
func (s *ProjectsCreateForOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgForbidden from json.
func (s *ProjectsCreateForOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForOrgGone as json.
func (s *ProjectsCreateForOrgGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgGone from json.
func (s *ProjectsCreateForOrgGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForOrgGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForOrgGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForOrgNotFound as json.
func (s *ProjectsCreateForOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgNotFound from json.
func (s *ProjectsCreateForOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsCreateForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsCreateForOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsCreateForOrgReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForOrgReq from json.
func (s *ProjectsCreateForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForOrgReq) {
					name = jsonFieldsNameOfProjectsCreateForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForOrgUnauthorized as json.
func (s *ProjectsCreateForOrgUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgUnauthorized from json.
func (s *ProjectsCreateForOrgUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForOrgUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForOrgUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForRepoForbidden as json.
func (s *ProjectsCreateForRepoForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoForbidden from json.
func (s *ProjectsCreateForRepoForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForRepoForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForRepoForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForRepoGone as json.
func (s *ProjectsCreateForRepoGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoGone from json.
func (s *ProjectsCreateForRepoGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForRepoGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForRepoGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForRepoNotFound as json.
func (s *ProjectsCreateForRepoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoNotFound from json.
func (s *ProjectsCreateForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForRepoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForRepoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsCreateForRepoReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsCreateForRepoReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsCreateForRepoReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForRepoReq from json.
func (s *ProjectsCreateForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForRepoReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForRepoReq) {
					name = jsonFieldsNameOfProjectsCreateForRepoReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForRepoReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForRepoReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsCreateForRepoUnauthorized as json.
func (s *ProjectsCreateForRepoUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoUnauthorized from json.
func (s *ProjectsCreateForRepoUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsCreateForRepoUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsCreateForRepoUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsDeleteCardForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsDeleteCardForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectsDeleteCardForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsDeleteCardForbidden from json.
func (s *ProjectsDeleteCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsDeleteCardForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteCardForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteCardForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteCardNotFound as json.
func (s *ProjectsDeleteCardNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardNotFound from json.
func (s *ProjectsDeleteCardNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteCardNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteCardNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteCardUnauthorized as json.
func (s *ProjectsDeleteCardUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardUnauthorized from json.
func (s *ProjectsDeleteCardUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteCardUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteCardUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteColumnForbidden as json.
func (s *ProjectsDeleteColumnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnForbidden from json.
func (s *ProjectsDeleteColumnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteColumnForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteColumnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteColumnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteColumnUnauthorized as json.
func (s *ProjectsDeleteColumnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnUnauthorized from json.
func (s *ProjectsDeleteColumnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteColumnUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteColumnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteColumnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsDeleteForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsDeleteForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectsDeleteForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsDeleteForbidden from json.
func (s *ProjectsDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsDeleteForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteGone as json.
func (s *ProjectsDeleteGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteGone from json.
func (s *ProjectsDeleteGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteNotFound as json.
func (s *ProjectsDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteNotFound from json.
func (s *ProjectsDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsDeleteUnauthorized as json.
func (s *ProjectsDeleteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteUnauthorized from json.
func (s *ProjectsDeleteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsDeleteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsDeleteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetCardForbidden as json.
func (s *ProjectsGetCardForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardForbidden from json.
func (s *ProjectsGetCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetCardForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetCardForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetCardNotFound as json.
func (s *ProjectsGetCardNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardNotFound from json.
func (s *ProjectsGetCardNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetCardNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetCardNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetCardUnauthorized as json.
func (s *ProjectsGetCardUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardUnauthorized from json.
func (s *ProjectsGetCardUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetCardUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetCardUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetColumnForbidden as json.
func (s *ProjectsGetColumnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnForbidden from json.
func (s *ProjectsGetColumnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetColumnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetColumnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetColumnNotFound as json.
func (s *ProjectsGetColumnNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnNotFound from json.
func (s *ProjectsGetColumnNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetColumnNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetColumnNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetColumnUnauthorized as json.
func (s *ProjectsGetColumnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnUnauthorized from json.
func (s *ProjectsGetColumnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetColumnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetColumnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetForbidden as json.
func (s *ProjectsGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetForbidden from json.
func (s *ProjectsGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetPermissionForUserForbidden as json.
func (s *ProjectsGetPermissionForUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserForbidden from json.
func (s *ProjectsGetPermissionForUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetPermissionForUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetPermissionForUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetPermissionForUserNotFound as json.
func (s *ProjectsGetPermissionForUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserNotFound from json.
func (s *ProjectsGetPermissionForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetPermissionForUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetPermissionForUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetPermissionForUserUnauthorized as json.
func (s *ProjectsGetPermissionForUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserUnauthorized from json.
func (s *ProjectsGetPermissionForUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetPermissionForUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetPermissionForUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsGetUnauthorized as json.
func (s *ProjectsGetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetUnauthorized from json.
func (s *ProjectsGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListCardsForbidden as json.
func (s *ProjectsListCardsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsForbidden from json.
func (s *ProjectsListCardsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCardsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListCardsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListCardsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListCardsUnauthorized as json.
func (s *ProjectsListCardsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsUnauthorized from json.
func (s *ProjectsListCardsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCardsUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListCardsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListCardsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListCollaboratorsForbidden as json.
func (s *ProjectsListCollaboratorsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsForbidden from json.
func (s *ProjectsListCollaboratorsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListCollaboratorsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListCollaboratorsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListCollaboratorsNotFound as json.
func (s *ProjectsListCollaboratorsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsNotFound from json.
func (s *ProjectsListCollaboratorsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListCollaboratorsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListCollaboratorsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListCollaboratorsUnauthorized as json.
func (s *ProjectsListCollaboratorsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsUnauthorized from json.
func (s *ProjectsListCollaboratorsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListCollaboratorsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListCollaboratorsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListColumnsForbidden as json.
func (s *ProjectsListColumnsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsForbidden from json.
func (s *ProjectsListColumnsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListColumnsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListColumnsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListColumnsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListColumnsUnauthorized as json.
func (s *ProjectsListColumnsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsUnauthorized from json.
func (s *ProjectsListColumnsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListColumnsUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListColumnsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListColumnsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListForRepoForbidden as json.
func (s *ProjectsListForRepoForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoForbidden from json.
func (s *ProjectsListForRepoForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListForRepoForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListForRepoForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListForRepoGone as json.
func (s *ProjectsListForRepoGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoGone from json.
func (s *ProjectsListForRepoGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListForRepoGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListForRepoGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListForRepoNotFound as json.
func (s *ProjectsListForRepoNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoNotFound from json.
func (s *ProjectsListForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListForRepoNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListForRepoNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsListForRepoUnauthorized as json.
func (s *ProjectsListForRepoUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoUnauthorized from json.
func (s *ProjectsListForRepoUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsListForRepoUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsListForRepoUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectsMoveCardCreated = [0]string{}

// Decode decodes ProjectsMoveCardCreated from json.
func (s *ProjectsMoveCardCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectsMoveCardForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsMoveCardForbidden from json.
func (s *ProjectsMoveCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ProjectsMoveCardForbiddenErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectsMoveCardForbiddenErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardForbiddenErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardForbiddenErrorsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsMoveCardForbiddenErrorsItem = [4]string{
	0: "code",
	1: "message",
	2: "resource",
	3: "field",
}

// Decode decodes ProjectsMoveCardForbiddenErrorsItem from json.
func (s *ProjectsMoveCardForbiddenErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardForbiddenErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardForbiddenErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardForbiddenErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardForbiddenErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Str(s.Position)
	}
	{
		if s.ColumnID.Set {
			e.FieldStart("column_id")
			s.ColumnID.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsMoveCardReq = [2]string{
	0: "position",
	1: "column_id",
}

// Decode decodes ProjectsMoveCardReq from json.
func (s *ProjectsMoveCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Position = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "column_id":
			if err := func() error {
				s.ColumnID.Reset()
				if err := s.ColumnID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsMoveCardReq) {
					name = jsonFieldsNameOfProjectsMoveCardReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectsMoveCardServiceUnavailable = [4]string{
	0: "code",
	1: "message",
	2: "documentation_url",
	3: "errors",
}

// Decode decodes ProjectsMoveCardServiceUnavailable from json.
func (s *ProjectsMoveCardServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardServiceUnavailable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ProjectsMoveCardServiceUnavailableErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectsMoveCardServiceUnavailableErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardServiceUnavailable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsMoveCardServiceUnavailableErrorsItem = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes ProjectsMoveCardServiceUnavailableErrorsItem from json.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardServiceUnavailableErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardServiceUnavailableErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveColumnCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveColumnCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectsMoveColumnCreated = [0]string{}

// Decode decodes ProjectsMoveColumnCreated from json.
func (s *ProjectsMoveColumnCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveColumnCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveColumnCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveColumnCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsMoveColumnForbidden as json.
func (s *ProjectsMoveColumnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnForbidden from json.
func (s *ProjectsMoveColumnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveColumnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveColumnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsMoveColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsMoveColumnReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Str(s.Position)
	}
}

var jsonFieldsNameOfProjectsMoveColumnReq = [1]string{
	0: "position",
}

// Decode decodes ProjectsMoveColumnReq from json.
func (s *ProjectsMoveColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Position = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsMoveColumnReq) {
					name = jsonFieldsNameOfProjectsMoveColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveColumnReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveColumnReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsMoveColumnUnauthorized as json.
func (s *ProjectsMoveColumnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnUnauthorized from json.
func (s *ProjectsMoveColumnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsMoveColumnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsMoveColumnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsRemoveCollaboratorForbidden as json.
func (s *ProjectsRemoveCollaboratorForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorForbidden from json.
func (s *ProjectsRemoveCollaboratorForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsRemoveCollaboratorForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsRemoveCollaboratorForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsRemoveCollaboratorNotFound as json.
func (s *ProjectsRemoveCollaboratorNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorNotFound from json.
func (s *ProjectsRemoveCollaboratorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsRemoveCollaboratorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsRemoveCollaboratorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsRemoveCollaboratorUnauthorized as json.
func (s *ProjectsRemoveCollaboratorUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorUnauthorized from json.
func (s *ProjectsRemoveCollaboratorUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsRemoveCollaboratorUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsRemoveCollaboratorUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateCardForbidden as json.
func (s *ProjectsUpdateCardForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardForbidden from json.
func (s *ProjectsUpdateCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateCardForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateCardForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateCardNotFound as json.
func (s *ProjectsUpdateCardNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardNotFound from json.
func (s *ProjectsUpdateCardNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateCardNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateCardNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsUpdateCardReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsUpdateCardReq) encodeFields(e *jx.Encoder) {
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsUpdateCardReq = [2]string{
	0: "note",
	1: "archived",
}

// Decode decodes ProjectsUpdateCardReq from json.
func (s *ProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateCardReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateCardReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateCardReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateCardUnauthorized as json.
func (s *ProjectsUpdateCardUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardUnauthorized from json.
func (s *ProjectsUpdateCardUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateCardUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateCardUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateColumnForbidden as json.
func (s *ProjectsUpdateColumnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnForbidden from json.
func (s *ProjectsUpdateColumnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateColumnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateColumnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsUpdateColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsUpdateColumnReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfProjectsUpdateColumnReq = [1]string{
	0: "name",
}

// Decode decodes ProjectsUpdateColumnReq from json.
func (s *ProjectsUpdateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsUpdateColumnReq) {
					name = jsonFieldsNameOfProjectsUpdateColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateColumnReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateColumnReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateColumnUnauthorized as json.
func (s *ProjectsUpdateColumnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnUnauthorized from json.
func (s *ProjectsUpdateColumnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateColumnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateColumnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsUpdateForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsUpdateForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectsUpdateForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsUpdateForbidden from json.
func (s *ProjectsUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateGone as json.
func (s *ProjectsUpdateGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateGone from json.
func (s *ProjectsUpdateGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectsUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectsUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.OrganizationPermission.Set {
			e.FieldStart("organization_permission")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectsUpdateReq = [5]string{
	0: "name",
	1: "body",
	2: "state",
	3: "organization_permission",
	4: "private",
}

// Decode decodes ProjectsUpdateReq from json.
func (s *ProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (s ProjectsUpdateReqOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (s *ProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateReqOrganizationPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsUpdateReqOrganizationPermission(v) {
	case ProjectsUpdateReqOrganizationPermissionRead:
		*s = ProjectsUpdateReqOrganizationPermissionRead
	case ProjectsUpdateReqOrganizationPermissionWrite:
		*s = ProjectsUpdateReqOrganizationPermissionWrite
	case ProjectsUpdateReqOrganizationPermissionAdmin:
		*s = ProjectsUpdateReqOrganizationPermissionAdmin
	case ProjectsUpdateReqOrganizationPermissionNone:
		*s = ProjectsUpdateReqOrganizationPermissionNone
	default:
		*s = ProjectsUpdateReqOrganizationPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectsUpdateReqOrganizationPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateReqOrganizationPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectsUpdateUnauthorized as json.
func (s *ProjectsUpdateUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateUnauthorized from json.
func (s *ProjectsUpdateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectsUpdateUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectsUpdateUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.RequiredStatusChecks.Set {
			e.FieldStart("required_status_checks")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			e.FieldStart("required_pull_request_reviews")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			e.FieldStart("required_signatures")
			s.RequiredSignatures.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			e.FieldStart("enforce_admins")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			e.FieldStart("required_linear_history")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.FieldStart("allow_force_pushes")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.FieldStart("allow_deletions")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			e.FieldStart("restrictions")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.FieldStart("required_conversation_resolution")
			s.RequiredConversationResolution.Encode(e)
		}
	}
}

var jsonFieldsNameOfProtectedBranch = [10]string{
	0: "url",
	1: "required_status_checks",
	2: "required_pull_request_reviews",
	3: "required_signatures",
	4: "enforce_admins",
	5: "required_linear_history",
	6: "allow_force_pushes",
	7: "allow_deletions",
	8: "restrictions",
	9: "required_conversation_resolution",
}

// Decode decodes ProtectedBranch from json.
func (s *ProtectedBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranch to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "required_status_checks":
			if err := func() error {
				s.RequiredStatusChecks.Reset()
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "required_pull_request_reviews":
			if err := func() error {
				s.RequiredPullRequestReviews.Reset()
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "required_signatures":
			if err := func() error {
				s.RequiredSignatures.Reset()
				if err := s.RequiredSignatures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_signatures\"")
			}
		case "enforce_admins":
			if err := func() error {
				s.EnforceAdmins.Reset()
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "restrictions":
			if err := func() error {
				s.Restrictions.Reset()
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranch) {
					name = jsonFieldsNameOfProtectedBranch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchAdminEnforced) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchAdminEnforced) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchAdminEnforced = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (s *ProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAdminEnforced to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAdminEnforced")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAdminEnforced) {
					name = jsonFieldsNameOfProtectedBranchAdminEnforced[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchAdminEnforced) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchAdminEnforced) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchAllowDeletions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchAllowDeletions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchAllowDeletions = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (s *ProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAllowDeletions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAllowDeletions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAllowDeletions) {
					name = jsonFieldsNameOfProtectedBranchAllowDeletions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchAllowDeletions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchAllowDeletions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchAllowForcePushes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchAllowForcePushes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchAllowForcePushes = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (s *ProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAllowForcePushes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAllowForcePushes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAllowForcePushes) {
					name = jsonFieldsNameOfProtectedBranchAllowForcePushes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchAllowForcePushes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchAllowForcePushes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchEnforceAdmins) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchEnforceAdmins) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchEnforceAdmins = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (s *ProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchEnforceAdmins to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchEnforceAdmins")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchEnforceAdmins) {
					name = jsonFieldsNameOfProtectedBranchEnforceAdmins[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchEnforceAdmins) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchEnforceAdmins) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchPullRequestReview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchPullRequestReview) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			e.FieldStart("dismissal_restrictions")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		e.FieldStart("dismiss_stale_reviews")
		e.Bool(s.DismissStaleReviews)
	}
	{
		e.FieldStart("require_code_owner_reviews")
		e.Bool(s.RequireCodeOwnerReviews)
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.FieldStart("required_approving_review_count")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfProtectedBranchPullRequestReview = [5]string{
	0: "url",
	1: "dismissal_restrictions",
	2: "dismiss_stale_reviews",
	3: "require_code_owner_reviews",
	4: "required_approving_review_count",
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (s *ProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchPullRequestReview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.DismissStaleReviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.RequireCodeOwnerReviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchPullRequestReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchPullRequestReview) {
					name = jsonFieldsNameOfProtectedBranchPullRequestReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchPullRequestReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchPullRequestReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.UsersURL.Set {
			e.FieldStart("users_url")
			s.UsersURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			e.FieldStart("teams_url")
			s.TeamsURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfProtectedBranchPullRequestReviewDismissalRestrictions = [5]string{
	0: "users",
	1: "teams",
	2: "url",
	3: "users_url",
	4: "teams_url",
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchPullRequestReviewDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]SimpleUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = make([]Team, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			if err := func() error {
				s.UsersURL.Reset()
				if err := s.UsersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchPullRequestReviewDismissalRestrictions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchRequiredConversationResolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchRequiredConversationResolution) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfProtectedBranchRequiredConversationResolution = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (s *ProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredConversationResolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredConversationResolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchRequiredConversationResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchRequiredConversationResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchRequiredLinearHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchRequiredLinearHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchRequiredLinearHistory = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (s *ProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredLinearHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredLinearHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredLinearHistory) {
					name = jsonFieldsNameOfProtectedBranchRequiredLinearHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchRequiredLinearHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchRequiredLinearHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchRequiredPullRequestReviews) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.DismissStaleReviews.Set {
			e.FieldStart("dismiss_stale_reviews")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			e.FieldStart("require_code_owner_reviews")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.FieldStart("required_approving_review_count")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			e.FieldStart("dismissal_restrictions")
			s.DismissalRestrictions.Encode(e)
		}
	}
}

var jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews = [5]string{
	0: "url",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
	4: "dismissal_restrictions",
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (s *ProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredPullRequestReviews to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredPullRequestReviews")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews) {
					name = jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchRequiredPullRequestReviews) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchRequiredPullRequestReviews) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("users_url")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions = [5]string{
	0: "url",
	1: "users_url",
	2: "teams_url",
	3: "users",
	4: "teams",
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.UsersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Users = make([]SimpleUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Teams = make([]Team, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) {
					name = jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtectedBranchRequiredSignatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtectedBranchRequiredSignatures) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfProtectedBranchRequiredSignatures = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (s *ProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredSignatures to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredSignatures")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredSignatures) {
					name = jsonFieldsNameOfProtectedBranchRequiredSignatures[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtectedBranchRequiredSignatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtectedBranchRequiredSignatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	{
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hireable")
		s.Hireable.Encode(e)
	}
	{
		e.FieldStart("bio")
		s.Bio.Encode(e)
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.FieldStart("public_repos")
		e.Int(s.PublicRepos)
	}
	{
		e.FieldStart("public_gists")
		e.Int(s.PublicGists)
	}
	{
		e.FieldStart("followers")
		e.Int(s.Followers)
	}
	{
		e.FieldStart("following")
		e.Int(s.Following)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.FieldStart("suspended_at")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PrivateGists.Set {
			e.FieldStart("private_gists")
			s.PrivateGists.Encode(e)
		}
	}
	{
		if s.TotalPrivateRepos.Set {
			e.FieldStart("total_private_repos")
			s.TotalPrivateRepos.Encode(e)
		}
	}
	{
		if s.OwnedPrivateRepos.Set {
			e.FieldStart("owned_private_repos")
			s.OwnedPrivateRepos.Encode(e)
		}
	}
	{
		if s.DiskUsage.Set {
			e.FieldStart("disk_usage")
			s.DiskUsage.Encode(e)
		}
	}
	{
		if s.Collaborators.Set {
			e.FieldStart("collaborators")
			s.Collaborators.Encode(e)
		}
	}
}

var jsonFieldsNameOfPublicUser = [39]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "name",
	19: "company",
	20: "blog",
	21: "location",
	22: "email",
	23: "hireable",
	24: "bio",
	25: "twitter_username",
	26: "public_repos",
	27: "public_gists",
	28: "followers",
	29: "following",
	30: "created_at",
	31: "updated_at",
	32: "plan",
	33: "suspended_at",
	34: "private_gists",
	35: "total_private_repos",
	36: "owned_private_repos",
	37: "disk_usage",
	38: "collaborators",
}

// Decode decodes PublicUser from json.
func (s *PublicUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicUser to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hireable":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "public_repos":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		case "private_gists":
			if err := func() error {
				s.PrivateGists.Reset()
				if err := s.PrivateGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "total_private_repos":
			if err := func() error {
				s.TotalPrivateRepos.Reset()
				if err := s.TotalPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			if err := func() error {
				s.OwnedPrivateRepos.Reset()
				if err := s.OwnedPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "disk_usage":
			if err := func() error {
				s.DiskUsage.Reset()
				if err := s.DiskUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators.Reset()
				if err := s.Collaborators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicUser) {
					name = jsonFieldsNameOfPublicUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicUserPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicUserPlan) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("collaborators")
		e.Int(s.Collaborators)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("space")
		e.Int(s.Space)
	}
	{
		e.FieldStart("private_repos")
		e.Int(s.PrivateRepos)
	}
}

var jsonFieldsNameOfPublicUserPlan = [4]string{
	0: "collaborators",
	1: "name",
	2: "space",
	3: "private_repos",
}

// Decode decodes PublicUserPlan from json.
func (s *PublicUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicUserPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicUserPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicUserPlan) {
					name = jsonFieldsNameOfPublicUserPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicUserPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicUserPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("diff_url")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.FieldStart("patch_url")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.FieldStart("issue_url")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.FieldStart("commits_url")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.FieldStart("review_comments_url")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.FieldStart("review_comment_url")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("statuses_url")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("locked")
		e.Bool(s.Locked)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.FieldStart("active_lock_reason")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("merged_at")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("merge_commit_sha")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.FieldStart("assignees")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.FieldStart("requested_reviewers")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.FieldStart("requested_teams")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.FieldStart("head")
		s.Head.Encode(e)
	}
	{
		e.FieldStart("base")
		s.Base.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.FieldStart("auto_merge")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
	{
		e.FieldStart("merged")
		e.Bool(s.Merged)
	}
	{
		e.FieldStart("mergeable")
		s.Mergeable.Encode(e)
	}
	{
		if s.Rebaseable.Set {
			e.FieldStart("rebaseable")
			s.Rebaseable.Encode(e)
		}
	}
	{
		e.FieldStart("mergeable_state")
		e.Str(s.MergeableState)
	}
	{
		e.FieldStart("merged_by")
		s.MergedBy.Encode(e)
	}
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		e.FieldStart("review_comments")
		e.Int(s.ReviewComments)
	}
	{
		e.FieldStart("maintainer_can_modify")
		e.Bool(s.MaintainerCanModify)
	}
	{
		e.FieldStart("commits")
		e.Int(s.Commits)
	}
	{
		e.FieldStart("additions")
		e.Int(s.Additions)
	}
	{
		e.FieldStart("deletions")
		e.Int(s.Deletions)
	}
	{
		e.FieldStart("changed_files")
		e.Int(s.ChangedFiles)
	}
}

var jsonFieldsNameOfPullRequest = [48]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "html_url",
	4:  "diff_url",
	5:  "patch_url",
	6:  "issue_url",
	7:  "commits_url",
	8:  "review_comments_url",
	9:  "review_comment_url",
	10: "comments_url",
	11: "statuses_url",
	12: "number",
	13: "state",
	14: "locked",
	15: "title",
	16: "user",
	17: "body",
	18: "labels",
	19: "milestone",
	20: "active_lock_reason",
	21: "created_at",
	22: "updated_at",
	23: "closed_at",
	24: "merged_at",
	25: "merge_commit_sha",
	26: "assignee",
	27: "assignees",
	28: "requested_reviewers",
	29: "requested_teams",
	30: "head",
	31: "base",
	32: "_links",
	33: "author_association",
	34: "auto_merge",
	35: "draft",
	36: "merged",
	37: "mergeable",
	38: "rebaseable",
	39: "mergeable_state",
	40: "merged_by",
	41: "comments",
	42: "review_comments",
	43: "maintainer_can_modify",
	44: "commits",
	45: "additions",
	46: "deletions",
	47: "changed_files",
}

// Decode decodes PullRequest from json.
func (s *PullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequest to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "issue_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "review_comments_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReviewCommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments_url\"")
			}
		case "review_comment_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReviewCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "user":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "labels":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Labels = make([]PullRequestLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "merged_at":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "merge_commit_sha":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.MergeCommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_commit_sha\"")
			}
		case "assignee":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "requested_reviewers":
			if err := func() error {
				s.RequestedReviewers.Reset()
				if err := s.RequestedReviewers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewers\"")
			}
		case "requested_teams":
			if err := func() error {
				s.RequestedTeams.Reset()
				if err := s.RequestedTeams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_teams\"")
			}
		case "head":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "_links":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "author_association":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "auto_merge":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "merged":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Merged = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged\"")
			}
		case "mergeable":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				if err := s.Mergeable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mergeable\"")
			}
		case "rebaseable":
			if err := func() error {
				s.Rebaseable.Reset()
				if err := s.Rebaseable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebaseable\"")
			}
		case "mergeable_state":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MergeableState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mergeable_state\"")
			}
		case "merged_by":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				if err := s.MergedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_by\"")
			}
		case "comments":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "review_comments":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ReviewComments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "maintainer_can_modify":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.MaintainerCanModify = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		case "commits":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Commits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "additions":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Additions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Deletions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changed_files":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ChangedFiles = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changed_files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11000111,
		0b10110111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequest) {
					name = jsonFieldsNameOfPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestBase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestBase) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestBase = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestBase from json.
func (s *PullRequestBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBase) {
					name = jsonFieldsNameOfPullRequestBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestBase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestBase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestBaseRepo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestBaseRepo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		e.FieldStart("pushed_at")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestBaseRepo = [81]string{
	0:  "archive_url",
	1:  "assignees_url",
	2:  "blobs_url",
	3:  "branches_url",
	4:  "collaborators_url",
	5:  "comments_url",
	6:  "commits_url",
	7:  "compare_url",
	8:  "contents_url",
	9:  "contributors_url",
	10: "deployments_url",
	11: "description",
	12: "downloads_url",
	13: "events_url",
	14: "fork",
	15: "forks_url",
	16: "full_name",
	17: "git_commits_url",
	18: "git_refs_url",
	19: "git_tags_url",
	20: "hooks_url",
	21: "html_url",
	22: "id",
	23: "node_id",
	24: "issue_comment_url",
	25: "issue_events_url",
	26: "issues_url",
	27: "keys_url",
	28: "labels_url",
	29: "languages_url",
	30: "merges_url",
	31: "milestones_url",
	32: "name",
	33: "notifications_url",
	34: "owner",
	35: "private",
	36: "pulls_url",
	37: "releases_url",
	38: "stargazers_url",
	39: "statuses_url",
	40: "subscribers_url",
	41: "subscription_url",
	42: "tags_url",
	43: "teams_url",
	44: "trees_url",
	45: "url",
	46: "clone_url",
	47: "default_branch",
	48: "forks",
	49: "forks_count",
	50: "git_url",
	51: "has_downloads",
	52: "has_issues",
	53: "has_projects",
	54: "has_wiki",
	55: "has_pages",
	56: "homepage",
	57: "language",
	58: "master_branch",
	59: "archived",
	60: "disabled",
	61: "mirror_url",
	62: "open_issues",
	63: "open_issues_count",
	64: "permissions",
	65: "temp_clone_token",
	66: "allow_merge_commit",
	67: "allow_squash_merge",
	68: "allow_rebase_merge",
	69: "license",
	70: "pushed_at",
	71: "size",
	72: "ssh_url",
	73: "stargazers_count",
	74: "svn_url",
	75: "topics",
	76: "watchers",
	77: "watchers_count",
	78: "created_at",
	79: "updated_at",
	80: "allow_forking",
}

// Decode decodes PullRequestBaseRepo from json.
func (s *PullRequestBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepo to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "downloads_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "forks_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "full_name":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "git_commits_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "hooks_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "name":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "owner":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "default_branch":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "forks":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "git_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "has_downloads":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "has_issues":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "homepage":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "archived":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "mirror_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "open_issues":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "license":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "size":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "ssh_url":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_count":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "svn_url":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "watchers":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "watchers_count":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b11100000,
		0b11110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepo) {
					name = jsonFieldsNameOfPullRequestBaseRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestBaseRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestBaseRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestBaseRepoOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestBaseRepoOwner) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfPullRequestBaseRepoOwner = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestBaseRepoOwner from json.
func (s *PullRequestBaseRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepoOwner to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepoOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepoOwner) {
					name = jsonFieldsNameOfPullRequestBaseRepoOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestBaseRepoOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestBaseRepoOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestBaseRepoPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestBaseRepoPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
}

var jsonFieldsNameOfPullRequestBaseRepoPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (s *PullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepoPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepoPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepoPermissions) {
					name = jsonFieldsNameOfPullRequestBaseRepoPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestBaseRepoPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestBaseRepoPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestBaseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestBaseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfPullRequestBaseUser = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestBaseUser from json.
func (s *PullRequestBaseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseUser) {
					name = jsonFieldsNameOfPullRequestBaseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestBaseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestBaseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestHead = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestHead from json.
func (s *PullRequestHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHead) {
					name = jsonFieldsNameOfPullRequestHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHeadRepo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHeadRepo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		e.FieldStart("pushed_at")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestHeadRepo = [81]string{
	0:  "archive_url",
	1:  "assignees_url",
	2:  "blobs_url",
	3:  "branches_url",
	4:  "collaborators_url",
	5:  "comments_url",
	6:  "commits_url",
	7:  "compare_url",
	8:  "contents_url",
	9:  "contributors_url",
	10: "deployments_url",
	11: "description",
	12: "downloads_url",
	13: "events_url",
	14: "fork",
	15: "forks_url",
	16: "full_name",
	17: "git_commits_url",
	18: "git_refs_url",
	19: "git_tags_url",
	20: "hooks_url",
	21: "html_url",
	22: "id",
	23: "node_id",
	24: "issue_comment_url",
	25: "issue_events_url",
	26: "issues_url",
	27: "keys_url",
	28: "labels_url",
	29: "languages_url",
	30: "merges_url",
	31: "milestones_url",
	32: "name",
	33: "notifications_url",
	34: "owner",
	35: "private",
	36: "pulls_url",
	37: "releases_url",
	38: "stargazers_url",
	39: "statuses_url",
	40: "subscribers_url",
	41: "subscription_url",
	42: "tags_url",
	43: "teams_url",
	44: "trees_url",
	45: "url",
	46: "clone_url",
	47: "default_branch",
	48: "forks",
	49: "forks_count",
	50: "git_url",
	51: "has_downloads",
	52: "has_issues",
	53: "has_projects",
	54: "has_wiki",
	55: "has_pages",
	56: "homepage",
	57: "language",
	58: "master_branch",
	59: "archived",
	60: "disabled",
	61: "mirror_url",
	62: "open_issues",
	63: "open_issues_count",
	64: "permissions",
	65: "temp_clone_token",
	66: "allow_merge_commit",
	67: "allow_squash_merge",
	68: "allow_rebase_merge",
	69: "license",
	70: "pushed_at",
	71: "size",
	72: "ssh_url",
	73: "stargazers_count",
	74: "svn_url",
	75: "topics",
	76: "watchers",
	77: "watchers_count",
	78: "created_at",
	79: "updated_at",
	80: "allow_forking",
}

// Decode decodes PullRequestHeadRepo from json.
func (s *PullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepo to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "downloads_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "forks_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "full_name":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "git_commits_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "hooks_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "name":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "owner":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "default_branch":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "forks":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "git_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "has_downloads":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "has_issues":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "homepage":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "archived":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "mirror_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "open_issues":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "license":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "size":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "ssh_url":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_count":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "svn_url":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "watchers":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "watchers_count":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b11100000,
		0b11110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepo) {
					name = jsonFieldsNameOfPullRequestHeadRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHeadRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHeadRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHeadRepoLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHeadRepoLicense) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
}

var jsonFieldsNameOfPullRequestHeadRepoLicense = [5]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (s *PullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoLicense to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoLicense")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoLicense) {
					name = jsonFieldsNameOfPullRequestHeadRepoLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHeadRepoLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHeadRepoLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHeadRepoOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHeadRepoOwner) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfPullRequestHeadRepoOwner = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestHeadRepoOwner from json.
func (s *PullRequestHeadRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoOwner to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoOwner) {
					name = jsonFieldsNameOfPullRequestHeadRepoOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHeadRepoOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHeadRepoOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHeadRepoPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHeadRepoPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
}

var jsonFieldsNameOfPullRequestHeadRepoPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (s *PullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoPermissions) {
					name = jsonFieldsNameOfPullRequestHeadRepoPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHeadRepoPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHeadRepoPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestHeadUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestHeadUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfPullRequestHeadUser = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestHeadUser from json.
func (s *PullRequestHeadUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadUser) {
					name = jsonFieldsNameOfPullRequestHeadUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestHeadUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestHeadUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestLabelsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes PullRequestLabelsItem from json.
func (s *PullRequestLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestLabelsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("comments")
		s.Comments.Encode(e)
	}
	{
		e.FieldStart("commits")
		s.Commits.Encode(e)
	}
	{
		e.FieldStart("statuses")
		s.Statuses.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("issue")
		s.Issue.Encode(e)
	}
	{
		e.FieldStart("review_comments")
		s.ReviewComments.Encode(e)
	}
	{
		e.FieldStart("review_comment")
		s.ReviewComment.Encode(e)
	}
	{
		e.FieldStart("self")
		s.Self.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestLinks = [8]string{
	0: "comments",
	1: "commits",
	2: "statuses",
	3: "html",
	4: "issue",
	5: "review_comments",
	6: "review_comment",
	7: "self",
}

// Decode decodes PullRequestLinks from json.
func (s *PullRequestLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "commits":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "issue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "review_comments":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ReviewComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "review_comment":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ReviewComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestLinks) {
					name = jsonFieldsNameOfPullRequestLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMergeResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMergeResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("merged")
		e.Bool(s.Merged)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfPullRequestMergeResult = [3]string{
	0: "sha",
	1: "merged",
	2: "message",
}

// Decode decodes PullRequestMergeResult from json.
func (s *PullRequestMergeResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMergeResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "merged":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Merged = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMergeResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMergeResult) {
					name = jsonFieldsNameOfPullRequestMergeResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMergeResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMergeResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMinimal) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMinimal) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("head")
		s.Head.Encode(e)
	}
	{
		e.FieldStart("base")
		s.Base.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestMinimal = [5]string{
	0: "id",
	1: "number",
	2: "url",
	3: "head",
	4: "base",
}

// Decode decodes PullRequestMinimal from json.
func (s *PullRequestMinimal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimal to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimal")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimal) {
					name = jsonFieldsNameOfPullRequestMinimal[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMinimal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMinimal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMinimalBase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMinimalBase) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestMinimalBase = [3]string{
	0: "ref",
	1: "sha",
	2: "repo",
}

// Decode decodes PullRequestMinimalBase from json.
func (s *PullRequestMinimalBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalBase) {
					name = jsonFieldsNameOfPullRequestMinimalBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMinimalBase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMinimalBase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMinimalBaseRepo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMinimalBaseRepo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfPullRequestMinimalBaseRepo = [3]string{
	0: "id",
	1: "url",
	2: "name",
}

// Decode decodes PullRequestMinimalBaseRepo from json.
func (s *PullRequestMinimalBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalBaseRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalBaseRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalBaseRepo) {
					name = jsonFieldsNameOfPullRequestMinimalBaseRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMinimalBaseRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMinimalBaseRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMinimalHead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMinimalHead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestMinimalHead = [3]string{
	0: "ref",
	1: "sha",
	2: "repo",
}

// Decode decodes PullRequestMinimalHead from json.
func (s *PullRequestMinimalHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalHead) {
					name = jsonFieldsNameOfPullRequestMinimalHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMinimalHead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMinimalHead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestMinimalHeadRepo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestMinimalHeadRepo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfPullRequestMinimalHeadRepo = [3]string{
	0: "id",
	1: "url",
	2: "name",
}

// Decode decodes PullRequestMinimalHeadRepo from json.
func (s *PullRequestMinimalHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalHeadRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalHeadRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalHeadRepo) {
					name = jsonFieldsNameOfPullRequestMinimalHeadRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestMinimalHeadRepo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestMinimalHeadRepo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("pull_request_url")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		if s.SubmittedAt.Set {
			e.FieldStart("submitted_at")
			s.SubmittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("commit_id")
		e.Str(s.CommitID)
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestReview = [13]string{
	0:  "id",
	1:  "node_id",
	2:  "user",
	3:  "body",
	4:  "state",
	5:  "html_url",
	6:  "pull_request_url",
	7:  "_links",
	8:  "submitted_at",
	9:  "commit_id",
	10: "body_html",
	11: "body_text",
	12: "author_association",
}

// Decode decodes PullRequestReview from json.
func (s *PullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReview to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "_links":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "submitted_at":
			if err := func() error {
				s.SubmittedAt.Reset()
				if err := s.SubmittedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"submitted_at\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReview) {
					name = jsonFieldsNameOfPullRequestReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("pull_request_review_id")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("diff_hunk")
		e.Str(s.DiffHunk)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		e.FieldStart("original_position")
		e.Int(s.OriginalPosition)
	}
	{
		e.FieldStart("commit_id")
		e.Str(s.CommitID)
	}
	{
		e.FieldStart("original_commit_id")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.FieldStart("in_reply_to_id")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("pull_request_url")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		if s.StartLine.Set {
			e.FieldStart("start_line")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.FieldStart("original_start_line")
			s.OriginalStartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.FieldStart("start_side")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.FieldStart("line")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.FieldStart("original_line")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.FieldStart("side")
			s.Side.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestReviewComment = [28]string{
	0:  "url",
	1:  "pull_request_review_id",
	2:  "id",
	3:  "node_id",
	4:  "diff_hunk",
	5:  "path",
	6:  "position",
	7:  "original_position",
	8:  "commit_id",
	9:  "original_commit_id",
	10: "in_reply_to_id",
	11: "user",
	12: "body",
	13: "created_at",
	14: "updated_at",
	15: "html_url",
	16: "pull_request_url",
	17: "author_association",
	18: "_links",
	19: "start_line",
	20: "original_start_line",
	21: "start_side",
	22: "line",
	23: "original_line",
	24: "side",
	25: "reactions",
	26: "body_html",
	27: "body_text",
}

// Decode decodes PullRequestReviewComment from json.
func (s *PullRequestReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewComment to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "pull_request_review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequestReviewID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_review_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "diff_hunk":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DiffHunk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_hunk\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "original_position":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OriginalPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_position\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "original_commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OriginalCommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_commit_id\"")
			}
		case "in_reply_to_id":
			if err := func() error {
				s.InReplyToID.Reset()
				if err := s.InReplyToID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "author_association":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "_links":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "original_start_line":
			if err := func() error {
				s.OriginalStartLine.Reset()
				if err := s.OriginalStartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "original_line":
			if err := func() error {
				s.OriginalLine.Reset()
				if err := s.OriginalLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_line\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111011,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewComment) {
					name = jsonFieldsNameOfPullRequestReviewComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewCommentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewCommentLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("self")
		s.Self.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("pull_request")
		s.PullRequest.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestReviewCommentLinks = [3]string{
	0: "self",
	1: "html",
	2: "pull_request",
}

// Decode decodes PullRequestReviewCommentLinks from json.
func (s *PullRequestReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinks) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewCommentLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewCommentLinksHTML) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewCommentLinksHTML) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		json.EncodeURI(e, s.Href)
	}
}

var jsonFieldsNameOfPullRequestReviewCommentLinksHTML = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksHTML from json.
func (s *PullRequestReviewCommentLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksHTML to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksHTML")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksHTML) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksHTML[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewCommentLinksHTML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentLinksHTML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewCommentLinksPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewCommentLinksPullRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		json.EncodeURI(e, s.Href)
	}
}

var jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksPullRequest from json.
func (s *PullRequestReviewCommentLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewCommentLinksPullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentLinksPullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewCommentLinksSelf) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewCommentLinksSelf) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		json.EncodeURI(e, s.Href)
	}
}

var jsonFieldsNameOfPullRequestReviewCommentLinksSelf = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksSelf from json.
func (s *PullRequestReviewCommentLinksSelf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksSelf to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksSelf")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksSelf) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksSelf[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewCommentLinksSelf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentLinksSelf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestReviewCommentSide as json.
func (s PullRequestReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (s *PullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentSide(v) {
	case PullRequestReviewCommentSideLEFT:
		*s = PullRequestReviewCommentSideLEFT
	case PullRequestReviewCommentSideRIGHT:
		*s = PullRequestReviewCommentSideRIGHT
	default:
		*s = PullRequestReviewCommentSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullRequestReviewCommentSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (s PullRequestReviewCommentStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (s *PullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentStartSide(v) {
	case PullRequestReviewCommentStartSideLEFT:
		*s = PullRequestReviewCommentStartSideLEFT
	case PullRequestReviewCommentStartSideRIGHT:
		*s = PullRequestReviewCommentStartSideRIGHT
	default:
		*s = PullRequestReviewCommentStartSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullRequestReviewCommentStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewCommentStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("pull_request")
		s.PullRequest.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestReviewLinks = [2]string{
	0: "html",
	1: "pull_request",
}

// Decode decodes PullRequestReviewLinks from json.
func (s *PullRequestReviewLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinks) {
					name = jsonFieldsNameOfPullRequestReviewLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewLinksHTML) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewLinksHTML) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		e.Str(s.Href)
	}
}

var jsonFieldsNameOfPullRequestReviewLinksHTML = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewLinksHTML from json.
func (s *PullRequestReviewLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinksHTML to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinksHTML")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinksHTML) {
					name = jsonFieldsNameOfPullRequestReviewLinksHTML[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewLinksHTML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewLinksHTML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewLinksPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewLinksPullRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("href")
		e.Str(s.Href)
	}
}

var jsonFieldsNameOfPullRequestReviewLinksPullRequest = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewLinksPullRequest from json.
func (s *PullRequestReviewLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinksPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinksPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinksPullRequest) {
					name = jsonFieldsNameOfPullRequestReviewLinksPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewLinksPullRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewLinksPullRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestReviewRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestReviewRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPullRequestReviewRequest = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes PullRequestReviewRequest from json.
func (s *PullRequestReviewRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]SimpleUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Teams = make([]Team, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewRequest) {
					name = jsonFieldsNameOfPullRequestReviewRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestReviewRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestReviewRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("diff_url")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.FieldStart("patch_url")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.FieldStart("issue_url")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.FieldStart("commits_url")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.FieldStart("review_comments_url")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.FieldStart("review_comment_url")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("statuses_url")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("locked")
		e.Bool(s.Locked)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.FieldStart("active_lock_reason")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("closed_at")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("merged_at")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("merge_commit_sha")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.FieldStart("assignees")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.FieldStart("requested_reviewers")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.FieldStart("requested_teams")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.FieldStart("head")
		s.Head.Encode(e)
	}
	{
		e.FieldStart("base")
		s.Base.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.FieldStart("auto_merge")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestSimple = [36]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "html_url",
	4:  "diff_url",
	5:  "patch_url",
	6:  "issue_url",
	7:  "commits_url",
	8:  "review_comments_url",
	9:  "review_comment_url",
	10: "comments_url",
	11: "statuses_url",
	12: "number",
	13: "state",
	14: "locked",
	15: "title",
	16: "user",
	17: "body",
	18: "labels",
	19: "milestone",
	20: "active_lock_reason",
	21: "created_at",
	22: "updated_at",
	23: "closed_at",
	24: "merged_at",
	25: "merge_commit_sha",
	26: "assignee",
	27: "assignees",
	28: "requested_reviewers",
	29: "requested_teams",
	30: "head",
	31: "base",
	32: "_links",
	33: "author_association",
	34: "auto_merge",
	35: "draft",
}

// Decode decodes PullRequestSimple from json.
func (s *PullRequestSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimple to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "issue_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "review_comments_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReviewCommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments_url\"")
			}
		case "review_comment_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReviewCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "user":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "labels":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Labels = make([]PullRequestSimpleLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestSimpleLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "merged_at":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "merge_commit_sha":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.MergeCommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_commit_sha\"")
			}
		case "assignee":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "requested_reviewers":
			if err := func() error {
				s.RequestedReviewers.Reset()
				if err := s.RequestedReviewers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewers\"")
			}
		case "requested_teams":
			if err := func() error {
				s.RequestedTeams.Reset()
				if err := s.RequestedTeams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_teams\"")
			}
		case "head":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "_links":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "author_association":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "auto_merge":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11000111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimple) {
					name = jsonFieldsNameOfPullRequestSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestSimpleBase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestSimpleBase) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestSimpleBase = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestSimpleBase from json.
func (s *PullRequestSimpleBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleBase) {
					name = jsonFieldsNameOfPullRequestSimpleBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestSimpleBase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestSimpleBase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestSimpleHead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestSimpleHead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestSimpleHead = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestSimpleHead from json.
func (s *PullRequestSimpleHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleHead) {
					name = jsonFieldsNameOfPullRequestSimpleHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestSimpleHead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestSimpleHead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestSimpleLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestSimpleLabelsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullRequestSimpleLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes PullRequestSimpleLabelsItem from json.
func (s *PullRequestSimpleLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleLabelsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestSimpleLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestSimpleLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullRequestSimpleLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullRequestSimpleLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("comments")
		s.Comments.Encode(e)
	}
	{
		e.FieldStart("commits")
		s.Commits.Encode(e)
	}
	{
		e.FieldStart("statuses")
		s.Statuses.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("issue")
		s.Issue.Encode(e)
	}
	{
		e.FieldStart("review_comments")
		s.ReviewComments.Encode(e)
	}
	{
		e.FieldStart("review_comment")
		s.ReviewComment.Encode(e)
	}
	{
		e.FieldStart("self")
		s.Self.Encode(e)
	}
}

var jsonFieldsNameOfPullRequestSimpleLinks = [8]string{
	0: "comments",
	1: "commits",
	2: "statuses",
	3: "html",
	4: "issue",
	5: "review_comments",
	6: "review_comment",
	7: "self",
}

// Decode decodes PullRequestSimpleLinks from json.
func (s *PullRequestSimpleLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "commits":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "issue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "review_comments":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ReviewComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "review_comment":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ReviewComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleLinks) {
					name = jsonFieldsNameOfPullRequestSimpleLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullRequestSimpleLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestSimpleLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullRequestState as json.
func (s PullRequestState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestState from json.
func (s *PullRequestState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestState(v) {
	case PullRequestStateOpen:
		*s = PullRequestStateOpen
	case PullRequestStateClosed:
		*s = PullRequestStateClosed
	default:
		*s = PullRequestState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullRequestState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullRequestState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsCreateReplyForReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsCreateReplyForReviewCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfPullsCreateReplyForReviewCommentReq = [1]string{
	0: "body",
}

// Decode decodes PullsCreateReplyForReviewCommentReq from json.
func (s *PullsCreateReplyForReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReplyForReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReplyForReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReplyForReviewCommentReq) {
					name = jsonFieldsNameOfPullsCreateReplyForReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsCreateReplyForReviewCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReplyForReviewCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsCreateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		e.FieldStart("head")
		e.Str(s.Head)
	}
	{
		e.FieldStart("base")
		e.Str(s.Base)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			e.FieldStart("maintainer_can_modify")
			s.MaintainerCanModify.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			e.FieldStart("issue")
			s.Issue.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsCreateReq = [7]string{
	0: "title",
	1: "head",
	2: "base",
	3: "body",
	4: "maintainer_can_modify",
	5: "draft",
	6: "issue",
}

// Decode decodes PullsCreateReq from json.
func (s *PullsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Head = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Base = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "maintainer_can_modify":
			if err := func() error {
				s.MaintainerCanModify.Reset()
				if err := s.MaintainerCanModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReq) {
					name = jsonFieldsNameOfPullsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsCreateReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsCreateReviewCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.CommitID.Set {
			e.FieldStart("commit_id")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.FieldStart("side")
			s.Side.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.FieldStart("line")
			s.Line.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.FieldStart("start_line")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.FieldStart("start_side")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.InReplyTo.Set {
			e.FieldStart("in_reply_to")
			s.InReplyTo.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsCreateReviewCommentReq = [9]string{
	0: "body",
	1: "commit_id",
	2: "path",
	3: "position",
	4: "side",
	5: "line",
	6: "start_line",
	7: "start_side",
	8: "in_reply_to",
}

// Decode decodes PullsCreateReviewCommentReq from json.
func (s *PullsCreateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "commit_id":
			if err := func() error {
				s.CommitID.Reset()
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "in_reply_to":
			if err := func() error {
				s.InReplyTo.Reset()
				if err := s.InReplyTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReviewCommentReq) {
					name = jsonFieldsNameOfPullsCreateReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsCreateReviewCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (s PullsCreateReviewCommentReqSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (s *PullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReqSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqSide(v) {
	case PullsCreateReviewCommentReqSideLEFT:
		*s = PullsCreateReviewCommentReqSideLEFT
	case PullsCreateReviewCommentReqSideRIGHT:
		*s = PullsCreateReviewCommentReqSideRIGHT
	default:
		*s = PullsCreateReviewCommentReqSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsCreateReviewCommentReqSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewCommentReqSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (s PullsCreateReviewCommentReqStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (s *PullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReqStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqStartSide(v) {
	case PullsCreateReviewCommentReqStartSideLEFT:
		*s = PullsCreateReviewCommentReqStartSideLEFT
	case PullsCreateReviewCommentReqStartSideRIGHT:
		*s = PullsCreateReviewCommentReqStartSideRIGHT
	case PullsCreateReviewCommentReqStartSideSide:
		*s = PullsCreateReviewCommentReqStartSideSide
	default:
		*s = PullsCreateReviewCommentReqStartSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsCreateReviewCommentReqStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewCommentReqStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsCreateReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsCreateReviewReq) encodeFields(e *jx.Encoder) {
	{
		if s.CommitID.Set {
			e.FieldStart("commit_id")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Event.Set {
			e.FieldStart("event")
			s.Event.Encode(e)
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPullsCreateReviewReq = [4]string{
	0: "commit_id",
	1: "body",
	2: "event",
	3: "comments",
}

// Decode decodes PullsCreateReviewReq from json.
func (s *PullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_id":
			if err := func() error {
				s.CommitID.Reset()
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]PullsCreateReviewReqCommentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullsCreateReviewReqCommentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsCreateReviewReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsCreateReviewReqCommentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsCreateReviewReqCommentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.Line.Set {
			e.FieldStart("line")
			s.Line.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.FieldStart("side")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.FieldStart("start_line")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.FieldStart("start_side")
			s.StartSide.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsCreateReviewReqCommentsItem = [7]string{
	0: "path",
	1: "position",
	2: "body",
	3: "line",
	4: "side",
	5: "start_line",
	6: "start_side",
}

// Decode decodes PullsCreateReviewReqCommentsItem from json.
func (s *PullsCreateReviewReqCommentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReqCommentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewReqCommentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReviewReqCommentsItem) {
					name = jsonFieldsNameOfPullsCreateReviewReqCommentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsCreateReviewReqCommentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewReqCommentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (s PullsCreateReviewReqEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (s *PullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReqEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewReqEvent(v) {
	case PullsCreateReviewReqEventAPPROVE:
		*s = PullsCreateReviewReqEventAPPROVE
	case PullsCreateReviewReqEventREQUESTCHANGES:
		*s = PullsCreateReviewReqEventREQUESTCHANGES
	case PullsCreateReviewReqEventCOMMENT:
		*s = PullsCreateReviewReqEventCOMMENT
	default:
		*s = PullsCreateReviewReqEvent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsCreateReviewReqEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsCreateReviewReqEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsDismissReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsDismissReviewReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Event.Set {
			e.FieldStart("event")
			s.Event.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsDismissReviewReq = [2]string{
	0: "message",
	1: "event",
}

// Decode decodes PullsDismissReviewReq from json.
func (s *PullsDismissReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsDismissReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsDismissReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsDismissReviewReq) {
					name = jsonFieldsNameOfPullsDismissReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsDismissReviewReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsDismissReviewReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsGetInternalServerError as json.
func (s *PullsGetInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsGetInternalServerError from json.
func (s *PullsGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsGetInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsGetNotFound as json.
func (s *PullsGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsGetNotFound from json.
func (s *PullsGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsGetNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsMergeConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsMergeConflict) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsMergeConflict = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PullsMergeConflict from json.
func (s *PullsMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeConflict to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeConflict")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsMergeConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsMergeForbidden as json.
func (s *PullsMergeForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsMergeForbidden from json.
func (s *PullsMergeForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsMergeForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsMergeMethodNotAllowed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsMergeMethodNotAllowed) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsMergeMethodNotAllowed = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PullsMergeMethodNotAllowed from json.
func (s *PullsMergeMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeMethodNotAllowed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeMethodNotAllowed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsMergeMethodNotAllowed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeMethodNotAllowed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsMergeNotFound as json.
func (s *PullsMergeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsMergeNotFound from json.
func (s *PullsMergeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsMergeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsMergeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsMergeReq) encodeFields(e *jx.Encoder) {
	{
		if s.CommitTitle.Set {
			e.FieldStart("commit_title")
			s.CommitTitle.Encode(e)
		}
	}
	{
		if s.CommitMessage.Set {
			e.FieldStart("commit_message")
			s.CommitMessage.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.MergeMethod.Set {
			e.FieldStart("merge_method")
			s.MergeMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsMergeReq = [4]string{
	0: "commit_title",
	1: "commit_message",
	2: "sha",
	3: "merge_method",
}

// Decode decodes PullsMergeReq from json.
func (s *PullsMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_title":
			if err := func() error {
				s.CommitTitle.Reset()
				if err := s.CommitTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_title\"")
			}
		case "commit_message":
			if err := func() error {
				s.CommitMessage.Reset()
				if err := s.CommitMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "merge_method":
			if err := func() error {
				s.MergeMethod.Reset()
				if err := s.MergeMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsMergeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (s PullsMergeReqMergeMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (s *PullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeReqMergeMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsMergeReqMergeMethod(v) {
	case PullsMergeReqMergeMethodMerge:
		*s = PullsMergeReqMergeMethodMerge
	case PullsMergeReqMergeMethodSquash:
		*s = PullsMergeReqMergeMethodSquash
	case PullsMergeReqMergeMethodRebase:
		*s = PullsMergeReqMergeMethodRebase
	default:
		*s = PullsMergeReqMergeMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsMergeReqMergeMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsMergeReqMergeMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsRemoveRequestedReviewersReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsRemoveRequestedReviewersReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reviewers")
		e.ArrStart()
		for _, elem := range s.Reviewers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.TeamReviewers != nil {
			e.FieldStart("team_reviewers")
			e.ArrStart()
			for _, elem := range s.TeamReviewers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPullsRemoveRequestedReviewersReq = [2]string{
	0: "reviewers",
	1: "team_reviewers",
}

// Decode decodes PullsRemoveRequestedReviewersReq from json.
func (s *PullsRemoveRequestedReviewersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsRemoveRequestedReviewersReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reviewers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Reviewers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Reviewers = append(s.Reviewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reviewers\"")
			}
		case "team_reviewers":
			if err := func() error {
				s.TeamReviewers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TeamReviewers = append(s.TeamReviewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_reviewers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsRemoveRequestedReviewersReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsRemoveRequestedReviewersReq) {
					name = jsonFieldsNameOfPullsRemoveRequestedReviewersReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsRemoveRequestedReviewersReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsRemoveRequestedReviewersReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsSubmitReviewForbidden as json.
func (s *PullsSubmitReviewForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewForbidden from json.
func (s *PullsSubmitReviewForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsSubmitReviewForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsSubmitReviewForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsSubmitReviewNotFound as json.
func (s *PullsSubmitReviewNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewNotFound from json.
func (s *PullsSubmitReviewNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsSubmitReviewNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsSubmitReviewNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsSubmitReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsSubmitReviewReq) encodeFields(e *jx.Encoder) {
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("event")
		s.Event.Encode(e)
	}
}

var jsonFieldsNameOfPullsSubmitReviewReq = [2]string{
	0: "body",
	1: "event",
}

// Decode decodes PullsSubmitReviewReq from json.
func (s *PullsSubmitReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsSubmitReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsSubmitReviewReq) {
					name = jsonFieldsNameOfPullsSubmitReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsSubmitReviewReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsSubmitReviewReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsSubmitReviewReqEvent as json.
func (s PullsSubmitReviewReqEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsSubmitReviewReqEvent from json.
func (s *PullsSubmitReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewReqEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsSubmitReviewReqEvent(v) {
	case PullsSubmitReviewReqEventAPPROVE:
		*s = PullsSubmitReviewReqEventAPPROVE
	case PullsSubmitReviewReqEventREQUESTCHANGES:
		*s = PullsSubmitReviewReqEventREQUESTCHANGES
	case PullsSubmitReviewReqEventCOMMENT:
		*s = PullsSubmitReviewReqEventCOMMENT
	default:
		*s = PullsSubmitReviewReqEvent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsSubmitReviewReqEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsSubmitReviewReqEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsUpdateBranchAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsUpdateBranchAccepted) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsUpdateBranchAccepted = [2]string{
	0: "message",
	1: "url",
}

// Decode decodes PullsUpdateBranchAccepted from json.
func (s *PullsUpdateBranchAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateBranchAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateBranchAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsUpdateBranchAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateBranchAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsUpdateBranchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsUpdateBranchReq) encodeFields(e *jx.Encoder) {
	{
		if s.ExpectedHeadSha.Set {
			e.FieldStart("expected_head_sha")
			s.ExpectedHeadSha.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsUpdateBranchReq = [1]string{
	0: "expected_head_sha",
}

// Decode decodes PullsUpdateBranchReq from json.
func (s *PullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateBranchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expected_head_sha":
			if err := func() error {
				s.ExpectedHeadSha.Reset()
				if err := s.ExpectedHeadSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_head_sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateBranchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsUpdateBranchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateBranchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Base.Set {
			e.FieldStart("base")
			s.Base.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			e.FieldStart("maintainer_can_modify")
			s.MaintainerCanModify.Encode(e)
		}
	}
}

var jsonFieldsNameOfPullsUpdateReq = [5]string{
	0: "title",
	1: "body",
	2: "state",
	3: "base",
	4: "maintainer_can_modify",
}

// Decode decodes PullsUpdateReq from json.
func (s *PullsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "base":
			if err := func() error {
				s.Base.Reset()
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "maintainer_can_modify":
			if err := func() error {
				s.MaintainerCanModify.Reset()
				if err := s.MaintainerCanModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PullsUpdateReqState as json.
func (s PullsUpdateReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsUpdateReqState from json.
func (s *PullsUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsUpdateReqState(v) {
	case PullsUpdateReqStateOpen:
		*s = PullsUpdateReqStateOpen
	case PullsUpdateReqStateClosed:
		*s = PullsUpdateReqStateClosed
	default:
		*s = PullsUpdateReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PullsUpdateReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsUpdateReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsUpdateReviewCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfPullsUpdateReviewCommentReq = [1]string{
	0: "body",
}

// Decode decodes PullsUpdateReviewCommentReq from json.
func (s *PullsUpdateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsUpdateReviewCommentReq) {
					name = jsonFieldsNameOfPullsUpdateReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsUpdateReviewCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateReviewCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PullsUpdateReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PullsUpdateReviewReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfPullsUpdateReviewReq = [1]string{
	0: "body",
}

// Decode decodes PullsUpdateReviewReq from json.
func (s *PullsUpdateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsUpdateReviewReq) {
					name = jsonFieldsNameOfPullsUpdateReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PullsUpdateReviewReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PullsUpdateReviewReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("remaining")
		e.Int(s.Remaining)
	}
	{
		e.FieldStart("reset")
		e.Int(s.Reset)
	}
	{
		e.FieldStart("used")
		e.Int(s.Used)
	}
}

var jsonFieldsNameOfRateLimit = [4]string{
	0: "limit",
	1: "remaining",
	2: "reset",
	3: "used",
}

// Decode decodes RateLimit from json.
func (s *RateLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "remaining":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Remaining = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "reset":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Reset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset\"")
			}
		case "used":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Used = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimit) {
					name = jsonFieldsNameOfRateLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitOverview) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitOverview) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resources")
		s.Resources.Encode(e)
	}
	{
		e.FieldStart("rate")
		s.Rate.Encode(e)
	}
}

var jsonFieldsNameOfRateLimitOverview = [2]string{
	0: "resources",
	1: "rate",
}

// Decode decodes RateLimitOverview from json.
func (s *RateLimitOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitOverview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resources":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Rate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitOverview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitOverview) {
					name = jsonFieldsNameOfRateLimitOverview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitOverview) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitOverview) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RateLimitOverviewResources) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RateLimitOverviewResources) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("core")
		s.Core.Encode(e)
	}
	{
		if s.Graphql.Set {
			e.FieldStart("graphql")
			s.Graphql.Encode(e)
		}
	}
	{
		e.FieldStart("search")
		s.Search.Encode(e)
	}
	{
		if s.SourceImport.Set {
			e.FieldStart("source_import")
			s.SourceImport.Encode(e)
		}
	}
	{
		if s.IntegrationManifest.Set {
			e.FieldStart("integration_manifest")
			s.IntegrationManifest.Encode(e)
		}
	}
	{
		if s.CodeScanningUpload.Set {
			e.FieldStart("code_scanning_upload")
			s.CodeScanningUpload.Encode(e)
		}
	}
	{
		if s.ActionsRunnerRegistration.Set {
			e.FieldStart("actions_runner_registration")
			s.ActionsRunnerRegistration.Encode(e)
		}
	}
}

var jsonFieldsNameOfRateLimitOverviewResources = [7]string{
	0: "core",
	1: "graphql",
	2: "search",
	3: "source_import",
	4: "integration_manifest",
	5: "code_scanning_upload",
	6: "actions_runner_registration",
}

// Decode decodes RateLimitOverviewResources from json.
func (s *RateLimitOverviewResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitOverviewResources to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "core":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Core.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"core\"")
			}
		case "graphql":
			if err := func() error {
				s.Graphql.Reset()
				if err := s.Graphql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"graphql\"")
			}
		case "search":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Search.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		case "source_import":
			if err := func() error {
				s.SourceImport.Reset()
				if err := s.SourceImport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_import\"")
			}
		case "integration_manifest":
			if err := func() error {
				s.IntegrationManifest.Reset()
				if err := s.IntegrationManifest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_manifest\"")
			}
		case "code_scanning_upload":
			if err := func() error {
				s.CodeScanningUpload.Reset()
				if err := s.CodeScanningUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_scanning_upload\"")
			}
		case "actions_runner_registration":
			if err := func() error {
				s.ActionsRunnerRegistration.Reset()
				if err := s.ActionsRunnerRegistration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions_runner_registration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitOverviewResources")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitOverviewResources) {
					name = jsonFieldsNameOfRateLimitOverviewResources[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RateLimitOverviewResources) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RateLimitOverviewResources) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Reaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Reaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfReaction = [5]string{
	0: "id",
	1: "node_id",
	2: "user",
	3: "content",
	4: "created_at",
}

// Decode decodes Reaction from json.
func (s *Reaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Reaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReaction) {
					name = jsonFieldsNameOfReaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Reaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Reaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionContent as json.
func (s ReactionContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionContent from json.
func (s *ReactionContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionContent(v) {
	case ReactionContentPlus1:
		*s = ReactionContentPlus1
	case ReactionContentMinus1:
		*s = ReactionContentMinus1
	case ReactionContentLaugh:
		*s = ReactionContentLaugh
	case ReactionContentConfused:
		*s = ReactionContentConfused
	case ReactionContentHeart:
		*s = ReactionContentHeart
	case ReactionContentHooray:
		*s = ReactionContentHooray
	case ReactionContentRocket:
		*s = ReactionContentRocket
	case ReactionContentEyes:
		*s = ReactionContentEyes
	default:
		*s = ReactionContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionRollup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionRollup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("+1")
		e.Int(s.Plus1)
	}
	{
		e.FieldStart("-1")
		e.Int(s.Minus1)
	}
	{
		e.FieldStart("laugh")
		e.Int(s.Laugh)
	}
	{
		e.FieldStart("confused")
		e.Int(s.Confused)
	}
	{
		e.FieldStart("heart")
		e.Int(s.Heart)
	}
	{
		e.FieldStart("hooray")
		e.Int(s.Hooray)
	}
	{
		e.FieldStart("eyes")
		e.Int(s.Eyes)
	}
	{
		e.FieldStart("rocket")
		e.Int(s.Rocket)
	}
}

var jsonFieldsNameOfReactionRollup = [10]string{
	0: "url",
	1: "total_count",
	2: "+1",
	3: "-1",
	4: "laugh",
	5: "confused",
	6: "heart",
	7: "hooray",
	8: "eyes",
	9: "rocket",
}

// Decode decodes ReactionRollup from json.
func (s *ReactionRollup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionRollup to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "+1":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Plus1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"+1\"")
			}
		case "-1":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Minus1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"-1\"")
			}
		case "laugh":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Laugh = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"laugh\"")
			}
		case "confused":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Confused = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confused\"")
			}
		case "heart":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Heart = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heart\"")
			}
		case "hooray":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Hooray = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooray\"")
			}
		case "eyes":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Eyes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eyes\"")
			}
		case "rocket":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Rocket = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rocket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionRollup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionRollup) {
					name = jsonFieldsNameOfReactionRollup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionRollup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionRollup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForCommitCommentCreated as json.
func (s *ReactionsCreateForCommitCommentCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentCreated from json.
func (s *ReactionsCreateForCommitCommentCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForCommitCommentCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForCommitCommentCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForCommitCommentOK as json.
func (s *ReactionsCreateForCommitCommentOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentOK from json.
func (s *ReactionsCreateForCommitCommentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForCommitCommentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForCommitCommentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForCommitCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForCommitCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForCommitCommentReq from json.
func (s *ReactionsCreateForCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForCommitCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForCommitCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForCommitCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForCommitCommentReqContent as json.
func (s ReactionsCreateForCommitCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForCommitCommentReqContent from json.
func (s *ReactionsCreateForCommitCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForCommitCommentReqContent(v) {
	case ReactionsCreateForCommitCommentReqContentPlus1:
		*s = ReactionsCreateForCommitCommentReqContentPlus1
	case ReactionsCreateForCommitCommentReqContentMinus1:
		*s = ReactionsCreateForCommitCommentReqContentMinus1
	case ReactionsCreateForCommitCommentReqContentLaugh:
		*s = ReactionsCreateForCommitCommentReqContentLaugh
	case ReactionsCreateForCommitCommentReqContentConfused:
		*s = ReactionsCreateForCommitCommentReqContentConfused
	case ReactionsCreateForCommitCommentReqContentHeart:
		*s = ReactionsCreateForCommitCommentReqContentHeart
	case ReactionsCreateForCommitCommentReqContentHooray:
		*s = ReactionsCreateForCommitCommentReqContentHooray
	case ReactionsCreateForCommitCommentReqContentRocket:
		*s = ReactionsCreateForCommitCommentReqContentRocket
	case ReactionsCreateForCommitCommentReqContentEyes:
		*s = ReactionsCreateForCommitCommentReqContentEyes
	default:
		*s = ReactionsCreateForCommitCommentReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForCommitCommentReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForCommitCommentReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueCommentCreated as json.
func (s *ReactionsCreateForIssueCommentCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentCreated from json.
func (s *ReactionsCreateForIssueCommentCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueCommentCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueCommentCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueCommentOK as json.
func (s *ReactionsCreateForIssueCommentOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentOK from json.
func (s *ReactionsCreateForIssueCommentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueCommentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueCommentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForIssueCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForIssueCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForIssueCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForIssueCommentReq from json.
func (s *ReactionsCreateForIssueCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForIssueCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForIssueCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForIssueCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueCommentReqContent as json.
func (s ReactionsCreateForIssueCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueCommentReqContent from json.
func (s *ReactionsCreateForIssueCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueCommentReqContent(v) {
	case ReactionsCreateForIssueCommentReqContentPlus1:
		*s = ReactionsCreateForIssueCommentReqContentPlus1
	case ReactionsCreateForIssueCommentReqContentMinus1:
		*s = ReactionsCreateForIssueCommentReqContentMinus1
	case ReactionsCreateForIssueCommentReqContentLaugh:
		*s = ReactionsCreateForIssueCommentReqContentLaugh
	case ReactionsCreateForIssueCommentReqContentConfused:
		*s = ReactionsCreateForIssueCommentReqContentConfused
	case ReactionsCreateForIssueCommentReqContentHeart:
		*s = ReactionsCreateForIssueCommentReqContentHeart
	case ReactionsCreateForIssueCommentReqContentHooray:
		*s = ReactionsCreateForIssueCommentReqContentHooray
	case ReactionsCreateForIssueCommentReqContentRocket:
		*s = ReactionsCreateForIssueCommentReqContentRocket
	case ReactionsCreateForIssueCommentReqContentEyes:
		*s = ReactionsCreateForIssueCommentReqContentEyes
	default:
		*s = ReactionsCreateForIssueCommentReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForIssueCommentReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueCommentReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueCreated as json.
func (s *ReactionsCreateForIssueCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCreated from json.
func (s *ReactionsCreateForIssueCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueOK as json.
func (s *ReactionsCreateForIssueOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueOK from json.
func (s *ReactionsCreateForIssueOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForIssueReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForIssueReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForIssueReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForIssueReq from json.
func (s *ReactionsCreateForIssueReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForIssueReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForIssueReq) {
					name = jsonFieldsNameOfReactionsCreateForIssueReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForIssueReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForIssueReqContent as json.
func (s ReactionsCreateForIssueReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueReqContent from json.
func (s *ReactionsCreateForIssueReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueReqContent(v) {
	case ReactionsCreateForIssueReqContentPlus1:
		*s = ReactionsCreateForIssueReqContentPlus1
	case ReactionsCreateForIssueReqContentMinus1:
		*s = ReactionsCreateForIssueReqContentMinus1
	case ReactionsCreateForIssueReqContentLaugh:
		*s = ReactionsCreateForIssueReqContentLaugh
	case ReactionsCreateForIssueReqContentConfused:
		*s = ReactionsCreateForIssueReqContentConfused
	case ReactionsCreateForIssueReqContentHeart:
		*s = ReactionsCreateForIssueReqContentHeart
	case ReactionsCreateForIssueReqContentHooray:
		*s = ReactionsCreateForIssueReqContentHooray
	case ReactionsCreateForIssueReqContentRocket:
		*s = ReactionsCreateForIssueReqContentRocket
	case ReactionsCreateForIssueReqContentEyes:
		*s = ReactionsCreateForIssueReqContentEyes
	default:
		*s = ReactionsCreateForIssueReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForIssueReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForIssueReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentCreated as json.
func (s *ReactionsCreateForPullRequestReviewCommentCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentCreated from json.
func (s *ReactionsCreateForPullRequestReviewCommentCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForPullRequestReviewCommentCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForPullRequestReviewCommentCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentOK as json.
func (s *ReactionsCreateForPullRequestReviewCommentOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentOK from json.
func (s *ReactionsCreateForPullRequestReviewCommentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForPullRequestReviewCommentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForPullRequestReviewCommentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForPullRequestReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForPullRequestReviewCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReq from json.
func (s *ReactionsCreateForPullRequestReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForPullRequestReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForPullRequestReviewCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForPullRequestReviewCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentReqContent as json.
func (s ReactionsCreateForPullRequestReviewCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReqContent from json.
func (s *ReactionsCreateForPullRequestReviewCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForPullRequestReviewCommentReqContent(v) {
	case ReactionsCreateForPullRequestReviewCommentReqContentPlus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentPlus1
	case ReactionsCreateForPullRequestReviewCommentReqContentMinus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentMinus1
	case ReactionsCreateForPullRequestReviewCommentReqContentLaugh:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentLaugh
	case ReactionsCreateForPullRequestReviewCommentReqContentConfused:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentConfused
	case ReactionsCreateForPullRequestReviewCommentReqContentHeart:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHeart
	case ReactionsCreateForPullRequestReviewCommentReqContentHooray:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHooray
	case ReactionsCreateForPullRequestReviewCommentReqContentRocket:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentRocket
	case ReactionsCreateForPullRequestReviewCommentReqContentEyes:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentEyes
	default:
		*s = ReactionsCreateForPullRequestReviewCommentReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForPullRequestReviewCommentReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForPullRequestReviewCommentReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForReleaseCreated as json.
func (s *ReactionsCreateForReleaseCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseCreated from json.
func (s *ReactionsCreateForReleaseCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForReleaseCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForReleaseCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForReleaseOK as json.
func (s *ReactionsCreateForReleaseOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseOK from json.
func (s *ReactionsCreateForReleaseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForReleaseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForReleaseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForReleaseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForReleaseReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForReleaseReq from json.
func (s *ReactionsCreateForReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForReleaseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForReleaseReq) {
					name = jsonFieldsNameOfReactionsCreateForReleaseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForReleaseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForReleaseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForReleaseReqContent as json.
func (s ReactionsCreateForReleaseReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForReleaseReqContent from json.
func (s *ReactionsCreateForReleaseReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForReleaseReqContent(v) {
	case ReactionsCreateForReleaseReqContentPlus1:
		*s = ReactionsCreateForReleaseReqContentPlus1
	case ReactionsCreateForReleaseReqContentLaugh:
		*s = ReactionsCreateForReleaseReqContentLaugh
	case ReactionsCreateForReleaseReqContentHeart:
		*s = ReactionsCreateForReleaseReqContentHeart
	case ReactionsCreateForReleaseReqContentHooray:
		*s = ReactionsCreateForReleaseReqContentHooray
	case ReactionsCreateForReleaseReqContentRocket:
		*s = ReactionsCreateForReleaseReqContentRocket
	case ReactionsCreateForReleaseReqContentEyes:
		*s = ReactionsCreateForReleaseReqContentEyes
	default:
		*s = ReactionsCreateForReleaseReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForReleaseReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForReleaseReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgCreated as json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgCreated from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgOK as json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgOK from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgCreated as json.
func (s *ReactionsCreateForTeamDiscussionInOrgCreated) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgCreated from json.
func (s *ReactionsCreateForTeamDiscussionInOrgCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgOK as json.
func (s *ReactionsCreateForTeamDiscussionInOrgOK) Encode(e *jx.Encoder) {
	unwrapped := (*Reaction)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgOK from json.
func (s *ReactionsCreateForTeamDiscussionInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionInOrgReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForTeamDiscussionInOrgReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionInOrgReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsCreateForTeamDiscussionLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionLegacyReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionsCreateForTeamDiscussionLegacyReqContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsCreateForTeamDiscussionLegacyReqContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsDeleteLegacyForbidden as json.
func (s *ReactionsDeleteLegacyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyForbidden from json.
func (s *ReactionsDeleteLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsDeleteLegacyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsDeleteLegacyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsDeleteLegacyGone as json.
func (s *ReactionsDeleteLegacyGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyGone from json.
func (s *ReactionsDeleteLegacyGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsDeleteLegacyGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsDeleteLegacyGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsDeleteLegacyUnauthorized as json.
func (s *ReactionsDeleteLegacyUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyUnauthorized from json.
func (s *ReactionsDeleteLegacyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsDeleteLegacyUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsDeleteLegacyUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsListForIssueGone as json.
func (s *ReactionsListForIssueGone) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueGone from json.
func (s *ReactionsListForIssueGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueGone(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsListForIssueGone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsListForIssueGone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionsListForIssueNotFound as json.
func (s *ReactionsListForIssueNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueNotFound from json.
func (s *ReactionsListForIssueNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReactionsListForIssueNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionsListForIssueNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReferrerTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReferrerTraffic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("referrer")
		e.Str(s.Referrer)
	}
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("uniques")
		e.Int(s.Uniques)
	}
}

var jsonFieldsNameOfReferrerTraffic = [3]string{
	0: "referrer",
	1: "count",
	2: "uniques",
}

// Decode decodes ReferrerTraffic from json.
func (s *ReferrerTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferrerTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referrer":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Referrer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referrer\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReferrerTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReferrerTraffic) {
					name = jsonFieldsNameOfReferrerTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReferrerTraffic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferrerTraffic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Release) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Release) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("assets_url")
		json.EncodeURI(e, s.AssetsURL)
	}
	{
		e.FieldStart("upload_url")
		e.Str(s.UploadURL)
	}
	{
		e.FieldStart("tarball_url")
		s.TarballURL.Encode(e)
	}
	{
		e.FieldStart("zipball_url")
		s.ZipballURL.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("tag_name")
		e.Str(s.TagName)
	}
	{
		e.FieldStart("target_commitish")
		e.Str(s.TargetCommitish)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		e.FieldStart("draft")
		e.Bool(s.Draft)
	}
	{
		e.FieldStart("prerelease")
		e.Bool(s.Prerelease)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("published_at")
		s.PublishedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.MentionsCount.Set {
			e.FieldStart("mentions_count")
			s.MentionsCount.Encode(e)
		}
	}
	{
		if s.DiscussionURL.Set {
			e.FieldStart("discussion_url")
			s.DiscussionURL.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfRelease = [23]string{
	0:  "url",
	1:  "html_url",
	2:  "assets_url",
	3:  "upload_url",
	4:  "tarball_url",
	5:  "zipball_url",
	6:  "id",
	7:  "node_id",
	8:  "tag_name",
	9:  "target_commitish",
	10: "name",
	11: "body",
	12: "draft",
	13: "prerelease",
	14: "created_at",
	15: "published_at",
	16: "author",
	17: "assets",
	18: "body_html",
	19: "body_text",
	20: "mentions_count",
	21: "discussion_url",
	22: "reactions",
}

// Decode decodes Release from json.
func (s *Release) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Release to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "assets_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AssetsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets_url\"")
			}
		case "upload_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UploadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_url\"")
			}
		case "tarball_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TarballURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tarball_url\"")
			}
		case "zipball_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ZipballURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zipball_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "tag_name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TagName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TargetCommitish = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Draft = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Prerelease = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "published_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"published_at\"")
			}
		case "author":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "assets":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				s.Assets = make([]ReleaseAsset, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReleaseAsset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "mentions_count":
			if err := func() error {
				s.MentionsCount.Reset()
				if err := s.MentionsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentions_count\"")
			}
		case "discussion_url":
			if err := func() error {
				s.DiscussionURL.Reset()
				if err := s.DiscussionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Release")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11110111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelease) {
					name = jsonFieldsNameOfRelease[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Release) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Release) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReleaseAsset) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReleaseAsset) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("browser_download_url")
		json.EncodeURI(e, s.BrowserDownloadURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("label")
		s.Label.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("content_type")
		e.Str(s.ContentType)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("download_count")
		e.Int(s.DownloadCount)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("uploader")
		s.Uploader.Encode(e)
	}
}

var jsonFieldsNameOfReleaseAsset = [13]string{
	0:  "url",
	1:  "browser_download_url",
	2:  "id",
	3:  "node_id",
	4:  "name",
	5:  "label",
	6:  "state",
	7:  "content_type",
	8:  "size",
	9:  "download_count",
	10: "created_at",
	11: "updated_at",
	12: "uploader",
}

// Decode decodes ReleaseAsset from json.
func (s *ReleaseAsset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseAsset to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "browser_download_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BrowserDownloadURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_download_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "size":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "download_count":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DownloadCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_count\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "uploader":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Uploader.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploader\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReleaseAsset")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReleaseAsset) {
					name = jsonFieldsNameOfReleaseAsset[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseAsset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseAsset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReleaseAssetState as json.
func (s ReleaseAssetState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReleaseAssetState from json.
func (s *ReleaseAssetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseAssetState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReleaseAssetState(v) {
	case ReleaseAssetStateUploaded:
		*s = ReleaseAssetStateUploaded
	case ReleaseAssetStateOpen:
		*s = ReleaseAssetStateOpen
	default:
		*s = ReleaseAssetState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReleaseAssetState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseAssetState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepoSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepoSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("pushed_at")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepoSearchResultItem = [85]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "created_at",
	11: "updated_at",
	12: "pushed_at",
	13: "homepage",
	14: "size",
	15: "stargazers_count",
	16: "watchers_count",
	17: "language",
	18: "forks_count",
	19: "open_issues_count",
	20: "master_branch",
	21: "default_branch",
	22: "score",
	23: "forks_url",
	24: "keys_url",
	25: "collaborators_url",
	26: "teams_url",
	27: "hooks_url",
	28: "issue_events_url",
	29: "events_url",
	30: "assignees_url",
	31: "branches_url",
	32: "tags_url",
	33: "blobs_url",
	34: "git_tags_url",
	35: "git_refs_url",
	36: "trees_url",
	37: "statuses_url",
	38: "languages_url",
	39: "stargazers_url",
	40: "contributors_url",
	41: "subscribers_url",
	42: "subscription_url",
	43: "commits_url",
	44: "git_commits_url",
	45: "comments_url",
	46: "issue_comment_url",
	47: "contents_url",
	48: "compare_url",
	49: "merges_url",
	50: "archive_url",
	51: "downloads_url",
	52: "issues_url",
	53: "pulls_url",
	54: "milestones_url",
	55: "notifications_url",
	56: "labels_url",
	57: "releases_url",
	58: "deployments_url",
	59: "git_url",
	60: "ssh_url",
	61: "clone_url",
	62: "svn_url",
	63: "forks",
	64: "open_issues",
	65: "watchers",
	66: "topics",
	67: "mirror_url",
	68: "has_issues",
	69: "has_projects",
	70: "has_pages",
	71: "has_wiki",
	72: "has_downloads",
	73: "archived",
	74: "disabled",
	75: "license",
	76: "permissions",
	77: "text_matches",
	78: "temp_clone_token",
	79: "allow_merge_commit",
	80: "allow_squash_merge",
	81: "allow_rebase_merge",
	82: "allow_auto_merge",
	83: "delete_branch_on_merge",
	84: "allow_forking",
}

// Decode decodes RepoSearchResultItem from json.
func (s *RepoSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepoSearchResultItem to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "pushed_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "homepage":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "size":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "stargazers_count":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "language":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "open_issues_count":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "default_branch":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "score":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "collaborators_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "teams_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "hooks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "assignees_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "branches_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "tags_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "blobs_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_refs_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "trees_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "contributors_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "commits_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "git_commits_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "comments_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "contents_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "compare_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "merges_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "archive_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "downloads_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "issues_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "pulls_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "milestones_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "labels_url":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "releases_url":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "deployments_url":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "git_url":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "ssh_url":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "clone_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "svn_url":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "forks":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "mirror_url":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_downloads":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "license":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepoSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepoSearchResultItem) {
					name = jsonFieldsNameOfRepoSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepoSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepoSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepoSearchResultItemPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepoSearchResultItemPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
}

var jsonFieldsNameOfRepoSearchResultItemPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (s *RepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepoSearchResultItemPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepoSearchResultItemPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepoSearchResultItemPermissions) {
					name = jsonFieldsNameOfRepoSearchResultItemPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepoSearchResultItemPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepoSearchResultItemPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAcceptInvitationConflict as json.
func (s *ReposAcceptInvitationConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationConflict from json.
func (s *ReposAcceptInvitationConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAcceptInvitationConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAcceptInvitationConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAcceptInvitationForbidden as json.
func (s *ReposAcceptInvitationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationForbidden from json.
func (s *ReposAcceptInvitationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAcceptInvitationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAcceptInvitationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAcceptInvitationNotFound as json.
func (s *ReposAcceptInvitationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationNotFound from json.
func (s *ReposAcceptInvitationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAcceptInvitationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAcceptInvitationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Integration(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposAddAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = make([]Integration, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddAppAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddAppAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (s ReposAddAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq:
		s.ReposAddAppAccessRestrictionsReq0.Encode(e)
	case StringArrayReposAddAppAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (s *ReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposAddAppAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposAddAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposAddAppAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposAddAppAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apps")
		e.ArrStart()
		for _, elem := range s.Apps {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposAddAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposAddAppAccessRestrictionsReq0 from json.
func (s *ReposAddAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddAppAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddAppAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposAddCollaboratorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposAddCollaboratorReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposAddCollaboratorReq = [2]string{
	0: "permission",
	1: "permissions",
}

// Decode decodes ReposAddCollaboratorReq from json.
func (s *ReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddCollaboratorReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddCollaboratorReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddCollaboratorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddCollaboratorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (s ReposAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (s *ReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddCollaboratorReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposAddCollaboratorReqPermission(v) {
	case ReposAddCollaboratorReqPermissionPull:
		*s = ReposAddCollaboratorReqPermissionPull
	case ReposAddCollaboratorReqPermissionPush:
		*s = ReposAddCollaboratorReqPermissionPush
	case ReposAddCollaboratorReqPermissionAdmin:
		*s = ReposAddCollaboratorReqPermissionAdmin
	case ReposAddCollaboratorReqPermissionMaintain:
		*s = ReposAddCollaboratorReqPermissionMaintain
	case ReposAddCollaboratorReqPermissionTriage:
		*s = ReposAddCollaboratorReqPermissionTriage
	default:
		*s = ReposAddCollaboratorReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddCollaboratorReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddCollaboratorReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddStatusCheckContextsForbidden as json.
func (s *ReposAddStatusCheckContextsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsForbidden from json.
func (s *ReposAddStatusCheckContextsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddStatusCheckContextsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddStatusCheckContextsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddStatusCheckContextsNotFound as json.
func (s *ReposAddStatusCheckContextsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsNotFound from json.
func (s *ReposAddStatusCheckContextsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddStatusCheckContextsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddStatusCheckContextsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddStatusCheckContextsOKApplicationJSON as json.
func (s ReposAddStatusCheckContextsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ReposAddStatusCheckContextsOKApplicationJSON from json.
func (s *ReposAddStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddStatusCheckContextsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddStatusCheckContextsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (s ReposAddStatusCheckContextsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq:
		s.ReposAddStatusCheckContextsReq0.Encode(e)
	case StringArrayReposAddStatusCheckContextsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (s *ReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposAddStatusCheckContextsReq
	case jx.Object:
		if err := s.ReposAddStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposAddStatusCheckContextsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposAddStatusCheckContextsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposAddStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposAddStatusCheckContextsReq0 from json.
func (s *ReposAddStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposAddStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddStatusCheckContextsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddStatusCheckContextsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposAddTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = make([]Team, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddTeamAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddTeamAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (s ReposAddTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq:
		s.ReposAddTeamAccessRestrictionsReq0.Encode(e)
	case StringArrayReposAddTeamAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (s *ReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposAddTeamAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposAddTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposAddTeamAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposAddTeamAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposAddTeamAccessRestrictionsReq0 from json.
func (s *ReposAddTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddTeamAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddTeamAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposAddUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddUserAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddUserAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (s ReposAddUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq:
		s.ReposAddUserAccessRestrictionsReq0.Encode(e)
	case StringArrayReposAddUserAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (s *ReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposAddUserAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposAddUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposAddUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposAddUserAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposAddUserAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposAddUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposAddUserAccessRestrictionsReq0 from json.
func (s *ReposAddUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposAddUserAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposAddUserAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCompareCommitsInternalServerError as json.
func (s *ReposCompareCommitsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsInternalServerError from json.
func (s *ReposCompareCommitsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCompareCommitsInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCompareCommitsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCompareCommitsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCompareCommitsNotFound as json.
func (s *ReposCompareCommitsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsNotFound from json.
func (s *ReposCompareCommitsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCompareCommitsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCompareCommitsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCompareCommitsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateAutolinkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateAutolinkReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key_prefix")
		e.Str(s.KeyPrefix)
	}
	{
		e.FieldStart("url_template")
		e.Str(s.URLTemplate)
	}
}

var jsonFieldsNameOfReposCreateAutolinkReq = [2]string{
	0: "key_prefix",
	1: "url_template",
}

// Decode decodes ReposCreateAutolinkReq from json.
func (s *ReposCreateAutolinkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateAutolinkReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_prefix":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyPrefix = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_prefix\"")
			}
		case "url_template":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URLTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateAutolinkReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateAutolinkReq) {
					name = jsonFieldsNameOfReposCreateAutolinkReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateAutolinkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateAutolinkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateCommitCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.FieldStart("line")
			s.Line.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateCommitCommentReq = [4]string{
	0: "body",
	1: "path",
	2: "position",
	3: "line",
}

// Decode decodes ReposCreateCommitCommentReq from json.
func (s *ReposCreateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateCommitCommentReq) {
					name = jsonFieldsNameOfReposCreateCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateCommitCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateCommitCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateCommitStatusReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateCommitStatusReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.FieldStart("target_url")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateCommitStatusReq = [4]string{
	0: "state",
	1: "target_url",
	2: "description",
	3: "context",
}

// Decode decodes ReposCreateCommitStatusReq from json.
func (s *ReposCreateCommitStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitStatusReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "target_url":
			if err := func() error {
				s.TargetURL.Reset()
				if err := s.TargetURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateCommitStatusReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateCommitStatusReq) {
					name = jsonFieldsNameOfReposCreateCommitStatusReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateCommitStatusReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateCommitStatusReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateCommitStatusReqState as json.
func (s ReposCreateCommitStatusReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateCommitStatusReqState from json.
func (s *ReposCreateCommitStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitStatusReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateCommitStatusReqState(v) {
	case ReposCreateCommitStatusReqStateError:
		*s = ReposCreateCommitStatusReqStateError
	case ReposCreateCommitStatusReqStateFailure:
		*s = ReposCreateCommitStatusReqStateFailure
	case ReposCreateCommitStatusReqStatePending:
		*s = ReposCreateCommitStatusReqStatePending
	case ReposCreateCommitStatusReqStateSuccess:
		*s = ReposCreateCommitStatusReqStateSuccess
	default:
		*s = ReposCreateCommitStatusReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateCommitStatusReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateCommitStatusReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateDeployKeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateDeployKeyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("read_only")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateDeployKeyReq = [3]string{
	0: "title",
	1: "key",
	2: "read_only",
}

// Decode decodes ReposCreateDeployKeyReq from json.
func (s *ReposCreateDeployKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeployKeyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "read_only":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeployKeyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeployKeyReq) {
					name = jsonFieldsNameOfReposCreateDeployKeyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateDeployKeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeployKeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateDeploymentAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateDeploymentAccepted) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateDeploymentAccepted = [1]string{
	0: "message",
}

// Decode decodes ReposCreateDeploymentAccepted from json.
func (s *ReposCreateDeploymentAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateDeploymentAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateDeploymentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateDeploymentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		if s.Task.Set {
			e.FieldStart("task")
			s.Task.Encode(e)
		}
	}
	{
		if s.AutoMerge.Set {
			e.FieldStart("auto_merge")
			s.AutoMerge.Encode(e)
		}
	}
	{
		if s.RequiredContexts != nil {
			e.FieldStart("required_contexts")
			e.ArrStart()
			for _, elem := range s.RequiredContexts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Payload.Set {
			e.FieldStart("payload")
			s.Payload.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TransientEnvironment.Set {
			e.FieldStart("transient_environment")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.FieldStart("production_environment")
			s.ProductionEnvironment.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateDeploymentReq = [9]string{
	0: "ref",
	1: "task",
	2: "auto_merge",
	3: "required_contexts",
	4: "payload",
	5: "environment",
	6: "description",
	7: "transient_environment",
	8: "production_environment",
}

// Decode decodes ReposCreateDeploymentReq from json.
func (s *ReposCreateDeploymentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "task":
			if err := func() error {
				s.Task.Reset()
				if err := s.Task.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "auto_merge":
			if err := func() error {
				s.AutoMerge.Reset()
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "required_contexts":
			if err := func() error {
				s.RequiredContexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredContexts = append(s.RequiredContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_contexts\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeploymentReq) {
					name = jsonFieldsNameOfReposCreateDeploymentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateDeploymentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (s ReposCreateDeploymentReqPayload) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload:
		s.ReposCreateDeploymentReqPayload0.Encode(e)
	case StringReposCreateDeploymentReqPayload:
		e.Str(s.String)
	}
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (s *ReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReqPayload to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposCreateDeploymentReqPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringReposCreateDeploymentReqPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateDeploymentReqPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentReqPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentReqPayload0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ReposCreateDeploymentReqPayload0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ReposCreateDeploymentReqPayload0 from json.
func (s *ReposCreateDeploymentReqPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReqPayload0 to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentReqPayload0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateDeploymentReqPayload0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentReqPayload0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateDeploymentStatusReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateDeploymentStatusReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.FieldStart("target_url")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.FieldStart("log_url")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		if s.EnvironmentURL.Set {
			e.FieldStart("environment_url")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.AutoInactive.Set {
			e.FieldStart("auto_inactive")
			s.AutoInactive.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateDeploymentStatusReq = [7]string{
	0: "state",
	1: "target_url",
	2: "log_url",
	3: "description",
	4: "environment",
	5: "environment_url",
	6: "auto_inactive",
}

// Decode decodes ReposCreateDeploymentStatusReq from json.
func (s *ReposCreateDeploymentStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "target_url":
			if err := func() error {
				s.TargetURL.Reset()
				if err := s.TargetURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "log_url":
			if err := func() error {
				s.LogURL.Reset()
				if err := s.LogURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "environment_url":
			if err := func() error {
				s.EnvironmentURL.Reset()
				if err := s.EnvironmentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_url\"")
			}
		case "auto_inactive":
			if err := func() error {
				s.AutoInactive.Reset()
				if err := s.AutoInactive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_inactive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentStatusReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeploymentStatusReq) {
					name = jsonFieldsNameOfReposCreateDeploymentStatusReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateDeploymentStatusReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentStatusReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (s ReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (s *ReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReqEnvironment to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqEnvironment(v) {
	case ReposCreateDeploymentStatusReqEnvironmentProduction:
		*s = ReposCreateDeploymentStatusReqEnvironmentProduction
	case ReposCreateDeploymentStatusReqEnvironmentStaging:
		*s = ReposCreateDeploymentStatusReqEnvironmentStaging
	case ReposCreateDeploymentStatusReqEnvironmentQa:
		*s = ReposCreateDeploymentStatusReqEnvironmentQa
	default:
		*s = ReposCreateDeploymentStatusReqEnvironment(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateDeploymentStatusReqEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentStatusReqEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateDeploymentStatusReqState as json.
func (s ReposCreateDeploymentStatusReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqState from json.
func (s *ReposCreateDeploymentStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqState(v) {
	case ReposCreateDeploymentStatusReqStateError:
		*s = ReposCreateDeploymentStatusReqStateError
	case ReposCreateDeploymentStatusReqStateFailure:
		*s = ReposCreateDeploymentStatusReqStateFailure
	case ReposCreateDeploymentStatusReqStateInactive:
		*s = ReposCreateDeploymentStatusReqStateInactive
	case ReposCreateDeploymentStatusReqStateInProgress:
		*s = ReposCreateDeploymentStatusReqStateInProgress
	case ReposCreateDeploymentStatusReqStateQueued:
		*s = ReposCreateDeploymentStatusReqStateQueued
	case ReposCreateDeploymentStatusReqStatePending:
		*s = ReposCreateDeploymentStatusReqStatePending
	case ReposCreateDeploymentStatusReqStateSuccess:
		*s = ReposCreateDeploymentStatusReqStateSuccess
	default:
		*s = ReposCreateDeploymentStatusReqState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateDeploymentStatusReqState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDeploymentStatusReqState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateDispatchEventReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateDispatchEventReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		e.Str(s.EventType)
	}
	{
		if s.ClientPayload.Set {
			e.FieldStart("client_payload")
			s.ClientPayload.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateDispatchEventReq = [2]string{
	0: "event_type",
	1: "client_payload",
}

// Decode decodes ReposCreateDispatchEventReq from json.
func (s *ReposCreateDispatchEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDispatchEventReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "client_payload":
			if err := func() error {
				s.ClientPayload.Reset()
				if err := s.ClientPayload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDispatchEventReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDispatchEventReq) {
					name = jsonFieldsNameOfReposCreateDispatchEventReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateDispatchEventReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDispatchEventReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (s *ReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDispatchEventReqClientPayload to nil")
	}
	m := s.init()
	var propertiesCount int
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		propertiesCount++
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDispatchEventReqClientPayload")
	}
	// Validate properties count.
	if err := (validate.Object{
		MinProperties:    0,
		MinPropertiesSet: false,
		MaxProperties:    10,
		MaxPropertiesSet: true,
	}).ValidateProperties(propertiesCount); err != nil {
		return errors.Wrap(err, "object")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateDispatchEventReqClientPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForAuthenticatedUserBadRequest as json.
func (s *ReposCreateForAuthenticatedUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserBadRequest from json.
func (s *ReposCreateForAuthenticatedUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForAuthenticatedUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForAuthenticatedUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForAuthenticatedUserForbidden as json.
func (s *ReposCreateForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserForbidden from json.
func (s *ReposCreateForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForAuthenticatedUserNotFound as json.
func (s *ReposCreateForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserNotFound from json.
func (s *ReposCreateForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateForAuthenticatedUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.FieldStart("team_id")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.FieldStart("auto_init")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.FieldStart("gitignore_template")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.FieldStart("license_template")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.FieldStart("has_downloads")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateForAuthenticatedUserReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "has_issues",
	5:  "has_projects",
	6:  "has_wiki",
	7:  "team_id",
	8:  "auto_init",
	9:  "gitignore_template",
	10: "license_template",
	11: "allow_squash_merge",
	12: "allow_merge_commit",
	13: "allow_rebase_merge",
	14: "allow_auto_merge",
	15: "delete_branch_on_merge",
	16: "has_downloads",
	17: "is_template",
}

// Decode decodes ReposCreateForAuthenticatedUserReq from json.
func (s *ReposCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "auto_init":
			if err := func() error {
				s.AutoInit.Reset()
				if err := s.AutoInit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_init\"")
			}
		case "gitignore_template":
			if err := func() error {
				s.GitignoreTemplate.Reset()
				if err := s.GitignoreTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitignore_template\"")
			}
		case "license_template":
			if err := func() error {
				s.LicenseTemplate.Reset()
				if err := s.LicenseTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_template\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateForAuthenticatedUserReq) {
					name = jsonFieldsNameOfReposCreateForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForAuthenticatedUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForAuthenticatedUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForAuthenticatedUserUnauthorized as json.
func (s *ReposCreateForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserUnauthorized from json.
func (s *ReposCreateForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForkBadRequest as json.
func (s *ReposCreateForkBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkBadRequest from json.
func (s *ReposCreateForkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForkForbidden as json.
func (s *ReposCreateForkForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkForbidden from json.
func (s *ReposCreateForkForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForkForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForkForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateForkNotFound as json.
func (s *ReposCreateForkNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkNotFound from json.
func (s *ReposCreateForkNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForkNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForkNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateForkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateForkReq) encodeFields(e *jx.Encoder) {
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateForkReq = [1]string{
	0: "organization",
}

// Decode decodes ReposCreateForkReq from json.
func (s *ReposCreateForkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateForkReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateForkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateForkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.FieldStart("team_id")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.FieldStart("auto_init")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.FieldStart("gitignore_template")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.FieldStart("license_template")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateInOrgReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "visibility",
	5:  "has_issues",
	6:  "has_projects",
	7:  "has_wiki",
	8:  "is_template",
	9:  "team_id",
	10: "auto_init",
	11: "gitignore_template",
	12: "license_template",
	13: "allow_squash_merge",
	14: "allow_merge_commit",
	15: "allow_rebase_merge",
	16: "allow_auto_merge",
	17: "delete_branch_on_merge",
}

// Decode decodes ReposCreateInOrgReq from json.
func (s *ReposCreateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateInOrgReq to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "auto_init":
			if err := func() error {
				s.AutoInit.Reset()
				if err := s.AutoInit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_init\"")
			}
		case "gitignore_template":
			if err := func() error {
				s.GitignoreTemplate.Reset()
				if err := s.GitignoreTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitignore_template\"")
			}
		case "license_template":
			if err := func() error {
				s.LicenseTemplate.Reset()
				if err := s.LicenseTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_template\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateInOrgReq) {
					name = jsonFieldsNameOfReposCreateInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (s ReposCreateInOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (s *ReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateInOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateInOrgReqVisibility(v) {
	case ReposCreateInOrgReqVisibilityPublic:
		*s = ReposCreateInOrgReqVisibilityPublic
	case ReposCreateInOrgReqVisibilityPrivate:
		*s = ReposCreateInOrgReqVisibilityPrivate
	case ReposCreateInOrgReqVisibilityVisibility:
		*s = ReposCreateInOrgReqVisibilityVisibility
	case ReposCreateInOrgReqVisibilityInternal:
		*s = ReposCreateInOrgReqVisibilityInternal
	default:
		*s = ReposCreateInOrgReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreateInOrgReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateInOrgReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsConflict as json.
func (s *ReposCreateOrUpdateFileContentsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsConflict from json.
func (s *ReposCreateOrUpdateFileContentsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsCreated as json.
func (s *ReposCreateOrUpdateFileContentsCreated) Encode(e *jx.Encoder) {
	unwrapped := (*FileCommit)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsCreated from json.
func (s *ReposCreateOrUpdateFileContentsCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsCreated to nil")
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsNotFound as json.
func (s *ReposCreateOrUpdateFileContentsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsNotFound from json.
func (s *ReposCreateOrUpdateFileContentsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateOrUpdateFileContentsOK as json.
func (s *ReposCreateOrUpdateFileContentsOK) Encode(e *jx.Encoder) {
	unwrapped := (*FileCommit)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsOK from json.
func (s *ReposCreateOrUpdateFileContentsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsOK to nil")
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateOrUpdateFileContentsReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		if s.Sha.Set {
			e.FieldStart("sha")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Branch.Set {
			e.FieldStart("branch")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.FieldStart("committer")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReq = [6]string{
	0: "message",
	1: "content",
	2: "sha",
	3: "branch",
	4: "committer",
	5: "author",
}

// Decode decodes ReposCreateOrUpdateFileContentsReq from json.
func (s *ReposCreateOrUpdateFileContentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "branch":
			if err := func() error {
				s.Branch.Reset()
				if err := s.Branch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReq) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReqAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReqAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReqCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReqCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreatePagesSiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreatePagesSiteReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
}

var jsonFieldsNameOfReposCreatePagesSiteReq = [1]string{
	0: "source",
}

// Decode decodes ReposCreatePagesSiteReq from json.
func (s *ReposCreatePagesSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreatePagesSiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreatePagesSiteReq) {
					name = jsonFieldsNameOfReposCreatePagesSiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreatePagesSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreatePagesSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreatePagesSiteReqSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreatePagesSiteReqSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("branch")
		e.Str(s.Branch)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreatePagesSiteReqSource = [2]string{
	0: "branch",
	1: "path",
}

// Decode decodes ReposCreatePagesSiteReqSource from json.
func (s *ReposCreatePagesSiteReqSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReqSource to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreatePagesSiteReqSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreatePagesSiteReqSource) {
					name = jsonFieldsNameOfReposCreatePagesSiteReqSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreatePagesSiteReqSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreatePagesSiteReqSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (s ReposCreatePagesSiteReqSourcePath) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (s *ReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReqSourcePath to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreatePagesSiteReqSourcePath(v) {
	case ReposCreatePagesSiteReqSourcePathSlash:
		*s = ReposCreatePagesSiteReqSourcePathSlash
	case ReposCreatePagesSiteReqSourcePathSlashDocs:
		*s = ReposCreatePagesSiteReqSourcePathSlashDocs
	default:
		*s = ReposCreatePagesSiteReqSourcePath(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposCreatePagesSiteReqSourcePath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreatePagesSiteReqSourcePath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateReleaseReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag_name")
		e.Str(s.TagName)
	}
	{
		if s.TargetCommitish.Set {
			e.FieldStart("target_commitish")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			e.FieldStart("prerelease")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			e.FieldStart("discussion_category_name")
			s.DiscussionCategoryName.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateReleaseReq = [7]string{
	0: "tag_name",
	1: "target_commitish",
	2: "name",
	3: "body",
	4: "draft",
	5: "prerelease",
	6: "discussion_category_name",
}

// Decode decodes ReposCreateReleaseReq from json.
func (s *ReposCreateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateReleaseReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TagName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			if err := func() error {
				s.TargetCommitish.Reset()
				if err := s.TargetCommitish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			if err := func() error {
				s.Prerelease.Reset()
				if err := s.Prerelease.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "discussion_category_name":
			if err := func() error {
				s.DiscussionCategoryName.Reset()
				if err := s.DiscussionCategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_category_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateReleaseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateReleaseReq) {
					name = jsonFieldsNameOfReposCreateReleaseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateReleaseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateReleaseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateUsingTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateUsingTemplateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IncludeAllBranches.Set {
			e.FieldStart("include_all_branches")
			s.IncludeAllBranches.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateUsingTemplateReq = [5]string{
	0: "owner",
	1: "name",
	2: "description",
	3: "include_all_branches",
	4: "private",
}

// Decode decodes ReposCreateUsingTemplateReq from json.
func (s *ReposCreateUsingTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateUsingTemplateReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "include_all_branches":
			if err := func() error {
				s.IncludeAllBranches.Reset()
				if err := s.IncludeAllBranches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_all_branches\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateUsingTemplateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateUsingTemplateReq) {
					name = jsonFieldsNameOfReposCreateUsingTemplateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateUsingTemplateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateUsingTemplateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateWebhookForbidden as json.
func (s *ReposCreateWebhookForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookForbidden from json.
func (s *ReposCreateWebhookForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateWebhookForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateWebhookForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposCreateWebhookNotFound as json.
func (s *ReposCreateWebhookNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookNotFound from json.
func (s *ReposCreateWebhookNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateWebhookNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateWebhookNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateWebhookReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateWebhookReq = [4]string{
	0: "name",
	1: "config",
	2: "events",
	3: "active",
}

// Decode decodes ReposCreateWebhookReq from json.
func (s *ReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateWebhookReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposCreateWebhookReqConfig) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			e.FieldStart("digest")
			s.Digest.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposCreateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "token",
	5: "digest",
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (s *ReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookReqConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "digest":
			if err := func() error {
				s.Digest.Reset()
				if err := s.Digest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateWebhookReqConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposCreateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposCreateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeclineInvitationConflict as json.
func (s *ReposDeclineInvitationConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationConflict from json.
func (s *ReposDeclineInvitationConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeclineInvitationConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeclineInvitationConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeclineInvitationForbidden as json.
func (s *ReposDeclineInvitationForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationForbidden from json.
func (s *ReposDeclineInvitationForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeclineInvitationForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeclineInvitationForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeclineInvitationNotFound as json.
func (s *ReposDeclineInvitationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationNotFound from json.
func (s *ReposDeclineInvitationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeclineInvitationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeclineInvitationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteFileConflict as json.
func (s *ReposDeleteFileConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileConflict from json.
func (s *ReposDeleteFileConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteFileConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteFileConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteFileNotFound as json.
func (s *ReposDeleteFileNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileNotFound from json.
func (s *ReposDeleteFileNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteFileNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteFileNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposDeleteFileReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposDeleteFileReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		if s.Branch.Set {
			e.FieldStart("branch")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.FieldStart("committer")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposDeleteFileReq = [5]string{
	0: "message",
	1: "sha",
	2: "branch",
	3: "committer",
	4: "author",
}

// Decode decodes ReposDeleteFileReq from json.
func (s *ReposDeleteFileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "branch":
			if err := func() error {
				s.Branch.Reset()
				if err := s.Branch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposDeleteFileReq) {
					name = jsonFieldsNameOfReposDeleteFileReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteFileReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteFileReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposDeleteFileReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposDeleteFileReqAuthor) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposDeleteFileReqAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (s *ReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReqAuthor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReqAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteFileReqAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteFileReqAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposDeleteFileReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposDeleteFileReqCommitter) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposDeleteFileReqCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (s *ReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReqCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReqCommitter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteFileReqCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteFileReqCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposDeleteForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposDeleteForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposDeleteForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes ReposDeleteForbidden from json.
func (s *ReposDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteNotFound as json.
func (s *ReposDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteNotFound from json.
func (s *ReposDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposDeleteTemporaryRedirect as json.
func (s *ReposDeleteTemporaryRedirect) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteTemporaryRedirect from json.
func (s *ReposDeleteTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteTemporaryRedirect to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteTemporaryRedirect(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposDeleteTemporaryRedirect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposDeleteTemporaryRedirect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetAllStatusCheckContextsOKApplicationJSON as json.
func (s ReposGetAllStatusCheckContextsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAllStatusCheckContextsOKApplicationJSON from json.
func (s *ReposGetAllStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetAllStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAllStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetAllStatusCheckContextsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetAllStatusCheckContextsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Integration(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = make([]Integration, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetBranchMovedPermanently as json.
func (s *ReposGetBranchMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchMovedPermanently from json.
func (s *ReposGetBranchMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetBranchMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetBranchMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetBranchMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetBranchNotFound as json.
func (s *ReposGetBranchNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchNotFound from json.
func (s *ReposGetBranchNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetBranchNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetBranchNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetBranchNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetCodeFrequencyStatsOKApplicationJSON as json.
func (s ReposGetCodeFrequencyStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeFrequencyStat(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCodeFrequencyStatsOKApplicationJSON from json.
func (s *ReposGetCodeFrequencyStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCodeFrequencyStatsOKApplicationJSON to nil")
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = make([]CodeFrequencyStat, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCodeFrequencyStatsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetCodeFrequencyStatsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetCodeFrequencyStatsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetCommitActivityStatsOKApplicationJSON as json.
func (s ReposGetCommitActivityStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CommitActivity(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCommitActivityStatsOKApplicationJSON from json.
func (s *ReposGetCommitActivityStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitActivityStatsOKApplicationJSON to nil")
	}
	var unwrapped []CommitActivity
	if err := func() error {
		unwrapped = make([]CommitActivity, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CommitActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitActivityStatsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetCommitActivityStatsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetCommitActivityStatsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetCommitInternalServerError as json.
func (s *ReposGetCommitInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitInternalServerError from json.
func (s *ReposGetCommitInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetCommitInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetCommitInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetCommitNotFound as json.
func (s *ReposGetCommitNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitNotFound from json.
func (s *ReposGetCommitNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetCommitNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetCommitNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetContributorsStatsOKApplicationJSON as json.
func (s ReposGetContributorsStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ContributorActivity(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetContributorsStatsOKApplicationJSON from json.
func (s *ReposGetContributorsStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetContributorsStatsOKApplicationJSON to nil")
	}
	var unwrapped []ContributorActivity
	if err := func() error {
		unwrapped = make([]ContributorActivity, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContributorActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetContributorsStatsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetContributorsStatsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetContributorsStatsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetForbidden as json.
func (s *ReposGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetForbidden from json.
func (s *ReposGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetMovedPermanently as json.
func (s *ReposGetMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetMovedPermanently from json.
func (s *ReposGetMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetMovedPermanently(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetMovedPermanently) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetMovedPermanently) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetNotFound as json.
func (s *ReposGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposGetNotFound from json.
func (s *ReposGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetPunchCardStatsOKApplicationJSON as json.
func (s ReposGetPunchCardStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeFrequencyStat(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetPunchCardStatsOKApplicationJSON from json.
func (s *ReposGetPunchCardStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetPunchCardStatsOKApplicationJSON to nil")
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = make([]CodeFrequencyStat, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetPunchCardStatsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetPunchCardStatsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetPunchCardStatsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = make([]Team, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetTopPathsOKApplicationJSON as json.
func (s ReposGetTopPathsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ContentTraffic(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopPathsOKApplicationJSON from json.
func (s *ReposGetTopPathsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTopPathsOKApplicationJSON to nil")
	}
	var unwrapped []ContentTraffic
	if err := func() error {
		unwrapped = make([]ContentTraffic, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContentTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopPathsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetTopPathsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetTopPathsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetTopReferrersOKApplicationJSON as json.
func (s ReposGetTopReferrersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ReferrerTraffic(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopReferrersOKApplicationJSON from json.
func (s *ReposGetTopReferrersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTopReferrersOKApplicationJSON to nil")
	}
	var unwrapped []ReferrerTraffic
	if err := func() error {
		unwrapped = make([]ReferrerTraffic, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReferrerTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopReferrersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetTopReferrersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetTopReferrersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListBranchesForHeadCommitOKApplicationJSON as json.
func (s ReposListBranchesForHeadCommitOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []BranchShort(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesForHeadCommitOKApplicationJSON from json.
func (s *ReposListBranchesForHeadCommitOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListBranchesForHeadCommitOKApplicationJSON to nil")
	}
	var unwrapped []BranchShort
	if err := func() error {
		unwrapped = make([]BranchShort, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BranchShort
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesForHeadCommitOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposListBranchesForHeadCommitOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListBranchesForHeadCommitOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListCommitsBadRequest as json.
func (s *ReposListCommitsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsBadRequest from json.
func (s *ReposListCommitsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListCommitsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListCommitsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListCommitsConflict as json.
func (s *ReposListCommitsConflict) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsConflict from json.
func (s *ReposListCommitsConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListCommitsConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListCommitsConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListCommitsInternalServerError as json.
func (s *ReposListCommitsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsInternalServerError from json.
func (s *ReposListCommitsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListCommitsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListCommitsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListCommitsNotFound as json.
func (s *ReposListCommitsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsNotFound from json.
func (s *ReposListCommitsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListCommitsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListCommitsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListContributorsForbidden as json.
func (s *ReposListContributorsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsForbidden from json.
func (s *ReposListContributorsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListContributorsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListContributorsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListContributorsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListContributorsNotFound as json.
func (s *ReposListContributorsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsNotFound from json.
func (s *ReposListContributorsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListContributorsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListContributorsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListContributorsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListForAuthenticatedUserForbidden as json.
func (s *ReposListForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserForbidden from json.
func (s *ReposListForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Repository(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = make([]Repository, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposListForAuthenticatedUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListForAuthenticatedUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListForAuthenticatedUserUnauthorized as json.
func (s *ReposListForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserUnauthorized from json.
func (s *ReposListForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListInvitationsForAuthenticatedUserForbidden as json.
func (s *ReposListInvitationsForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserForbidden from json.
func (s *ReposListInvitationsForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListInvitationsForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListInvitationsForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListInvitationsForAuthenticatedUserNotFound as json.
func (s *ReposListInvitationsForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserNotFound from json.
func (s *ReposListInvitationsForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListInvitationsForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListInvitationsForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListInvitationsForAuthenticatedUserUnauthorized as json.
func (s *ReposListInvitationsForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserUnauthorized from json.
func (s *ReposListInvitationsForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposListInvitationsForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListInvitationsForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposListWebhookDeliveriesOKApplicationJSON as json.
func (s ReposListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HookDeliveryItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhookDeliveriesOKApplicationJSON from json.
func (s *ReposListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = make([]HookDeliveryItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposListWebhookDeliveriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposListWebhookDeliveriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposMergeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposMergeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("base")
		e.Str(s.Base)
	}
	{
		e.FieldStart("head")
		e.Str(s.Head)
	}
	{
		if s.CommitMessage.Set {
			e.FieldStart("commit_message")
			s.CommitMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposMergeReq = [3]string{
	0: "base",
	1: "head",
	2: "commit_message",
}

// Decode decodes ReposMergeReq from json.
func (s *ReposMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposMergeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Base = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Head = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "commit_message":
			if err := func() error {
				s.CommitMessage.Reset()
				if err := s.CommitMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposMergeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposMergeReq) {
					name = jsonFieldsNameOfReposMergeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposMergeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposMergeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposMergeUpstreamReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposMergeUpstreamReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("branch")
		e.Str(s.Branch)
	}
}

var jsonFieldsNameOfReposMergeUpstreamReq = [1]string{
	0: "branch",
}

// Decode decodes ReposMergeUpstreamReq from json.
func (s *ReposMergeUpstreamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposMergeUpstreamReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposMergeUpstreamReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposMergeUpstreamReq) {
					name = jsonFieldsNameOfReposMergeUpstreamReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposMergeUpstreamReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposMergeUpstreamReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Integration(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = make([]Integration, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveAppAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveAppAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (s ReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq:
		s.ReposRemoveAppAccessRestrictionsReq0.Encode(e)
	case StringArrayReposRemoveAppAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (s *ReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposRemoveAppAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposRemoveAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposRemoveAppAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposRemoveAppAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apps")
		e.ArrStart()
		for _, elem := range s.Apps {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq0 from json.
func (s *ReposRemoveAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRemoveAppAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveAppAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveStatusCheckContextsOKApplicationJSON as json.
func (s ReposRemoveStatusCheckContextsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveStatusCheckContextsOKApplicationJSON from json.
func (s *ReposRemoveStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveStatusCheckContextsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveStatusCheckContextsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (s ReposRemoveStatusCheckContextsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq:
		s.ReposRemoveStatusCheckContextsReq0.Encode(e)
	case StringArrayReposRemoveStatusCheckContextsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (s *ReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposRemoveStatusCheckContextsReq
	case jx.Object:
		if err := s.ReposRemoveStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposRemoveStatusCheckContextsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposRemoveStatusCheckContextsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposRemoveStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposRemoveStatusCheckContextsReq0 from json.
func (s *ReposRemoveStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposRemoveStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRemoveStatusCheckContextsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveStatusCheckContextsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = make([]Team, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveTeamAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveTeamAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (s ReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq:
		s.ReposRemoveTeamAccessRestrictionsReq0.Encode(e)
	case StringArrayReposRemoveTeamAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (s *ReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposRemoveTeamAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposRemoveTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposRemoveTeamAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposRemoveTeamAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq0 from json.
func (s *ReposRemoveTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRemoveTeamAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveTeamAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveUserAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveUserAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (s ReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq:
		s.ReposRemoveUserAccessRestrictionsReq0.Encode(e)
	case StringArrayReposRemoveUserAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (s *ReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposRemoveUserAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposRemoveUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposRemoveUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposRemoveUserAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposRemoveUserAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq0 from json.
func (s *ReposRemoveUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRemoveUserAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRemoveUserAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRenameBranchForbidden as json.
func (s *ReposRenameBranchForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchForbidden from json.
func (s *ReposRenameBranchForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRenameBranchForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRenameBranchForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposRenameBranchNotFound as json.
func (s *ReposRenameBranchNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchNotFound from json.
func (s *ReposRenameBranchNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRenameBranchNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRenameBranchNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposRenameBranchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposRenameBranchReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("new_name")
		e.Str(s.NewName)
	}
}

var jsonFieldsNameOfReposRenameBranchReq = [1]string{
	0: "new_name",
}

// Decode decodes ReposRenameBranchReq from json.
func (s *ReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRenameBranchReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRenameBranchReq) {
					name = jsonFieldsNameOfReposRenameBranchReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposRenameBranchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposRenameBranchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposReplaceAllTopicsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposReplaceAllTopicsReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("names")
		e.ArrStart()
		for _, elem := range s.Names {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposReplaceAllTopicsReq = [1]string{
	0: "names",
}

// Decode decodes ReposReplaceAllTopicsReq from json.
func (s *ReposReplaceAllTopicsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposReplaceAllTopicsReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposReplaceAllTopicsReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposReplaceAllTopicsReq) {
					name = jsonFieldsNameOfReposReplaceAllTopicsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposReplaceAllTopicsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposReplaceAllTopicsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Integration(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposSetAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = make([]Integration, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetAppAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetAppAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (s ReposSetAppAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq:
		s.ReposSetAppAccessRestrictionsReq0.Encode(e)
	case StringArrayReposSetAppAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (s *ReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposSetAppAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposSetAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetAppAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetAppAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposSetAppAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposSetAppAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apps")
		e.ArrStart()
		for _, elem := range s.Apps {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposSetAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposSetAppAccessRestrictionsReq0 from json.
func (s *ReposSetAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposSetAppAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetAppAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetStatusCheckContextsOKApplicationJSON as json.
func (s ReposSetStatusCheckContextsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ReposSetStatusCheckContextsOKApplicationJSON from json.
func (s *ReposSetStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetStatusCheckContextsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetStatusCheckContextsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (s ReposSetStatusCheckContextsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq:
		s.ReposSetStatusCheckContextsReq0.Encode(e)
	case StringArrayReposSetStatusCheckContextsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (s *ReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposSetStatusCheckContextsReq
	case jx.Object:
		if err := s.ReposSetStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetStatusCheckContextsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetStatusCheckContextsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposSetStatusCheckContextsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposSetStatusCheckContextsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposSetStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposSetStatusCheckContextsReq0 from json.
func (s *ReposSetStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposSetStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposSetStatusCheckContextsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetStatusCheckContextsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposSetTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = make([]Team, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetTeamAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetTeamAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (s ReposSetTeamAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq:
		s.ReposSetTeamAccessRestrictionsReq0.Encode(e)
	case StringArrayReposSetTeamAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (s *ReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposSetTeamAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposSetTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetTeamAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetTeamAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposSetTeamAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposSetTeamAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposSetTeamAccessRestrictionsReq0 from json.
func (s *ReposSetTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposSetTeamAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetTeamAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposSetUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetUserAccessRestrictionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetUserAccessRestrictionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (s ReposSetUserAccessRestrictionsReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq:
		s.ReposSetUserAccessRestrictionsReq0.Encode(e)
	case StringArrayReposSetUserAccessRestrictionsReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (s *ReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayReposSetUserAccessRestrictionsReq
	case jx.Object:
		if err := s.ReposSetUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposSetUserAccessRestrictionsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetUserAccessRestrictionsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposSetUserAccessRestrictionsReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposSetUserAccessRestrictionsReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposSetUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposSetUserAccessRestrictionsReq0 from json.
func (s *ReposSetUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposSetUserAccessRestrictionsReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposSetUserAccessRestrictionsReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposTransferReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposTransferReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("new_owner")
		e.Str(s.NewOwner)
	}
	{
		if s.TeamIds != nil {
			e.FieldStart("team_ids")
			e.ArrStart()
			for _, elem := range s.TeamIds {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReposTransferReq = [2]string{
	0: "new_owner",
	1: "team_ids",
}

// Decode decodes ReposTransferReq from json.
func (s *ReposTransferReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposTransferReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_owner":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewOwner = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_owner\"")
			}
		case "team_ids":
			if err := func() error {
				s.TeamIds = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.TeamIds = append(s.TeamIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposTransferReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposTransferReq) {
					name = jsonFieldsNameOfReposTransferReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposTransferReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposTransferReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionForbidden as json.
func (s *ReposUpdateBranchProtectionForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionForbidden from json.
func (s *ReposUpdateBranchProtectionForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateBranchProtectionNotFound as json.
func (s *ReposUpdateBranchProtectionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionNotFound from json.
func (s *ReposUpdateBranchProtectionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateBranchProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateBranchProtectionReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("required_status_checks")
		s.RequiredStatusChecks.Encode(e)
	}
	{
		e.FieldStart("enforce_admins")
		s.EnforceAdmins.Encode(e)
	}
	{
		e.FieldStart("required_pull_request_reviews")
		s.RequiredPullRequestReviews.Encode(e)
	}
	{
		e.FieldStart("restrictions")
		s.Restrictions.Encode(e)
	}
	{
		if s.RequiredLinearHistory.Set {
			e.FieldStart("required_linear_history")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.FieldStart("allow_force_pushes")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.FieldStart("allow_deletions")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.FieldStart("required_conversation_resolution")
			s.RequiredConversationResolution.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateBranchProtectionReq = [8]string{
	0: "required_status_checks",
	1: "enforce_admins",
	2: "required_pull_request_reviews",
	3: "restrictions",
	4: "required_linear_history",
	5: "allow_force_pushes",
	6: "allow_deletions",
	7: "required_conversation_resolution",
}

// Decode decodes ReposUpdateBranchProtectionReq from json.
func (s *ReposUpdateBranchProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required_status_checks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "enforce_admins":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_pull_request_reviews":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "restrictions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReq) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) encodeFields(e *jx.Encoder) {
	{
		if s.DismissalRestrictions.Set {
			e.FieldStart("dismissal_restrictions")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			e.FieldStart("dismiss_stale_reviews")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			e.FieldStart("require_code_owner_reviews")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.FieldStart("required_approving_review_count")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredPullRequestReviews = [4]string{
	0: "dismissal_restrictions",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("strict")
		e.Bool(s.Strict)
	}
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks = [2]string{
	0: "strict",
	1: "contexts",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredStatusChecks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Strict = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredStatusChecks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateBranchProtectionReqRestrictions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Apps != nil {
			e.FieldStart("apps")
			e.ArrStart()
			for _, elem := range s.Apps {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions = [3]string{
	0: "users",
	1: "teams",
	2: "apps",
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRestrictions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "apps":
			if err := func() error {
				s.Apps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRestrictions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateBranchProtectionReqRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateBranchProtectionReqRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateCommitCommentReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfReposUpdateCommitCommentReq = [1]string{
	0: "body",
}

// Decode decodes ReposUpdateCommitCommentReq from json.
func (s *ReposUpdateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateCommitCommentReq) {
					name = jsonFieldsNameOfReposUpdateCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateCommitCommentReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateCommitCommentReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateForbidden as json.
func (s *ReposUpdateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateForbidden from json.
func (s *ReposUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateInvitationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateInvitationReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateInvitationReq = [1]string{
	0: "permissions",
}

// Decode decodes ReposUpdateInvitationReq from json.
func (s *ReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateInvitationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateInvitationReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateInvitationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateInvitationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (s ReposUpdateInvitationReqPermissions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (s *ReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateInvitationReqPermissions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateInvitationReqPermissions(v) {
	case ReposUpdateInvitationReqPermissionsRead:
		*s = ReposUpdateInvitationReqPermissionsRead
	case ReposUpdateInvitationReqPermissionsWrite:
		*s = ReposUpdateInvitationReqPermissionsWrite
	case ReposUpdateInvitationReqPermissionsMaintain:
		*s = ReposUpdateInvitationReqPermissionsMaintain
	case ReposUpdateInvitationReqPermissionsTriage:
		*s = ReposUpdateInvitationReqPermissionsTriage
	case ReposUpdateInvitationReqPermissionsAdmin:
		*s = ReposUpdateInvitationReqPermissionsAdmin
	default:
		*s = ReposUpdateInvitationReqPermissions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposUpdateInvitationReqPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateInvitationReqPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateNotFound as json.
func (s *ReposUpdateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateNotFound from json.
func (s *ReposUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdatePullRequestReviewProtectionReq) encodeFields(e *jx.Encoder) {
	{
		if s.DismissalRestrictions.Set {
			e.FieldStart("dismissal_restrictions")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			e.FieldStart("dismiss_stale_reviews")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			e.FieldStart("require_code_owner_reviews")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.FieldStart("required_approving_review_count")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdatePullRequestReviewProtectionReq = [4]string{
	0: "dismissal_restrictions",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (s *ReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdatePullRequestReviewProtectionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdatePullRequestReviewProtectionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdatePullRequestReviewProtectionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdatePullRequestReviewProtectionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReposUpdatePullRequestReviewProtectionReqDismissalRestrictions = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReleaseAssetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReleaseAssetReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReleaseAssetReq = [3]string{
	0: "name",
	1: "label",
	2: "state",
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (s *ReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReleaseAssetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReleaseAssetReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReleaseAssetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReleaseAssetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReleaseReq) encodeFields(e *jx.Encoder) {
	{
		if s.TagName.Set {
			e.FieldStart("tag_name")
			s.TagName.Encode(e)
		}
	}
	{
		if s.TargetCommitish.Set {
			e.FieldStart("target_commitish")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.FieldStart("draft")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			e.FieldStart("prerelease")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			e.FieldStart("discussion_category_name")
			s.DiscussionCategoryName.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReleaseReq = [7]string{
	0: "tag_name",
	1: "target_commitish",
	2: "name",
	3: "body",
	4: "draft",
	5: "prerelease",
	6: "discussion_category_name",
}

// Decode decodes ReposUpdateReleaseReq from json.
func (s *ReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReleaseReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			if err := func() error {
				s.TagName.Reset()
				if err := s.TagName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			if err := func() error {
				s.TargetCommitish.Reset()
				if err := s.TargetCommitish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			if err := func() error {
				s.Prerelease.Reset()
				if err := s.Prerelease.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "discussion_category_name":
			if err := func() error {
				s.DiscussionCategoryName.Reset()
				if err := s.DiscussionCategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_category_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReleaseReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReleaseReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReleaseReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			e.FieldStart("security_and_analysis")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.FieldStart("default_branch")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "visibility",
	5:  "security_and_analysis",
	6:  "has_issues",
	7:  "has_projects",
	8:  "has_wiki",
	9:  "is_template",
	10: "default_branch",
	11: "allow_squash_merge",
	12: "allow_merge_commit",
	13: "allow_rebase_merge",
	14: "allow_auto_merge",
	15: "delete_branch_on_merge",
	16: "archived",
	17: "allow_forking",
}

// Decode decodes ReposUpdateReq from json.
func (s *ReposUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "security_and_analysis":
			if err := func() error {
				s.SecurityAndAnalysis.Reset()
				if err := s.SecurityAndAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_and_analysis\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReqSecurityAndAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.AdvancedSecurity.Set {
			e.FieldStart("advanced_security")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			e.FieldStart("secret_scanning")
			s.SecretScanning.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysis = [2]string{
	0: "advanced_security",
	1: "secret_scanning",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (s *ReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			if err := func() error {
				s.AdvancedSecurity.Reset()
				if err := s.AdvancedSecurity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advanced_security\"")
			}
		case "secret_scanning":
			if err := func() error {
				s.SecretScanning.Reset()
				if err := s.SecretScanning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReqSecurityAndAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysisAdvancedSecurity = [1]string{
	0: "status",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysisSecretScanning = [1]string{
	0: "status",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysisSecretScanning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysisSecretScanning")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateReqVisibility as json.
func (s ReposUpdateReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (s *ReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateReqVisibility(v) {
	case ReposUpdateReqVisibilityPublic:
		*s = ReposUpdateReqVisibilityPublic
	case ReposUpdateReqVisibilityPrivate:
		*s = ReposUpdateReqVisibilityPrivate
	case ReposUpdateReqVisibilityVisibility:
		*s = ReposUpdateReqVisibilityVisibility
	case ReposUpdateReqVisibilityInternal:
		*s = ReposUpdateReqVisibilityInternal
	default:
		*s = ReposUpdateReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReposUpdateReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateStatusCheckProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateStatusCheckProtectionReq) encodeFields(e *jx.Encoder) {
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.Contexts != nil {
			e.FieldStart("contexts")
			e.ArrStart()
			for _, elem := range s.Contexts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReposUpdateStatusCheckProtectionReq = [2]string{
	0: "strict",
	1: "contexts",
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (s *ReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateStatusCheckProtectionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateStatusCheckProtectionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateStatusCheckProtectionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateStatusCheckProtectionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReposUpdateTemporaryRedirect as json.
func (s *ReposUpdateTemporaryRedirect) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateTemporaryRedirect from json.
func (s *ReposUpdateTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateTemporaryRedirect to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateTemporaryRedirect(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateTemporaryRedirect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateTemporaryRedirect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateWebhookConfigForRepoReq) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateWebhookConfigForRepoReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (s *ReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookConfigForRepoReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookConfigForRepoReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateWebhookConfigForRepoReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateWebhookConfigForRepoReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateWebhookReq) encodeFields(e *jx.Encoder) {
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddEvents != nil {
			e.FieldStart("add_events")
			e.ArrStart()
			for _, elem := range s.AddEvents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveEvents != nil {
			e.FieldStart("remove_events")
			e.ArrStart()
			for _, elem := range s.RemoveEvents {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateWebhookReq = [5]string{
	0: "config",
	1: "events",
	2: "add_events",
	3: "remove_events",
	4: "active",
}

// Decode decodes ReposUpdateWebhookReq from json.
func (s *ReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "add_events":
			if err := func() error {
				s.AddEvents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddEvents = append(s.AddEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_events\"")
			}
		case "remove_events":
			if err := func() error {
				s.RemoveEvents = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveEvents = append(s.RemoveEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateWebhookReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateWebhookReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReposUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReposUpdateWebhookReqConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Room.Set {
			e.FieldStart("room")
			s.Room.Encode(e)
		}
	}
}

var jsonFieldsNameOfReposUpdateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "address",
	5: "room",
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (s *ReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "room":
			if err := func() error {
				s.Room.Reset()
				if err := s.Room.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateWebhookReqConfig) {
					name = jsonFieldsNameOfReposUpdateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReposUpdateWebhookReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReposUpdateWebhookReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Repository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Repository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.FieldStart("starred_at")
			s.StarredAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepository = [90]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "organization",
	6:  "forks",
	7:  "permissions",
	8:  "owner",
	9:  "private",
	10: "html_url",
	11: "description",
	12: "fork",
	13: "url",
	14: "archive_url",
	15: "assignees_url",
	16: "blobs_url",
	17: "branches_url",
	18: "collaborators_url",
	19: "comments_url",
	20: "commits_url",
	21: "compare_url",
	22: "contents_url",
	23: "contributors_url",
	24: "deployments_url",
	25: "downloads_url",
	26: "events_url",
	27: "forks_url",
	28: "git_commits_url",
	29: "git_refs_url",
	30: "git_tags_url",
	31: "git_url",
	32: "issue_comment_url",
	33: "issue_events_url",
	34: "issues_url",
	35: "keys_url",
	36: "labels_url",
	37: "languages_url",
	38: "merges_url",
	39: "milestones_url",
	40: "notifications_url",
	41: "pulls_url",
	42: "releases_url",
	43: "ssh_url",
	44: "stargazers_url",
	45: "statuses_url",
	46: "subscribers_url",
	47: "subscription_url",
	48: "tags_url",
	49: "teams_url",
	50: "trees_url",
	51: "clone_url",
	52: "mirror_url",
	53: "hooks_url",
	54: "svn_url",
	55: "homepage",
	56: "language",
	57: "forks_count",
	58: "stargazers_count",
	59: "watchers_count",
	60: "size",
	61: "default_branch",
	62: "open_issues_count",
	63: "is_template",
	64: "topics",
	65: "has_issues",
	66: "has_projects",
	67: "has_wiki",
	68: "has_pages",
	69: "has_downloads",
	70: "archived",
	71: "disabled",
	72: "visibility",
	73: "pushed_at",
	74: "created_at",
	75: "updated_at",
	76: "allow_rebase_merge",
	77: "template_repository",
	78: "temp_clone_token",
	79: "allow_squash_merge",
	80: "allow_auto_merge",
	81: "delete_branch_on_merge",
	82: "allow_merge_commit",
	83: "allow_forking",
	84: "subscribers_count",
	85: "network_count",
	86: "open_issues",
	87: "watchers",
	88: "master_branch",
	89: "starred_at",
}

// Decode decodes Repository from json.
func (s *Repository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Repository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Repository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b01011111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
		0b11111110,
		0b00001110,
		0b11000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepository) {
					name = jsonFieldsNameOfRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Repository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Repository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryCollaboratorPermission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryCollaboratorPermission) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("permission")
		e.Str(s.Permission)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfRepositoryCollaboratorPermission = [2]string{
	0: "permission",
	1: "user",
}

// Decode decodes RepositoryCollaboratorPermission from json.
func (s *RepositoryCollaboratorPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryCollaboratorPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryCollaboratorPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryCollaboratorPermission) {
					name = jsonFieldsNameOfRepositoryCollaboratorPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryCollaboratorPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryCollaboratorPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryInvitation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryInvitation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("invitee")
		s.Invitee.Encode(e)
	}
	{
		e.FieldStart("inviter")
		s.Inviter.Encode(e)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Expired.Set {
			e.FieldStart("expired")
			s.Expired.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		e.Str(s.HTMLURL)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
}

var jsonFieldsNameOfRepositoryInvitation = [10]string{
	0: "id",
	1: "repository",
	2: "invitee",
	3: "inviter",
	4: "permissions",
	5: "created_at",
	6: "expired",
	7: "url",
	8: "html_url",
	9: "node_id",
}

// Decode decodes RepositoryInvitation from json.
func (s *RepositoryInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryInvitation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "invitee":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Invitee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitee\"")
			}
		case "inviter":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Inviter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inviter\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expired":
			if err := func() error {
				s.Expired.Reset()
				if err := s.Expired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryInvitation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryInvitation) {
					name = jsonFieldsNameOfRepositoryInvitation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryInvitation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryInvitation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RepositoryInvitationPermissions as json.
func (s RepositoryInvitationPermissions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RepositoryInvitationPermissions from json.
func (s *RepositoryInvitationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryInvitationPermissions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RepositoryInvitationPermissions(v) {
	case RepositoryInvitationPermissionsRead:
		*s = RepositoryInvitationPermissionsRead
	case RepositoryInvitationPermissionsWrite:
		*s = RepositoryInvitationPermissionsWrite
	case RepositoryInvitationPermissionsAdmin:
		*s = RepositoryInvitationPermissionsAdmin
	case RepositoryInvitationPermissionsTriage:
		*s = RepositoryInvitationPermissionsTriage
	case RepositoryInvitationPermissionsMaintain:
		*s = RepositoryInvitationPermissionsMaintain
	default:
		*s = RepositoryInvitationPermissions(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RepositoryInvitationPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryInvitationPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes RepositoryPermissions from json.
func (s *RepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryPermissions) {
					name = jsonFieldsNameOfRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositorySubscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositorySubscription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscribed")
		e.Bool(s.Subscribed)
	}
	{
		e.FieldStart("ignored")
		e.Bool(s.Ignored)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("repository_url")
		json.EncodeURI(e, s.RepositoryURL)
	}
}

var jsonFieldsNameOfRepositorySubscription = [6]string{
	0: "subscribed",
	1: "ignored",
	2: "reason",
	3: "created_at",
	4: "url",
	5: "repository_url",
}

// Decode decodes RepositorySubscription from json.
func (s *RepositorySubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositorySubscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ignored = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositorySubscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositorySubscription) {
					name = jsonFieldsNameOfRepositorySubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositorySubscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositorySubscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryTemplateRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryTemplateRepository) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			e.FieldStart("full_name")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			e.FieldStart("fork")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			e.FieldStart("archive_url")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			e.FieldStart("assignees_url")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			e.FieldStart("blobs_url")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			e.FieldStart("branches_url")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			e.FieldStart("collaborators_url")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			e.FieldStart("comments_url")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			e.FieldStart("commits_url")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			e.FieldStart("compare_url")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			e.FieldStart("contents_url")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			e.FieldStart("contributors_url")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			e.FieldStart("deployments_url")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			e.FieldStart("downloads_url")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			e.FieldStart("forks_url")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			e.FieldStart("git_commits_url")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			e.FieldStart("git_refs_url")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			e.FieldStart("git_tags_url")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			e.FieldStart("git_url")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			e.FieldStart("issue_comment_url")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			e.FieldStart("issue_events_url")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			e.FieldStart("keys_url")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			e.FieldStart("labels_url")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			e.FieldStart("languages_url")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			e.FieldStart("merges_url")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			e.FieldStart("milestones_url")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			e.FieldStart("notifications_url")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			e.FieldStart("pulls_url")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			e.FieldStart("releases_url")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			e.FieldStart("ssh_url")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			e.FieldStart("stargazers_url")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			e.FieldStart("statuses_url")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			e.FieldStart("subscribers_url")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			e.FieldStart("subscription_url")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			e.FieldStart("tags_url")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			e.FieldStart("teams_url")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			e.FieldStart("trees_url")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			e.FieldStart("clone_url")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.FieldStart("mirror_url")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			e.FieldStart("hooks_url")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			e.FieldStart("svn_url")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.FieldStart("forks_count")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.FieldStart("stargazers_count")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.FieldStart("watchers_count")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.FieldStart("default_branch")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.FieldStart("open_issues_count")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.FieldStart("has_issues")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.FieldStart("has_projects")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.FieldStart("has_wiki")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.FieldStart("has_pages")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.FieldStart("has_downloads")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.FieldStart("disabled")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.FieldStart("pushed_at")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepositoryTemplateRepository = [81]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "temp_clone_token",
	75: "allow_squash_merge",
	76: "allow_auto_merge",
	77: "delete_branch_on_merge",
	78: "allow_merge_commit",
	79: "subscribers_count",
	80: "network_count",
}

// Decode decodes RepositoryTemplateRepository from json.
func (s *RepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepository to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			if err := func() error {
				s.Fork.Reset()
				if err := s.Fork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			if err := func() error {
				s.AssigneesURL.Reset()
				if err := s.AssigneesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			if err := func() error {
				s.BlobsURL.Reset()
				if err := s.BlobsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			if err := func() error {
				s.BranchesURL.Reset()
				if err := s.BranchesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			if err := func() error {
				s.CollaboratorsURL.Reset()
				if err := s.CollaboratorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			if err := func() error {
				s.CompareURL.Reset()
				if err := s.CompareURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			if err := func() error {
				s.ContributorsURL.Reset()
				if err := s.ContributorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			if err := func() error {
				s.DeploymentsURL.Reset()
				if err := s.DeploymentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			if err := func() error {
				s.DownloadsURL.Reset()
				if err := s.DownloadsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			if err := func() error {
				s.GitCommitsURL.Reset()
				if err := s.GitCommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			if err := func() error {
				s.GitRefsURL.Reset()
				if err := s.GitRefsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			if err := func() error {
				s.GitTagsURL.Reset()
				if err := s.GitTagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			if err := func() error {
				s.IssueCommentURL.Reset()
				if err := s.IssueCommentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			if err := func() error {
				s.IssueEventsURL.Reset()
				if err := s.IssueEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			if err := func() error {
				s.KeysURL.Reset()
				if err := s.KeysURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			if err := func() error {
				s.LabelsURL.Reset()
				if err := s.LabelsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			if err := func() error {
				s.LanguagesURL.Reset()
				if err := s.LanguagesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			if err := func() error {
				s.MergesURL.Reset()
				if err := s.MergesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			if err := func() error {
				s.MilestonesURL.Reset()
				if err := s.MilestonesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			if err := func() error {
				s.NotificationsURL.Reset()
				if err := s.NotificationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			if err := func() error {
				s.PullsURL.Reset()
				if err := s.PullsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			if err := func() error {
				s.ReleasesURL.Reset()
				if err := s.ReleasesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			if err := func() error {
				s.StargazersURL.Reset()
				if err := s.StargazersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			if err := func() error {
				s.StatusesURL.Reset()
				if err := s.StatusesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			if err := func() error {
				s.SubscribersURL.Reset()
				if err := s.SubscribersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			if err := func() error {
				s.TagsURL.Reset()
				if err := s.TagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			if err := func() error {
				s.TreesURL.Reset()
				if err := s.TreesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepository")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryTemplateRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryTemplateRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryTemplateRepositoryOwner) encodeFields(e *jx.Encoder) {
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			e.FieldStart("gravatar_id")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			e.FieldStart("followers_url")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			e.FieldStart("following_url")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			e.FieldStart("gists_url")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			e.FieldStart("starred_url")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			e.FieldStart("subscriptions_url")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			e.FieldStart("organizations_url")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			e.FieldStart("repos_url")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			e.FieldStart("events_url")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			e.FieldStart("received_events_url")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			e.FieldStart("site_admin")
			s.SiteAdmin.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepositoryTemplateRepositoryOwner = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (s *RepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepositoryOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepositoryOwner")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryTemplateRepositoryOwner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryTemplateRepositoryOwner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RepositoryTemplateRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			e.FieldStart("push")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			e.FieldStart("pull")
			s.Pull.Encode(e)
		}
	}
}

var jsonFieldsNameOfRepositoryTemplateRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (s *RepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepositoryPermissions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RepositoryTemplateRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RepositoryTemplateRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReviewComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReviewComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("pull_request_review_id")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("diff_hunk")
		e.Str(s.DiffHunk)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	{
		e.FieldStart("original_position")
		e.Int(s.OriginalPosition)
	}
	{
		e.FieldStart("commit_id")
		e.Str(s.CommitID)
	}
	{
		e.FieldStart("original_commit_id")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.FieldStart("in_reply_to_id")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("pull_request_url")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	{
		if s.BodyText.Set {
			e.FieldStart("body_text")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.FieldStart("body_html")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.FieldStart("side")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.FieldStart("start_side")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.FieldStart("line")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.FieldStart("original_line")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.FieldStart("start_line")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.FieldStart("original_start_line")
			s.OriginalStartLine.Encode(e)
		}
	}
}

var jsonFieldsNameOfReviewComment = [28]string{
	0:  "url",
	1:  "pull_request_review_id",
	2:  "id",
	3:  "node_id",
	4:  "diff_hunk",
	5:  "path",
	6:  "position",
	7:  "original_position",
	8:  "commit_id",
	9:  "original_commit_id",
	10: "in_reply_to_id",
	11: "user",
	12: "body",
	13: "created_at",
	14: "updated_at",
	15: "html_url",
	16: "pull_request_url",
	17: "author_association",
	18: "_links",
	19: "body_text",
	20: "body_html",
	21: "reactions",
	22: "side",
	23: "start_side",
	24: "line",
	25: "original_line",
	26: "start_line",
	27: "original_start_line",
}

// Decode decodes ReviewComment from json.
func (s *ReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewComment to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "pull_request_review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequestReviewID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_review_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "diff_hunk":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DiffHunk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_hunk\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "original_position":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OriginalPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_position\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "original_commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OriginalCommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_commit_id\"")
			}
		case "in_reply_to_id":
			if err := func() error {
				s.InReplyToID.Reset()
				if err := s.InReplyToID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "author_association":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "_links":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "original_line":
			if err := func() error {
				s.OriginalLine.Reset()
				if err := s.OriginalLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_line\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "original_start_line":
			if err := func() error {
				s.OriginalStartLine.Reset()
				if err := s.OriginalStartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_start_line\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReviewComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111011,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReviewComment) {
					name = jsonFieldsNameOfReviewComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReviewComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReviewComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReviewCommentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReviewCommentLinks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("self")
		s.Self.Encode(e)
	}
	{
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	{
		e.FieldStart("pull_request")
		s.PullRequest.Encode(e)
	}
}

var jsonFieldsNameOfReviewCommentLinks = [3]string{
	0: "self",
	1: "html",
	2: "pull_request",
}

// Decode decodes ReviewCommentLinks from json.
func (s *ReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReviewCommentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReviewCommentLinks) {
					name = jsonFieldsNameOfReviewCommentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReviewCommentLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReviewCommentLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReviewCommentSide as json.
func (s ReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentSide from json.
func (s *ReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentSide(v) {
	case ReviewCommentSideLEFT:
		*s = ReviewCommentSideLEFT
	case ReviewCommentSideRIGHT:
		*s = ReviewCommentSideRIGHT
	default:
		*s = ReviewCommentSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReviewCommentSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReviewCommentSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReviewCommentStartSide as json.
func (s ReviewCommentStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentStartSide from json.
func (s *ReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentStartSide(v) {
	case ReviewCommentStartSideLEFT:
		*s = ReviewCommentStartSideLEFT
	case ReviewCommentStartSideRIGHT:
		*s = ReviewCommentStartSideRIGHT
	default:
		*s = ReviewCommentStartSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReviewCommentStartSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReviewCommentStartSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Runner) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Runner) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("os")
		e.Str(s.Os)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("busy")
		e.Bool(s.Busy)
	}
	{
		e.FieldStart("labels")
		e.ArrStart()
		for _, elem := range s.Labels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRunner = [6]string{
	0: "id",
	1: "name",
	2: "os",
	3: "status",
	4: "busy",
	5: "labels",
}

// Decode decodes Runner from json.
func (s *Runner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Runner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "os":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Os = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "busy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Busy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"busy\"")
			}
		case "labels":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Labels = make([]RunnerLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Runner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunner) {
					name = jsonFieldsNameOfRunner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Runner) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Runner) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunnerApplication) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunnerApplication) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("os")
		e.Str(s.Os)
	}
	{
		e.FieldStart("architecture")
		e.Str(s.Architecture)
	}
	{
		e.FieldStart("download_url")
		e.Str(s.DownloadURL)
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		if s.TempDownloadToken.Set {
			e.FieldStart("temp_download_token")
			s.TempDownloadToken.Encode(e)
		}
	}
	{
		if s.SHA256Checksum.Set {
			e.FieldStart("sha256_checksum")
			s.SHA256Checksum.Encode(e)
		}
	}
}

var jsonFieldsNameOfRunnerApplication = [6]string{
	0: "os",
	1: "architecture",
	2: "download_url",
	3: "filename",
	4: "temp_download_token",
	5: "sha256_checksum",
}

// Decode decodes RunnerApplication from json.
func (s *RunnerApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerApplication to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "os":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Os = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "architecture":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Architecture = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "download_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DownloadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "temp_download_token":
			if err := func() error {
				s.TempDownloadToken.Reset()
				if err := s.TempDownloadToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_download_token\"")
			}
		case "sha256_checksum":
			if err := func() error {
				s.SHA256Checksum.Reset()
				if err := s.SHA256Checksum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha256_checksum\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerApplication")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerApplication) {
					name = jsonFieldsNameOfRunnerApplication[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunnerApplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunnerApplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunnerGroupsEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunnerGroupsEnterprise) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("visibility")
		e.Str(s.Visibility)
	}
	{
		e.FieldStart("default")
		e.Bool(s.Default)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.FieldStart("selected_organizations_url")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		e.FieldStart("runners_url")
		e.Str(s.RunnersURL)
	}
	{
		e.FieldStart("allows_public_repositories")
		e.Bool(s.AllowsPublicRepositories)
	}
}

var jsonFieldsNameOfRunnerGroupsEnterprise = [7]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "default",
	4: "selected_organizations_url",
	5: "runners_url",
	6: "allows_public_repositories",
}

// Decode decodes RunnerGroupsEnterprise from json.
func (s *RunnerGroupsEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerGroupsEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Visibility = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "selected_organizations_url":
			if err := func() error {
				s.SelectedOrganizationsURL.Reset()
				if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organizations_url\"")
			}
		case "runners_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RunnersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners_url\"")
			}
		case "allows_public_repositories":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AllowsPublicRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_public_repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerGroupsEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerGroupsEnterprise) {
					name = jsonFieldsNameOfRunnerGroupsEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunnerGroupsEnterprise) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunnerGroupsEnterprise) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunnerGroupsOrg) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunnerGroupsOrg) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("visibility")
		e.Str(s.Visibility)
	}
	{
		e.FieldStart("default")
		e.Bool(s.Default)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.FieldStart("selected_repositories_url")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		e.FieldStart("runners_url")
		e.Str(s.RunnersURL)
	}
	{
		e.FieldStart("inherited")
		e.Bool(s.Inherited)
	}
	{
		if s.InheritedAllowsPublicRepositories.Set {
			e.FieldStart("inherited_allows_public_repositories")
			s.InheritedAllowsPublicRepositories.Encode(e)
		}
	}
	{
		e.FieldStart("allows_public_repositories")
		e.Bool(s.AllowsPublicRepositories)
	}
}

var jsonFieldsNameOfRunnerGroupsOrg = [9]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "default",
	4: "selected_repositories_url",
	5: "runners_url",
	6: "inherited",
	7: "inherited_allows_public_repositories",
	8: "allows_public_repositories",
}

// Decode decodes RunnerGroupsOrg from json.
func (s *RunnerGroupsOrg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerGroupsOrg to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Visibility = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		case "runners_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RunnersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners_url\"")
			}
		case "inherited":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Inherited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inherited\"")
			}
		case "inherited_allows_public_repositories":
			if err := func() error {
				s.InheritedAllowsPublicRepositories.Reset()
				if err := s.InheritedAllowsPublicRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inherited_allows_public_repositories\"")
			}
		case "allows_public_repositories":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AllowsPublicRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_public_repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerGroupsOrg")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerGroupsOrg) {
					name = jsonFieldsNameOfRunnerGroupsOrg[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunnerGroupsOrg) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunnerGroupsOrg) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RunnerLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RunnerLabelsItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfRunnerLabelsItem = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes RunnerLabelsItem from json.
func (s *RunnerLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerLabelsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RunnerLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunnerLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RunnerLabelsItemType as json.
func (s RunnerLabelsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunnerLabelsItemType from json.
func (s *RunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerLabelsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunnerLabelsItemType(v) {
	case RunnerLabelsItemTypeReadOnly:
		*s = RunnerLabelsItemTypeReadOnly
	case RunnerLabelsItemTypeCustom:
		*s = RunnerLabelsItemTypeCustom
	default:
		*s = RunnerLabelsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RunnerLabelsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RunnerLabelsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimDeleteUserFromOrgForbidden as json.
func (s *ScimDeleteUserFromOrgForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ScimError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgForbidden from json.
func (s *ScimDeleteUserFromOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimDeleteUserFromOrgForbidden to nil")
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimDeleteUserFromOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimDeleteUserFromOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScimDeleteUserFromOrgNotFound as json.
func (s *ScimDeleteUserFromOrgNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ScimError)(s)

	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgNotFound from json.
func (s *ScimDeleteUserFromOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimDeleteUserFromOrgNotFound to nil")
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimDeleteUserFromOrgNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimDeleteUserFromOrgNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseGroup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.FieldStart("externalId")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.FieldStart("members")
			e.ArrStart()
			for _, elem := range s.Members {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseGroup = [6]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "displayName",
	4: "members",
	5: "meta",
}

// Decode decodes ScimEnterpriseGroup from json.
func (s *ScimEnterpriseGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]ScimEnterpriseGroupMembersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseGroupMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimEnterpriseGroup) {
					name = jsonFieldsNameOfScimEnterpriseGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseGroupMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseGroupMembersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			e.FieldStart("$ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			e.FieldStart("display")
			s.Display.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseGroupMembersItem = [3]string{
	0: "value",
	1: "$ref",
	2: "display",
}

// Decode decodes ScimEnterpriseGroupMembersItem from json.
func (s *ScimEnterpriseGroupMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroupMembersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "display":
			if err := func() error {
				s.Display.Reset()
				if err := s.Display.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroupMembersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseGroupMembersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseGroupMembersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseGroupMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseGroupMeta) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			e.FieldStart("lastModified")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseGroupMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (s *ScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroupMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroupMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseGroupMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseGroupMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.FieldStart("externalId")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.FieldStart("userName")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.FieldStart("emails")
			e.ArrStart()
			for _, elem := range s.Emails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseUser = [9]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "userName",
	4: "name",
	5: "emails",
	6: "groups",
	7: "active",
	8: "meta",
}

// Decode decodes ScimEnterpriseUser from json.
func (s *ScimEnterpriseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "userName":
			if err := func() error {
				s.UserName.Reset()
				if err := s.UserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = make([]ScimEnterpriseUserEmailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseUserEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]ScimEnterpriseUserGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseUserGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimEnterpriseUser) {
					name = jsonFieldsNameOfScimEnterpriseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseUserEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseUserEmailsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			e.FieldStart("primary")
			s.Primary.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseUserEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes ScimEnterpriseUserEmailsItem from json.
func (s *ScimEnterpriseUserEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserEmailsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseUserEmailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseUserEmailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseUserGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseUserGroupsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseUserGroupsItem = [1]string{
	0: "value",
}

// Decode decodes ScimEnterpriseUserGroupsItem from json.
func (s *ScimEnterpriseUserGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserGroupsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseUserGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseUserGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseUserMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseUserMeta) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			e.FieldStart("lastModified")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseUserMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (s *ScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseUserMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseUserMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimEnterpriseUserName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimEnterpriseUserName) encodeFields(e *jx.Encoder) {
	{
		if s.GivenName.Set {
			e.FieldStart("givenName")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			e.FieldStart("familyName")
			s.FamilyName.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimEnterpriseUserName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes ScimEnterpriseUserName from json.
func (s *ScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			if err := func() error {
				s.FamilyName.Reset()
				if err := s.FamilyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserName")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimEnterpriseUserName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimEnterpriseUserName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimError) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ScimType.Set {
			e.FieldStart("scimType")
			s.ScimType.Encode(e)
		}
	}
	{
		if s.Schemas != nil {
			e.FieldStart("schemas")
			e.ArrStart()
			for _, elem := range s.Schemas {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfScimError = [6]string{
	0: "message",
	1: "documentation_url",
	2: "detail",
	3: "status",
	4: "scimType",
	5: "schemas",
}

// Decode decodes ScimError from json.
func (s *ScimError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "scimType":
			if err := func() error {
				s.ScimType.Reset()
				if err := s.ScimType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scimType\"")
			}
		case "schemas":
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimGroupListEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimGroupListEnterprise) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalResults")
		e.Float64(s.TotalResults)
	}
	{
		e.FieldStart("itemsPerPage")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.FieldStart("startIndex")
		e.Float64(s.StartIndex)
	}
	{
		e.FieldStart("Resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfScimGroupListEnterprise = [5]string{
	0: "schemas",
	1: "totalResults",
	2: "itemsPerPage",
	3: "startIndex",
	4: "Resources",
}

// Decode decodes ScimGroupListEnterprise from json.
func (s *ScimGroupListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "totalResults":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalResults = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalResults\"")
			}
		case "itemsPerPage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ItemsPerPage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsPerPage\"")
			}
		case "startIndex":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartIndex = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIndex\"")
			}
		case "Resources":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Resources = make([]ScimGroupListEnterpriseResourcesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimGroupListEnterpriseResourcesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimGroupListEnterprise) {
					name = jsonFieldsNameOfScimGroupListEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimGroupListEnterprise) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimGroupListEnterprise) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimGroupListEnterpriseResourcesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.FieldStart("externalId")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.FieldStart("members")
			e.ArrStart()
			for _, elem := range s.Members {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItem = [6]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "displayName",
	4: "members",
	5: "meta",
}

// Decode decodes ScimGroupListEnterpriseResourcesItem from json.
func (s *ScimGroupListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = make([]ScimGroupListEnterpriseResourcesItemMembersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimGroupListEnterpriseResourcesItemMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimGroupListEnterpriseResourcesItem) {
					name = jsonFieldsNameOfScimGroupListEnterpriseResourcesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimGroupListEnterpriseResourcesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			e.FieldStart("$ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			e.FieldStart("display")
			s.Display.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItemMembersItem = [3]string{
	0: "value",
	1: "$ref",
	2: "display",
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMembersItem from json.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItemMembersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "display":
			if err := func() error {
				s.Display.Reset()
				if err := s.Display.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItemMembersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimGroupListEnterpriseResourcesItemMeta) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			e.FieldStart("lastModified")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItemMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (s *ScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItemMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItemMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimGroupListEnterpriseResourcesItemMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimGroupListEnterpriseResourcesItemMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterprise) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalResults")
		e.Float64(s.TotalResults)
	}
	{
		e.FieldStart("itemsPerPage")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.FieldStart("startIndex")
		e.Float64(s.StartIndex)
	}
	{
		e.FieldStart("Resources")
		e.ArrStart()
		for _, elem := range s.Resources {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfScimUserListEnterprise = [5]string{
	0: "schemas",
	1: "totalResults",
	2: "itemsPerPage",
	3: "startIndex",
	4: "Resources",
}

// Decode decodes ScimUserListEnterprise from json.
func (s *ScimUserListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "totalResults":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalResults = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalResults\"")
			}
		case "itemsPerPage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ItemsPerPage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsPerPage\"")
			}
		case "startIndex":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartIndex = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIndex\"")
			}
		case "Resources":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Resources = make([]ScimUserListEnterpriseResourcesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUserListEnterprise) {
					name = jsonFieldsNameOfScimUserListEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterprise) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterprise) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterpriseResourcesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterpriseResourcesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.FieldStart("externalId")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.FieldStart("userName")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.FieldStart("emails")
			e.ArrStart()
			for _, elem := range s.Emails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItem = [9]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "userName",
	4: "name",
	5: "emails",
	6: "groups",
	7: "active",
	8: "meta",
}

// Decode decodes ScimUserListEnterpriseResourcesItem from json.
func (s *ScimUserListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "userName":
			if err := func() error {
				s.UserName.Reset()
				if err := s.UserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = make([]ScimUserListEnterpriseResourcesItemEmailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItemEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]ScimUserListEnterpriseResourcesItemGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItemGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUserListEnterpriseResourcesItem) {
					name = jsonFieldsNameOfScimUserListEnterpriseResourcesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterpriseResourcesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterpriseResourcesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			e.FieldStart("primary")
			s.Primary.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemEmailsItem = [3]string{
	0: "value",
	1: "primary",
	2: "type",
}

// Decode decodes ScimUserListEnterpriseResourcesItemEmailsItem from json.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemEmailsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemGroupsItem = [1]string{
	0: "value",
}

// Decode decodes ScimUserListEnterpriseResourcesItemGroupsItem from json.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemGroupsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterpriseResourcesItemMeta) encodeFields(e *jx.Encoder) {
	{
		if s.ResourceType.Set {
			e.FieldStart("resourceType")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			e.FieldStart("lastModified")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (s *ScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterpriseResourcesItemMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScimUserListEnterpriseResourcesItemName) encodeFields(e *jx.Encoder) {
	{
		if s.GivenName.Set {
			e.FieldStart("givenName")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			e.FieldStart("familyName")
			s.FamilyName.Encode(e)
		}
	}
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (s *ScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			if err := func() error {
				s.FamilyName.Reset()
				if err := s.FamilyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemName")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScimUserListEnterpriseResourcesItemName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScimUserListEnterpriseResourcesItemName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchCodeOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchCodeOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchCodeOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchCodeOK from json.
func (s *SearchCodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCodeOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]CodeSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CodeSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchCodeOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchCodeOK) {
					name = jsonFieldsNameOfSearchCodeOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCodeOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCodeOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchCommitsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchCommitsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchCommitsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchCommitsOK from json.
func (s *SearchCommitsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCommitsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]CommitSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchCommitsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchCommitsOK) {
					name = jsonFieldsNameOfSearchCommitsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchCommitsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchCommitsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchIssuesAndPullRequestsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchIssuesAndPullRequestsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchIssuesAndPullRequestsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchIssuesAndPullRequestsOK from json.
func (s *SearchIssuesAndPullRequestsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchIssuesAndPullRequestsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]IssueSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchIssuesAndPullRequestsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchIssuesAndPullRequestsOK) {
					name = jsonFieldsNameOfSearchIssuesAndPullRequestsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchIssuesAndPullRequestsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchIssuesAndPullRequestsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchLabelsForbidden as json.
func (s *SearchLabelsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsForbidden from json.
func (s *SearchLabelsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchLabelsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchLabelsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchLabelsNotFound as json.
func (s *SearchLabelsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsNotFound from json.
func (s *SearchLabelsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchLabelsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchLabelsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchLabelsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchLabelsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchLabelsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchLabelsOK from json.
func (s *SearchLabelsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]LabelSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabelSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchLabelsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchLabelsOK) {
					name = jsonFieldsNameOfSearchLabelsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchLabelsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchLabelsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchReposOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchReposOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchReposOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchReposOK from json.
func (s *SearchReposOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReposOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]RepoSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RepoSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchReposOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchReposOK) {
					name = jsonFieldsNameOfSearchReposOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchReposOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReposOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResultTextMatches as json.
func (s SearchResultTextMatches) Encode(e *jx.Encoder) {
	unwrapped := []SearchResultTextMatchesItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SearchResultTextMatches from json.
func (s *SearchResultTextMatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatches to nil")
	}
	var unwrapped []SearchResultTextMatchesItem
	if err := func() error {
		unwrapped = make([]SearchResultTextMatchesItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SearchResultTextMatchesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchResultTextMatches(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchResultTextMatches) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultTextMatches) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultTextMatchesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultTextMatchesItem) encodeFields(e *jx.Encoder) {
	{
		if s.ObjectURL.Set {
			e.FieldStart("object_url")
			s.ObjectURL.Encode(e)
		}
	}
	{
		if s.ObjectType.Set {
			e.FieldStart("object_type")
			s.ObjectType.Encode(e)
		}
	}
	{
		if s.Property.Set {
			e.FieldStart("property")
			s.Property.Encode(e)
		}
	}
	{
		if s.Fragment.Set {
			e.FieldStart("fragment")
			s.Fragment.Encode(e)
		}
	}
	{
		if s.Matches != nil {
			e.FieldStart("matches")
			e.ArrStart()
			for _, elem := range s.Matches {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchResultTextMatchesItem = [5]string{
	0: "object_url",
	1: "object_type",
	2: "property",
	3: "fragment",
	4: "matches",
}

// Decode decodes SearchResultTextMatchesItem from json.
func (s *SearchResultTextMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatchesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_url":
			if err := func() error {
				s.ObjectURL.Reset()
				if err := s.ObjectURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_url\"")
			}
		case "object_type":
			if err := func() error {
				s.ObjectType.Reset()
				if err := s.ObjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_type\"")
			}
		case "property":
			if err := func() error {
				s.Property.Reset()
				if err := s.Property.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"property\"")
			}
		case "fragment":
			if err := func() error {
				s.Fragment.Reset()
				if err := s.Fragment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fragment\"")
			}
		case "matches":
			if err := func() error {
				s.Matches = make([]SearchResultTextMatchesItemMatchesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItemMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Matches = append(s.Matches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultTextMatchesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultTextMatchesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultTextMatchesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResultTextMatchesItemMatchesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResultTextMatchesItemMatchesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Indices != nil {
			e.FieldStart("indices")
			e.ArrStart()
			for _, elem := range s.Indices {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSearchResultTextMatchesItemMatchesItem = [2]string{
	0: "text",
	1: "indices",
}

// Decode decodes SearchResultTextMatchesItemMatchesItem from json.
func (s *SearchResultTextMatchesItemMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatchesItemMatchesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "indices":
			if err := func() error {
				s.Indices = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Indices = append(s.Indices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultTextMatchesItemMatchesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResultTextMatchesItemMatchesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResultTextMatchesItemMatchesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchTopicsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchTopicsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchTopicsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchTopicsOK from json.
func (s *SearchTopicsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchTopicsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]TopicSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TopicSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchTopicsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchTopicsOK) {
					name = jsonFieldsNameOfSearchTopicsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchTopicsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchTopicsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchUsersOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchUsersOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("incomplete_results")
		e.Bool(s.IncompleteResults)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchUsersOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchUsersOK from json.
func (s *SearchUsersOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchUsersOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]UserSearchResultItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchUsersOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchUsersOK) {
					name = jsonFieldsNameOfSearchUsersOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchUsersOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchUsersOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretScanningAlert) encodeFields(e *jx.Encoder) {
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			e.FieldStart("html_url")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			e.FieldStart("locations_url")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			e.FieldStart("resolution")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			e.FieldStart("resolved_at")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			e.FieldStart("resolved_by")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			e.FieldStart("secret_type")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecretScanningAlert = [11]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "locations_url",
	5:  "state",
	6:  "resolution",
	7:  "resolved_at",
	8:  "resolved_by",
	9:  "secret_type",
	10: "secret",
}

// Decode decodes SecretScanningAlert from json.
func (s *SecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlert to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "locations_url":
			if err := func() error {
				s.LocationsURL.Reset()
				if err := s.LocationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locations_url\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		case "resolved_at":
			if err := func() error {
				s.ResolvedAt.Reset()
				if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_at\"")
			}
		case "resolved_by":
			if err := func() error {
				s.ResolvedBy.Reset()
				if err := s.ResolvedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_by\"")
			}
		case "secret_type":
			if err := func() error {
				s.SecretType.Reset()
				if err := s.SecretType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretScanningAlert")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretScanningAlert) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretScanningAlert) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretScanningAlertResolution as json.
func (s SecretScanningAlertResolution) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertResolution from json.
func (s *SecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlertResolution to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertResolution(v) {
	case SecretScanningAlertResolutionFalsePositive:
		*s = SecretScanningAlertResolutionFalsePositive
	case SecretScanningAlertResolutionWontFix:
		*s = SecretScanningAlertResolutionWontFix
	case SecretScanningAlertResolutionRevoked:
		*s = SecretScanningAlertResolutionRevoked
	case SecretScanningAlertResolutionUsedInTests:
		*s = SecretScanningAlertResolutionUsedInTests
	default:
		*s = SecretScanningAlertResolution(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretScanningAlertResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretScanningAlertResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretScanningAlertState as json.
func (s SecretScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertState from json.
func (s *SecretScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlertState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertState(v) {
	case SecretScanningAlertStateOpen:
		*s = SecretScanningAlertStateOpen
	case SecretScanningAlertStateResolved:
		*s = SecretScanningAlertStateResolved
	default:
		*s = SecretScanningAlertState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretScanningAlertState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretScanningAlertState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretScanningListAlertsForRepoOKApplicationJSON as json.
func (s SecretScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SecretScanningAlert(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForRepoOKApplicationJSON from json.
func (s *SecretScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningListAlertsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []SecretScanningAlert
	if err := func() error {
		unwrapped = make([]SecretScanningAlert, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretScanningListAlertsForRepoOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretScanningListAlertsForRepoOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretScanningUpdateAlertReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretScanningUpdateAlertReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.Resolution.Set {
			e.FieldStart("resolution")
			s.Resolution.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecretScanningUpdateAlertReq = [2]string{
	0: "state",
	1: "resolution",
}

// Decode decodes SecretScanningUpdateAlertReq from json.
func (s *SecretScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningUpdateAlertReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretScanningUpdateAlertReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretScanningUpdateAlertReq) {
					name = jsonFieldsNameOfSecretScanningUpdateAlertReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretScanningUpdateAlertReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretScanningUpdateAlertReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectedActions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectedActions) encodeFields(e *jx.Encoder) {
	{
		if s.GithubOwnedAllowed.Set {
			e.FieldStart("github_owned_allowed")
			s.GithubOwnedAllowed.Encode(e)
		}
	}
	{
		if s.VerifiedAllowed.Set {
			e.FieldStart("verified_allowed")
			s.VerifiedAllowed.Encode(e)
		}
	}
	{
		if s.PatternsAllowed != nil {
			e.FieldStart("patterns_allowed")
			e.ArrStart()
			for _, elem := range s.PatternsAllowed {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSelectedActions = [3]string{
	0: "github_owned_allowed",
	1: "verified_allowed",
	2: "patterns_allowed",
}

// Decode decodes SelectedActions from json.
func (s *SelectedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedActions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github_owned_allowed":
			if err := func() error {
				s.GithubOwnedAllowed.Reset()
				if err := s.GithubOwnedAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github_owned_allowed\"")
			}
		case "verified_allowed":
			if err := func() error {
				s.VerifiedAllowed.Reset()
				if err := s.VerifiedAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified_allowed\"")
			}
		case "patterns_allowed":
			if err := func() error {
				s.PatternsAllowed = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PatternsAllowed = append(s.PatternsAllowed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patterns_allowed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectedActions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectedActions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectedActions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectedActionsURL as json.
func (s SelectedActionsURL) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes SelectedActionsURL from json.
func (s *SelectedActionsURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedActionsURL to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectedActionsURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SelectedActionsURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectedActionsURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfServiceUnavailable = [3]string{
	0: "code",
	1: "message",
	2: "documentation_url",
}

// Decode decodes ServiceUnavailable from json.
func (s *ServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceUnavailable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceUnavailable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShortBlob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShortBlob) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
}

var jsonFieldsNameOfShortBlob = [2]string{
	0: "url",
	1: "sha",
}

// Decode decodes ShortBlob from json.
func (s *ShortBlob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBlob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBlob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBlob) {
					name = jsonFieldsNameOfShortBlob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShortBlob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShortBlob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShortBranch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShortBranch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("protected")
		e.Bool(s.Protected)
	}
	{
		if s.Protection.Set {
			e.FieldStart("protection")
			s.Protection.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			e.FieldStart("protection_url")
			s.ProtectionURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfShortBranch = [5]string{
	0: "name",
	1: "commit",
	2: "protected",
	3: "protection",
	4: "protection_url",
}

// Decode decodes ShortBranch from json.
func (s *ShortBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBranch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		case "protection":
			if err := func() error {
				s.Protection.Reset()
				if err := s.Protection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection\"")
			}
		case "protection_url":
			if err := func() error {
				s.ProtectionURL.Reset()
				if err := s.ProtectionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBranch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBranch) {
					name = jsonFieldsNameOfShortBranch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShortBranch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShortBranch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShortBranchCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShortBranchCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfShortBranchCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes ShortBranchCommit from json.
func (s *ShortBranchCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBranchCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBranchCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBranchCommit) {
					name = jsonFieldsNameOfShortBranchCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShortBranchCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShortBranchCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("tree_id")
		e.Str(s.TreeID)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
}

var jsonFieldsNameOfSimpleCommit = [6]string{
	0: "id",
	1: "tree_id",
	2: "message",
	3: "timestamp",
	4: "author",
	5: "committer",
}

// Decode decodes SimpleCommit from json.
func (s *SimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tree_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommit) {
					name = jsonFieldsNameOfSimpleCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleCommitAuthor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfSimpleCommitAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes SimpleCommitAuthor from json.
func (s *SimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitAuthor) {
					name = jsonFieldsNameOfSimpleCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleCommitAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleCommitAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleCommitCommitter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfSimpleCommitCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes SimpleCommitCommitter from json.
func (s *SimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitCommitter) {
					name = jsonFieldsNameOfSimpleCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleCommitCommitter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleCommitCommitter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleCommitStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleCommitStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("context")
		e.Str(s.Context)
	}
	{
		e.FieldStart("target_url")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfSimpleCommitStatus = [11]string{
	0:  "description",
	1:  "id",
	2:  "node_id",
	3:  "state",
	4:  "context",
	5:  "target_url",
	6:  "required",
	7:  "avatar_url",
	8:  "url",
	9:  "created_at",
	10: "updated_at",
}

// Decode decodes SimpleCommitStatus from json.
func (s *SimpleCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "context":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Context = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TargetURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitStatus) {
					name = jsonFieldsNameOfSimpleCommitStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleCommitStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleCommitStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleUser) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.FieldStart("starred_at")
			s.StarredAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfSimpleUser = [21]string{
	0:  "name",
	1:  "email",
	2:  "login",
	3:  "id",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "starred_at",
}

// Decode decodes SimpleUser from json.
func (s *SimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111100,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleUser) {
					name = jsonFieldsNameOfSimpleUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Status) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Status) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("target_url")
		e.Str(s.TargetURL)
	}
	{
		e.FieldStart("context")
		e.Str(s.Context)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
}

var jsonFieldsNameOfStatus = [11]string{
	0:  "url",
	1:  "avatar_url",
	2:  "id",
	3:  "node_id",
	4:  "state",
	5:  "description",
	6:  "target_url",
	7:  "context",
	8:  "created_at",
	9:  "updated_at",
	10: "creator",
}

// Decode decodes Status from json.
func (s *Status) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Status to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TargetURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "context":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Context = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Status")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatus) {
					name = jsonFieldsNameOfStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Status) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Status) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusCheckPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusCheckPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("strict")
		e.Bool(s.Strict)
	}
	{
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("contexts_url")
		json.EncodeURI(e, s.ContextsURL)
	}
}

var jsonFieldsNameOfStatusCheckPolicy = [4]string{
	0: "url",
	1: "strict",
	2: "contexts",
	3: "contexts_url",
}

// Decode decodes StatusCheckPolicy from json.
func (s *StatusCheckPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusCheckPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "strict":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Strict = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Contexts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		case "contexts_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContextsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusCheckPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusCheckPolicy) {
					name = jsonFieldsNameOfStatusCheckPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusCheckPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusCheckPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("commit")
		s.Commit.Encode(e)
	}
	{
		e.FieldStart("zipball_url")
		json.EncodeURI(e, s.ZipballURL)
	}
	{
		e.FieldStart("tarball_url")
		json.EncodeURI(e, s.TarballURL)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
}

var jsonFieldsNameOfTag = [5]string{
	0: "name",
	1: "commit",
	2: "zipball_url",
	3: "tarball_url",
	4: "node_id",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "zipball_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ZipballURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zipball_url\"")
			}
		case "tarball_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TarballURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tarball_url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTag) {
					name = jsonFieldsNameOfTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagCommit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sha")
		e.Str(s.Sha)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfTagCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes TagCommit from json.
func (s *TagCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagCommit) {
					name = jsonFieldsNameOfTagCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagCommit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagCommit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Team) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Team) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		e.FieldStart("permission")
		e.Str(s.Permission)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("repositories_url")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.FieldStart("parent")
		s.Parent.Encode(e)
	}
}

var jsonFieldsNameOfTeam = [13]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "slug",
	4:  "description",
	5:  "privacy",
	6:  "permission",
	7:  "permissions",
	8:  "url",
	9:  "html_url",
	10: "members_url",
	11: "repositories_url",
	12: "parent",
}

// Decode decodes Team from json.
func (s *Team) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Team to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Team")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeam) {
					name = jsonFieldsNameOfTeam[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Team) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Team) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamDiscussion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamDiscussion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("body_html")
		e.Str(s.BodyHTML)
	}
	{
		e.FieldStart("body_version")
		e.Str(s.BodyVersion)
	}
	{
		e.FieldStart("comments_count")
		e.Int(s.CommentsCount)
	}
	{
		e.FieldStart("comments_url")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("last_edited_at")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("pinned")
		e.Bool(s.Pinned)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("team_url")
		json.EncodeURI(e, s.TeamURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamDiscussion = [18]string{
	0:  "author",
	1:  "body",
	2:  "body_html",
	3:  "body_version",
	4:  "comments_count",
	5:  "comments_url",
	6:  "created_at",
	7:  "last_edited_at",
	8:  "html_url",
	9:  "node_id",
	10: "number",
	11: "pinned",
	12: "private",
	13: "team_url",
	14: "title",
	15: "updated_at",
	16: "url",
	17: "reactions",
}

// Decode decodes TeamDiscussion from json.
func (s *TeamDiscussion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamDiscussion to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_html":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BodyHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BodyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_version\"")
			}
		case "comments_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CommentsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_count\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_edited_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_edited_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "pinned":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Pinned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "team_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_url\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamDiscussion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamDiscussion) {
					name = jsonFieldsNameOfTeamDiscussion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamDiscussion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamDiscussion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamDiscussionComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamDiscussionComment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("body_html")
		e.Str(s.BodyHTML)
	}
	{
		e.FieldStart("body_version")
		e.Str(s.BodyVersion)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("last_edited_at")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("discussion_url")
		json.EncodeURI(e, s.DiscussionURL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.FieldStart("reactions")
			s.Reactions.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamDiscussionComment = [13]string{
	0:  "author",
	1:  "body",
	2:  "body_html",
	3:  "body_version",
	4:  "created_at",
	5:  "last_edited_at",
	6:  "discussion_url",
	7:  "html_url",
	8:  "node_id",
	9:  "number",
	10: "updated_at",
	11: "url",
	12: "reactions",
}

// Decode decodes TeamDiscussionComment from json.
func (s *TeamDiscussionComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamDiscussionComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_html":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BodyHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BodyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_version\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_edited_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_edited_at\"")
			}
		case "discussion_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiscussionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamDiscussionComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamDiscussionComment) {
					name = jsonFieldsNameOfTeamDiscussionComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamDiscussionComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamDiscussionComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamFull) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		e.FieldStart("permission")
		e.Str(s.Permission)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("repositories_url")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		if s.Parent.Set {
			e.FieldStart("parent")
			s.Parent.Encode(e)
		}
	}
	{
		e.FieldStart("members_count")
		e.Int(s.MembersCount)
	}
	{
		e.FieldStart("repos_count")
		e.Int(s.ReposCount)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}
	{
		if s.LdapDn.Set {
			e.FieldStart("ldap_dn")
			s.LdapDn.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamFull = [18]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "html_url",
	4:  "name",
	5:  "slug",
	6:  "description",
	7:  "privacy",
	8:  "permission",
	9:  "members_url",
	10: "repositories_url",
	11: "parent",
	12: "members_count",
	13: "repos_count",
	14: "created_at",
	15: "updated_at",
	16: "organization",
	17: "ldap_dn",
}

// Decode decodes TeamFull from json.
func (s *TeamFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamFull to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "members_count":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MembersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_count\"")
			}
		case "repos_count":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ReposCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_count\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b11110111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamFull) {
					name = jsonFieldsNameOfTeamFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamFullPrivacy as json.
func (s TeamFullPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamFullPrivacy from json.
func (s *TeamFullPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamFullPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamFullPrivacy(v) {
	case TeamFullPrivacyClosed:
		*s = TeamFullPrivacyClosed
	case TeamFullPrivacySecret:
		*s = TeamFullPrivacySecret
	default:
		*s = TeamFullPrivacy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamFullPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamFullPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamMembership) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamMembership) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfTeamMembership = [3]string{
	0: "url",
	1: "role",
	2: "state",
}

// Decode decodes TeamMembership from json.
func (s *TeamMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembership to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamMembership")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamMembership) {
					name = jsonFieldsNameOfTeamMembership[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamMembership) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMembership) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamMembershipRole as json.
func (s TeamMembershipRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipRole from json.
func (s *TeamMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembershipRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipRole(v) {
	case TeamMembershipRoleMember:
		*s = TeamMembershipRoleMember
	case TeamMembershipRoleMaintainer:
		*s = TeamMembershipRoleMaintainer
	default:
		*s = TeamMembershipRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamMembershipRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMembershipRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamMembershipState as json.
func (s TeamMembershipState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipState from json.
func (s *TeamMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembershipState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipState(v) {
	case TeamMembershipStateActive:
		*s = TeamMembershipStateActive
	case TeamMembershipStatePending:
		*s = TeamMembershipStatePending
	default:
		*s = TeamMembershipState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamMembershipState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMembershipState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
	{
		e.FieldStart("triage")
		e.Bool(s.Triage)
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		e.FieldStart("maintain")
		e.Bool(s.Maintain)
	}
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
}

var jsonFieldsNameOfTeamPermissions = [5]string{
	0: "pull",
	1: "triage",
	2: "push",
	3: "maintain",
	4: "admin",
}

// Decode decodes TeamPermissions from json.
func (s *TeamPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Triage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Maintain = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamPermissions) {
					name = jsonFieldsNameOfTeamPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamProject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamProject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("owner_url")
		e.Str(s.OwnerURL)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		e.Str(s.HTMLURL)
	}
	{
		e.FieldStart("columns_url")
		e.Str(s.ColumnsURL)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
	{
		e.FieldStart("creator")
		s.Creator.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.FieldStart("organization_permission")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
}

var jsonFieldsNameOfTeamProject = [16]string{
	0:  "owner_url",
	1:  "url",
	2:  "html_url",
	3:  "columns_url",
	4:  "id",
	5:  "node_id",
	6:  "name",
	7:  "body",
	8:  "number",
	9:  "state",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "organization_permission",
	14: "private",
	15: "permissions",
}

// Decode decodes TeamProject from json.
func (s *TeamProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamProject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OwnerURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "columns_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ColumnsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamProject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b10011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamProject) {
					name = jsonFieldsNameOfTeamProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamProjectPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamProjectPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("read")
		e.Bool(s.Read)
	}
	{
		e.FieldStart("write")
		e.Bool(s.Write)
	}
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
}

var jsonFieldsNameOfTeamProjectPermissions = [3]string{
	0: "read",
	1: "write",
	2: "admin",
}

// Decode decodes TeamProjectPermissions from json.
func (s *TeamProjectPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamProjectPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "read":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Read = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read\"")
			}
		case "write":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Write = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"write\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamProjectPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamProjectPermissions) {
					name = jsonFieldsNameOfTeamProjectPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamProjectPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamProjectPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamRepository) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("full_name")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		e.FieldStart("forks")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("private")
		e.Bool(s.Private)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("fork")
		e.Bool(s.Fork)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("archive_url")
		e.Str(s.ArchiveURL)
	}
	{
		e.FieldStart("assignees_url")
		e.Str(s.AssigneesURL)
	}
	{
		e.FieldStart("blobs_url")
		e.Str(s.BlobsURL)
	}
	{
		e.FieldStart("branches_url")
		e.Str(s.BranchesURL)
	}
	{
		e.FieldStart("collaborators_url")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.FieldStart("comments_url")
		e.Str(s.CommentsURL)
	}
	{
		e.FieldStart("commits_url")
		e.Str(s.CommitsURL)
	}
	{
		e.FieldStart("compare_url")
		e.Str(s.CompareURL)
	}
	{
		e.FieldStart("contents_url")
		e.Str(s.ContentsURL)
	}
	{
		e.FieldStart("contributors_url")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.FieldStart("deployments_url")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.FieldStart("downloads_url")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.FieldStart("events_url")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.FieldStart("forks_url")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.FieldStart("git_commits_url")
		e.Str(s.GitCommitsURL)
	}
	{
		e.FieldStart("git_refs_url")
		e.Str(s.GitRefsURL)
	}
	{
		e.FieldStart("git_tags_url")
		e.Str(s.GitTagsURL)
	}
	{
		e.FieldStart("git_url")
		e.Str(s.GitURL)
	}
	{
		e.FieldStart("issue_comment_url")
		e.Str(s.IssueCommentURL)
	}
	{
		e.FieldStart("issue_events_url")
		e.Str(s.IssueEventsURL)
	}
	{
		e.FieldStart("issues_url")
		e.Str(s.IssuesURL)
	}
	{
		e.FieldStart("keys_url")
		e.Str(s.KeysURL)
	}
	{
		e.FieldStart("labels_url")
		e.Str(s.LabelsURL)
	}
	{
		e.FieldStart("languages_url")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.FieldStart("merges_url")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.FieldStart("milestones_url")
		e.Str(s.MilestonesURL)
	}
	{
		e.FieldStart("notifications_url")
		e.Str(s.NotificationsURL)
	}
	{
		e.FieldStart("pulls_url")
		e.Str(s.PullsURL)
	}
	{
		e.FieldStart("releases_url")
		e.Str(s.ReleasesURL)
	}
	{
		e.FieldStart("ssh_url")
		e.Str(s.SSHURL)
	}
	{
		e.FieldStart("stargazers_url")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.FieldStart("statuses_url")
		e.Str(s.StatusesURL)
	}
	{
		e.FieldStart("subscribers_url")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.FieldStart("subscription_url")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.FieldStart("tags_url")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.FieldStart("teams_url")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.FieldStart("trees_url")
		e.Str(s.TreesURL)
	}
	{
		e.FieldStart("clone_url")
		e.Str(s.CloneURL)
	}
	{
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	{
		e.FieldStart("hooks_url")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.FieldStart("svn_url")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("forks_count")
		e.Int(s.ForksCount)
	}
	{
		e.FieldStart("stargazers_count")
		e.Int(s.StargazersCount)
	}
	{
		e.FieldStart("watchers_count")
		e.Int(s.WatchersCount)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		e.FieldStart("default_branch")
		e.Str(s.DefaultBranch)
	}
	{
		e.FieldStart("open_issues_count")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.FieldStart("is_template")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.FieldStart("topics")
			e.ArrStart()
			for _, elem := range s.Topics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("has_issues")
		e.Bool(s.HasIssues)
	}
	{
		e.FieldStart("has_projects")
		e.Bool(s.HasProjects)
	}
	{
		e.FieldStart("has_wiki")
		e.Bool(s.HasWiki)
	}
	{
		e.FieldStart("has_pages")
		e.Bool(s.HasPages)
	}
	{
		e.FieldStart("has_downloads")
		e.Bool(s.HasDownloads)
	}
	{
		e.FieldStart("archived")
		e.Bool(s.Archived)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.FieldStart("allow_rebase_merge")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.FieldStart("template_repository")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.FieldStart("temp_clone_token")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.FieldStart("allow_squash_merge")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.FieldStart("allow_auto_merge")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.FieldStart("delete_branch_on_merge")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.FieldStart("allow_merge_commit")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.FieldStart("allow_forking")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.FieldStart("subscribers_count")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.FieldStart("network_count")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.FieldStart("open_issues")
		e.Int(s.OpenIssues)
	}
	{
		e.FieldStart("watchers")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.FieldStart("master_branch")
			s.MasterBranch.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamRepository = [88]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "forks",
	6:  "permissions",
	7:  "owner",
	8:  "private",
	9:  "html_url",
	10: "description",
	11: "fork",
	12: "url",
	13: "archive_url",
	14: "assignees_url",
	15: "blobs_url",
	16: "branches_url",
	17: "collaborators_url",
	18: "comments_url",
	19: "commits_url",
	20: "compare_url",
	21: "contents_url",
	22: "contributors_url",
	23: "deployments_url",
	24: "downloads_url",
	25: "events_url",
	26: "forks_url",
	27: "git_commits_url",
	28: "git_refs_url",
	29: "git_tags_url",
	30: "git_url",
	31: "issue_comment_url",
	32: "issue_events_url",
	33: "issues_url",
	34: "keys_url",
	35: "labels_url",
	36: "languages_url",
	37: "merges_url",
	38: "milestones_url",
	39: "notifications_url",
	40: "pulls_url",
	41: "releases_url",
	42: "ssh_url",
	43: "stargazers_url",
	44: "statuses_url",
	45: "subscribers_url",
	46: "subscription_url",
	47: "tags_url",
	48: "teams_url",
	49: "trees_url",
	50: "clone_url",
	51: "mirror_url",
	52: "hooks_url",
	53: "svn_url",
	54: "homepage",
	55: "language",
	56: "forks_count",
	57: "stargazers_count",
	58: "watchers_count",
	59: "size",
	60: "default_branch",
	61: "open_issues_count",
	62: "is_template",
	63: "topics",
	64: "has_issues",
	65: "has_projects",
	66: "has_wiki",
	67: "has_pages",
	68: "has_downloads",
	69: "archived",
	70: "disabled",
	71: "visibility",
	72: "pushed_at",
	73: "created_at",
	74: "updated_at",
	75: "allow_rebase_merge",
	76: "template_repository",
	77: "temp_clone_token",
	78: "allow_squash_merge",
	79: "allow_auto_merge",
	80: "delete_branch_on_merge",
	81: "allow_merge_commit",
	82: "allow_forking",
	83: "subscribers_count",
	84: "network_count",
	85: "open_issues",
	86: "watchers",
	87: "master_branch",
}

// Decode decodes TeamRepository from json.
func (s *TeamRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamRepository to nil")
	}
	var requiredBitSet [11]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b00111111,
		0b01111111,
		0b00000111,
		0b01100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamRepository) {
					name = jsonFieldsNameOfTeamRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamRepositoryPermissions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("admin")
		e.Bool(s.Admin)
	}
	{
		e.FieldStart("pull")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.FieldStart("triage")
			s.Triage.Encode(e)
		}
	}
	{
		e.FieldStart("push")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.FieldStart("maintain")
			s.Maintain.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes TeamRepositoryPermissions from json.
func (s *TeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamRepositoryPermissions) {
					name = jsonFieldsNameOfTeamRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamRepositoryPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamRepositoryPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("members_url")
		e.Str(s.MembersURL)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("permission")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("repositories_url")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.FieldStart("ldap_dn")
			s.LdapDn.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamSimple = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "members_url",
	4:  "name",
	5:  "description",
	6:  "permission",
	7:  "privacy",
	8:  "html_url",
	9:  "repositories_url",
	10: "slug",
	11: "ldap_dn",
}

// Decode decodes TeamSimple from json.
func (s *TeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "members_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "slug":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamSimple) {
					name = jsonFieldsNameOfTeamSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateMembershipForUserInOrgReq = [1]string{
	0: "role",
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateMembershipForUserInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserInOrgReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateMembershipForUserLegacyReq = [1]string{
	0: "role",
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateMembershipForUserLegacyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserLegacyReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyReqRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReqRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsInOrgForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsInOrgReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			e.FieldStart("documentation_url")
			s.DocumentationURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsLegacyForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsLegacyReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsLegacyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateRepoPermissionsInOrgReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateRepoPermissionsInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage
	default:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsAddOrUpdateRepoPermissionsLegacyReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateRepoPermissionsLegacyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateDiscussionCommentInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq = [1]string{
	0: "body",
}

// Decode decodes TeamsCreateDiscussionCommentInOrgReq from json.
func (s *TeamsCreateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateDiscussionCommentInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateDiscussionCommentInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateDiscussionCommentLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq = [1]string{
	0: "body",
}

// Decode decodes TeamsCreateDiscussionCommentLegacyReq from json.
func (s *TeamsCreateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateDiscussionCommentLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateDiscussionCommentLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateDiscussionInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsCreateDiscussionInOrgReq = [3]string{
	0: "title",
	1: "body",
	2: "private",
}

// Decode decodes TeamsCreateDiscussionInOrgReq from json.
func (s *TeamsCreateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionInOrgReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionInOrgReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateDiscussionInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateDiscussionInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateDiscussionLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsCreateDiscussionLegacyReq = [3]string{
	0: "title",
	1: "body",
	2: "private",
}

// Decode decodes TeamsCreateDiscussionLegacyReq from json.
func (s *TeamsCreateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionLegacyReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateDiscussionLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateDiscussionLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReq = [1]string{
	0: "groups",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = make([]TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("group_id")
		e.Str(s.GroupID)
	}
	{
		e.FieldStart("group_name")
		e.Str(s.GroupName)
	}
	{
		e.FieldStart("group_description")
		e.Str(s.GroupDescription)
	}
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem = [3]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.SyncedAt.Set {
			e.FieldStart("synced_at")
			s.SyncedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq = [2]string{
	0: "groups",
	1: "synced_at",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Groups = make([]TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "synced_at":
			if err := func() error {
				s.SyncedAt.Reset()
				if err := s.SyncedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synced_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("group_id")
		e.Str(s.GroupID)
	}
	{
		e.FieldStart("group_name")
		e.Str(s.GroupName)
	}
	{
		e.FieldStart("group_description")
		e.Str(s.GroupDescription)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem = [6]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
	3: "id",
	4: "name",
	5: "description",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsCreateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Maintainers != nil {
			e.FieldStart("maintainers")
			e.ArrStart()
			for _, elem := range s.Maintainers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepoNames != nil {
			e.FieldStart("repo_names")
			e.ArrStart()
			for _, elem := range s.RepoNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.FieldStart("parent_team_id")
			s.ParentTeamID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsCreateReq = [7]string{
	0: "name",
	1: "description",
	2: "maintainers",
	3: "repo_names",
	4: "privacy",
	5: "permission",
	6: "parent_team_id",
}

// Decode decodes TeamsCreateReq from json.
func (s *TeamsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "maintainers":
			if err := func() error {
				s.Maintainers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Maintainers = append(s.Maintainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainers\"")
			}
		case "repo_names":
			if err := func() error {
				s.RepoNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RepoNames = append(s.RepoNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo_names\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateReq) {
					name = jsonFieldsNameOfTeamsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsCreateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsCreateReqPermission as json.
func (s TeamsCreateReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPermission from json.
func (s *TeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPermission(v) {
	case TeamsCreateReqPermissionPull:
		*s = TeamsCreateReqPermissionPull
	case TeamsCreateReqPermissionPush:
		*s = TeamsCreateReqPermissionPush
	case TeamsCreateReqPermissionAdmin:
		*s = TeamsCreateReqPermissionAdmin
	default:
		*s = TeamsCreateReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsCreateReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (s TeamsCreateReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (s *TeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPrivacy(v) {
	case TeamsCreateReqPrivacySecret:
		*s = TeamsCreateReqPrivacySecret
	case TeamsCreateReqPrivacyClosed:
		*s = TeamsCreateReqPrivacyClosed
	default:
		*s = TeamsCreateReqPrivacy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsCreateReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsCreateReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListChildLegacyForbidden as json.
func (s *TeamsListChildLegacyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyForbidden from json.
func (s *TeamsListChildLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListChildLegacyForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListChildLegacyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListChildLegacyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListChildLegacyNotFound as json.
func (s *TeamsListChildLegacyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyNotFound from json.
func (s *TeamsListChildLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListChildLegacyNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListChildLegacyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListChildLegacyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListForAuthenticatedUserForbidden as json.
func (s *TeamsListForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserForbidden from json.
func (s *TeamsListForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListForAuthenticatedUserNotFound as json.
func (s *TeamsListForAuthenticatedUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserNotFound from json.
func (s *TeamsListForAuthenticatedUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListForAuthenticatedUserNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListForAuthenticatedUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListForAuthenticatedUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListIdpGroupsForLegacyForbidden as json.
func (s *TeamsListIdpGroupsForLegacyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyForbidden from json.
func (s *TeamsListIdpGroupsForLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListIdpGroupsForLegacyForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListIdpGroupsForLegacyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListIdpGroupsForLegacyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsListIdpGroupsForLegacyNotFound as json.
func (s *TeamsListIdpGroupsForLegacyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyNotFound from json.
func (s *TeamsListIdpGroupsForLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListIdpGroupsForLegacyNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsListIdpGroupsForLegacyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsListIdpGroupsForLegacyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateDiscussionCommentInOrgReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq = [1]string{
	0: "body",
}

// Decode decodes TeamsUpdateDiscussionCommentInOrgReq from json.
func (s *TeamsUpdateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateDiscussionCommentInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateDiscussionCommentInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateDiscussionCommentLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq = [1]string{
	0: "body",
}

// Decode decodes TeamsUpdateDiscussionCommentLegacyReq from json.
func (s *TeamsUpdateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateDiscussionCommentLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateDiscussionCommentLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateDiscussionInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsUpdateDiscussionInOrgReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (s *TeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateDiscussionInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateDiscussionInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateDiscussionLegacyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsUpdateDiscussionLegacyReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (s *TeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionLegacyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateDiscussionLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateDiscussionLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateInOrgReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.FieldStart("parent_team_id")
			s.ParentTeamID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsUpdateInOrgReq = [5]string{
	0: "name",
	1: "description",
	2: "privacy",
	3: "permission",
	4: "parent_team_id",
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (s *TeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateInOrgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateInOrgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateInOrgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (s TeamsUpdateInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (s *TeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPermission(v) {
	case TeamsUpdateInOrgReqPermissionPull:
		*s = TeamsUpdateInOrgReqPermissionPull
	case TeamsUpdateInOrgReqPermissionPush:
		*s = TeamsUpdateInOrgReqPermissionPush
	case TeamsUpdateInOrgReqPermissionAdmin:
		*s = TeamsUpdateInOrgReqPermissionAdmin
	default:
		*s = TeamsUpdateInOrgReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsUpdateInOrgReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateInOrgReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (s TeamsUpdateInOrgReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (s *TeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPrivacy(v) {
	case TeamsUpdateInOrgReqPrivacySecret:
		*s = TeamsUpdateInOrgReqPrivacySecret
	case TeamsUpdateInOrgReqPrivacyClosed:
		*s = TeamsUpdateInOrgReqPrivacyClosed
	default:
		*s = TeamsUpdateInOrgReqPrivacy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsUpdateInOrgReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateInOrgReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyCreated as json.
func (s *TeamsUpdateLegacyCreated) Encode(e *jx.Encoder) {
	unwrapped := (*TeamFull)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyCreated from json.
func (s *TeamsUpdateLegacyCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyCreated to nil")
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyCreated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateLegacyCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyForbidden as json.
func (s *TeamsUpdateLegacyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyForbidden from json.
func (s *TeamsUpdateLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateLegacyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyNotFound as json.
func (s *TeamsUpdateLegacyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyNotFound from json.
func (s *TeamsUpdateLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateLegacyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyOK as json.
func (s *TeamsUpdateLegacyOK) Encode(e *jx.Encoder) {
	unwrapped := (*TeamFull)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyOK from json.
func (s *TeamsUpdateLegacyOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyOK to nil")
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateLegacyOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamsUpdateLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamsUpdateLegacyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			e.FieldStart("privacy")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.FieldStart("permission")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.FieldStart("parent_team_id")
			s.ParentTeamID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamsUpdateLegacyReq = [5]string{
	0: "name",
	1: "description",
	2: "privacy",
	3: "permission",
	4: "parent_team_id",
}

// Decode decodes TeamsUpdateLegacyReq from json.
func (s *TeamsUpdateLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateLegacyReq) {
					name = jsonFieldsNameOfTeamsUpdateLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsUpdateLegacyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (s TeamsUpdateLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (s *TeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPermission(v) {
	case TeamsUpdateLegacyReqPermissionPull:
		*s = TeamsUpdateLegacyReqPermissionPull
	case TeamsUpdateLegacyReqPermissionPush:
		*s = TeamsUpdateLegacyReqPermissionPush
	case TeamsUpdateLegacyReqPermissionAdmin:
		*s = TeamsUpdateLegacyReqPermissionAdmin
	default:
		*s = TeamsUpdateLegacyReqPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsUpdateLegacyReqPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyReqPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (s TeamsUpdateLegacyReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (s *TeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPrivacy(v) {
	case TeamsUpdateLegacyReqPrivacySecret:
		*s = TeamsUpdateLegacyReqPrivacySecret
	case TeamsUpdateLegacyReqPrivacyClosed:
		*s = TeamsUpdateLegacyReqPrivacyClosed
	default:
		*s = TeamsUpdateLegacyReqPrivacy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TeamsUpdateLegacyReqPrivacy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsUpdateLegacyReqPrivacy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Thread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Thread) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("subject")
		s.Subject.Encode(e)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("unread")
		e.Bool(s.Unread)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("last_read_at")
		s.LastReadAt.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("subscription_url")
		e.Str(s.SubscriptionURL)
	}
}

var jsonFieldsNameOfThread = [9]string{
	0: "id",
	1: "repository",
	2: "subject",
	3: "reason",
	4: "unread",
	5: "updated_at",
	6: "last_read_at",
	7: "url",
	8: "subscription_url",
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Thread to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Subject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "unread":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Unread = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unread\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "last_read_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.LastReadAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "subscription_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Thread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThread) {
					name = jsonFieldsNameOfThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Thread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Thread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadSubject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadSubject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("latest_comment_url")
		e.Str(s.LatestCommentURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfThreadSubject = [4]string{
	0: "title",
	1: "url",
	2: "latest_comment_url",
	3: "type",
}

// Decode decodes ThreadSubject from json.
func (s *ThreadSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "latest_comment_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LatestCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_comment_url\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadSubject) {
					name = jsonFieldsNameOfThreadSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadSubject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadSubject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadSubscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadSubscription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscribed")
		e.Bool(s.Subscribed)
	}
	{
		e.FieldStart("ignored")
		e.Bool(s.Ignored)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	{
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.ThreadURL.Set {
			e.FieldStart("thread_url")
			s.ThreadURL.Encode(e)
		}
	}
	{
		if s.RepositoryURL.Set {
			e.FieldStart("repository_url")
			s.RepositoryURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfThreadSubscription = [7]string{
	0: "subscribed",
	1: "ignored",
	2: "reason",
	3: "created_at",
	4: "url",
	5: "thread_url",
	6: "repository_url",
}

// Decode decodes ThreadSubscription from json.
func (s *ThreadSubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadSubscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ignored = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thread_url":
			if err := func() error {
				s.ThreadURL.Reset()
				if err := s.ThreadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_url\"")
			}
		case "repository_url":
			if err := func() error {
				s.RepositoryURL.Reset()
				if err := s.RepositoryURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadSubscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadSubscription) {
					name = jsonFieldsNameOfThreadSubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadSubscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadSubscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Topic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Topic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("names")
		e.ArrStart()
		for _, elem := range s.Names {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTopic = [1]string{
	0: "names",
}

// Decode decodes Topic from json.
func (s *Topic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Topic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Topic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTopic) {
					name = jsonFieldsNameOfTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Topic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Topic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopicSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopicSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("display_name")
		s.DisplayName.Encode(e)
	}
	{
		e.FieldStart("short_description")
		s.ShortDescription.Encode(e)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("created_by")
		s.CreatedBy.Encode(e)
	}
	{
		e.FieldStart("released")
		s.Released.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		e.FieldStart("curated")
		e.Bool(s.Curated)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		if s.RepositoryCount.Set {
			e.FieldStart("repository_count")
			s.RepositoryCount.Encode(e)
		}
	}
	{
		if s.LogoURL.Set {
			e.FieldStart("logo_url")
			s.LogoURL.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.FieldStart("related")
			s.Related.Encode(e)
		}
	}
	{
		if s.Aliases.Set {
			e.FieldStart("aliases")
			s.Aliases.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopicSearchResultItem = [16]string{
	0:  "name",
	1:  "display_name",
	2:  "short_description",
	3:  "description",
	4:  "created_by",
	5:  "released",
	6:  "created_at",
	7:  "updated_at",
	8:  "featured",
	9:  "curated",
	10: "score",
	11: "repository_count",
	12: "logo_url",
	13: "text_matches",
	14: "related",
	15: "aliases",
}

// Decode decodes TopicSearchResultItem from json.
func (s *TopicSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "short_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ShortDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short_description\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_by":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "released":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Released.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"released\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "featured":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "curated":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Curated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"curated\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "repository_count":
			if err := func() error {
				s.RepositoryCount.Reset()
				if err := s.RepositoryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_count\"")
			}
		case "logo_url":
			if err := func() error {
				s.LogoURL.Reset()
				if err := s.LogoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logo_url\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "aliases":
			if err := func() error {
				s.Aliases.Reset()
				if err := s.Aliases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliases\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTopicSearchResultItem) {
					name = jsonFieldsNameOfTopicSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopicSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopicSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopicSearchResultItemAliasesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopicSearchResultItemAliasesItem) encodeFields(e *jx.Encoder) {
	{
		if s.TopicRelation.Set {
			e.FieldStart("topic_relation")
			s.TopicRelation.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopicSearchResultItemAliasesItem = [1]string{
	0: "topic_relation",
}

// Decode decodes TopicSearchResultItemAliasesItem from json.
func (s *TopicSearchResultItemAliasesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemAliasesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			if err := func() error {
				s.TopicRelation.Reset()
				if err := s.TopicRelation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_relation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemAliasesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopicSearchResultItemAliasesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopicSearchResultItemAliasesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopicSearchResultItemAliasesItemTopicRelation) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			e.FieldStart("topic_id")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			e.FieldStart("relation_type")
			s.RelationType.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopicSearchResultItemAliasesItemTopicRelation = [4]string{
	0: "id",
	1: "name",
	2: "topic_id",
	3: "relation_type",
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (s *TopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemAliasesItemTopicRelation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "topic_id":
			if err := func() error {
				s.TopicID.Reset()
				if err := s.TopicID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_id\"")
			}
		case "relation_type":
			if err := func() error {
				s.RelationType.Reset()
				if err := s.RelationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relation_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemAliasesItemTopicRelation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopicSearchResultItemAliasesItemTopicRelation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopicSearchResultItemAliasesItemTopicRelation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopicSearchResultItemRelatedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopicSearchResultItemRelatedItem) encodeFields(e *jx.Encoder) {
	{
		if s.TopicRelation.Set {
			e.FieldStart("topic_relation")
			s.TopicRelation.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopicSearchResultItemRelatedItem = [1]string{
	0: "topic_relation",
}

// Decode decodes TopicSearchResultItemRelatedItem from json.
func (s *TopicSearchResultItemRelatedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemRelatedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			if err := func() error {
				s.TopicRelation.Reset()
				if err := s.TopicRelation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_relation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemRelatedItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopicSearchResultItemRelatedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopicSearchResultItemRelatedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopicSearchResultItemRelatedItemTopicRelation) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			e.FieldStart("topic_id")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			e.FieldStart("relation_type")
			s.RelationType.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopicSearchResultItemRelatedItemTopicRelation = [4]string{
	0: "id",
	1: "name",
	2: "topic_id",
	3: "relation_type",
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (s *TopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemRelatedItemTopicRelation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "topic_id":
			if err := func() error {
				s.TopicID.Reset()
				if err := s.TopicID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_id\"")
			}
		case "relation_type":
			if err := func() error {
				s.RelationType.Reset()
				if err := s.RelationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relation_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemRelatedItemTopicRelation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopicSearchResultItemRelatedItemTopicRelation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopicSearchResultItemRelatedItemTopicRelation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Traffic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Traffic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.FieldStart("uniques")
		e.Int(s.Uniques)
	}
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfTraffic = [3]string{
	0: "timestamp",
	1: "uniques",
	2: "count",
}

// Decode decodes Traffic from json.
func (s *Traffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Traffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Traffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraffic) {
					name = jsonFieldsNameOfTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Traffic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Traffic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserMarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserMarketplacePurchase) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("billing_cycle")
		e.Str(s.BillingCycle)
	}
	{
		e.FieldStart("next_billing_date")
		s.NextBillingDate.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("unit_count")
		s.UnitCount.Encode(e)
	}
	{
		e.FieldStart("on_free_trial")
		e.Bool(s.OnFreeTrial)
	}
	{
		e.FieldStart("free_trial_ends_on")
		s.FreeTrialEndsOn.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("account")
		s.Account.Encode(e)
	}
	{
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
}

var jsonFieldsNameOfUserMarketplacePurchase = [8]string{
	0: "billing_cycle",
	1: "next_billing_date",
	2: "unit_count",
	3: "on_free_trial",
	4: "free_trial_ends_on",
	5: "updated_at",
	6: "account",
	7: "plan",
}

// Decode decodes UserMarketplacePurchase from json.
func (s *UserMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserMarketplacePurchase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BillingCycle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_cycle\"")
			}
		case "next_billing_date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextBillingDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_billing_date\"")
			}
		case "unit_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "on_free_trial":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.OnFreeTrial = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_free_trial\"")
			}
		case "free_trial_ends_on":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FreeTrialEndsOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_trial_ends_on\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "plan":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserMarketplacePurchase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserMarketplacePurchase) {
					name = jsonFieldsNameOfUserMarketplacePurchase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserMarketplacePurchase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserMarketplacePurchase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSearchResultItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("avatar_url")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	{
		e.FieldStart("url")
		json.EncodeURI(e, s.URL)
	}
	{
		e.FieldStart("html_url")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.FieldStart("followers_url")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.FieldStart("subscriptions_url")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.FieldStart("organizations_url")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.FieldStart("repos_url")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.FieldStart("received_events_url")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("score")
		e.Float64(s.Score)
	}
	{
		e.FieldStart("following_url")
		e.Str(s.FollowingURL)
	}
	{
		e.FieldStart("gists_url")
		e.Str(s.GistsURL)
	}
	{
		e.FieldStart("starred_url")
		e.Str(s.StarredURL)
	}
	{
		e.FieldStart("events_url")
		e.Str(s.EventsURL)
	}
	{
		if s.PublicRepos.Set {
			e.FieldStart("public_repos")
			s.PublicRepos.Encode(e)
		}
	}
	{
		if s.PublicGists.Set {
			e.FieldStart("public_gists")
			s.PublicGists.Encode(e)
		}
	}
	{
		if s.Followers.Set {
			e.FieldStart("followers")
			s.Followers.Encode(e)
		}
	}
	{
		if s.Following.Set {
			e.FieldStart("following")
			s.Following.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		e.FieldStart("site_admin")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Hireable.Set {
			e.FieldStart("hireable")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.FieldStart("text_matches")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.FieldStart("blog")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.FieldStart("company")
			s.Company.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.FieldStart("suspended_at")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUserSearchResultItem = [34]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "subscriptions_url",
	9:  "organizations_url",
	10: "repos_url",
	11: "received_events_url",
	12: "type",
	13: "score",
	14: "following_url",
	15: "gists_url",
	16: "starred_url",
	17: "events_url",
	18: "public_repos",
	19: "public_gists",
	20: "followers",
	21: "following",
	22: "created_at",
	23: "updated_at",
	24: "name",
	25: "bio",
	26: "email",
	27: "location",
	28: "site_admin",
	29: "hireable",
	30: "text_matches",
	31: "blog",
	32: "company",
	33: "suspended_at",
}

// Decode decodes UserSearchResultItem from json.
func (s *UserSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSearchResultItem to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "public_repos":
			if err := func() error {
				s.PublicRepos.Reset()
				if err := s.PublicRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			if err := func() error {
				s.PublicGists.Reset()
				if err := s.PublicGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			if err := func() error {
				s.Followers.Reset()
				if err := s.Followers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			if err := func() error {
				s.Following.Reset()
				if err := s.Following.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "site_admin":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "hireable":
			if err := func() error {
				s.Hireable.Reset()
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "text_matches":
			if err := func() error {
				if err := s.TextMatches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserSearchResultItem) {
					name = jsonFieldsNameOfUserSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSearchResultItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSearchResultItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedCreatedApplicationJSON as json.
func (s UsersAddEmailForAuthenticatedCreatedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Email(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersAddEmailForAuthenticatedCreatedApplicationJSON from json.
func (s *UsersAddEmailForAuthenticatedCreatedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedCreatedApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = make([]Email, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedCreatedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersAddEmailForAuthenticatedCreatedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedCreatedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedForbidden as json.
func (s *UsersAddEmailForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedForbidden from json.
func (s *UsersAddEmailForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersAddEmailForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedNotFound as json.
func (s *UsersAddEmailForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedNotFound from json.
func (s *UsersAddEmailForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersAddEmailForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (s UsersAddEmailForAuthenticatedReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq:
		s.UsersAddEmailForAuthenticatedReq0.Encode(e)
	case StringArrayUsersAddEmailForAuthenticatedReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	case StringUsersAddEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (s *UsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayUsersAddEmailForAuthenticatedReq
	case jx.Object:
		if err := s.UsersAddEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersAddEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersAddEmailForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersAddEmailForAuthenticatedReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersAddEmailForAuthenticatedReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0 = [1]string{
	0: "emails",
}

// Decode decodes UsersAddEmailForAuthenticatedReq0 from json.
func (s *UsersAddEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Emails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersAddEmailForAuthenticatedReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0) {
					name = jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersAddEmailForAuthenticatedReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersAddEmailForAuthenticatedUnauthorized as json.
func (s *UsersAddEmailForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedUnauthorized from json.
func (s *UsersAddEmailForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersAddEmailForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersAddEmailForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersBlockForbidden as json.
func (s *UsersBlockForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersBlockForbidden from json.
func (s *UsersBlockForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBlockForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBlockForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersBlockNotFound as json.
func (s *UsersBlockNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersBlockNotFound from json.
func (s *UsersBlockNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBlockNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBlockNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersBlockUnauthorized as json.
func (s *UsersBlockUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersBlockUnauthorized from json.
func (s *UsersBlockUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBlockUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBlockUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckBlockedForbidden as json.
func (s *UsersCheckBlockedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedForbidden from json.
func (s *UsersCheckBlockedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckBlockedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckBlockedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckBlockedNotFound as json.
func (s *UsersCheckBlockedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedNotFound from json.
func (s *UsersCheckBlockedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckBlockedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckBlockedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckBlockedUnauthorized as json.
func (s *UsersCheckBlockedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedUnauthorized from json.
func (s *UsersCheckBlockedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckBlockedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckBlockedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedForbidden as json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedForbidden from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedNotFound as json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedNotFound from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedUnauthorized as json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedUnauthorized from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCheckPersonIsFollowedByAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedForbidden as json.
func (s *UsersCreateGpgKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedForbidden from json.
func (s *UsersCreateGpgKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreateGpgKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreateGpgKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedNotFound as json.
func (s *UsersCreateGpgKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedNotFound from json.
func (s *UsersCreateGpgKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreateGpgKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreateGpgKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersCreateGpgKeyForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersCreateGpgKeyForAuthenticatedReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("armored_public_key")
		e.Str(s.ArmoredPublicKey)
	}
}

var jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq = [1]string{
	0: "armored_public_key",
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedReq from json.
func (s *UsersCreateGpgKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "armored_public_key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArmoredPublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armored_public_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersCreateGpgKeyForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreateGpgKeyForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreateGpgKeyForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedUnauthorized as json.
func (s *UsersCreateGpgKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedUnauthorized from json.
func (s *UsersCreateGpgKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreateGpgKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreateGpgKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedForbidden as json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedForbidden from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedNotFound as json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedNotFound from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
}

var jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq = [2]string{
	0: "title",
	1: "key",
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedReq from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersCreatePublicSSHKeyForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedUnauthorized as json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedUnauthorized from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersCreatePublicSSHKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteEmailForAuthenticatedForbidden as json.
func (s *UsersDeleteEmailForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedForbidden from json.
func (s *UsersDeleteEmailForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteEmailForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteEmailForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteEmailForAuthenticatedNotFound as json.
func (s *UsersDeleteEmailForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedNotFound from json.
func (s *UsersDeleteEmailForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteEmailForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteEmailForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (s UsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq:
		s.UsersDeleteEmailForAuthenticatedReq0.Encode(e)
	case StringArrayUsersDeleteEmailForAuthenticatedReq:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	case StringUsersDeleteEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (s *UsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayUsersDeleteEmailForAuthenticatedReq
	case jx.Object:
		if err := s.UsersDeleteEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersDeleteEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersDeleteEmailForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteEmailForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersDeleteEmailForAuthenticatedReq0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersDeleteEmailForAuthenticatedReq0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0 = [1]string{
	0: "emails",
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq0 from json.
func (s *UsersDeleteEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Emails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersDeleteEmailForAuthenticatedReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0) {
					name = jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteEmailForAuthenticatedReq0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteEmailForAuthenticatedReq0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteEmailForAuthenticatedUnauthorized as json.
func (s *UsersDeleteEmailForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedUnauthorized from json.
func (s *UsersDeleteEmailForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteEmailForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteEmailForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedForbidden as json.
func (s *UsersDeleteGpgKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedForbidden from json.
func (s *UsersDeleteGpgKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedNotFound as json.
func (s *UsersDeleteGpgKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedNotFound from json.
func (s *UsersDeleteGpgKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedUnauthorized as json.
func (s *UsersDeleteGpgKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedUnauthorized from json.
func (s *UsersDeleteGpgKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeleteGpgKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedForbidden as json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedForbidden from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedNotFound as json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedNotFound from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedUnauthorized as json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedUnauthorized from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDeletePublicSSHKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersFollowForbidden as json.
func (s *UsersFollowForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersFollowForbidden from json.
func (s *UsersFollowForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersFollowForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersFollowForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersFollowNotFound as json.
func (s *UsersFollowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersFollowNotFound from json.
func (s *UsersFollowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersFollowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersFollowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersFollowUnauthorized as json.
func (s *UsersFollowUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersFollowUnauthorized from json.
func (s *UsersFollowUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersFollowUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersFollowUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetAuthenticatedForbidden as json.
func (s *UsersGetAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedForbidden from json.
func (s *UsersGetAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetAuthenticatedOK as json.
func (s UsersGetAuthenticatedOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetAuthenticatedOK:
		s.PublicUser.Encode(e)
	}
}

func (s UsersGetAuthenticatedOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		s.PrivateUser.encodeFields(e)
	case PublicUserUsersGetAuthenticatedOK:
		s.PublicUser.encodeFields(e)
	}
}

// Decode decodes UsersGetAuthenticatedOK from json.
func (s *UsersGetAuthenticatedOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "two_factor_authentication":
				match := PrivateUserUsersGetAuthenticatedOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "business_plus":
				match := PrivateUserUsersGetAuthenticatedOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "ldap_dn":
				match := PrivateUserUsersGetAuthenticatedOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = PublicUserUsersGetAuthenticatedOK
	}
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetAuthenticatedOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersGetAuthenticatedOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetAuthenticatedOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetAuthenticatedUnauthorized as json.
func (s *UsersGetAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedUnauthorized from json.
func (s *UsersGetAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetByUsernameOK as json.
func (s UsersGetByUsernameOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetByUsernameOK:
		s.PublicUser.Encode(e)
	}
}

func (s UsersGetByUsernameOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		s.PrivateUser.encodeFields(e)
	case PublicUserUsersGetByUsernameOK:
		s.PublicUser.encodeFields(e)
	}
}

// Decode decodes UsersGetByUsernameOK from json.
func (s *UsersGetByUsernameOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetByUsernameOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "two_factor_authentication":
				match := PrivateUserUsersGetByUsernameOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "business_plus":
				match := PrivateUserUsersGetByUsernameOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "ldap_dn":
				match := PrivateUserUsersGetByUsernameOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = PublicUserUsersGetByUsernameOK
	}
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetByUsernameOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersGetByUsernameOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetByUsernameOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetGpgKeyForAuthenticatedForbidden as json.
func (s *UsersGetGpgKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedForbidden from json.
func (s *UsersGetGpgKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetGpgKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetGpgKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetGpgKeyForAuthenticatedNotFound as json.
func (s *UsersGetGpgKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedNotFound from json.
func (s *UsersGetGpgKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetGpgKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetGpgKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetGpgKeyForAuthenticatedUnauthorized as json.
func (s *UsersGetGpgKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedUnauthorized from json.
func (s *UsersGetGpgKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetGpgKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetGpgKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedForbidden as json.
func (s *UsersGetPublicSSHKeyForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedForbidden from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedNotFound as json.
func (s *UsersGetPublicSSHKeyForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedNotFound from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedUnauthorized as json.
func (s *UsersGetPublicSSHKeyForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedUnauthorized from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersGetPublicSSHKeyForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListBlockedByAuthenticatedForbidden as json.
func (s *UsersListBlockedByAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedForbidden from json.
func (s *UsersListBlockedByAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListBlockedByAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListBlockedByAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListBlockedByAuthenticatedNotFound as json.
func (s *UsersListBlockedByAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedNotFound from json.
func (s *UsersListBlockedByAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListBlockedByAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListBlockedByAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListBlockedByAuthenticatedOKApplicationJSON as json.
func (s UsersListBlockedByAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListBlockedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListBlockedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = make([]SimpleUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersListBlockedByAuthenticatedOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListBlockedByAuthenticatedOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListBlockedByAuthenticatedUnauthorized as json.
func (s *UsersListBlockedByAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedUnauthorized from json.
func (s *UsersListBlockedByAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListBlockedByAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListBlockedByAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListEmailsForAuthenticatedForbidden as json.
func (s *UsersListEmailsForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedForbidden from json.
func (s *UsersListEmailsForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListEmailsForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListEmailsForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListEmailsForAuthenticatedNotFound as json.
func (s *UsersListEmailsForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedNotFound from json.
func (s *UsersListEmailsForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListEmailsForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListEmailsForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListEmailsForAuthenticatedUnauthorized as json.
func (s *UsersListEmailsForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedUnauthorized from json.
func (s *UsersListEmailsForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListEmailsForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListEmailsForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListFollowedByAuthenticatedForbidden as json.
func (s *UsersListFollowedByAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedForbidden from json.
func (s *UsersListFollowedByAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowedByAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListFollowedByAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListFollowedByAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListFollowedByAuthenticatedUnauthorized as json.
func (s *UsersListFollowedByAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedUnauthorized from json.
func (s *UsersListFollowedByAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowedByAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListFollowedByAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListFollowedByAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListFollowersForAuthenticatedUserForbidden as json.
func (s *UsersListFollowersForAuthenticatedUserForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserForbidden from json.
func (s *UsersListFollowersForAuthenticatedUserForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowersForAuthenticatedUserForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListFollowersForAuthenticatedUserForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListFollowersForAuthenticatedUserForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListFollowersForAuthenticatedUserUnauthorized as json.
func (s *UsersListFollowersForAuthenticatedUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserUnauthorized from json.
func (s *UsersListFollowersForAuthenticatedUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowersForAuthenticatedUserUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListFollowersForAuthenticatedUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListFollowersForAuthenticatedUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListGpgKeysForAuthenticatedForbidden as json.
func (s *UsersListGpgKeysForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedForbidden from json.
func (s *UsersListGpgKeysForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListGpgKeysForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListGpgKeysForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListGpgKeysForAuthenticatedNotFound as json.
func (s *UsersListGpgKeysForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedNotFound from json.
func (s *UsersListGpgKeysForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListGpgKeysForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListGpgKeysForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListGpgKeysForAuthenticatedUnauthorized as json.
func (s *UsersListGpgKeysForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedUnauthorized from json.
func (s *UsersListGpgKeysForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListGpgKeysForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListGpgKeysForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicEmailsForAuthenticatedForbidden as json.
func (s *UsersListPublicEmailsForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedForbidden from json.
func (s *UsersListPublicEmailsForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicEmailsForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicEmailsForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicEmailsForAuthenticatedNotFound as json.
func (s *UsersListPublicEmailsForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedNotFound from json.
func (s *UsersListPublicEmailsForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicEmailsForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicEmailsForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicEmailsForAuthenticatedUnauthorized as json.
func (s *UsersListPublicEmailsForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedUnauthorized from json.
func (s *UsersListPublicEmailsForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicEmailsForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicEmailsForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedForbidden as json.
func (s *UsersListPublicSSHKeysForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedForbidden from json.
func (s *UsersListPublicSSHKeysForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedNotFound as json.
func (s *UsersListPublicSSHKeysForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedNotFound from json.
func (s *UsersListPublicSSHKeysForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedUnauthorized as json.
func (s *UsersListPublicSSHKeysForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedUnauthorized from json.
func (s *UsersListPublicSSHKeysForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersListPublicSSHKeysForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden as json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound as json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Email(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = make([]Email, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
}

var jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq = [1]string{
	0: "visibility",
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReq from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visibility":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v) {
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate
	default:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized as json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnblockForbidden as json.
func (s *UsersUnblockForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockForbidden from json.
func (s *UsersUnblockForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnblockForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnblockForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnblockNotFound as json.
func (s *UsersUnblockNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockNotFound from json.
func (s *UsersUnblockNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnblockNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnblockNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnblockUnauthorized as json.
func (s *UsersUnblockUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockUnauthorized from json.
func (s *UsersUnblockUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnblockUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnblockUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnfollowForbidden as json.
func (s *UsersUnfollowForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowForbidden from json.
func (s *UsersUnfollowForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnfollowForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnfollowForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnfollowNotFound as json.
func (s *UsersUnfollowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowNotFound from json.
func (s *UsersUnfollowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnfollowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnfollowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUnfollowUnauthorized as json.
func (s *UsersUnfollowUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowUnauthorized from json.
func (s *UsersUnfollowUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUnfollowUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUnfollowUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUpdateAuthenticatedForbidden as json.
func (s *UsersUpdateAuthenticatedForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedForbidden from json.
func (s *UsersUpdateAuthenticatedForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUpdateAuthenticatedForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUpdateAuthenticatedForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUpdateAuthenticatedNotFound as json.
func (s *UsersUpdateAuthenticatedNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedNotFound from json.
func (s *UsersUpdateAuthenticatedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUpdateAuthenticatedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUpdateAuthenticatedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersUpdateAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersUpdateAuthenticatedReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.FieldStart("blog")
			s.Blog.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.FieldStart("company")
			s.Company.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Hireable.Set {
			e.FieldStart("hireable")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersUpdateAuthenticatedReq = [8]string{
	0: "name",
	1: "email",
	2: "blog",
	3: "twitter_username",
	4: "company",
	5: "location",
	6: "hireable",
	7: "bio",
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (s *UsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "hireable":
			if err := func() error {
				s.Hireable.Reset()
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersUpdateAuthenticatedReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUpdateAuthenticatedReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUpdateAuthenticatedReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersUpdateAuthenticatedUnauthorized as json.
func (s *UsersUpdateAuthenticatedUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*BasicError)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedUnauthorized from json.
func (s *UsersUpdateAuthenticatedUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUpdateAuthenticatedUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUpdateAuthenticatedUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("documentation_url")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ValidationErrorErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationErrorErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationErrorErrorsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Index.Set {
			e.FieldStart("index")
			s.Index.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidationErrorErrorsItem = [6]string{
	0: "resource",
	1: "field",
	2: "message",
	3: "code",
	4: "index",
	5: "value",
}

// Decode decodes ValidationErrorErrorsItem from json.
func (s *ValidationErrorErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorErrorsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationErrorErrorsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationErrorErrorsItem) {
					name = jsonFieldsNameOfValidationErrorErrorsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationErrorErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (s ValidationErrorErrorsItemValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case NullValidationErrorErrorsItemValue:
		_ = s.Null
		e.Null()
	case StringValidationErrorErrorsItemValue:
		e.Str(s.String)
	case IntValidationErrorErrorsItemValue:
		e.Int(s.Int)
	case StringArrayValidationErrorErrorsItemValue:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (s *ValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorErrorsItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayValidationErrorErrorsItemValue
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullValidationErrorErrorsItemValue
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorErrorsItemValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorErrorsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationErrorErrorsItemValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorErrorsItemValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationErrorSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationErrorSimple) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("documentation_url")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationErrorSimple = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ValidationErrorSimple from json.
func (s *ValidationErrorSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationErrorSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationErrorSimple) {
					name = jsonFieldsNameOfValidationErrorSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationErrorSimple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorSimple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Verification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Verification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
	{
		e.FieldStart("signature")
		s.Signature.Encode(e)
	}
}

var jsonFieldsNameOfVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "payload",
	3: "signature",
}

// Decode decodes Verification from json.
func (s *Verification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Verification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "signature":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Verification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerification) {
					name = jsonFieldsNameOfVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Verification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Verification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ViewTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ViewTraffic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("uniques")
		e.Int(s.Uniques)
	}
	{
		e.FieldStart("views")
		e.ArrStart()
		for _, elem := range s.Views {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfViewTraffic = [3]string{
	0: "count",
	1: "uniques",
	2: "views",
}

// Decode decodes ViewTraffic from json.
func (s *ViewTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ViewTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Views = make([]Traffic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Traffic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Views = append(s.Views, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ViewTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfViewTraffic) {
					name = jsonFieldsNameOfViewTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ViewTraffic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ViewTraffic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookConfig) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.FieldStart("insecure_ssl")
			s.InsecureSsl.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookConfig = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes WebhookConfig from json.
func (s *WebhookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigContentType as json.
func (s WebhookConfigContentType) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes WebhookConfigContentType from json.
func (s *WebhookConfigContentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigContentType to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigContentType(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookConfigContentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfigContentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (s WebhookConfigInsecureSsl) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringWebhookConfigInsecureSsl:
		e.Str(s.String)
	case Float64WebhookConfigInsecureSsl:
		e.Float64(s.Float64)
	}
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (s *WebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigInsecureSsl to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64WebhookConfigInsecureSsl
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringWebhookConfigInsecureSsl
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookConfigInsecureSsl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfigInsecureSsl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigSecret as json.
func (s WebhookConfigSecret) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes WebhookConfigSecret from json.
func (s *WebhookConfigSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigSecret to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigSecret(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookConfigSecret) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfigSecret) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfigURL as json.
func (s WebhookConfigURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes WebhookConfigURL from json.
func (s *WebhookConfigURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookConfigURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfigURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Workflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Workflow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		e.Str(s.HTMLURL)
	}
	{
		e.FieldStart("badge_url")
		e.Str(s.BadgeURL)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deleted_at")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfWorkflow = [11]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "path",
	4:  "state",
	5:  "created_at",
	6:  "updated_at",
	7:  "url",
	8:  "html_url",
	9:  "badge_url",
	10: "deleted_at",
}

// Decode decodes Workflow from json.
func (s *Workflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Workflow to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "badge_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BadgeURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badge_url\"")
			}
		case "deleted_at":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Workflow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflow) {
					name = jsonFieldsNameOfWorkflow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Workflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Workflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRun) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRun) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		if s.CheckSuiteID.Set {
			e.FieldStart("check_suite_id")
			s.CheckSuiteID.Encode(e)
		}
	}
	{
		if s.CheckSuiteNodeID.Set {
			e.FieldStart("check_suite_node_id")
			s.CheckSuiteNodeID.Encode(e)
		}
	}
	{
		e.FieldStart("head_branch")
		s.HeadBranch.Encode(e)
	}
	{
		e.FieldStart("head_sha")
		e.Str(s.HeadSha)
	}
	{
		e.FieldStart("run_number")
		e.Int(s.RunNumber)
	}
	{
		if s.RunAttempt.Set {
			e.FieldStart("run_attempt")
			s.RunAttempt.Encode(e)
		}
	}
	{
		e.FieldStart("event")
		e.Str(s.Event)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("conclusion")
		s.Conclusion.Encode(e)
	}
	{
		e.FieldStart("workflow_id")
		e.Int(s.WorkflowID)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("html_url")
		e.Str(s.HTMLURL)
	}
	{
		e.FieldStart("pull_requests")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.PullRequests {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("jobs_url")
		e.Str(s.JobsURL)
	}
	{
		e.FieldStart("logs_url")
		e.Str(s.LogsURL)
	}
	{
		e.FieldStart("check_suite_url")
		e.Str(s.CheckSuiteURL)
	}
	{
		e.FieldStart("artifacts_url")
		e.Str(s.ArtifactsURL)
	}
	{
		e.FieldStart("cancel_url")
		e.Str(s.CancelURL)
	}
	{
		e.FieldStart("rerun_url")
		e.Str(s.RerunURL)
	}
	{
		if s.PreviousAttemptURL.Set {
			e.FieldStart("previous_attempt_url")
			s.PreviousAttemptURL.Encode(e)
		}
	}
	{
		e.FieldStart("workflow_url")
		e.Str(s.WorkflowURL)
	}
	{
		e.FieldStart("head_commit")
		s.HeadCommit.Encode(e)
	}
	{
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	{
		e.FieldStart("head_repository")
		s.HeadRepository.Encode(e)
	}
	{
		if s.HeadRepositoryID.Set {
			e.FieldStart("head_repository_id")
			s.HeadRepositoryID.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowRun = [30]string{
	0:  "id",
	1:  "name",
	2:  "node_id",
	3:  "check_suite_id",
	4:  "check_suite_node_id",
	5:  "head_branch",
	6:  "head_sha",
	7:  "run_number",
	8:  "run_attempt",
	9:  "event",
	10: "status",
	11: "conclusion",
	12: "workflow_id",
	13: "url",
	14: "html_url",
	15: "pull_requests",
	16: "created_at",
	17: "updated_at",
	18: "jobs_url",
	19: "logs_url",
	20: "check_suite_url",
	21: "artifacts_url",
	22: "cancel_url",
	23: "rerun_url",
	24: "previous_attempt_url",
	25: "workflow_url",
	26: "head_commit",
	27: "repository",
	28: "head_repository",
	29: "head_repository_id",
}

// Decode decodes WorkflowRun from json.
func (s *WorkflowRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRun to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "check_suite_id":
			if err := func() error {
				s.CheckSuiteID.Reset()
				if err := s.CheckSuiteID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_id\"")
			}
		case "check_suite_node_id":
			if err := func() error {
				s.CheckSuiteNodeID.Reset()
				if err := s.CheckSuiteNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_node_id\"")
			}
		case "head_branch":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HeadBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_branch\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "run_number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.RunNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_number\"")
			}
		case "run_attempt":
			if err := func() error {
				s.RunAttempt.Reset()
				if err := s.RunAttempt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_attempt\"")
			}
		case "event":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "workflow_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WorkflowID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.PullRequests = make([]PullRequestMinimal, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem PullRequestMinimal
						if err := elem.Decode(d); err != nil {
							return err
						}
						s.PullRequests = append(s.PullRequests, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "jobs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.JobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs_url\"")
			}
		case "logs_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LogsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs_url\"")
			}
		case "check_suite_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CheckSuiteURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_url\"")
			}
		case "artifacts_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArtifactsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts_url\"")
			}
		case "cancel_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CancelURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancel_url\"")
			}
		case "rerun_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RerunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rerun_url\"")
			}
		case "previous_attempt_url":
			if err := func() error {
				s.PreviousAttemptURL.Reset()
				if err := s.PreviousAttemptURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_attempt_url\"")
			}
		case "workflow_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_url\"")
			}
		case "head_commit":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.HeadCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_commit\"")
			}
		case "repository":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "head_repository":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.HeadRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_repository\"")
			}
		case "head_repository_id":
			if err := func() error {
				s.HeadRepositoryID.Reset()
				if err := s.HeadRepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_repository_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11100101,
		0b11111110,
		0b11111111,
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRun) {
					name = jsonFieldsNameOfWorkflowRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRun) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRun) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRunUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRunUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("billable")
		s.Billable.Encode(e)
	}
	{
		if s.RunDurationMs.Set {
			e.FieldStart("run_duration_ms")
			s.RunDurationMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowRunUsage = [2]string{
	0: "billable",
	1: "run_duration_ms",
}

// Decode decodes WorkflowRunUsage from json.
func (s *WorkflowRunUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billable":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Billable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billable\"")
			}
		case "run_duration_ms":
			if err := func() error {
				s.RunDurationMs.Reset()
				if err := s.RunDurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_duration_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsage) {
					name = jsonFieldsNameOfWorkflowRunUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRunUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRunUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRunUsageBillable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRunUsageBillable) encodeFields(e *jx.Encoder) {
	{
		if s.UBUNTU.Set {
			e.FieldStart("UBUNTU")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			e.FieldStart("MACOS")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			e.FieldStart("WINDOWS")
			s.WINDOWS.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowRunUsageBillable = [3]string{
	0: "UBUNTU",
	1: "MACOS",
	2: "WINDOWS",
}

// Decode decodes WorkflowRunUsageBillable from json.
func (s *WorkflowRunUsageBillable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			if err := func() error {
				s.UBUNTU.Reset()
				if err := s.UBUNTU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UBUNTU\"")
			}
		case "MACOS":
			if err := func() error {
				s.MACOS.Reset()
				if err := s.MACOS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MACOS\"")
			}
		case "WINDOWS":
			if err := func() error {
				s.WINDOWS.Reset()
				if err := s.WINDOWS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WINDOWS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRunUsageBillable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRunUsageBillable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRunUsageBillableMACOS) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRunUsageBillableMACOS) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_ms")
		e.Int(s.TotalMs)
	}
	{
		e.FieldStart("jobs")
		e.Int(s.Jobs)
	}
}

var jsonFieldsNameOfWorkflowRunUsageBillableMACOS = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (s *WorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableMACOS to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableMACOS")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableMACOS) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableMACOS[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRunUsageBillableMACOS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRunUsageBillableMACOS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRunUsageBillableUBUNTU) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRunUsageBillableUBUNTU) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_ms")
		e.Int(s.TotalMs)
	}
	{
		e.FieldStart("jobs")
		e.Int(s.Jobs)
	}
}

var jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (s *WorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableUBUNTU to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableUBUNTU")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRunUsageBillableUBUNTU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRunUsageBillableUBUNTU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowRunUsageBillableWINDOWS) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowRunUsageBillableWINDOWS) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_ms")
		e.Int(s.TotalMs)
	}
	{
		e.FieldStart("jobs")
		e.Int(s.Jobs)
	}
}

var jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (s *WorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableWINDOWS to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableWINDOWS")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowRunUsageBillableWINDOWS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowRunUsageBillableWINDOWS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowState as json.
func (s WorkflowState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowState from json.
func (s *WorkflowState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowState(v) {
	case WorkflowStateActive:
		*s = WorkflowStateActive
	case WorkflowStateDeleted:
		*s = WorkflowStateDeleted
	case WorkflowStateDisabledFork:
		*s = WorkflowStateDisabledFork
	case WorkflowStateDisabledInactivity:
		*s = WorkflowStateDisabledInactivity
	case WorkflowStateDisabledManually:
		*s = WorkflowStateDisabledManually
	default:
		*s = WorkflowState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
