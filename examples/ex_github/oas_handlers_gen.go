// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a repository to the list of selected repositories that can access a self-hosted runner group.
// The runner group must have `visibility` set to `selected`. For more information, see "[Create a
// self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/add-repo-access-to-self-hosted-runner-group-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsAddSelectedRepoToOrgSecretRequest handles actions/add-selected-repo-to-org-secret operation.
//
// Adds a repository to an organization secret when the `visibility` for repository access is set to
// `selected`. The visibility is set when you [Create or update an organization secret](https://docs.
// github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsAddSelectedRepoToOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelectedRepoToOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsAddSelectedRepoToOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsAddSelectedRepoToOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsAddSelectedRepoToOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddSelectedRepoToOrgSecret",
			OperationID:   "actions/add-selected-repo-to-org-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelectedRepoToOrgSecretParams
			Response = ActionsAddSelectedRepoToOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelectedRepoToOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsAddSelfHostedRunnerToGroupForOrgRequest handles actions/add-self-hosted-runner-to-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a self-hosted runner to a runner group configured in an organization.
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelfHostedRunnerToGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsAddSelfHostedRunnerToGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsAddSelfHostedRunnerToGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsAddSelfHostedRunnerToGroupForOrg",
			OperationID:   "actions/add-self-hosted-runner-to-group-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelfHostedRunnerToGroupForOrgParams
			Response = *ActionsAddSelfHostedRunnerToGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelfHostedRunnerToGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsApproveWorkflowRunRequest handles actions/approve-workflow-run operation.
//
// Approves a workflow run for a pull request from a public fork of a first time contributor. For
// more information, see ["Approving workflow runs from public forks](https://docs.github.
// com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `actions:write` permission to use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (s *Server) handleActionsApproveWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsApproveWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsApproveWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsApproveWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsApproveWorkflowRunRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsApproveWorkflowRun",
			OperationID:   "actions/approve-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsApproveWorkflowRunParams
			Response = ActionsApproveWorkflowRunRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsApproveWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsApproveWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsApproveWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCancelWorkflowRunRequest handles actions/cancel-workflow-run operation.
//
// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (s *Server) handleActionsCancelWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCancelWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCancelWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCancelWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsCancelWorkflowRunAccepted
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCancelWorkflowRun",
			OperationID:   "actions/cancel-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCancelWorkflowRunParams
			Response = *ActionsCancelWorkflowRunAccepted
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCancelWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsCancelWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsCancelWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateEnvironmentSecretRequest handles actions/create-or-update-environment-secret operation.
//
// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateOrUpdateEnvironmentSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateEnvironmentSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateEnvironmentSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateEnvironmentSecret",
			OperationID:   "actions/create-or-update-environment-secret",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateEnvironmentSecretReq
			Params   = ActionsCreateOrUpdateEnvironmentSecretParams
			Response = ActionsCreateOrUpdateEnvironmentSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateOrgSecretRequest handles actions/create-or-update-org-secret operation.
//
// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to
// use this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateOrUpdateOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateOrUpdateOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateOrgSecret",
			OperationID:   "actions/create-or-update-org-secret",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateOrgSecretReq
			Params   = ActionsCreateOrUpdateOrgSecretParams
			Response = ActionsCreateOrUpdateOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateOrUpdateRepoSecretRequest handles actions/create-or-update-repo-secret operation.
//
// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateRepoSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateOrUpdateRepoSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateOrUpdateRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateOrUpdateRepoSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateRepoSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateOrUpdateRepoSecret",
			OperationID:   "actions/create-or-update-repo-secret",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateRepoSecretReq
			Params   = ActionsCreateOrUpdateRepoSecretParams
			Response = ActionsCreateOrUpdateRepoSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRegistrationTokenForOrgRequest handles actions/create-registration-token-for-org operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateRegistrationTokenForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRegistrationTokenForOrg",
			OperationID:   "actions/create-registration-token-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForOrgParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRegistrationTokenForRepoRequest handles actions/create-registration-token-for-repo operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour. You
// must authenticate
// using an access token with the `repo` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateRegistrationTokenForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRegistrationTokenForRepo",
			OperationID:   "actions/create-registration-token-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForRepoParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRemoveTokenForOrgRequest handles actions/create-remove-token-for-org operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// organization. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateRemoveTokenForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateRemoveTokenForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRemoveTokenForOrg",
			OperationID:   "actions/create-remove-token-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForOrgParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateRemoveTokenForRepoRequest handles actions/create-remove-token-for-repo operation.
//
// Returns a token that you can pass to remove a self-hosted runner from a repository. The token
// expires after one hour.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
// by this endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateRemoveTokenForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateRemoveTokenForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateRemoveTokenForRepo",
			OperationID:   "actions/create-remove-token-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForRepoParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsCreateSelfHostedRunnerGroupForOrgRequest handles actions/create-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Creates a new self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// POST /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsCreateSelfHostedRunnerGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsCreateSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/create-self-hosted-runner-group-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsCreateSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteArtifactRequest handles actions/delete-artifact operation.
//
// Deletes an artifact for a workflow run. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsDeleteArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteArtifact",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteArtifact
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteArtifactNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteArtifact",
			OperationID:   "actions/delete-artifact",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteArtifactParams
			Response = *ActionsDeleteArtifactNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteEnvironmentSecretRequest handles actions/delete-environment-secret operation.
//
// Deletes a secret in an environment using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsDeleteEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteEnvironmentSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteEnvironmentSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteEnvironmentSecret",
			OperationID:   "actions/delete-environment-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteEnvironmentSecretParams
			Response = *ActionsDeleteEnvironmentSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteEnvironmentSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteEnvironmentSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteOrgSecretRequest handles actions/delete-org-secret operation.
//
// Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteOrgSecret",
			OperationID:   "actions/delete-org-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteOrgSecretParams
			Response = *ActionsDeleteOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteRepoSecretRequest handles actions/delete-repo-secret operation.
//
// Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteRepoSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteRepoSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteRepoSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteRepoSecret",
			OperationID:   "actions/delete-repo-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteRepoSecretParams
			Response = *ActionsDeleteRepoSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteRepoSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteRepoSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromOrgRequest handles actions/delete-self-hosted-runner-from-org operation.
//
// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteSelfHostedRunnerFromOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteSelfHostedRunnerFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerFromOrg",
			OperationID:   "actions/delete-self-hosted-runner-from-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromOrgParams
			Response = *ActionsDeleteSelfHostedRunnerFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromRepoRequest handles actions/delete-self-hosted-runner-from-repo operation.
//
// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `repo`
// scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteSelfHostedRunnerFromRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteSelfHostedRunnerFromRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerFromRepo",
			OperationID:   "actions/delete-self-hosted-runner-from-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromRepoParams
			Response = *ActionsDeleteSelfHostedRunnerFromRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest handles actions/delete-self-hosted-runner-group-from-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Deletes a self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerGroupFromOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteSelfHostedRunnerGroupFromOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteSelfHostedRunnerGroupFromOrg",
			OperationID:   "actions/delete-self-hosted-runner-group-from-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerGroupFromOrgParams
			Response = *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerGroupFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteWorkflowRunRequest handles actions/delete-workflow-run operation.
//
// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
// If the repository is
// private you must use an access token with the `repo` scope. GitHub Apps must have the
// `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsDeleteWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteWorkflowRunNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteWorkflowRun",
			OperationID:   "actions/delete-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunParams
			Response = *ActionsDeleteWorkflowRunNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDeleteWorkflowRunLogsRequest handles actions/delete-workflow-run-logs operation.
//
// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDeleteWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDeleteWorkflowRunLogs
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDeleteWorkflowRunLogsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDeleteWorkflowRunLogsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDeleteWorkflowRunLogs",
			OperationID:   "actions/delete-workflow-run-logs",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunLogsParams
			Response = *ActionsDeleteWorkflowRunLogsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest handles actions/disable-selected-repository-github-actions-organization operation.
//
// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in
// an organization. To use this endpoint, the organization permission policy for
// `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDisableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDisableSelectedRepositoryGithubActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDisableSelectedRepositoryGithubActionsOrganization",
			OperationID:   "actions/disable-selected-repository-github-actions-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
			Response = *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDisableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadArtifactRequest handles actions/download-artifact operation.
//
// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look
// for `Location:` in
// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone
// with read access to
// the repository can use this endpoint. If the repository is private you must use an access token
// with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (s *Server) handleActionsDownloadArtifactRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadArtifact",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDownloadArtifact
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDownloadArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDownloadArtifactFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadArtifact",
			OperationID:   "actions/download-artifact",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
				{
					Name: "archive_format",
					In:   "path",
				}: params.ArchiveFormat,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadArtifactParams
			Response = *ActionsDownloadArtifactFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadJobLogsForWorkflowRunRequest handles actions/download-job-logs-for-workflow-run operation.
//
// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires
// after 1 minute. Look
// for `Location:` in the response header to find the URL for the download. Anyone with read access
// to the repository can
// use this endpoint. If the repository is private you must use an access token with the `repo` scope.
//
//	GitHub Apps must
//
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (s *Server) handleActionsDownloadJobLogsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadJobLogsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDownloadJobLogsForWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDownloadJobLogsForWorkflowRunFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadJobLogsForWorkflowRun",
			OperationID:   "actions/download-job-logs-for-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "job_id",
					In:   "path",
				}: params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadJobLogsForWorkflowRunParams
			Response = *ActionsDownloadJobLogsForWorkflowRunFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadJobLogsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsDownloadWorkflowRunLogsRequest handles actions/download-workflow-run-logs operation.
//
// Gets a redirect URL to download an archive of log files for a workflow run. This link expires
// after 1 minute. Look for
// `Location:` in the response header to find the URL for the download. Anyone with read access to
// the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have
// the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDownloadWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsDownloadWorkflowRunLogs
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsDownloadWorkflowRunLogsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsDownloadWorkflowRunLogsFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsDownloadWorkflowRunLogs",
			OperationID:   "actions/download-workflow-run-logs",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadWorkflowRunLogsParams
			Response = *ActionsDownloadWorkflowRunLogsFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest handles actions/enable-selected-repository-github-actions-organization operation.
//
// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an
// organization. To use this endpoint, the organization permission policy for `enabled_repositories`
// must be must be configured to `selected`. For more information, see "[Set GitHub Actions
// permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsEnableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsEnableSelectedRepositoryGithubActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsEnableSelectedRepositoryGithubActionsOrganization",
			OperationID:   "actions/enable-selected-repository-github-actions-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
			Response = *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsEnableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetAllowedActionsOrganizationRequest handles actions/get-allowed-actions-organization operation.
//
// Gets the selected actions that are allowed in an organization. To use this endpoint, the
// organization permission policy for `allowed_actions` must be configured to `selected`. For more
// information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization).""
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetAllowedActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetAllowedActionsOrganization",
			OperationID:   "actions/get-allowed-actions-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsOrganizationParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetAllowedActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetAllowedActionsRepositoryRequest handles actions/get-allowed-actions-repository operation.
//
// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the
// repository policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for a
// repository](#set-github-actions-permissions-for-a-repository)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetAllowedActionsRepository
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetAllowedActionsRepository",
			OperationID:   "actions/get-allowed-actions-repository",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsRepositoryParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetAllowedActionsRepository(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsRepository(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetArtifactRequest handles actions/get-artifact operation.
//
// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsGetArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetArtifact",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetArtifact
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetArtifactParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Artifact
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetArtifact",
			OperationID:   "actions/get-artifact",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetArtifactParams
			Response = *Artifact
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetArtifact(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetEnvironmentPublicKeyRequest handles actions/get-environment-public-key operation.
//
// Get the public key for an environment, which you need to encrypt environment secrets. You need to
// encrypt a secret before you can create or update secrets. Anyone with read access to the
// repository can use this endpoint. If the repository is private you must use an access token with
// the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (s *Server) handleActionsGetEnvironmentPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentPublicKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetEnvironmentPublicKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetEnvironmentPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetEnvironmentPublicKey",
			OperationID:   "actions/get-environment-public-key",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetEnvironmentPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetEnvironmentSecretRequest handles actions/get-environment-secret operation.
//
// Gets a single environment secret without revealing its encrypted value. You must authenticate
// using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
// `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsGetEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetEnvironmentSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetEnvironmentSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetEnvironmentSecret",
			OperationID:   "actions/get-environment-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentSecretParams
			Response = *ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetEnvironmentSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetGithubActionsPermissionsOrganizationRequest handles actions/get-github-actions-permissions-organization operation.
//
// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetGithubActionsPermissionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsOrganizationPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetGithubActionsPermissionsOrganization",
			OperationID:   "actions/get-github-actions-permissions-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsOrganizationParams
			Response = *ActionsOrganizationPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetGithubActionsPermissionsRepositoryRequest handles actions/get-github-actions-permissions-repository operation.
//
// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is
// enabled and the actions allowed to run in the repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint. GitHub Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetGithubActionsPermissionsRepository
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsRepositoryPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetGithubActionsPermissionsRepository",
			OperationID:   "actions/get-github-actions-permissions-repository",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsRepositoryParams
			Response = *ActionsRepositoryPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetJobForWorkflowRunRequest handles actions/get-job-for-workflow-run operation.
//
// Gets a specific job in a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (s *Server) handleActionsGetJobForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetJobForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetJobForWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetJobForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Job
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetJobForWorkflowRun",
			OperationID:   "actions/get-job-for-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "job_id",
					In:   "path",
				}: params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetJobForWorkflowRunParams
			Response = *Job
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetJobForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetJobForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetJobForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetOrgPublicKeyRequest handles actions/get-org-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/public-key
func (s *Server) handleActionsGetOrgPublicKeyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgPublicKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetOrgPublicKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetOrgPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetOrgPublicKey",
			OperationID:   "actions/get-org-public-key",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetOrgPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetOrgSecretRequest handles actions/get-org-secret operation.
//
// Gets a single organization secret without revealing its encrypted value. You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrganizationActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetOrgSecret",
			OperationID:   "actions/get-org-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgSecretParams
			Response = *OrganizationActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetRepoPublicKeyRequest handles actions/get-repo-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (s *Server) handleActionsGetRepoPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoPublicKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetRepoPublicKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetRepoPublicKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetRepoPublicKey",
			OperationID:   "actions/get-repo-public-key",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetRepoPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoPublicKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetRepoSecretRequest handles actions/get-repo-secret operation.
//
// Gets a single repository secret without revealing its encrypted value. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
// repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetRepoSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetRepoSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetRepoSecret",
			OperationID:   "actions/get-repo-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoSecretParams
			Response = *ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetRepoSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetReviewsForRunRequest handles actions/get-reviews-for-run operation.
//
// Anyone with read access to the repository can use this endpoint. If the repository is private, you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (s *Server) handleActionsGetReviewsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetReviewsForRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetReviewsForRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetReviewsForRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []EnvironmentApprovals
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetReviewsForRun",
			OperationID:   "actions/get-reviews-for-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetReviewsForRunParams
			Response = []EnvironmentApprovals
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetReviewsForRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetReviewsForRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetReviewsForRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerForOrgRequest handles actions/get-self-hosted-runner-for-org operation.
//
// Gets a specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetSelfHostedRunnerForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerForOrg",
			OperationID:   "actions/get-self-hosted-runner-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForOrgParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerForRepoRequest handles actions/get-self-hosted-runner-for-repo operation.
//
// Gets a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetSelfHostedRunnerForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerForRepo",
			OperationID:   "actions/get-self-hosted-runner-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForRepoParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetSelfHostedRunnerGroupForOrgRequest handles actions/get-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Gets a specific self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsGetSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetSelfHostedRunnerGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/get-self-hosted-runner-group-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetWorkflowRunRequest handles actions/get-workflow-run operation.
//
// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsGetWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *WorkflowRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetWorkflowRun",
			OperationID:   "actions/get-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunParams
			Response = *WorkflowRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsGetWorkflowRunUsageRequest handles actions/get-workflow-run-usage operation.
//
// Gets the number of billable minutes and total run time for a specific workflow run. Billable
// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is
// listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (s *Server) handleActionsGetWorkflowRunUsageRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRunUsage",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsGetWorkflowRunUsage
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsGetWorkflowRunUsageParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *WorkflowRunUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsGetWorkflowRunUsage",
			OperationID:   "actions/get-workflow-run-usage",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunUsageParams
			Response = *WorkflowRunUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunUsageParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetWorkflowRunUsage(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRunUsage(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListArtifactsForRepoRequest handles actions/list-artifacts-for-repo operation.
//
// Lists all artifacts for a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (s *Server) handleActionsListArtifactsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListArtifactsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListArtifactsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListArtifactsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListArtifactsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListArtifactsForRepo",
			OperationID:   "actions/list-artifacts-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListArtifactsForRepoParams
			Response = *ActionsListArtifactsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListArtifactsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListArtifactsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListArtifactsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListEnvironmentSecretsRequest handles actions/list-environment-secrets operation.
//
// Lists all secrets available in an environment without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (s *Server) handleActionsListEnvironmentSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListEnvironmentSecrets",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListEnvironmentSecrets
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListEnvironmentSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListEnvironmentSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListEnvironmentSecrets",
			OperationID:   "actions/list-environment-secrets",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListEnvironmentSecretsParams
			Response = *ActionsListEnvironmentSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListEnvironmentSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListEnvironmentSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListEnvironmentSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListJobsForWorkflowRunRequest handles actions/list-jobs-for-workflow-run operation.
//
// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list
// of results. For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (s *Server) handleActionsListJobsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListJobsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListJobsForWorkflowRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListJobsForWorkflowRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListJobsForWorkflowRunOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListJobsForWorkflowRun",
			OperationID:   "actions/list-jobs-for-workflow-run",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListJobsForWorkflowRunParams
			Response = *ActionsListJobsForWorkflowRunOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListJobsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListJobsForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListJobsForWorkflowRun(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListOrgSecretsRequest handles actions/list-org-secrets operation.
//
// Lists all secrets available in an organization without revealing their encrypted values. You must
// authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps
// must have the `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets
func (s *Server) handleActionsListOrgSecretsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListOrgSecrets",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListOrgSecrets
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListOrgSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListOrgSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListOrgSecrets",
			OperationID:   "actions/list-org-secrets",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListOrgSecretsParams
			Response = *ActionsListOrgSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListOrgSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListOrgSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListOrgSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists the repositories with access to a self-hosted runner group configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/list-repo-access-to-self-hosted-runner-group-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoSecretsRequest handles actions/list-repo-secrets operation.
//
// Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (s *Server) handleActionsListRepoSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoSecrets",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListRepoSecrets
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListRepoSecretsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListRepoSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoSecrets",
			OperationID:   "actions/list-repo-secrets",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoSecretsParams
			Response = *ActionsListRepoSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoSecrets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRepoWorkflowsRequest handles actions/list-repo-workflows operation.
//
// Lists the workflows in a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (s *Server) handleActionsListRepoWorkflowsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoWorkflows",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListRepoWorkflows
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListRepoWorkflowsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListRepoWorkflowsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRepoWorkflows",
			OperationID:   "actions/list-repo-workflows",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoWorkflowsParams
			Response = *ActionsListRepoWorkflowsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoWorkflowsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoWorkflows(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoWorkflows(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRunnerApplicationsForOrgRequest handles actions/list-runner-applications-for-org operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListRunnerApplicationsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListRunnerApplicationsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRunnerApplicationsForOrg",
			OperationID:   "actions/list-runner-applications-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForOrgParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListRunnerApplicationsForRepoRequest handles actions/list-runner-applications-for-repo operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListRunnerApplicationsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListRunnerApplicationsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListRunnerApplicationsForRepo",
			OperationID:   "actions/list-runner-applications-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForRepoParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelectedReposForOrgSecretRequest handles actions/list-selected-repos-for-org-secret operation.
//
// Lists all repositories that have been selected when the `visibility` for repository access to a
// secret is set to `selected`. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsListSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelectedReposForOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelectedReposForOrgSecretOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelectedReposForOrgSecret",
			OperationID:   "actions/list-selected-repos-for-org-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedReposForOrgSecretParams
			Response = *ActionsListSelectedReposForOrgSecretOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use
// this endpoint, the organization permission policy for `enabled_repositories` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
			OperationID:   "actions/list-selected-repositories-enabled-github-actions-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnerGroupsForOrgRequest handles actions/list-self-hosted-runner-groups-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsListSelfHostedRunnerGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnerGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelfHostedRunnerGroupsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelfHostedRunnerGroupsForOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnerGroupsForOrg",
			OperationID:   "actions/list-self-hosted-runner-groups-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnerGroupsForOrgParams
			Response = *ActionsListSelfHostedRunnerGroupsForOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnerGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersForOrgRequest handles actions/list-self-hosted-runners-for-org operation.
//
// Lists all self-hosted runners configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelfHostedRunnersForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelfHostedRunnersForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersForOrg",
			OperationID:   "actions/list-self-hosted-runners-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForOrgParams
			Response = *ActionsListSelfHostedRunnersForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersForRepoRequest handles actions/list-self-hosted-runners-for-repo operation.
//
// Lists all self-hosted runners configured in a repository. You must authenticate using an access
// token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelfHostedRunnersForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelfHostedRunnersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersForRepo",
			OperationID:   "actions/list-self-hosted-runners-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForRepoParams
			Response = *ActionsListSelfHostedRunnersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListSelfHostedRunnersInGroupForOrgRequest handles actions/list-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists self-hosted runners that are in a specific organization group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsListSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListSelfHostedRunnersInGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListSelfHostedRunnersInGroupForOrg",
			OperationID:   "actions/list-self-hosted-runners-in-group-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersInGroupForOrgParams
			Response = *ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListWorkflowRunArtifactsRequest handles actions/list-workflow-run-artifacts operation.
//
// Lists artifacts for a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (s *Server) handleActionsListWorkflowRunArtifactsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunArtifacts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListWorkflowRunArtifacts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListWorkflowRunArtifactsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListWorkflowRunArtifactsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListWorkflowRunArtifacts",
			OperationID:   "actions/list-workflow-run-artifacts",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunArtifactsParams
			Response = *ActionsListWorkflowRunArtifactsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunArtifactsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListWorkflowRunArtifacts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunArtifacts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsListWorkflowRunsForRepoRequest handles actions/list-workflow-runs-for-repo operation.
//
// Lists all workflow runs for a repository. You can use parameters to narrow the list of results.
// For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs
func (s *Server) handleActionsListWorkflowRunsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsListWorkflowRunsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsListWorkflowRunsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsListWorkflowRunsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsListWorkflowRunsForRepo",
			OperationID:   "actions/list-workflow-runs-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "actor",
					In:   "query",
				}: params.Actor,
				{
					Name: "branch",
					In:   "query",
				}: params.Branch,
				{
					Name: "event",
					In:   "query",
				}: params.Event,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "created",
					In:   "query",
				}: params.Created,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunsForRepoParams
			Response = *ActionsListWorkflowRunsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListWorkflowRunsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsReRunWorkflowRequest handles actions/re-run-workflow operation.
//
// **Deprecation Notice:** This endpoint is deprecated.
// We recommend migrating your existing code to use the new [retry workflow](https://docs.github.
// com/rest/reference/actions#retry-a-workflow) endpoint.
// Re-runs your workflow run using its `id`. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have
// the `actions:write` permission to use this endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (s *Server) handleActionsReRunWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReRunWorkflow",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsReRunWorkflow
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsReRunWorkflowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsReRunWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsReRunWorkflow",
			OperationID:   "actions/re-run-workflow",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsReRunWorkflowParams
			Response = *ActionsReRunWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReRunWorkflowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsReRunWorkflow(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsReRunWorkflow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a repository from the list of selected repositories that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/remove-repo-access-to-self-hosted-runner-group-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveSelectedRepoFromOrgSecretRequest handles actions/remove-selected-repo-from-org-secret operation.
//
// Removes a repository from an organization secret when the `visibility` for repository access is
// set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsRemoveSelectedRepoFromOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelectedRepoFromOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsRemoveSelectedRepoFromOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActionsRemoveSelectedRepoFromOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveSelectedRepoFromOrgSecret",
			OperationID:   "actions/remove-selected-repo-from-org-secret",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelectedRepoFromOrgSecretParams
			Response = ActionsRemoveSelectedRepoFromOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelectedRepoFromOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest handles actions/remove-self-hosted-runner-from-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a self-hosted runner from a group configured in an organization. The runner is then
// returned to the default group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsRemoveSelfHostedRunnerFromGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
			OperationID:   "actions/remove-self-hosted-runner-from-group-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
			Response = *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelfHostedRunnerFromGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsRetryWorkflowRequest handles actions/retry-workflow operation.
//
// Retry your workflow run using its `id`. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (s *Server) handleActionsRetryWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRetryWorkflow",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsRetryWorkflow
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsRetryWorkflowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsRetryWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsRetryWorkflow",
			OperationID:   "actions/retry-workflow",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRetryWorkflowParams
			Response = *ActionsRetryWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRetryWorkflowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRetryWorkflow(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRetryWorkflow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsReviewPendingDeploymentsForRunRequest handles actions/review-pending-deployments-for-run operation.
//
// Approve or reject pending deployments that are waiting on approval by a required reviewer.
// Anyone with read access to the repository contents and deployments can use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (s *Server) handleActionsReviewPendingDeploymentsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReviewPendingDeploymentsForRun",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsReviewPendingDeploymentsForRun
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsReviewPendingDeploymentsForRunParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsReviewPendingDeploymentsForRunRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []Deployment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsReviewPendingDeploymentsForRun",
			OperationID:   "actions/review-pending-deployments-for-run",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsReviewPendingDeploymentsForRunReq
			Params   = ActionsReviewPendingDeploymentsForRunParams
			Response = []Deployment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReviewPendingDeploymentsForRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReviewPendingDeploymentsForRunResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetAllowedActionsOrganizationRequest handles actions/set-allowed-actions-organization operation.
//
// Sets the actions that are allowed in an organization. To use this endpoint, the organization
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// If the organization belongs to an enterprise that has `selected` actions set at the enterprise
// level, then you cannot override any of the enterprise's allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the organization must belong to an
// enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories in the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetAllowedActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetAllowedActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetAllowedActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetAllowedActionsOrganization",
			OperationID:   "actions/set-allowed-actions-organization",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsOrganizationParams
			Response = *ActionsSetAllowedActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetAllowedActionsRepositoryRequest handles actions/set-allowed-actions-repository operation.
//
// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission
// policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set
// GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
// If the repository belongs to an organization or enterprise that has `selected` actions set at the
// organization or enterprise levels, then you cannot override any of the allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the repository must belong to an
// enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetAllowedActionsRepository
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetAllowedActionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetAllowedActionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetAllowedActionsRepository",
			OperationID:   "actions/set-allowed-actions-repository",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsRepositoryParams
			Response = *ActionsSetAllowedActionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetGithubActionsPermissionsOrganizationRequest handles actions/set-github-actions-permissions-organization operation.
//
// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// If the organization belongs to an enterprise that has set restrictive permissions at the
// enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them
// for the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetGithubActionsPermissionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetGithubActionsPermissionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetGithubActionsPermissionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetGithubActionsPermissionsOrganization",
			OperationID:   "actions/set-github-actions-permissions-organization",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetGithubActionsPermissionsOrganizationReq
			Params   = ActionsSetGithubActionsPermissionsOrganizationParams
			Response = *ActionsSetGithubActionsPermissionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetGithubActionsPermissionsRepositoryRequest handles actions/set-github-actions-permissions-repository operation.
//
// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the
// repository.
// If the repository belongs to an organization or enterprise that has set restrictive permissions at
// the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you
// cannot override them for the repository.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetGithubActionsPermissionsRepository
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetGithubActionsPermissionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetGithubActionsPermissionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetGithubActionsPermissionsRepository",
			OperationID:   "actions/set-github-actions-permissions-repository",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetGithubActionsPermissionsRepositoryReq
			Params   = ActionsSetGithubActionsPermissionsRepositoryParams
			Response = *ActionsSetGithubActionsPermissionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of repositories that have access to a self-hosted runner group configured in an
// organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
			OperationID:   "actions/set-repo-access-to-self-hosted-runner-group-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
			Params   = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelectedReposForOrgSecretRequest handles actions/set-selected-repos-for-org-secret operation.
//
// Replaces all repositories for an organization secret when the `visibility` for repository access
// is set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsSetSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetSelectedReposForOrgSecret
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelectedReposForOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelectedReposForOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelectedReposForOrgSecret",
			OperationID:   "actions/set-selected-repos-for-org-secret",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelectedReposForOrgSecretReq
			Params   = ActionsSetSelectedReposForOrgSecretParams
			Response = *ActionsSetSelectedReposForOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization.
// To use this endpoint, the organization permission policy for `enabled_repositories` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
			OperationID:   "actions/set-selected-repositories-enabled-github-actions-organization",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
			Params   = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsSetSelfHostedRunnersInGroupForOrgRequest handles actions/set-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of self-hosted runners that are part of an organization runner group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsSetSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsSetSelfHostedRunnersInGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelfHostedRunnersInGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsSetSelfHostedRunnersInGroupForOrg",
			OperationID:   "actions/set-self-hosted-runners-in-group-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelfHostedRunnersInGroupForOrgReq
			Params   = ActionsSetSelfHostedRunnersInGroupForOrgParams
			Response = *ActionsSetSelfHostedRunnersInGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActionsUpdateSelfHostedRunnerGroupForOrgRequest handles actions/update-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsUpdateSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsUpdateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActionsUpdateSelfHostedRunnerGroupForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActionsUpdateSelfHostedRunnerGroupForOrg",
			OperationID:   "actions/update-self-hosted-runner-group-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsUpdateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsUpdateSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsUpdateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityCheckRepoIsStarredByAuthenticatedUserRequest handles activity/check-repo-is-starred-by-authenticated-user operation.
//
// Check if a repository is starred by the authenticated user.
//
// GET /user/starred/{owner}/{repo}
func (s *Server) handleActivityCheckRepoIsStarredByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityCheckRepoIsStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityCheckRepoIsStarredByAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityCheckRepoIsStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityCheckRepoIsStarredByAuthenticatedUser",
			OperationID:   "activity/check-repo-is-starred-by-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityCheckRepoIsStarredByAuthenticatedUserParams
			Response = ActivityCheckRepoIsStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityCheckRepoIsStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityDeleteRepoSubscriptionRequest handles activity/delete-repo-subscription operation.
//
// This endpoint should only be used to stop watching a repository. To control whether or not you
// wish to receive notifications from a repository, [set the repository's subscription
// manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
//
// DELETE /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityDeleteRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityDeleteRepoSubscription
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityDeleteRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActivityDeleteRepoSubscriptionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityDeleteRepoSubscription",
			OperationID:   "activity/delete-repo-subscription",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteRepoSubscriptionParams
			Response = *ActivityDeleteRepoSubscriptionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActivityDeleteRepoSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActivityDeleteRepoSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityDeleteThreadSubscriptionRequest handles activity/delete-thread-subscription operation.
//
// Mutes all future notifications for a conversation until you comment on the thread or get an
// **@mention**. If you are watching the repository of the thread, you will still receive
// notifications. To ignore future notifications for a repository you are watching, use the [Set a
// thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
// endpoint and set `ignore` to `true`.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityDeleteThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityDeleteThreadSubscription
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityDeleteThreadSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityDeleteThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityDeleteThreadSubscription",
			OperationID:   "activity/delete-thread-subscription",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteThreadSubscriptionParams
			Response = ActivityDeleteThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityDeleteThreadSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityDeleteThreadSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetFeedsRequest handles activity/get-feeds operation.
//
// GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard))
// format. The Feeds API lists all the feeds available to the authenticated user:
// *   **Timeline**: The GitHub global public timeline
// *   **User**: The public timeline for any user, using [URI template](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia)
// *   **Current user public**: The public timeline for the authenticated user
// *   **Current user**: The private timeline for the authenticated user
// *   **Current user actor**: The private timeline for activity created by the authenticated user
// *   **Current user organizations**: The private timeline for the organizations the authenticated
// user is a member of.
// *   **Security advisories**: A collection of public announcements that provide information about
// security-related vulnerabilities in software on GitHub.
// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use
// the older, non revocable auth tokens.
//
// GET /feeds
func (s *Server) handleActivityGetFeedsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetFeeds",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityGetFeeds
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *Feed
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetFeeds",
			OperationID:   "activity/get-feeds",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *Feed
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetFeeds(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetFeeds(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetRepoSubscriptionRequest handles activity/get-repo-subscription operation.
//
// Get a repository subscription.
//
// GET /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityGetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityGetRepoSubscription
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityGetRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetRepoSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetRepoSubscription",
			OperationID:   "activity/get-repo-subscription",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetRepoSubscriptionParams
			Response = ActivityGetRepoSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetRepoSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetRepoSubscription(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetThreadRequest handles activity/get-thread operation.
//
// Get a thread.
//
// GET /notifications/threads/{thread_id}
func (s *Server) handleActivityGetThreadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThread",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityGetThread
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityGetThreadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetThreadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetThread",
			OperationID:   "activity/get-thread",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadParams
			Response = ActivityGetThreadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetThread(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetThread(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityGetThreadSubscriptionForAuthenticatedUserRequest handles activity/get-thread-subscription-for-authenticated-user operation.
//
// This checks to see if the current user is subscribed to a thread. You can also [get a repository
// subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
// Note that subscriptions are only generated if a user is participating in a conversation--for
// example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
//
// GET /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityGetThreadSubscriptionForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThreadSubscriptionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityGetThreadSubscriptionForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityGetThreadSubscriptionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityGetThreadSubscriptionForAuthenticatedUser",
			OperationID:   "activity/get-thread-subscription-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadSubscriptionForAuthenticatedUserParams
			Response = ActivityGetThreadSubscriptionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadSubscriptionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListEventsForAuthenticatedUserRequest handles activity/list-events-for-authenticated-user operation.
//
// If you are authenticated as the given user, you will see your private events. Otherwise, you'll
// only see public events.
//
// GET /users/{username}/events
func (s *Server) handleActivityListEventsForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListEventsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListEventsForAuthenticatedUser",
			OperationID:   "activity/list-events-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListNotificationsForAuthenticatedUserRequest handles activity/list-notifications-for-authenticated-user operation.
//
// List all notifications for the current user, sorted by most recently updated.
//
// GET /notifications
func (s *Server) handleActivityListNotificationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListNotificationsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListNotificationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListNotificationsForAuthenticatedUser",
			OperationID:   "activity/list-notifications-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "all",
					In:   "query",
				}: params.All,
				{
					Name: "participating",
					In:   "query",
				}: params.Participating,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListNotificationsForAuthenticatedUserParams
			Response = ActivityListNotificationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListOrgEventsForAuthenticatedUserRequest handles activity/list-org-events-for-authenticated-user operation.
//
// This is the user's organization dashboard. You must be authenticated as the user to view this.
//
// GET /users/{username}/events/orgs/{org}
func (s *Server) handleActivityListOrgEventsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListOrgEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListOrgEventsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListOrgEventsForAuthenticatedUser",
			OperationID:   "activity/list-org-events-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListOrgEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListOrgEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsRequest handles activity/list-public-events operation.
//
// We delay the public events feed by five minutes, which means the most recent event returned by the
// public events API actually occurred at least five minutes ago.
//
// GET /events
func (s *Server) handleActivityListPublicEventsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEvents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListPublicEvents
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListPublicEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListPublicEventsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEvents",
			OperationID:   "activity/list-public-events",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsParams
			Response = ActivityListPublicEventsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsForRepoNetworkRequest handles activity/list-public-events-for-repo-network operation.
//
// List public events for a network of repositories.
//
// GET /networks/{owner}/{repo}/events
func (s *Server) handleActivityListPublicEventsForRepoNetworkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForRepoNetwork",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListPublicEventsForRepoNetwork
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListPublicEventsForRepoNetworkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListPublicEventsForRepoNetworkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEventsForRepoNetwork",
			OperationID:   "activity/list-public-events-for-repo-network",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForRepoNetworkParams
			Response = ActivityListPublicEventsForRepoNetworkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForRepoNetworkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicEventsForUserRequest handles activity/list-public-events-for-user operation.
//
// List public events for a user.
//
// GET /users/{username}/events/public
func (s *Server) handleActivityListPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListPublicEventsForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListPublicEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicEventsForUser",
			OperationID:   "activity/list-public-events-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListPublicOrgEventsRequest handles activity/list-public-org-events operation.
//
// List public organization events.
//
// GET /orgs/{org}/events
func (s *Server) handleActivityListPublicOrgEventsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicOrgEvents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListPublicOrgEvents
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListPublicOrgEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListPublicOrgEvents",
			OperationID:   "activity/list-public-org-events",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicOrgEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicOrgEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicOrgEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicOrgEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReceivedEventsForUserRequest handles activity/list-received-events-for-user operation.
//
// These are events that you've received by watching repos and following users. If you are
// authenticated as the given user, you will see private events. Otherwise, you'll only see public
// events.
//
// GET /users/{username}/received_events
func (s *Server) handleActivityListReceivedEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedEventsForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListReceivedEventsForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListReceivedEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReceivedEventsForUser",
			OperationID:   "activity/list-received-events-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReceivedEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReceivedPublicEventsForUserRequest handles activity/list-received-public-events-for-user operation.
//
// List public events received by a user.
//
// GET /users/{username}/received_events/public
func (s *Server) handleActivityListReceivedPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListReceivedPublicEventsForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListReceivedPublicEventsForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReceivedPublicEventsForUser",
			OperationID:   "activity/list-received-public-events-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListRepoEventsRequest handles activity/list-repo-events operation.
//
// List repository events.
//
// GET /repos/{owner}/{repo}/events
func (s *Server) handleActivityListRepoEventsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoEvents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListRepoEvents
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListRepoEventsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListRepoEvents",
			OperationID:   "activity/list-repo-events",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListRepoEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListRepoEvents(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListRepoNotificationsForAuthenticatedUserRequest handles activity/list-repo-notifications-for-authenticated-user operation.
//
// List all notifications for the current user.
//
// GET /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityListRepoNotificationsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListRepoNotificationsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListRepoNotificationsForAuthenticatedUser",
			OperationID:   "activity/list-repo-notifications-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "all",
					In:   "query",
				}: params.All,
				{
					Name: "participating",
					In:   "query",
				}: params.Participating,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoNotificationsForAuthenticatedUserParams
			Response = *ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReposStarredByAuthenticatedUserRequest handles activity/list-repos-starred-by-authenticated-user operation.
//
// Lists repositories the authenticated user has starred.
// You can also find out _when_ stars were created by passing the following custom [media
// type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:.
//
// GET /user/starred
func (s *Server) handleActivityListReposStarredByAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListReposStarredByAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListReposStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListReposStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReposStarredByAuthenticatedUser",
			OperationID:   "activity/list-repos-starred-by-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposStarredByAuthenticatedUserParams
			Response = ActivityListReposStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListReposWatchedByUserRequest handles activity/list-repos-watched-by-user operation.
//
// Lists repositories a user is watching.
//
// GET /users/{username}/subscriptions
func (s *Server) handleActivityListReposWatchedByUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposWatchedByUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListReposWatchedByUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListReposWatchedByUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActivityListReposWatchedByUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListReposWatchedByUser",
			OperationID:   "activity/list-repos-watched-by-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposWatchedByUserParams
			Response = *ActivityListReposWatchedByUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposWatchedByUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReposWatchedByUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReposWatchedByUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListWatchedReposForAuthenticatedUserRequest handles activity/list-watched-repos-for-authenticated-user operation.
//
// Lists repositories the authenticated user is watching.
//
// GET /user/subscriptions
func (s *Server) handleActivityListWatchedReposForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchedReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListWatchedReposForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListWatchedReposForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityListWatchedReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListWatchedReposForAuthenticatedUser",
			OperationID:   "activity/list-watched-repos-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchedReposForAuthenticatedUserParams
			Response = ActivityListWatchedReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchedReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityListWatchersForRepoRequest handles activity/list-watchers-for-repo operation.
//
// Lists the people watching the specified repository.
//
// GET /repos/{owner}/{repo}/subscribers
func (s *Server) handleActivityListWatchersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchersForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityListWatchersForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityListWatchersForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActivityListWatchersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityListWatchersForRepo",
			OperationID:   "activity/list-watchers-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchersForRepoParams
			Response = *ActivityListWatchersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchersForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListWatchersForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListWatchersForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkNotificationsAsReadRequest handles activity/mark-notifications-as-read operation.
//
// Marks all notifications as "read" removes it from the [default view on GitHub](https://github.
// com/notifications). If the number of notifications is too large to complete in one request, you
// will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark
// notifications as "read." To check whether any "unread" notifications remain, you can use the [List
// notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the
// query parameter `all=false`.
//
// PUT /notifications
func (s *Server) handleActivityMarkNotificationsAsReadRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityMarkNotificationsAsRead
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeActivityMarkNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkNotificationsAsRead",
			OperationID:   "activity/mark-notifications-as-read",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptActivityMarkNotificationsAsReadReq
			Params   = struct{}
			Response = ActivityMarkNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkNotificationsAsRead(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkNotificationsAsRead(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkRepoNotificationsAsReadRequest handles activity/mark-repo-notifications-as-read operation.
//
// Marks all notifications in a repository as "read" removes them from the [default view on
// GitHub](https://github.com/notifications). If the number of notifications is too large to complete
// in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous
// process to mark notifications as "read." To check whether any "unread" notifications remain, you
// can use the [List repository notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and
// pass the query parameter `all=false`.
//
// PUT /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityMarkRepoNotificationsAsReadRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkRepoNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityMarkRepoNotificationsAsRead
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityMarkRepoNotificationsAsReadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivityMarkRepoNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkRepoNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkRepoNotificationsAsRead",
			OperationID:   "activity/mark-repo-notifications-as-read",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivityMarkRepoNotificationsAsReadReq
			Params   = ActivityMarkRepoNotificationsAsReadParams
			Response = ActivityMarkRepoNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkRepoNotificationsAsReadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityMarkThreadAsReadRequest handles activity/mark-thread-as-read operation.
//
// Mark a thread as read.
//
// PATCH /notifications/threads/{thread_id}
func (s *Server) handleActivityMarkThreadAsReadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkThreadAsRead",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityMarkThreadAsRead
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityMarkThreadAsReadParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityMarkThreadAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityMarkThreadAsRead",
			OperationID:   "activity/mark-thread-as-read",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityMarkThreadAsReadParams
			Response = ActivityMarkThreadAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkThreadAsReadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkThreadAsRead(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkThreadAsRead(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivitySetRepoSubscriptionRequest handles activity/set-repo-subscription operation.
//
// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore
// notifications made within a repository, set `ignored` to `true`. If you would like to stop
// watching a repository, [delete the repository's subscription](https://docs.github.
// com/rest/reference/activity#delete-a-repository-subscription) completely.
//
// PUT /repos/{owner}/{repo}/subscription
func (s *Server) handleActivitySetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivitySetRepoSubscription
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivitySetRepoSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivitySetRepoSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositorySubscription
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivitySetRepoSubscription",
			OperationID:   "activity/set-repo-subscription",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetRepoSubscriptionReq
			Params   = ActivitySetRepoSubscriptionParams
			Response = *RepositorySubscription
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivitySetRepoSubscription(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivitySetRepoSubscription(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivitySetThreadSubscriptionRequest handles activity/set-thread-subscription operation.
//
// If you are watching a repository, you receive notifications for all threads by default. Use this
// endpoint to ignore future notifications for threads until you comment on the thread or get an
// **@mention**.
// You can also use this endpoint to subscribe to threads that you are currently not receiving
// notifications for or to subscribed to threads that you have previously ignored.
// Unsubscribing from a conversation in a repository that you are not watching is functionally
// equivalent to the [Delete a thread subscription](https://docs.github.
// com/rest/reference/activity#delete-a-thread-subscription) endpoint.
//
// PUT /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivitySetThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivitySetThreadSubscription
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivitySetThreadSubscriptionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeActivitySetThreadSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivitySetThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivitySetThreadSubscription",
			OperationID:   "activity/set-thread-subscription",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetThreadSubscriptionReq
			Params   = ActivitySetThreadSubscriptionParams
			Response = ActivitySetThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivitySetThreadSubscription(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivitySetThreadSubscription(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityStarRepoForAuthenticatedUserRequest handles activity/star-repo-for-authenticated-user operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /user/starred/{owner}/{repo}
func (s *Server) handleActivityStarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityStarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityStarRepoForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityStarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityStarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityStarRepoForAuthenticatedUser",
			OperationID:   "activity/star-repo-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityStarRepoForAuthenticatedUserParams
			Response = ActivityStarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityStarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleActivityUnstarRepoForAuthenticatedUserRequest handles activity/unstar-repo-for-authenticated-user operation.
//
// Unstar a repository for the authenticated user.
//
// DELETE /user/starred/{owner}/{repo}
func (s *Server) handleActivityUnstarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityUnstarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ActivityUnstarRepoForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ActivityUnstarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ActivityUnstarRepoForAuthenticatedUser",
			OperationID:   "activity/unstar-repo-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityUnstarRepoForAuthenticatedUserParams
			Response = ActivityUnstarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityUnstarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsAddRepoToInstallationRequest handles apps/add-repo-to-installation operation.
//
// Add a single repository to an installation. The authenticated user must have admin access to the
// repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsAddRepoToInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsAddRepoToInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsAddRepoToInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsAddRepoToInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsAddRepoToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsAddRepoToInstallation",
			OperationID:   "apps/add-repo-to-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsAddRepoToInstallationParams
			Response = AppsAddRepoToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsAddRepoToInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsAddRepoToInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsAddRepoToInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCheckTokenRequest handles apps/check-token operation.
//
// OAuth applications can use a special API method for checking OAuth token validity without
// exceeding the normal rate limits for failed login attempts. Authentication works differently with
// this particular endpoint. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where
// the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid
// tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token
func (s *Server) handleAppsCheckTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCheckToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsCheckToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsCheckTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCheckTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCheckTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCheckToken",
			OperationID:   "apps/check-token",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCheckTokenReq
			Params   = AppsCheckTokenParams
			Response = AppsCheckTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCheckTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCheckToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCheckToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCheckTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateContentAttachmentRequest handles apps/create-content-attachment operation.
//
// Creates an attachment under a content reference URL in the body or comment of an issue or pull
// request. Use the `id` and `repository` `full_name` of the content reference from the
// [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to
// create an attachment.
// The app must create a content attachment within six hours of the content reference URL being
// posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)"
// for details about content attachments.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (s *Server) handleAppsCreateContentAttachmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateContentAttachment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsCreateContentAttachment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsCreateContentAttachmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateContentAttachmentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateContentAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateContentAttachment",
			OperationID:   "apps/create-content-attachment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "content_reference_id",
					In:   "path",
				}: params.ContentReferenceID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCreateContentAttachmentReq
			Params   = AppsCreateContentAttachmentParams
			Response = AppsCreateContentAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateContentAttachmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateContentAttachment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateContentAttachment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateContentAttachmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateFromManifestRequest handles apps/create-from-manifest operation.
//
// Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest
// flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
// When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
// retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
//
// POST /app-manifests/{code}/conversions
func (s *Server) handleAppsCreateFromManifestRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-from-manifest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateFromManifest",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsCreateFromManifest
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsCreateFromManifestParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateFromManifestRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateFromManifestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateFromManifest",
			OperationID:   "apps/create-from-manifest",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "code",
					In:   "path",
				}: params.Code,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCreateFromManifestReq
			Params   = AppsCreateFromManifestParams
			Response = AppsCreateFromManifestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateFromManifestParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateFromManifest(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateFromManifest(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateFromManifestResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsCreateInstallationAccessTokenRequest handles apps/create-installation-access-token operation.
//
// Creates an installation access token that enables a GitHub App to make authenticated API requests
// for the app's installation on an organization or individual account. Installation tokens expire
// one hour from the time you create them. Using an expired token produces a status code of `401 -
// Unauthorized`, and requires creating a new installation token. By default the installation token
// has access to all repositories that the installation can access. To restrict the access to
// specific repositories, you can provide the `repository_ids` when creating the token. When you omit
// `repository_ids`, the response does not contain the `repositories` key.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/installations/{installation_id}/access_tokens
func (s *Server) handleAppsCreateInstallationAccessTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsCreateInstallationAccessToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsCreateInstallationAccessTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsCreateInstallationAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateInstallationAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsCreateInstallationAccessToken",
			OperationID:   "apps/create-installation-access-token",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = OptAppsCreateInstallationAccessTokenReq
			Params   = AppsCreateInstallationAccessTokenParams
			Response = AppsCreateInstallationAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateInstallationAccessTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateInstallationAccessToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateInstallationAccessToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateInstallationAccessTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteAuthorizationRequest handles apps/delete-authorization operation.
//
// OAuth application owners can revoke a grant for their OAuth application and a specific user. You
// must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password. You
// must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's
// owner will be deleted.
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for the user. Once deleted, the application will have no access to the user's account
// and will no longer be listed on [the application authorizations settings screen within
// GitHub](https://github.com/settings/applications#authorized).
//
// DELETE /applications/{client_id}/grant
func (s *Server) handleAppsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsDeleteAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsDeleteAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsDeleteAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteAuthorization",
			OperationID:   "apps/delete-authorization",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsDeleteAuthorizationReq
			Params   = AppsDeleteAuthorizationParams
			Response = AppsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteAuthorization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteAuthorization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteInstallationRequest handles apps/delete-installation operation.
//
// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
// suspend an app's access to your account's resources, then we recommend the "[Suspend an app
// installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}
func (s *Server) handleAppsDeleteInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsDeleteInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsDeleteInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsDeleteInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteInstallation",
			OperationID:   "apps/delete-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsDeleteInstallationParams
			Response = AppsDeleteInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsDeleteTokenRequest handles apps/delete-token operation.
//
// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
//
// DELETE /applications/{client_id}/token
func (s *Server) handleAppsDeleteTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsDeleteToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsDeleteTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsDeleteTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsDeleteToken",
			OperationID:   "apps/delete-token",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsDeleteTokenReq
			Params   = AppsDeleteTokenParams
			Response = AppsDeleteTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetAuthenticatedRequest handles apps/get-authenticated operation.
//
// Returns the GitHub App associated with the authentication credentials used. To see how many app
// installations are associated with this GitHub App, see the `installations_count` in the response.
// For more details about your app's installations, see the "[List installations for the
// authenticated app](https://docs.github.
// com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app
func (s *Server) handleAppsGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *Integration
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetAuthenticated",
			OperationID:   "apps/get-authenticated",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *Integration
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetBySlugRequest handles apps/get-by-slug operation.
//
// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on
// the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
// If the GitHub App you specify is public, you can access this endpoint without authenticating. If
// the GitHub App you specify is private, you must authenticate with a [personal access
// token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or
// an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /apps/{app_slug}
func (s *Server) handleAppsGetBySlugRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetBySlug",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetBySlug
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsGetBySlugParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetBySlugRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetBySlug",
			OperationID:   "apps/get-by-slug",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "app_slug",
					In:   "path",
				}: params.AppSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetBySlugParams
			Response = AppsGetBySlugRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetBySlugParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetBySlug(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetBySlug(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountRequest handles apps/get-subscription-plan-for-account operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetSubscriptionPlanForAccount
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetSubscriptionPlanForAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetSubscriptionPlanForAccount",
			OperationID:   "apps/get-subscription-plan-for-account",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountParams
			Response = AppsGetSubscriptionPlanForAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountStubbedRequest handles apps/get-subscription-plan-for-account-stubbed operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccountStubbed",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetSubscriptionPlanForAccountStubbed
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetSubscriptionPlanForAccountStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetSubscriptionPlanForAccountStubbed",
			OperationID:   "apps/get-subscription-plan-for-account-stubbed",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountStubbedParams
			Response = AppsGetSubscriptionPlanForAccountStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetWebhookConfigForAppRequest handles apps/get-webhook-config-for-app operation.
//
// Returns the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/config
func (s *Server) handleAppsGetWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetWebhookConfigForApp
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetWebhookConfigForApp",
			OperationID:   "apps/get-webhook-config-for-app",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetWebhookConfigForApp(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookConfigForApp(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsGetWebhookDeliveryRequest handles apps/get-webhook-delivery operation.
//
// Returns a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries/{delivery_id}
func (s *Server) handleAppsGetWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsGetWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsGetWebhookDelivery",
			OperationID:   "apps/get-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetWebhookDeliveryParams
			Response = AppsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListAccountsForPlanRequest handles apps/list-accounts-for-plan operation.
//
// Returns user and organization accounts associated with the specified plan, including free plans.
// For per-seat pricing, you see the list of accounts that have purchased the plan, including the
// number of seats purchased. When someone submits a plan change that won't be processed until the
// end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlan",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListAccountsForPlan
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListAccountsForPlanParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListAccountsForPlanRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListAccountsForPlan",
			OperationID:   "apps/list-accounts-for-plan",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "plan_id",
					In:   "path",
				}: params.PlanID,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanParams
			Response = AppsListAccountsForPlanRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListAccountsForPlan(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlan(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListAccountsForPlanStubbedRequest handles apps/list-accounts-for-plan-stubbed operation.
//
// Returns repository and organization accounts associated with the specified plan, including free
// plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including
// the number of seats purchased. When someone submits a plan change that won't be processed until
// the end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlanStubbed",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListAccountsForPlanStubbed
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListAccountsForPlanStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListAccountsForPlanStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListAccountsForPlanStubbed",
			OperationID:   "apps/list-accounts-for-plan-stubbed",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "plan_id",
					In:   "path",
				}: params.PlanID,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanStubbedParams
			Response = AppsListAccountsForPlanStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListAccountsForPlanStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlanStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListInstallationReposForAuthenticatedUserRequest handles apps/list-installation-repos-for-authenticated-user operation.
//
// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access for an installation.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
// You must use a [user-to-server OAuth access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
// The access the user has to each repository is included in the hash under the `permissions` key.
//
// GET /user/installations/{installation_id}/repositories
func (s *Server) handleAppsListInstallationReposForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListInstallationReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListInstallationReposForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListInstallationReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListInstallationReposForAuthenticatedUser",
			OperationID:   "apps/list-installation-repos-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListInstallationReposForAuthenticatedUserParams
			Response = AppsListInstallationReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListInstallationReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListPlansRequest handles apps/list-plans operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans
func (s *Server) handleAppsListPlansRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlans",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListPlans
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListPlansParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListPlansRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListPlans",
			OperationID:   "apps/list-plans",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansParams
			Response = AppsListPlansRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListPlans(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListPlans(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListPlansStubbedRequest handles apps/list-plans-stubbed operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans
func (s *Server) handleAppsListPlansStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlansStubbed",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListPlansStubbed
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListPlansStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListPlansStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListPlansStubbed",
			OperationID:   "apps/list-plans-stubbed",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansStubbedParams
			Response = AppsListPlansStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListPlansStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListPlansStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListReposAccessibleToInstallationRequest handles apps/list-repos-accessible-to-installation operation.
//
// List repositories that an app installation can access.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /installation/repositories
func (s *Server) handleAppsListReposAccessibleToInstallationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListReposAccessibleToInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListReposAccessibleToInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListReposAccessibleToInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListReposAccessibleToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListReposAccessibleToInstallation",
			OperationID:   "apps/list-repos-accessible-to-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListReposAccessibleToInstallationParams
			Response = AppsListReposAccessibleToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListReposAccessibleToInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListReposAccessibleToInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListReposAccessibleToInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserRequest handles apps/list-subscriptions-for-authenticated-user operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListSubscriptionsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListSubscriptionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListSubscriptionsForAuthenticatedUser",
			OperationID:   "apps/list-subscriptions-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserParams
			Response = AppsListSubscriptionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest handles apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases/stubbed
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUserStubbed",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListSubscriptionsForAuthenticatedUserStubbed
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListSubscriptionsForAuthenticatedUserStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListSubscriptionsForAuthenticatedUserStubbed",
			OperationID:   "apps/list-subscriptions-for-authenticated-user-stubbed",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserStubbedParams
			Response = AppsListSubscriptionsForAuthenticatedUserStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsListWebhookDeliveriesRequest handles apps/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries
func (s *Server) handleAppsListWebhookDeliveriesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsListWebhookDeliveries
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsListWebhookDeliveries",
			OperationID:   "apps/list-webhook-deliveries",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListWebhookDeliveriesParams
			Response = AppsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRedeliverWebhookDeliveryRequest handles apps/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (s *Server) handleAppsRedeliverWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsRedeliverWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRedeliverWebhookDelivery",
			OperationID:   "apps/redeliver-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRedeliverWebhookDeliveryParams
			Response = AppsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRemoveRepoFromInstallationRequest handles apps/remove-repo-from-installation operation.
//
// Remove a single repository from an installation. The authenticated user must have admin access to
// the repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsRemoveRepoFromInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRemoveRepoFromInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsRemoveRepoFromInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsRemoveRepoFromInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsRemoveRepoFromInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRemoveRepoFromInstallation",
			OperationID:   "apps/remove-repo-from-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRemoveRepoFromInstallationParams
			Response = AppsRemoveRepoFromInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRemoveRepoFromInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsRemoveRepoFromInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsRemoveRepoFromInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsResetTokenRequest handles apps/reset-token operation.
//
// OAuth applications can use this API method to reset a valid OAuth token without end-user
// involvement. Applications must save the "token" property in the response because changes take
// effect immediately. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
// Invalid tokens will return `404 NOT FOUND`.
//
// PATCH /applications/{client_id}/token
func (s *Server) handleAppsResetTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsResetToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsResetToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsResetTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsResetTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsResetTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsResetToken",
			OperationID:   "apps/reset-token",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsResetTokenReq
			Params   = AppsResetTokenParams
			Response = AppsResetTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsResetTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsResetToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsResetToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsResetTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsRevokeInstallationAccessTokenRequest handles apps/revoke-installation-access-token operation.
//
// Revokes the installation token you're using to authenticate as an installation and access this
// endpoint.
// Once an installation token is revoked, the token is invalidated and cannot be used. Other
// endpoints that require the revoked installation token must have a new installation token to work.
// You can create a new token using the "[Create an installation access token for an
// app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
// endpoint.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// DELETE /installation/token
func (s *Server) handleAppsRevokeInstallationAccessTokenRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRevokeInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsRevokeInstallationAccessToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *AppsRevokeInstallationAccessTokenNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsRevokeInstallationAccessToken",
			OperationID:   "apps/revoke-installation-access-token",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *AppsRevokeInstallationAccessTokenNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppsRevokeInstallationAccessToken(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.AppsRevokeInstallationAccessToken(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsScopeTokenRequest handles apps/scope-token operation.
//
// Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission
// scoped user-to-server OAuth access token. You can specify which repositories the token can access
// and which permissions are granted to the token. You must use [Basic Authentication](https://docs.
// github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this
// endpoint, using the OAuth application's `client_id` and `client_secret` as the username and
// password. Invalid tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token/scoped
func (s *Server) handleAppsScopeTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsScopeToken",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsScopeToken
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsScopeTokenParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAppsScopeTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsScopeTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsScopeToken",
			OperationID:   "apps/scope-token",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsScopeTokenReq
			Params   = AppsScopeTokenParams
			Response = AppsScopeTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsScopeTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsScopeToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsScopeToken(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsScopeTokenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsSuspendInstallationRequest handles apps/suspend-installation operation.
//
// Suspends a GitHub App on a user, organization, or business account, which blocks the app from
// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub
// API or webhook events is blocked for that account.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PUT /app/installations/{installation_id}/suspended
func (s *Server) handleAppsSuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsSuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsSuspendInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsSuspendInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsSuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsSuspendInstallation",
			OperationID:   "apps/suspend-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsSuspendInstallationParams
			Response = AppsSuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsSuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsSuspendInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsSuspendInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsUnsuspendInstallationRequest handles apps/unsuspend-installation operation.
//
// Removes a GitHub App installation suspension.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}/suspended
func (s *Server) handleAppsUnsuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUnsuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsUnsuspendInstallation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeAppsUnsuspendInstallationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response AppsUnsuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsUnsuspendInstallation",
			OperationID:   "apps/unsuspend-installation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsUnsuspendInstallationParams
			Response = AppsUnsuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsUnsuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsUnsuspendInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsUnsuspendInstallation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAppsUpdateWebhookConfigForAppRequest handles apps/update-webhook-config-for-app operation.
//
// Updates the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PATCH /app/hook/config
func (s *Server) handleAppsUpdateWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUpdateWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().AppsUpdateWebhookConfigForApp
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeAppsUpdateWebhookConfigForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "AppsUpdateWebhookConfigForApp",
			OperationID:   "apps/update-webhook-config-for-app",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptAppsUpdateWebhookConfigForAppReq
			Params   = struct{}
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsUpdateWebhookConfigForApp(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsUpdateWebhookConfigForApp(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingGheRequest handles billing/get-github-actions-billing-ghe operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingGhe",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubActionsBillingGhe
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubActionsBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingGhe",
			OperationID:   "billing/get-github-actions-billing-ghe",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingGheParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingOrgRequest handles billing/get-github-actions-billing-org operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubActionsBillingOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubActionsBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingOrg",
			OperationID:   "billing/get-github-actions-billing-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingOrgParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubActionsBillingUserRequest handles billing/get-github-actions-billing-user operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubActionsBillingUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubActionsBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubActionsBillingUser",
			OperationID:   "billing/get-github-actions-billing-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingUserParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingGheRequest handles billing/get-github-packages-billing-ghe operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingGhe",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubPackagesBillingGhe
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingGhe",
			OperationID:   "billing/get-github-packages-billing-ghe",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingGheParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingOrgRequest handles billing/get-github-packages-billing-org operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubPackagesBillingOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingOrg",
			OperationID:   "billing/get-github-packages-billing-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingOrgParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetGithubPackagesBillingUserRequest handles billing/get-github-packages-billing-user operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetGithubPackagesBillingUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetGithubPackagesBillingUser",
			OperationID:   "billing/get-github-packages-billing-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingUserParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingGheRequest handles billing/get-shared-storage-billing-ghe operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingGhe",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetSharedStorageBillingGhe
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetSharedStorageBillingGheParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingGhe",
			OperationID:   "billing/get-shared-storage-billing-ghe",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingGheParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingGhe(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingOrgRequest handles billing/get-shared-storage-billing-org operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetSharedStorageBillingOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetSharedStorageBillingOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingOrg",
			OperationID:   "billing/get-shared-storage-billing-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingOrgParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleBillingGetSharedStorageBillingUserRequest handles billing/get-shared-storage-billing-user operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().BillingGetSharedStorageBillingUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeBillingGetSharedStorageBillingUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "BillingGetSharedStorageBillingUser",
			OperationID:   "billing/get-shared-storage-billing-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingUserParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksCreateSuiteRequest handles checks/create-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// By default, check suites are automatically created when you create a [check run](https://docs.
// github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually
// creating check suites when you've disabled automatic creation using "[Update repository
// preferences for check suites](https://docs.github.
// com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must
// have the `checks:write` permission to create check suites.
//
// POST /repos/{owner}/{repo}/check-suites
func (s *Server) handleChecksCreateSuiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksCreateSuite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksCreateSuite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksCreateSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeChecksCreateSuiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ChecksCreateSuiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksCreateSuite",
			OperationID:   "checks/create-suite",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ChecksCreateSuiteReq
			Params   = ChecksCreateSuiteParams
			Response = ChecksCreateSuiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksCreateSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksCreateSuite(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksCreateSuite(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksGetRequest handles checks/get operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check runs. OAuth Apps and
// authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (s *Server) handleChecksGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CheckRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksGet",
			OperationID:   "checks/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_run_id",
					In:   "path",
				}: params.CheckRunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetParams
			Response = *CheckRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksGetSuiteRequest handles checks/get-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check suites. OAuth Apps and
// authenticated users must have the `repo` scope to get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (s *Server) handleChecksGetSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGetSuite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksGetSuite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksGetSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CheckSuite
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksGetSuite",
			OperationID:   "checks/get-suite",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetSuiteParams
			Response = *CheckSuite
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksGetSuite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksGetSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListAnnotationsRequest handles checks/list-annotations operation.
//
// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the
// `checks:read` permission on a private repository or pull access to a public repository to get
// annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get
// annotations for a check run in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (s *Server) handleChecksListAnnotationsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListAnnotations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksListAnnotations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksListAnnotationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ChecksListAnnotationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListAnnotations",
			OperationID:   "checks/list-annotations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_run_id",
					In:   "path",
				}: params.CheckRunID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListAnnotationsParams
			Response = *ChecksListAnnotationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListAnnotationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListAnnotations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListAnnotations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListForRefRequest handles checks/list-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps
// must have the `checks:read` permission on a private repository or pull access to a public
// repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get
// check runs in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (s *Server) handleChecksListForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksListForRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksListForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ChecksListForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListForRef",
			OperationID:   "checks/list-for-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "app_id",
					In:   "query",
				}: params.AppID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForRefParams
			Response = *ChecksListForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListForSuiteRequest handles checks/list-for-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read`
// permission on a private repository or pull access to a public repository to get check runs. OAuth
// Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (s *Server) handleChecksListForSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForSuite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksListForSuite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksListForSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ChecksListForSuiteOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListForSuite",
			OperationID:   "checks/list-for-suite",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForSuiteParams
			Response = *ChecksListForSuiteOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListForSuite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListForSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksListSuitesForRefRequest handles checks/list-suites-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub
// Apps must have the `checks:read` permission on a private repository or pull access to a public
// repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to
// get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (s *Server) handleChecksListSuitesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListSuitesForRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksListSuitesForRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksListSuitesForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ChecksListSuitesForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksListSuitesForRef",
			OperationID:   "checks/list-suites-for-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "app_id",
					In:   "query",
				}: params.AppID,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListSuitesForRefParams
			Response = *ChecksListSuitesForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListSuitesForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListSuitesForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListSuitesForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksRerequestSuiteRequest handles checks/rerequest-suite operation.
//
// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
// This endpoint will trigger the [`check_suite` webhook](https://docs.github.
// com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite
// is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private
// repository or pull access to a public repository.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (s *Server) handleChecksRerequestSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksRerequestSuite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksRerequestSuite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksRerequestSuiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ChecksRerequestSuiteCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksRerequestSuite",
			OperationID:   "checks/rerequest-suite",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksRerequestSuiteParams
			Response = *ChecksRerequestSuiteCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksRerequestSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ChecksRerequestSuite(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ChecksRerequestSuite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleChecksSetSuitesPreferencesRequest handles checks/set-suites-preferences operation.
//
// Changes the default automatic flow when creating check suites. By default, a check suite is
// automatically created each time code is pushed to a repository. When you disable the automatic
// creation of check suites, you can manually [Create a check suite](https://docs.github.
// com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository
// to set preferences for check suites.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (s *Server) handleChecksSetSuitesPreferencesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksSetSuitesPreferences",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ChecksSetSuitesPreferences
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeChecksSetSuitesPreferencesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeChecksSetSuitesPreferencesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CheckSuitePreference
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ChecksSetSuitesPreferences",
			OperationID:   "checks/set-suites-preferences",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ChecksSetSuitesPreferencesReq
			Params   = ChecksSetSuitesPreferencesParams
			Response = *CheckSuitePreference
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksSetSuitesPreferencesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksSetSuitesPreferences(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksSetSuitesPreferences(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningDeleteAnalysisRequest handles code-scanning/delete-analysis operation.
//
// Deletes a specified code scanning analysis from a repository. For
// private repositories, you must use an access token with the `repo` scope. For public repositories,
// you must use an access token with `public_repo` and `repo:security_events` scopes.
// GitHub Apps must have the `security_events` write permission to use this endpoint.
// You can delete one analysis at a time.
// To delete a series of analyses, start with the most recent analysis and work backwards.
// Conceptually, the process is similar to the undo function in a text editor.
// When you list the analyses for a repository,
// one or more will be identified as deletable in the response:
// ```
// "deletable": true
// ```
// An analysis is deletable when it's the most recent in a set of analyses.
// Typically, a repository will have multiple sets of analyses
// for each enabled code scanning tool,
// where a set is determined by a unique combination of analysis values:
// * `ref`
// * `tool`
// * `analysis_key`
// * `environment`
// If you attempt to delete an analysis that is not the most recent in a set,
// you'll get a 400 response with the message:
// ```
// Analysis specified is not deletable.
// ```
// The response from a successful `DELETE` operation provides you with
// two alternative URLs for deleting the next analysis in the set
// (see the example default response below).
// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
// in the set. This is a useful option if you want to preserve at least one analysis
// for the specified tool in your repository.
// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
// When you delete the last analysis in a set the value of `next_analysis_url` and
// `confirm_delete_url`
// in the 200 response is `null`.
// As an example of the deletion process,
// let's imagine that you added a workflow that configured a particular code scanning tool
// to analyze the code in a repository. This tool has added 15 analyses:
// 10 on the default branch, and another 5 on a topic branch.
// You therefore have two separate sets of analyses for this tool.
// You've now decided that you want to remove all of the analyses for the tool.
// To do this you must make 15 separate deletion requests.
// To start, you must find the deletable analysis for one of the sets,
// step through deleting the analyses in that set,
// and then repeat the process for the second set.
// The procedure therefore consists of a nested loop:
// **Outer loop**:
// * List the analyses for the repository, filtered by tool.
// * Parse this list to find a deletable analysis. If found:
// **Inner loop**:
// * Delete the identified analysis.
// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next
// iteration.
// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub
// user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value.
//
//	Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis
//
// in each set undeleted to avoid removing a tool's analysis entirely.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningDeleteAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningDeleteAnalysis",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningDeleteAnalysis
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningDeleteAnalysisParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningDeleteAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningDeleteAnalysis",
			OperationID:   "code-scanning/delete-analysis",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "analysis_id",
					In:   "path",
				}: params.AnalysisID,
				{
					Name: "confirm_delete",
					In:   "query",
				}: params.ConfirmDelete,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningDeleteAnalysisParams
			Response = CodeScanningDeleteAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningDeleteAnalysisParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningDeleteAnalysis(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningDeleteAnalysis(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetAlertRequest handles code-scanning/get-alert operation.
//
// Gets a single code scanning alert. You must use an access token with the `security_events` scope
// to use this endpoint. GitHub Apps must have the `security_events` read permission to use this
// endpoint.
// **Deprecation notice**:
// The instances field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The same information can now be retrieved via
// a GET request to the URL specified by `instances_url`.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningGetAlert
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningGetAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetAlert",
			OperationID:   "code-scanning/get-alert",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAlertParams
			Response = CodeScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetAlert(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAlert(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetAnalysisRequest handles code-scanning/get-analysis operation.
//
// Gets a specified code scanning analysis for a repository.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// The default JSON response contains fields that describe the analysis.
// This includes the Git reference and commit SHA to which the analysis relates,
// the datetime of the analysis, the name of the code scanning tool,
// and the number of alerts.
// The `rules_count` field in the default response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// If you use the Accept header `application/sarif+json`,
// the response contains the analysis data that was uploaded.
// This is formatted as
// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningGetAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAnalysis",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningGetAnalysis
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningGetAnalysisParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetAnalysis",
			OperationID:   "code-scanning/get-analysis",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "analysis_id",
					In:   "path",
				}: params.AnalysisID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAnalysisParams
			Response = CodeScanningGetAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAnalysisParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetAnalysis(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAnalysis(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningGetSarifRequest handles code-scanning/get-sarif operation.
//
// Gets information about a SARIF upload, including the status and the URL of the analysis that was
// uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code
// scanning analysis for a
// repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You
// must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must
// have the `security_events` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (s *Server) handleCodeScanningGetSarifRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetSarif",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningGetSarif
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningGetSarifParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningGetSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningGetSarif",
			OperationID:   "code-scanning/get-sarif",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sarif_id",
					In:   "path",
				}: params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetSarifParams
			Response = CodeScanningGetSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetSarifParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetSarif(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetSarif(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListAlertInstancesRequest handles code-scanning/list-alert-instances operation.
//
// Lists all instances of the specified code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (s *Server) handleCodeScanningListAlertInstancesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertInstances",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningListAlertInstances
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningListAlertInstancesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListAlertInstancesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListAlertInstances",
			OperationID:   "code-scanning/list-alert-instances",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertInstancesParams
			Response = CodeScanningListAlertInstancesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertInstancesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListAlertInstances(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertInstances(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListAlertsForRepoRequest handles code-scanning/list-alerts-for-repo operation.
//
// Lists all open code scanning alerts for the default branch (usually `main`
// or `master`). You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` read permission to use
// this endpoint.
// The response includes a `most_recent_instance` object.
// This provides details of the most recent instance of this alert
// for the default branch or for the specified Git reference
// (if you used `ref` in the request).
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (s *Server) handleCodeScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningListAlertsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningListAlertsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListAlertsForRepo",
			OperationID:   "code-scanning/list-alerts-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tool_name",
					In:   "query",
				}: params.ToolName,
				{
					Name: "tool_guid",
					In:   "query",
				}: params.ToolGUID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertsForRepoParams
			Response = CodeScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListAlertsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningListRecentAnalysesRequest handles code-scanning/list-recent-analyses operation.
//
// Lists the details of all code scanning analyses for a repository,
// starting with the most recent.
// The response is paginated and you can use the `page` and `per_page` parameters
// to list the analyses you're interested in.
// By default 30 analyses are listed per page.
// The `rules_count` field in the response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (s *Server) handleCodeScanningListRecentAnalysesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListRecentAnalyses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningListRecentAnalyses
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningListRecentAnalysesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodeScanningListRecentAnalysesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningListRecentAnalyses",
			OperationID:   "code-scanning/list-recent-analyses",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tool_name",
					In:   "query",
				}: params.ToolName,
				{
					Name: "tool_guid",
					In:   "query",
				}: params.ToolGUID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "sarif_id",
					In:   "query",
				}: params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListRecentAnalysesParams
			Response = CodeScanningListRecentAnalysesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListRecentAnalysesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListRecentAnalyses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListRecentAnalyses(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningUpdateAlertRequest handles code-scanning/update-alert operation.
//
// Updates the status of a single code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write
// permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningUpdateAlert
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningUpdateAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeCodeScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningUpdateAlert",
			OperationID:   "code-scanning/update-alert",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = *CodeScanningUpdateAlertReq
			Params   = CodeScanningUpdateAlertParams
			Response = CodeScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningUpdateAlert(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodeScanningUploadSarifRequest handles code-scanning/upload-sarif operation.
//
// Uploads SARIF data containing the results of a code scanning analysis to make the results
// available in a repository. You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
// There are two places where you can upload code scanning results.
// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref
// refs/pull/42/head`, then the results appear as alerts in a pull request check. For more
// information, see "[Triaging code scanning alerts in pull
// requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in
// the **Security** tab for your repository. For more information, see "[Managing code scanning
// alerts for your
// repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and
// then encode it as a Base64 format string. For example:
// ```
// gzip -c analysis-data.sarif | base64 -w0
// ```
// SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are
// ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not
// necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool
// generates too many results, you should update the analysis configuration to run only the most
// important rules or queries.
// The `202 Accepted`, response includes an `id` value.
// You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}`
// endpoint.
// For more information, see "[Get information about a SARIF
// upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).".
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (s *Server) handleCodeScanningUploadSarifRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUploadSarif",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodeScanningUploadSarif
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodeScanningUploadSarifParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeCodeScanningUploadSarifRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUploadSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodeScanningUploadSarif",
			OperationID:   "code-scanning/upload-sarif",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *CodeScanningUploadSarifReq
			Params   = CodeScanningUploadSarifParams
			Response = CodeScanningUploadSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUploadSarifParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningUploadSarif(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningUploadSarif(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodesOfConductGetAllCodesOfConductRequest handles codes-of-conduct/get-all-codes-of-conduct operation.
//
// Get all codes of conduct.
//
// GET /codes_of_conduct
func (s *Server) handleCodesOfConductGetAllCodesOfConductRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetAllCodesOfConduct",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodesOfConductGetAllCodesOfConduct
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response CodesOfConductGetAllCodesOfConductRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodesOfConductGetAllCodesOfConduct",
			OperationID:   "codes-of-conduct/get-all-codes-of-conduct",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = CodesOfConductGetAllCodesOfConductRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodesOfConductGetAllCodesOfConduct(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetAllCodesOfConduct(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCodesOfConductGetConductCodeRequest handles codes-of-conduct/get-conduct-code operation.
//
// Get a code of conduct.
//
// GET /codes_of_conduct/{key}
func (s *Server) handleCodesOfConductGetConductCodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetConductCode",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().CodesOfConductGetConductCode
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeCodesOfConductGetConductCodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CodesOfConductGetConductCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CodesOfConductGetConductCode",
			OperationID:   "codes-of-conduct/get-conduct-code",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "key",
					In:   "path",
				}: params.Key,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodesOfConductGetConductCodeParams
			Response = CodesOfConductGetConductCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodesOfConductGetConductCodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodesOfConductGetConductCode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetConductCode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEmojisGetRequest handles emojis/get operation.
//
// Lists all the emojis available to use on GitHub.
//
// GET /emojis
func (s *Server) handleEmojisGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmojisGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EmojisGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response EmojisGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EmojisGet",
			OperationID:   "emojis/get",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = EmojisGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmojisGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmojisGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEmojisGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Adds an organization to the list of selected organizations that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest handles enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// Adds a self-hosted runner to a runner group configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise`
// scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
			OperationID:   "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
			Response = *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest handles enterprise-admin/create-registration-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (s *Server) handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRegistrationTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminCreateRegistrationTokenForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateRegistrationTokenForEnterprise",
			OperationID:   "enterprise-admin/create-registration-token-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRegistrationTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest handles enterprise-admin/create-remove-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// enterprise. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (s *Server) handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRemoveTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminCreateRemoveTokenForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateRemoveTokenForEnterprise",
			OperationID:   "enterprise-admin/create-remove-token-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRemoveTokenForEnterpriseParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRemoveTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// Creates a new self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/create-self-hosted-runner-group-for-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest handles enterprise-admin/delete-scim-group-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteScimGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminDeleteScimGroupFromEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteScimGroupFromEnterprise",
			OperationID:   "enterprise-admin/delete-scim-group-from-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteScimGroupFromEnterpriseParams
			Response = *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteScimGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
			OperationID:   "enterprise-admin/delete-self-hosted-runner-from-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
			Response = *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// Deletes a self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
			OperationID:   "enterprise-admin/delete-self-hosted-runner-group-from-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
			Response = *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDeleteUserFromEnterpriseRequest handles enterprise-admin/delete-user-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteUserFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminDeleteUserFromEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminDeleteUserFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDeleteUserFromEnterprise",
			OperationID:   "enterprise-admin/delete-user-from-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteUserFromEnterpriseParams
			Response = *EnterpriseAdminDeleteUserFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteUserFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// Removes an organization from the list of selected organizations that are enabled for GitHub
// Actions in an enterprise. To use this endpoint, the enterprise permission policy for
// `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
			OperationID:   "enterprise-admin/disable-selected-organization-github-actions-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
			Response = *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in
// an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations`
// must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for
// an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
			OperationID:   "enterprise-admin/enable-selected-organization-github-actions-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
			Response = *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetAllowedActionsEnterpriseRequest handles enterprise-admin/get-allowed-actions-enterprise operation.
//
// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetAllowedActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetAllowedActionsEnterprise",
			OperationID:   "enterprise-admin/get-allowed-actions-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAllowedActionsEnterpriseParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetAuditLogRequest handles enterprise-admin/get-audit-log operation.
//
// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and
// you must use an access token with the `admin:enterprise` scope.
//
// GET /enterprises/{enterprise}/audit-log
func (s *Server) handleEnterpriseAdminGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetAuditLog
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetAuditLogParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetAuditLog",
			OperationID:   "enterprise-admin/get-audit-log",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "phrase",
					In:   "query",
				}: params.Phrase,
				{
					Name: "include",
					In:   "query",
				}: params.Include,
				{
					Name: "after",
					In:   "query",
				}: params.After,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetAuditLog(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAuditLog(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetGithubActionsPermissionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ActionsEnterprisePermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
			OperationID:   "enterprise-admin/get-github-actions-permissions-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
			Response = *ActionsEnterprisePermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest handles enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetProvisioningInformationForEnterpriseGroup
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
			OperationID:   "enterprise-admin/get-provisioning-information-for-enterprise-group",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
				{
					Name: "excludedAttributes",
					In:   "query",
				}: params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest handles enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetProvisioningInformationForEnterpriseUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
			OperationID:   "enterprise-admin/get-provisioning-information-for-enterprise-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// Gets a specific self-hosted runner configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetSelfHostedRunnerForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
			OperationID:   "enterprise-admin/get-self-hosted-runner-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// Gets a specific self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/get-self-hosted-runner-group-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Lists the organizations with access to a self-hosted runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest handles enterprise-admin/list-provisioned-groups-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedGroupsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListProvisionedGroupsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ScimGroupListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListProvisionedGroupsEnterprise",
			OperationID:   "enterprise-admin/list-provisioned-groups-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "startIndex",
					In:   "query",
				}: params.StartIndex,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "excludedAttributes",
					In:   "query",
				}: params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedGroupsEnterpriseParams
			Response = *ScimGroupListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedGroupsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest handles enterprise-admin/list-provisioned-identities-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
// When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise,
// the account's metadata is immediately removed. However, the returned list of user accounts might
// not always match the organization or enterprise member list you see on GitHub. This can happen in
// certain cases where an external identity associated with an organization will not match an
// organization member:
// - When a user with a SCIM-provisioned external identity is removed from an enterprise, the
// account's metadata is preserved to allow the user to re-join the organization in the future.
// - When inviting a user to join an organization, you can expect to see their external identity in
// the results before they accept the invitation, or if the invitation is cancelled (or never
// accepted).
// - When a user is invited over SCIM, an external identity is created that matches with the
// invitee's email address. However, this identity is only linked to a user account when the user
// accepts the invitation by going through SAML SSO.
// The returned list of external identities can include an entry for a `null` user. These are
// unlinked SAML identities that are created when a user goes through the following Single Sign-On
// (SSO) process but does not sign in to their GitHub account after completing SSO:
// 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
// 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is
// not currently signed in to their GitHub account.
// 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is
// created and the user is prompted to sign in to their GitHub account:
// - If the user signs in, their GitHub account is linked to this entry.
// - If the user does not sign in (or does not create a new account when prompted), they are not
// added to the GitHub enterprise, and the external identity `null` entry remains in place.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedIdentitiesEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListProvisionedIdentitiesEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ScimUserListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListProvisionedIdentitiesEnterprise",
			OperationID:   "enterprise-admin/list-provisioned-identities-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "startIndex",
					In:   "query",
				}: params.StartIndex,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
			Response = *ScimUserListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedIdentitiesEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest handles enterprise-admin/list-runner-applications-for-enterprise operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (s *Server) handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListRunnerApplicationsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListRunnerApplicationsForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListRunnerApplicationsForEnterprise",
			OperationID:   "enterprise-admin/list-runner-applications-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListRunnerApplicationsForEnterpriseParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListRunnerApplicationsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use
// this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
			OperationID:   "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest handles enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// Lists all self-hosted runner groups for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runner-groups-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// Lists all self-hosted runners configured for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListSelfHostedRunnersForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnersForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runners-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// Lists the self-hosted runners that are in a specific enterprise group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
			OperationID:   "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest handles enterprise-admin/provision-and-invite-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision an enterprise group, and invite users to the group. This sends invitation emails to the
// email address of the invited users to join the GitHub organization that the SCIM group corresponds
// to.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminProvisionAndInviteEnterpriseGroup
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
			OperationID:   "enterprise-admin/provision-and-invite-enterprise-group",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest handles enterprise-admin/provision-and-invite-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision enterprise membership for a user, and send organization invitation emails to the email
// address.
// You can optionally include the groups a user will be invited to join. If you do not provide a list
// of `groups`, the user is provisioned for the enterprise, but no organization invitation emails
// will be sent.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminProvisionAndInviteEnterpriseUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminProvisionAndInviteEnterpriseUser",
			OperationID:   "enterprise-admin/provision-and-invite-enterprise-user",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminProvisionAndInviteEnterpriseUserReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Removes an organization from the list of selected organizations that can access a self-hosted
// runner group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest handles enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned
// to the default group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
			OperationID:   "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
			Response = *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetAllowedActionsEnterpriseRequest handles enterprise-admin/set-allowed-actions-enterprise operation.
//
// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetAllowedActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetAllowedActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetAllowedActionsEnterprise",
			OperationID:   "enterprise-admin/set-allowed-actions-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *SelectedActions
			Params   = EnterpriseAdminSetAllowedActionsEnterpriseParams
			Response = *EnterpriseAdminSetAllowedActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetGithubActionsPermissionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
			OperationID:   "enterprise-admin/set-github-actions-permissions-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
			Params   = EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
			Response = *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest handles enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned group’s information. You must provide all the information
// required for the group as if you were provisioning it for the first time. Any existing group
// information that you don't provide will be removed, including group membership. If you want to
// only update a specific attribute, use the [Update an attribute for a SCIM enterprise
// group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetInformationForProvisionedEnterpriseGroup
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
			OperationID:   "enterprise-admin/set-information-for-provisioned-enterprise-group",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest handles enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned user's information. You must provide all the information required
// for the user as if you were provisioning them for the first time. Any existing user information
// that you don't provide will be removed. If you want to only update a specific attribute, use the
// [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint
// instead.
// You must at least provide the required values for the user: `userName`, `name`, and `emails`.
// **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external
// identity, and deletes the associated `{scim_user_id}`.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetInformationForProvisionedEnterpriseUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
			OperationID:   "enterprise-admin/set-information-for-provisioned-enterprise-user",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Replaces the list of organizations that have access to a self-hosted runner configured in an
// enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
			OperationID:   "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
			Params   = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise.
// To use this endpoint, the enterprise permission policy for `enabled_organizations` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
			OperationID:   "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
			Params   = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// Replaces the list of self-hosted runners that are part of an enterprise runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
			OperationID:   "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
			Params   = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
			Response = *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest handles enterprise-admin/update-attribute-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned group’s individual attributes. To change a group’s values,
// you must provide a specific Operations JSON format that contains at least one of the add, remove,
// or replace operations. For examples and more information on the SCIM operations format, see the
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminUpdateAttributeForEnterpriseGroup
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
			OperationID:   "enterprise-admin/update-attribute-for-enterprise-group",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest handles enterprise-admin/update-attribute-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned user's individual attributes. To change a user's values, you
// must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`,
//
//	or `replace` operations. For examples and more information on the SCIM operations format, see the
//
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a
// `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
// **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example
// below), it removes the user from the enterprise, deletes the external identity, and deletes the
// associated `:scim_user_id`.
// ```
// {
// "Operations":[{
// "op":"replace",
// "value":{
// "active":false
// }
// }]
// }
// ```.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminUpdateAttributeForEnterpriseUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateAttributeForEnterpriseUser",
			OperationID:   "enterprise-admin/update-attribute-for-enterprise-user",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminUpdateAttributeForEnterpriseUserReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
			OperationID:   "enterprise-admin/update-self-hosted-runner-group-for-enterprise",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCheckIsStarredRequest handles gists/check-is-starred operation.
//
// Check if a gist is starred.
//
// GET /gists/{gist_id}/star
func (s *Server) handleGistsCheckIsStarredRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCheckIsStarred",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsCheckIsStarred
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsCheckIsStarredParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsCheckIsStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCheckIsStarred",
			OperationID:   "gists/check-is-starred",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsCheckIsStarredParams
			Response = GistsCheckIsStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCheckIsStarredParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCheckIsStarred(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCheckIsStarred(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCreateRequest handles gists/create operation.
//
// Allows you to add a new gist with one or more files.
// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the
// automatic naming scheme that Gist uses internally.
//
// POST /gists
func (s *Server) handleGistsCreateRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsCreate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeGistsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCreate",
			OperationID:   "gists/create",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *GistsCreateReq
			Params   = struct{}
			Response = GistsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCreate(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCreate(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsCreateCommentRequest handles gists/create-comment operation.
//
// Create a gist comment.
//
// POST /gists/{gist_id}/comments
func (s *Server) handleGistsCreateCommentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreateComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsCreateComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsCreateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGistsCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsCreateComment",
			OperationID:   "gists/create-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = *GistsCreateCommentReq
			Params   = GistsCreateCommentParams
			Response = GistsCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCreateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCreateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsDeleteRequest handles gists/delete operation.
//
// Delete a gist.
//
// DELETE /gists/{gist_id}
func (s *Server) handleGistsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsDelete
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsDelete",
			OperationID:   "gists/delete",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteParams
			Response = GistsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsDeleteCommentRequest handles gists/delete-comment operation.
//
// Delete a gist comment.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsDeleteCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDeleteComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsDeleteComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsDeleteCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsDeleteCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsDeleteComment",
			OperationID:   "gists/delete-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteCommentParams
			Response = GistsDeleteCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsDeleteComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsDeleteComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsForkRequest handles gists/fork operation.
//
// **Note**: This was previously `/gists/:gist_id/fork`.
//
// POST /gists/{gist_id}/forks
func (s *Server) handleGistsForkRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsFork",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsFork
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsForkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsFork",
			OperationID:   "gists/fork",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsForkParams
			Response = GistsForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsForkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsFork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsFork(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsForkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetRequest handles gists/get operation.
//
// Get a gist.
//
// GET /gists/{gist_id}
func (s *Server) handleGistsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGet",
			OperationID:   "gists/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetParams
			Response = GistsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetCommentRequest handles gists/get-comment operation.
//
// Get a gist comment.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsGetCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsGetComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsGetCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGetComment",
			OperationID:   "gists/get-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetCommentParams
			Response = GistsGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGetComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGetComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsGetRevisionRequest handles gists/get-revision operation.
//
// Get a gist revision.
//
// GET /gists/{gist_id}/{sha}
func (s *Server) handleGistsGetRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetRevision",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsGetRevision
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsGetRevisionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsGetRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsGetRevision",
			OperationID:   "gists/get-revision",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "sha",
					In:   "path",
				}: params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetRevisionParams
			Response = GistsGetRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetRevisionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGetRevision(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGetRevision(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetRevisionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListRequest handles gists/list operation.
//
// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public
// gists:.
//
// GET /gists
func (s *Server) handleGistsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsList",
			OperationID:   "gists/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListParams
			Response = GistsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListCommentsRequest handles gists/list-comments operation.
//
// List gist comments.
//
// GET /gists/{gist_id}/comments
func (s *Server) handleGistsListCommentsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListComments",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListComments
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListComments",
			OperationID:   "gists/list-comments",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommentsParams
			Response = GistsListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListCommitsRequest handles gists/list-commits operation.
//
// List gist commits.
//
// GET /gists/{gist_id}/commits
func (s *Server) handleGistsListCommitsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListCommits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListCommits
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListCommits",
			OperationID:   "gists/list-commits",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommitsParams
			Response = GistsListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListForUserRequest handles gists/list-for-user operation.
//
// Lists public gists for the specified user:.
//
// GET /users/{username}/gists
func (s *Server) handleGistsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListForUser",
			OperationID:   "gists/list-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForUserParams
			Response = GistsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListForksRequest handles gists/list-forks operation.
//
// List gist forks.
//
// GET /gists/{gist_id}/forks
func (s *Server) handleGistsListForksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListForks
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListForksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListForks",
			OperationID:   "gists/list-forks",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForksParams
			Response = GistsListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListForks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListForks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListPublicRequest handles gists/list-public operation.
//
// List public gists sorted by most recently updated to least recently updated.
// Note: With [pagination](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For
// example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
//
// GET /gists/public
func (s *Server) handleGistsListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListPublic",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListPublic
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListPublicParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListPublic",
			OperationID:   "gists/list-public",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListPublicParams
			Response = GistsListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListPublicParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListPublic(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListPublic(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListPublicResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsListStarredRequest handles gists/list-starred operation.
//
// List the authenticated user's starred gists:.
//
// GET /gists/starred
func (s *Server) handleGistsListStarredRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListStarred",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsListStarred
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsListStarredParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsListStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsListStarred",
			OperationID:   "gists/list-starred",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListStarredParams
			Response = GistsListStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListStarredParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListStarred(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListStarred(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListStarredResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsStarRequest handles gists/star operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /gists/{gist_id}/star
func (s *Server) handleGistsStarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsStar",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsStar
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsStarParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsStarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsStar",
			OperationID:   "gists/star",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsStarParams
			Response = GistsStarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsStarParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsStar(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsStar(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsStarResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsUnstarRequest handles gists/unstar operation.
//
// Unstar a gist.
//
// DELETE /gists/{gist_id}/star
func (s *Server) handleGistsUnstarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUnstar",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsUnstar
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsUnstarParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GistsUnstarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsUnstar",
			OperationID:   "gists/unstar",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsUnstarParams
			Response = GistsUnstarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUnstarParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsUnstar(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsUnstar(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUnstarResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGistsUpdateCommentRequest handles gists/update-comment operation.
//
// Update a gist comment.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsUpdateCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUpdateComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GistsUpdateComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGistsUpdateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGistsUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GistsUpdateComment",
			OperationID:   "gists/update-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *GistsUpdateCommentReq
			Params   = GistsUpdateCommentParams
			Response = GistsUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsUpdateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsUpdateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateBlobRequest handles git/create-blob operation.
//
// Create a blob.
//
// POST /repos/{owner}/{repo}/git/blobs
func (s *Server) handleGitCreateBlobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateBlob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitCreateBlob
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitCreateBlobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateBlobRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateBlob",
			OperationID:   "git/create-blob",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateBlobReq
			Params   = GitCreateBlobParams
			Response = GitCreateBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateBlobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateBlob(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateBlob(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateBlobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateCommitRequest handles git/create-commit operation.
//
// Creates a new Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/commits
func (s *Server) handleGitCreateCommitRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitCreateCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitCreateCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateCommitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateCommit",
			OperationID:   "git/create-commit",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateCommitReq
			Params   = GitCreateCommitParams
			Response = GitCreateCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateCommit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateCommit(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateRefRequest handles git/create-ref operation.
//
// Creates a reference for your repository. You are unable to create new references for empty
// repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
// without branches.
//
// POST /repos/{owner}/{repo}/git/refs
func (s *Server) handleGitCreateRefRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitCreateRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitCreateRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateRef",
			OperationID:   "git/create-ref",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateRefReq
			Params   = GitCreateRefParams
			Response = GitCreateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateRef(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateRef(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateTagRequest handles git/create-tag operation.
//
// Note that creating a tag object does not create the reference that makes a tag in Git. If you want
// to create an annotated tag in Git, you have to do this call to create the tag object, and then
// [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]`
// reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.
// com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/tags
func (s *Server) handleGitCreateTagRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTag",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitCreateTag
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitCreateTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateTagRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateTag",
			OperationID:   "git/create-tag",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateTagReq
			Params   = GitCreateTagParams
			Response = GitCreateTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateTag(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateTag(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitCreateTreeRequest handles git/create-tree operation.
//
// The tree creation API accepts nested entries. If you specify both a tree and a nested path
// modifying that tree, this endpoint will overwrite the contents of the tree with the new path
// contents, and create a new tree structure.
// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to
// commit the tree and then update a branch to point to the commit. For more information see "[Create
// a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
// reference](https://docs.github.com/rest/reference/git#update-a-reference).".
//
// POST /repos/{owner}/{repo}/git/trees
func (s *Server) handleGitCreateTreeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTree",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitCreateTree
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitCreateTreeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitCreateTreeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitCreateTree",
			OperationID:   "git/create-tree",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateTreeReq
			Params   = GitCreateTreeParams
			Response = GitCreateTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTreeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateTree(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateTree(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTreeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitDeleteRefRequest handles git/delete-ref operation.
//
// Delete a reference.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitDeleteRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitDeleteRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitDeleteRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitDeleteRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitDeleteRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitDeleteRef",
			OperationID:   "git/delete-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitDeleteRefParams
			Response = GitDeleteRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitDeleteRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitDeleteRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitDeleteRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitDeleteRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetBlobRequest handles git/get-blob operation.
//
// The `content` in the response will always be Base64 encoded.
// _Note_: This API supports blobs up to 100 megabytes in size.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (s *Server) handleGitGetBlobRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetBlob",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitGetBlob
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitGetBlobParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetBlob",
			OperationID:   "git/get-blob",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "file_sha",
					In:   "path",
				}: params.FileSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetBlobParams
			Response = GitGetBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetBlobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetBlob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetBlob(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetBlobResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetCommitRequest handles git/get-commit operation.
//
// Gets a Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (s *Server) handleGitGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitGetCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitGetCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetCommit",
			OperationID:   "git/get-commit",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetCommitParams
			Response = GitGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetRefRequest handles git/get-ref operation.
//
// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
// `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an
// existing ref, a `404` is returned.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (s *Server) handleGitGetRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitGetRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitGetRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetRef",
			OperationID:   "git/get-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetRefParams
			Response = GitGetRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetTagRequest handles git/get-tag operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (s *Server) handleGitGetTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTag",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitGetTag
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitGetTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetTag",
			OperationID:   "git/get-tag",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tag_sha",
					In:   "path",
				}: params.TagSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTagParams
			Response = GitGetTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetTag(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetTag(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitGetTreeRequest handles git/get-tree operation.
//
// Returns a single tree using the SHA1 value for that tree.
// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our
// maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees,
// and fetch one sub-tree at a time.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (s *Server) handleGitGetTreeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTree",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitGetTree
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitGetTreeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitGetTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitGetTree",
			OperationID:   "git/get-tree",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tree_sha",
					In:   "path",
				}: params.TreeSha,
				{
					Name: "recursive",
					In:   "query",
				}: params.Recursive,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTreeParams
			Response = GitGetTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTreeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetTree(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetTree(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTreeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitListMatchingRefsRequest handles git/list-matching-refs operation.
//
// Returns an array of references from your Git database that match the supplied name. The `:ref` in
// the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If
// the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be
// returned as an array.
// When you use this endpoint without providing a `:ref`, it will return an array of all the
// references from your Git database, including notes and stashes if they exist on the server.
// Anything in the namespace is returned, not just `heads` and `tags`.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// If you request matching references for a branch named `feature` but the branch `feature` doesn't
// exist, the response can still include other matching head refs that start with the word `feature`,
// such as `featureA` and `featureB`.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (s *Server) handleGitListMatchingRefsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitListMatchingRefs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitListMatchingRefs
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitListMatchingRefsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GitListMatchingRefsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitListMatchingRefs",
			OperationID:   "git/list-matching-refs",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitListMatchingRefsParams
			Response = *GitListMatchingRefsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitListMatchingRefsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitListMatchingRefs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitListMatchingRefs(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitUpdateRefRequest handles git/update-ref operation.
//
// Update a reference.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitUpdateRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitUpdateRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitUpdateRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitUpdateRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGitUpdateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitUpdateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitUpdateRef",
			OperationID:   "git/update-ref",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = *GitUpdateRefReq
			Params   = GitUpdateRefParams
			Response = GitUpdateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitUpdateRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitUpdateRef(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitUpdateRef(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitUpdateRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitignoreGetAllTemplatesRequest handles gitignore/get-all-templates operation.
//
// List all templates available to pass as an option when [creating a repository](https://docs.github.
// com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
//
// GET /gitignore/templates
func (s *Server) handleGitignoreGetAllTemplatesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetAllTemplates",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitignoreGetAllTemplates
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response GitignoreGetAllTemplatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitignoreGetAllTemplates",
			OperationID:   "gitignore/get-all-templates",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GitignoreGetAllTemplatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitignoreGetAllTemplates(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitignoreGetAllTemplates(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGitignoreGetTemplateRequest handles gitignore/get-template operation.
//
// The API also allows fetching the source of a single template.
// Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw
// contents.
//
// GET /gitignore/templates/{name}
func (s *Server) handleGitignoreGetTemplateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().GitignoreGetTemplate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeGitignoreGetTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GitignoreGetTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GitignoreGetTemplate",
			OperationID:   "gitignore/get-template",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitignoreGetTemplateParams
			Response = GitignoreGetTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitignoreGetTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitignoreGetTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitignoreGetTemplate(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest handles interactions/remove-restrictions-for-authenticated-user operation.
//
// Removes any interaction restrictions from your public repositories.
//
// DELETE /user/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsRemoveRestrictionsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForAuthenticatedUser",
			OperationID:   "interactions/remove-restrictions-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForOrgRequest handles interactions/remove-restrictions-for-org operation.
//
// Removes all interaction restrictions from public repositories in the given organization. You must
// be an organization owner to remove restrictions.
//
// DELETE /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsRemoveRestrictionsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *InteractionsRemoveRestrictionsForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForOrg",
			OperationID:   "interactions/remove-restrictions-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForOrgParams
			Response = *InteractionsRemoveRestrictionsForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsRemoveRestrictionsForRepoRequest handles interactions/remove-restrictions-for-repo operation.
//
// Removes all interaction restrictions from the given repository. You must have owner or admin
// access to remove restrictions. If the interaction limit is set for the user or organization that
// owns this repository, you will receive a `409 Conflict` response and will not be able to use this
// endpoint to change the interaction limit for a single repository.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsRemoveRestrictionsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response InteractionsRemoveRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsRemoveRestrictionsForRepo",
			OperationID:   "interactions/remove-restrictions-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForRepoParams
			Response = InteractionsRemoveRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForAuthenticatedUserRequest handles interactions/set-restrictions-for-authenticated-user operation.
//
// Temporarily restricts which type of GitHub user can interact with your public repositories.
// Setting the interaction limit at the user level will overwrite any interaction limits that are set
// for individual repositories owned by the user.
//
// PUT /user/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsSetRestrictionsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeInteractionsSetRestrictionsForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForAuthenticatedUser",
			OperationID:   "interactions/set-restrictions-for-authenticated-user",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *InteractionLimit
			Params   = struct{}
			Response = InteractionsSetRestrictionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForOrgRequest handles interactions/set-restrictions-for-org operation.
//
// Temporarily restricts interactions to a certain type of GitHub user in any public repository in
// the given organization. You must be an organization owner to set these restrictions. Setting the
// interaction limit at the organization level will overwrite any interaction limits that are set for
// individual repositories owned by the organization.
//
// PUT /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsSetRestrictionsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeInteractionsSetRestrictionsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeInteractionsSetRestrictionsForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForOrg",
			OperationID:   "interactions/set-restrictions-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *InteractionLimit
			Params   = InteractionsSetRestrictionsForOrgParams
			Response = InteractionsSetRestrictionsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleInteractionsSetRestrictionsForRepoRequest handles interactions/set-restrictions-for-repo operation.
//
// Temporarily restricts interactions to a certain type of GitHub user within the given repository.
// You must have owner or admin access to set these restrictions. If an interaction limit is set for
// the user or organization that owns this repository, you will receive a `409 Conflict` response and
// will not be able to use this endpoint to change the interaction limit for a single repository.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().InteractionsSetRestrictionsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeInteractionsSetRestrictionsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeInteractionsSetRestrictionsForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "InteractionsSetRestrictionsForRepo",
			OperationID:   "interactions/set-restrictions-for-repo",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *InteractionLimit
			Params   = InteractionsSetRestrictionsForRepoParams
			Response = InteractionsSetRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesAddAssigneesRequest handles issues/add-assignees operation.
//
// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesAddAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesAddAssignees",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesAddAssignees
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesAddAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesAddAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesAddAssignees",
			OperationID:   "issues/add-assignees",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesAddAssigneesReq
			Params   = IssuesAddAssigneesParams
			Response = *IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesAddAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesAddAssignees(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesAddAssignees(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCheckUserCanBeAssignedRequest handles issues/check-user-can-be-assigned operation.
//
// Checks if a user has permission to be assigned to an issue in this repository.
// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is
// returned.
// Otherwise a `404` status code is returned.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (s *Server) handleIssuesCheckUserCanBeAssignedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCheckUserCanBeAssigned",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesCheckUserCanBeAssigned
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesCheckUserCanBeAssignedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesCheckUserCanBeAssignedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCheckUserCanBeAssigned",
			OperationID:   "issues/check-user-can-be-assigned",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "assignee",
					In:   "path",
				}: params.Assignee,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesCheckUserCanBeAssignedParams
			Response = IssuesCheckUserCanBeAssignedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCheckUserCanBeAssignedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCheckUserCanBeAssigned(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCheckUserCanBeAssigned(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateRequest handles issues/create operation.
//
// Any user with pull access to a repository can create an issue. If [issues are disabled in the
// repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone`
// status.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesCreate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreate",
			OperationID:   "issues/create",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateReq
			Params   = IssuesCreateParams
			Response = IssuesCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateCommentRequest handles issues/create-comment operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesCreateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesCreateComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesCreateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateComment",
			OperationID:   "issues/create-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateCommentReq
			Params   = IssuesCreateCommentParams
			Response = IssuesCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateLabelRequest handles issues/create-label operation.
//
// Create a label.
//
// POST /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesCreateLabelRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateLabel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesCreateLabel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesCreateLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateLabel",
			OperationID:   "issues/create-label",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateLabelReq
			Params   = IssuesCreateLabelParams
			Response = IssuesCreateLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateLabel(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateLabel(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesCreateMilestoneRequest handles issues/create-milestone operation.
//
// Create a milestone.
//
// POST /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesCreateMilestoneRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateMilestone",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesCreateMilestone
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesCreateMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesCreateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesCreateMilestone",
			OperationID:   "issues/create-milestone",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateMilestoneReq
			Params   = IssuesCreateMilestoneParams
			Response = IssuesCreateMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateMilestone(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateMilestone(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteCommentRequest handles issues/delete-comment operation.
//
// Delete an issue comment.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesDeleteCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesDeleteComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesDeleteCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *IssuesDeleteCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteComment",
			OperationID:   "issues/delete-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteCommentParams
			Response = *IssuesDeleteCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.IssuesDeleteComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.IssuesDeleteComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteLabelRequest handles issues/delete-label operation.
//
// Delete a label.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesDeleteLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteLabel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesDeleteLabel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesDeleteLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *IssuesDeleteLabelNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteLabel",
			OperationID:   "issues/delete-label",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteLabelParams
			Response = *IssuesDeleteLabelNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.IssuesDeleteLabel(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.IssuesDeleteLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesDeleteMilestoneRequest handles issues/delete-milestone operation.
//
// Delete a milestone.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesDeleteMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteMilestone",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesDeleteMilestone
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesDeleteMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesDeleteMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesDeleteMilestone",
			OperationID:   "issues/delete-milestone",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteMilestoneParams
			Response = IssuesDeleteMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesDeleteMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesDeleteMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetRequest handles issues/get operation.
//
// The API returns a [`301 Moved Permanently` status](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
// [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to
// another repository. If
// the issue was transferred to or deleted from a repository where the authenticated user lacks read
// access, the API
// returns a `404 Not Found` status. If the issue was deleted from a repository where the
// authenticated user has read
// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted
// issues, subscribe
// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGet",
			OperationID:   "issues/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetParams
			Response = IssuesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetCommentRequest handles issues/get-comment operation.
//
// Get an issue comment.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesGetCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesGetComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesGetCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetComment",
			OperationID:   "issues/get-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetCommentParams
			Response = IssuesGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetEventRequest handles issues/get-event operation.
//
// Get an issue event.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (s *Server) handleIssuesGetEventRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesGetEvent
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesGetEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetEvent",
			OperationID:   "issues/get-event",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "event_id",
					In:   "path",
				}: params.EventID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetEventParams
			Response = IssuesGetEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetEvent(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetLabelRequest handles issues/get-label operation.
//
// Get a label.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesGetLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetLabel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesGetLabel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesGetLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetLabel",
			OperationID:   "issues/get-label",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetLabelParams
			Response = IssuesGetLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetLabel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesGetMilestoneRequest handles issues/get-milestone operation.
//
// Get a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesGetMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetMilestone",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesGetMilestone
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesGetMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesGetMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesGetMilestone",
			OperationID:   "issues/get-milestone",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetMilestoneParams
			Response = IssuesGetMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListRequest handles issues/list operation.
//
// List issues assigned to the authenticated user across all visible repositories including owned
// repositories, member
// repositories, and organization repositories. You can use the `filter` query parameter to fetch
// issues that are not
// necessarily assigned to you.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /issues
func (s *Server) handleIssuesListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesList",
			OperationID:   "issues/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "collab",
					In:   "query",
				}: params.Collab,
				{
					Name: "orgs",
					In:   "query",
				}: params.Orgs,
				{
					Name: "owned",
					In:   "query",
				}: params.Owned,
				{
					Name: "pulls",
					In:   "query",
				}: params.Pulls,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListParams
			Response = IssuesListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListAssigneesRequest handles issues/list-assignees operation.
//
// Lists the [available assignees](https://help.github.
// com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
//
// GET /repos/{owner}/{repo}/assignees
func (s *Server) handleIssuesListAssigneesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListAssignees",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListAssignees
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListAssigneesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListAssignees",
			OperationID:   "issues/list-assignees",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListAssigneesParams
			Response = IssuesListAssigneesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListAssignees(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListAssignees(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListCommentsRequest handles issues/list-comments operation.
//
// Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesListCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListComments",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListComments
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListComments",
			OperationID:   "issues/list-comments",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsParams
			Response = IssuesListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListCommentsForRepoRequest handles issues/list-comments-for-repo operation.
//
// By default, Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/comments
func (s *Server) handleIssuesListCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListCommentsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListCommentsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListCommentsForRepo",
			OperationID:   "issues/list-comments-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsForRepoParams
			Response = IssuesListCommentsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListEventsForRepoRequest handles issues/list-events-for-repo operation.
//
// List issue events for a repository.
//
// GET /repos/{owner}/{repo}/issues/events
func (s *Server) handleIssuesListEventsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListEventsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListEventsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListEventsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListEventsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListEventsForRepo",
			OperationID:   "issues/list-events-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListEventsForRepoParams
			Response = IssuesListEventsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListEventsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListEventsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListEventsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListEventsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForAuthenticatedUserRequest handles issues/list-for-authenticated-user operation.
//
// List issues across owned and member repositories assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /user/issues
func (s *Server) handleIssuesListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForAuthenticatedUser",
			OperationID:   "issues/list-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForAuthenticatedUserParams
			Response = IssuesListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForOrgRequest handles issues/list-for-org operation.
//
// List issues in an organization assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /orgs/{org}/issues
func (s *Server) handleIssuesListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForOrg",
			OperationID:   "issues/list-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForOrgParams
			Response = IssuesListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListForRepoRequest handles issues/list-for-repo operation.
//
// List issues in a repository.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListForRepo",
			OperationID:   "issues/list-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone",
					In:   "query",
				}: params.Milestone,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "assignee",
					In:   "query",
				}: params.Assignee,
				{
					Name: "creator",
					In:   "query",
				}: params.Creator,
				{
					Name: "mentioned",
					In:   "query",
				}: params.Mentioned,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForRepoParams
			Response = IssuesListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsForMilestoneRequest handles issues/list-labels-for-milestone operation.
//
// List labels for issues in a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (s *Server) handleIssuesListLabelsForMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForMilestone",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListLabelsForMilestone
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListLabelsForMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *IssuesListLabelsForMilestoneOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsForMilestone",
			OperationID:   "issues/list-labels-for-milestone",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForMilestoneParams
			Response = *IssuesListLabelsForMilestoneOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsForMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForMilestone(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsForRepoRequest handles issues/list-labels-for-repo operation.
//
// List labels for a repository.
//
// GET /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesListLabelsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListLabelsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListLabelsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListLabelsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsForRepo",
			OperationID:   "issues/list-labels-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForRepoParams
			Response = IssuesListLabelsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListLabelsOnIssueRequest handles issues/list-labels-on-issue operation.
//
// List labels for an issue.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesListLabelsOnIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsOnIssue",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListLabelsOnIssue
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListLabelsOnIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListLabelsOnIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListLabelsOnIssue",
			OperationID:   "issues/list-labels-on-issue",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsOnIssueParams
			Response = IssuesListLabelsOnIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsOnIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsOnIssue(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsOnIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesListMilestonesRequest handles issues/list-milestones operation.
//
// List milestones.
//
// GET /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesListMilestonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListMilestones",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesListMilestones
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesListMilestonesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesListMilestonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesListMilestones",
			OperationID:   "issues/list-milestones",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListMilestonesParams
			Response = IssuesListMilestonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListMilestonesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListMilestones(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListMilestones(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesLockRequest handles issues/lock operation.
//
// Users with push access can lock an issue or pull request's conversation.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesLockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesLock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesLock
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesLockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesLockRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesLockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesLock",
			OperationID:   "issues/lock",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilIssuesLockReq
			Params   = IssuesLockParams
			Response = IssuesLockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesLockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesLock(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesLock(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesLockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveAllLabelsRequest handles issues/remove-all-labels operation.
//
// Remove all labels from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesRemoveAllLabelsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAllLabels",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesRemoveAllLabels
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesRemoveAllLabelsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesRemoveAllLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveAllLabels",
			OperationID:   "issues/remove-all-labels",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveAllLabelsParams
			Response = IssuesRemoveAllLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAllLabelsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveAllLabels(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAllLabels(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveAssigneesRequest handles issues/remove-assignees operation.
//
// Removes one or more assignees from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesRemoveAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAssignees",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesRemoveAssignees
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesRemoveAssigneesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesRemoveAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveAssignees",
			OperationID:   "issues/remove-assignees",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesRemoveAssigneesReq
			Params   = IssuesRemoveAssigneesParams
			Response = *IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveAssignees(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAssignees(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesRemoveLabelRequest handles issues/remove-label operation.
//
// Removes the specified label from the issue, and returns the remaining labels on the issue. This
// endpoint returns a `404 Not Found` status if the label does not exist.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (s *Server) handleIssuesRemoveLabelRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveLabel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesRemoveLabel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesRemoveLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesRemoveLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesRemoveLabel",
			OperationID:   "issues/remove-label",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveLabelParams
			Response = IssuesRemoveLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveLabel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveLabel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUnlockRequest handles issues/unlock operation.
//
// Users with push access can unlock an issue's conversation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesUnlockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUnlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesUnlock
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesUnlockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response IssuesUnlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUnlock",
			OperationID:   "issues/unlock",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesUnlockParams
			Response = IssuesUnlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUnlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUnlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUnlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateRequest handles issues/update operation.
//
// Issue owners and users with push access can edit an issue.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesUpdate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdate",
			OperationID:   "issues/update",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateReq
			Params   = IssuesUpdateParams
			Response = IssuesUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateCommentRequest handles issues/update-comment operation.
//
// Update an issue comment.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesUpdateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesUpdateComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesUpdateCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateComment",
			OperationID:   "issues/update-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesUpdateCommentReq
			Params   = IssuesUpdateCommentParams
			Response = IssuesUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateLabelRequest handles issues/update-label operation.
//
// Update a label.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesUpdateLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateLabel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesUpdateLabel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesUpdateLabelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Label
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateLabel",
			OperationID:   "issues/update-label",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateLabelReq
			Params   = IssuesUpdateLabelParams
			Response = *Label
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateLabel(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateLabel(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleIssuesUpdateMilestoneRequest handles issues/update-milestone operation.
//
// Update a milestone.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesUpdateMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateMilestone",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().IssuesUpdateMilestone
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeIssuesUpdateMilestoneParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeIssuesUpdateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Milestone
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "IssuesUpdateMilestone",
			OperationID:   "issues/update-milestone",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateMilestoneReq
			Params   = IssuesUpdateMilestoneParams
			Response = *Milestone
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateMilestone(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateMilestone(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetRequest handles licenses/get operation.
//
// Get a license.
//
// GET /licenses/{license}
func (s *Server) handleLicensesGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().LicensesGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeLicensesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicensesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGet",
			OperationID:   "licenses/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "license",
					In:   "path",
				}: params.License,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetParams
			Response = LicensesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetAllCommonlyUsedRequest handles licenses/get-all-commonly-used operation.
//
// Get all commonly used licenses.
//
// GET /licenses
func (s *Server) handleLicensesGetAllCommonlyUsedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetAllCommonlyUsed",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().LicensesGetAllCommonlyUsed
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeLicensesGetAllCommonlyUsedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicensesGetAllCommonlyUsedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGetAllCommonlyUsed",
			OperationID:   "licenses/get-all-commonly-used",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "featured",
					In:   "query",
				}: params.Featured,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetAllCommonlyUsedParams
			Response = LicensesGetAllCommonlyUsedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetAllCommonlyUsedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGetAllCommonlyUsed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGetAllCommonlyUsed(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleLicensesGetForRepoRequest handles licenses/get-for-repo operation.
//
// This method returns the contents of the repository's license file, if one is detected.
// Similar to [Get repository content](https://docs.github.
// com/rest/reference/repos#get-repository-content), this method also supports [custom media
// types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content
// or rendered license HTML.
//
// GET /repos/{owner}/{repo}/license
func (s *Server) handleLicensesGetForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().LicensesGetForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeLicensesGetForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *LicenseContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "LicensesGetForRepo",
			OperationID:   "licenses/get-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetForRepoParams
			Response = *LicenseContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGetForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGetForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMarkdownRenderRequest handles markdown/render operation.
//
// Render a Markdown document.
//
// POST /markdown
func (s *Server) handleMarkdownRenderRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MarkdownRender",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MarkdownRender
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeMarkdownRenderRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MarkdownRenderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MarkdownRender",
			OperationID:   "markdown/render",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *MarkdownRenderReq
			Params   = struct{}
			Response = MarkdownRenderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MarkdownRender(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MarkdownRender(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMarkdownRenderResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMarkdownRenderRawRequest handles markdown/render-raw operation.
//
// You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or
// `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored
// Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain
// format like a README.md file. Markdown content must be 400 KB or less.
//
// POST /markdown/raw
func (s *Server) handleMarkdownRenderRawRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render-raw"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MarkdownRenderRaw",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MarkdownRenderRaw
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeMarkdownRenderRawRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MarkdownRenderRawRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MarkdownRenderRaw",
			OperationID:   "markdown/render-raw",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = MarkdownRenderRawReq
			Params   = struct{}
			Response = MarkdownRenderRawRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MarkdownRenderRaw(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MarkdownRenderRaw(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMarkdownRenderRawResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaGetRequest handles meta/get operation.
//
// Returns meta information about GitHub, including a list of GitHub's IP addresses. For more
// information, see "[About GitHub's IP addresses](https://help.github.
// com/articles/about-github-s-ip-addresses/)."
// **Note:** The IP addresses shown in the documentation's response are only example values. You must
// always query the API directly to get the latest list of IP addresses.
//
// GET /meta
func (s *Server) handleMetaGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MetaGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response MetaGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaGet",
			OperationID:   "meta/get",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaGetOctocatRequest handles meta/get-octocat operation.
//
// Get the octocat as ASCII art.
//
// GET /octocat
func (s *Server) handleMetaGetOctocatRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-octocat"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGetOctocat",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MetaGetOctocat
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMetaGetOctocatParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MetaGetOctocatOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaGetOctocat",
			OperationID:   "meta/get-octocat",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "s",
					In:   "query",
				}: params.S,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MetaGetOctocatParams
			Response = MetaGetOctocatOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMetaGetOctocatParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGetOctocat(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGetOctocat(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetOctocatResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaGetZenRequest handles meta/get-zen operation.
//
// Get a random sentence from the Zen of GitHub.
//
// GET /zen
func (s *Server) handleMetaGetZenRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-zen"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGetZen",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MetaGetZen
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response MetaGetZenOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaGetZen",
			OperationID:   "meta/get-zen",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetZenOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGetZen(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGetZen(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetZenResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMetaRootRequest handles meta/root operation.
//
// Get Hypermedia links to resources accessible in GitHub's REST API.
//
// GET /
func (s *Server) handleMetaRootRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaRoot",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MetaRoot
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *MetaRootOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MetaRoot",
			OperationID:   "meta/root",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *MetaRootOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaRoot(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaRoot(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaRootResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsCancelImportRequest handles migrations/cancel-import operation.
//
// Stop an import for a repository.
//
// DELETE /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsCancelImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsCancelImport",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsCancelImport
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsCancelImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *MigrationsCancelImportNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsCancelImport",
			OperationID:   "migrations/cancel-import",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsCancelImportParams
			Response = *MigrationsCancelImportNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsCancelImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.MigrationsCancelImport(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.MigrationsCancelImport(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDeleteArchiveForAuthenticatedUserRequest handles migrations/delete-archive-for-authenticated-user operation.
//
// Deletes a previous migration archive. Downloadable migration archives are automatically deleted
// after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.
// github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration
// status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints,
// will continue to be available even after an archive is deleted.
//
// DELETE /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsDeleteArchiveForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDeleteArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDeleteArchiveForAuthenticatedUser",
			OperationID:   "migrations/delete-archive-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForAuthenticatedUserParams
			Response = MigrationsDeleteArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDeleteArchiveForOrgRequest handles migrations/delete-archive-for-org operation.
//
// Deletes a previous migration archive. Migration archives are automatically deleted after seven
// days.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsDeleteArchiveForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsDeleteArchiveForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDeleteArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDeleteArchiveForOrg",
			OperationID:   "migrations/delete-archive-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForOrgParams
			Response = MigrationsDeleteArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDeleteArchiveForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsDownloadArchiveForOrgRequest handles migrations/download-archive-for-org operation.
//
// Fetches the URL to a migration archive.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDownloadArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDownloadArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsDownloadArchiveForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsDownloadArchiveForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsDownloadArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsDownloadArchiveForOrg",
			OperationID:   "migrations/download-archive-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDownloadArchiveForOrgParams
			Response = MigrationsDownloadArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDownloadArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDownloadArchiveForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDownloadArchiveForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetArchiveForAuthenticatedUserRequest handles migrations/get-archive-for-authenticated-user operation.
//
// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources
// your repository uses, the migration archive can contain JSON files with data for these objects:
// *   attachments
// *   bases
// *   commit\_comments
// *   issue\_comments
// *   issue\_events
// *   issues
// *   milestones
// *   organizations
// *   projects
// *   protected\_branches
// *   pull\_request\_reviews
// *   pull\_requests
// *   releases
// *   repositories
// *   review\_comments
// *   schema
// *   users
// The archive will also contain an `attachments` directory that includes all attachment files
// uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
//
// GET /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsGetArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetArchiveForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetArchiveForAuthenticatedUser",
			OperationID:   "migrations/get-archive-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetArchiveForAuthenticatedUserParams
			Response = MigrationsGetArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetCommitAuthorsRequest handles migrations/get-commit-authors operation.
//
// Each type of source control system represents authors in a different way. For example, a Git
// commit author has a display name and an email address, but a Subversion commit author just has a
// username. The GitHub Importer will make the author information valid, but the author might not be
// correct. For example, it will change the bare Subversion username `hubot` into something like
// `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
// This endpoint and the [Map a commit author](https://docs.github.
// com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git
// author information.
//
// GET /repos/{owner}/{repo}/import/authors
func (s *Server) handleMigrationsGetCommitAuthorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetCommitAuthors",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetCommitAuthors
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetCommitAuthorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetCommitAuthorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetCommitAuthors",
			OperationID:   "migrations/get-commit-authors",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetCommitAuthorsParams
			Response = MigrationsGetCommitAuthorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetCommitAuthorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetCommitAuthors(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetCommitAuthors(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetImportStatusRequest handles migrations/get-import-status operation.
//
// View the progress of an import.
// **Import status**
// This section includes details about the possible values of the `status` field of the Import
// Progress response.
// An import that does not have errors will progress through these steps:
// *   `detecting` - the "detection" step of the import is in progress because the request did not
// include a `vcs` parameter. The import is identifying the type of source control present at the URL.
// *   `importing` - the "raw" step of the import is in progress. This is where commit data is
// fetched from the original repository. The import progress response will include `commit_count`
// (the total number of raw commits that will be imported) and `percent` (0 - 100, the current
// progress through the import).
// *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are
// converted to Git branches, and where author updates are applied. The import progress response does
// not include progress information.
// *   `pushing` - the "push" step of the import is in progress. This is where the importer updates
// the repository on GitHub. The import progress response will include `push_percent`, which is the
// percent value reported by `git push` when it is "Writing objects".
// *   `complete` - the import is complete, and the repository is ready on GitHub.
// If there are problems, you will see one of these in the `status` field:
// *   `auth_failed` - the import requires authentication in order to connect to the original
// repository. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `error` - the import encountered an error. The import progress response will include the
// `failed_step` and an error message. Contact [GitHub Support](https://support.github.
// com/contact?tags=dotcom-rest-api) for more information.
// *   `detection_needs_auth` - the importer requires authentication for the originating repository
// to continue detection. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
// resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import)
// and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
// URL.
// *   `detection_found_multiple` - the importer found several projects or repositories at the
// provided URL. When this is the case, the Import Progress response will also include a
// `project_choices` field with the possible project choices as values. To update project choice,
// please see the [Update an import](https://docs.github.
// com/rest/reference/migrations#update-an-import) section.
// **The project_choices field**
// When multiple projects are found at the provided URL, the response hash will include a
// `project_choices` field, the value of which is an array of hashes each representing a project
// choice. The exact key/value pairs of the project hashes will differ depending on the version
// control type.
// **Git LFS related fields**
// This section includes details about Git LFS related fields that may be present in the Import
// Progress response.
// *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
// can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
// *   `has_large_files` - the boolean value describing whether files larger than 100MB were found
// during the `importing` step.
// *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the
// originating repository.
// *   `large_files_count` - the total number of files larger than 100MB found in the originating
// repository. To see a list of these files, make a "Get Large Files" request.
//
// GET /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsGetImportStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetImportStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetImportStatus
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetImportStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetImportStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetImportStatus",
			OperationID:   "migrations/get-import-status",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetImportStatusParams
			Response = MigrationsGetImportStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetImportStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetImportStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetImportStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetLargeFilesRequest handles migrations/get-large-files operation.
//
// List files larger than 100MB found during the import.
//
// GET /repos/{owner}/{repo}/import/large_files
func (s *Server) handleMigrationsGetLargeFilesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetLargeFiles",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetLargeFiles
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetLargeFilesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []PorterLargeFile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetLargeFiles",
			OperationID:   "migrations/get-large-files",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetLargeFilesParams
			Response = []PorterLargeFile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetLargeFilesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetLargeFiles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetLargeFiles(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetStatusForAuthenticatedUserRequest handles migrations/get-status-for-authenticated-user operation.
//
// Fetches a single user migration. The response includes the `state` of the migration, which can be
// one of the following values:
// *   `pending` - the migration hasn't started yet.
// *   `exporting` - the migration is in progress.
// *   `exported` - the migration finished successfully.
// *   `failed` - the migration failed.
// Once the migration has been `exported` you can [download the migration archive](https://docs.
// github.com/rest/reference/migrations#download-a-user-migration-archive).
//
// GET /user/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetStatusForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetStatusForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetStatusForAuthenticatedUser",
			OperationID:   "migrations/get-status-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForAuthenticatedUserParams
			Response = MigrationsGetStatusForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsGetStatusForOrgRequest handles migrations/get-status-for-org operation.
//
// Fetches the status of a migration.
// The `state` of a migration can be one of the following values:
// *   `pending`, which means the migration hasn't started yet.
// *   `exporting`, which means the migration is in progress.
// *   `exported`, which means the migration finished successfully.
// *   `failed`, which means the migration failed.
//
// GET /orgs/{org}/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsGetStatusForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsGetStatusForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsGetStatusForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsGetStatusForOrg",
			OperationID:   "migrations/get-status-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForOrgParams
			Response = MigrationsGetStatusForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetStatusForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListForAuthenticatedUserRequest handles migrations/list-for-authenticated-user operation.
//
// Lists all migrations a user has started.
//
// GET /user/migrations
func (s *Server) handleMigrationsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsListForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListForAuthenticatedUser",
			OperationID:   "migrations/list-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForAuthenticatedUserParams
			Response = MigrationsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListForOrgRequest handles migrations/list-for-org operation.
//
// Lists the most recent migrations.
//
// GET /orgs/{org}/migrations
func (s *Server) handleMigrationsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsListForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *MigrationsListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListForOrg",
			OperationID:   "migrations/list-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForOrgParams
			Response = *MigrationsListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListReposForOrgRequest handles migrations/list-repos-for-org operation.
//
// List all the repositories for this organization migration.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsListReposForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsListReposForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListReposForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListReposForOrg",
			OperationID:   "migrations/list-repos-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForOrgParams
			Response = MigrationsListReposForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListReposForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsListReposForUserRequest handles migrations/list-repos-for-user operation.
//
// Lists all the repositories for this user migration.
//
// GET /user/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsListReposForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsListReposForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsListReposForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsListReposForUser",
			OperationID:   "migrations/list-repos-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForUserParams
			Response = MigrationsListReposForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListReposForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsMapCommitAuthorRequest handles migrations/map-commit-author operation.
//
// Update an author's identity for the import. Your application can continue updating authors any
// time before you push new commits to the repository.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (s *Server) handleMigrationsMapCommitAuthorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsMapCommitAuthor",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsMapCommitAuthor
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsMapCommitAuthorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsMapCommitAuthorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsMapCommitAuthorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsMapCommitAuthor",
			OperationID:   "migrations/map-commit-author",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "author_id",
					In:   "path",
				}: params.AuthorID,
			},
			Raw: r,
		}

		type (
			Request  = OptMigrationsMapCommitAuthorReq
			Params   = MigrationsMapCommitAuthorParams
			Response = MigrationsMapCommitAuthorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsMapCommitAuthorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsMapCommitAuthor(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsMapCommitAuthor(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsMapCommitAuthorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsSetLfsPreferenceRequest handles migrations/set-lfs-preference operation.
//
// You can import repositories from Subversion, Mercurial, and TFS that include files larger than
// 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about
// our LFS feature and working with large files [on our help site](https://help.github.
// com/articles/versioning-large-files/).
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (s *Server) handleMigrationsSetLfsPreferenceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsSetLfsPreference",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsSetLfsPreference
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsSetLfsPreferenceParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsSetLfsPreferenceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsSetLfsPreferenceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsSetLfsPreference",
			OperationID:   "migrations/set-lfs-preference",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsSetLfsPreferenceReq
			Params   = MigrationsSetLfsPreferenceParams
			Response = MigrationsSetLfsPreferenceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsSetLfsPreferenceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsSetLfsPreference(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsSetLfsPreference(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsSetLfsPreferenceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartForAuthenticatedUserRequest handles migrations/start-for-authenticated-user operation.
//
// Initiates the generation of a user migration archive.
//
// POST /user/migrations
func (s *Server) handleMigrationsStartForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsStartForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeMigrationsStartForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartForAuthenticatedUser",
			OperationID:   "migrations/start-for-authenticated-user",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *MigrationsStartForAuthenticatedUserReq
			Params   = struct{}
			Response = MigrationsStartForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartForOrgRequest handles migrations/start-for-org operation.
//
// Initiates the generation of a migration archive.
//
// POST /orgs/{org}/migrations
func (s *Server) handleMigrationsStartForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsStartForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsStartForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsStartForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartForOrg",
			OperationID:   "migrations/start-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsStartForOrgReq
			Params   = MigrationsStartForOrgParams
			Response = MigrationsStartForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsStartImportRequest handles migrations/start-import operation.
//
// Start a source import to a GitHub repository using GitHub Importer.
//
// PUT /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsStartImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartImport",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsStartImport
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsStartImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsStartImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartImportRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsStartImport",
			OperationID:   "migrations/start-import",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsStartImportReq
			Params   = MigrationsStartImportParams
			Response = MigrationsStartImportRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartImport(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartImport(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUnlockRepoForAuthenticatedUserRequest handles migrations/unlock-repo-for-authenticated-user operation.
//
// Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.
// github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you
// can unlock each repository to begin using it again or [delete the repository](https://docs.github.
// com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a
// status of `404 Not Found` if the repository is not locked.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsUnlockRepoForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsUnlockRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUnlockRepoForAuthenticatedUser",
			OperationID:   "migrations/unlock-repo-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "repo_name",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForAuthenticatedUserParams
			Response = MigrationsUnlockRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUnlockRepoForOrgRequest handles migrations/unlock-repo-for-org operation.
//
// Unlocks a repository that was locked for migration. You should unlock each migrated repository and
// [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration
// is complete and you no longer need the source data.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsUnlockRepoForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsUnlockRepoForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response MigrationsUnlockRepoForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUnlockRepoForOrg",
			OperationID:   "migrations/unlock-repo-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "repo_name",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForOrgParams
			Response = MigrationsUnlockRepoForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUnlockRepoForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleMigrationsUpdateImportRequest handles migrations/update-import operation.
//
// An import can be updated with credentials or a project choice by passing in the appropriate
// parameters in this API
// request. If no parameters are provided, the import will be restarted.
//
// PATCH /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsUpdateImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUpdateImport",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().MigrationsUpdateImport
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeMigrationsUpdateImportParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeMigrationsUpdateImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Import
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "MigrationsUpdateImport",
			OperationID:   "migrations/update-import",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilMigrationsUpdateImportReq
			Params   = MigrationsUpdateImportParams
			Response = *Import
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUpdateImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUpdateImport(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUpdateImport(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsCreateAuthorizationRequest handles oauth-authorizations/create-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates OAuth tokens using [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor
// authentication setup, Basic Authentication for this endpoint requires that you use a one-time
// password (OTP) and your username and password instead of tokens. For more information, see
// "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// To create tokens for a particular OAuth application using this endpoint, you must authenticate as
// the user you want to create an authorization for and provide the app's client ID and secret, found
// on your OAuth application's settings page. If your OAuth application intends to create multiple
// tokens for one user, use `fingerprint` to differentiate between them.
// You can also create tokens on GitHub from the [personal access tokens settings](https://github.
// com/settings/tokens) page. Read more about these tokens in [the GitHub Help
// documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about
// allowing tokens in [the GitHub Help documentation](https://help.github.
// com/articles/about-identity-and-access-management-with-saml-single-sign-on).
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /authorizations
func (s *Server) handleOAuthAuthorizationsCreateAuthorizationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsCreateAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsCreateAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeOAuthAuthorizationsCreateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsCreateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsCreateAuthorization",
			OperationID:   "oauth-authorizations/create-authorization",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptOAuthAuthorizationsCreateAuthorizationReq
			Params   = struct{}
			Response = OAuthAuthorizationsCreateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsCreateAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsDeleteAuthorizationRequest handles oauth-authorizations/delete-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsDeleteAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsDeleteAuthorization",
			OperationID:   "oauth-authorizations/delete-authorization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteAuthorizationParams
			Response = OAuthAuthorizationsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsDeleteGrantRequest handles oauth-authorizations/delete-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for your user. Once deleted, the application has no access to your account and is no
// longer listed on [the application authorizations settings screen within GitHub](https://github.
// com/settings/applications#authorized).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsDeleteGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteGrant",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsDeleteGrant
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteGrantParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsDeleteGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsDeleteGrant",
			OperationID:   "oauth-authorizations/delete-grant",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "grant_id",
					In:   "path",
				}: params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteGrantParams
			Response = OAuthAuthorizationsDeleteGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteGrantParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetAuthorizationRequest handles oauth-authorizations/get-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsGetAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsGetAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsGetAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsGetAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetAuthorization",
			OperationID:   "oauth-authorizations/get-authorization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetAuthorizationParams
			Response = OAuthAuthorizationsGetAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetGrantRequest handles oauth-authorizations/get-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsGetGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetGrant",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsGetGrant
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsGetGrantParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsGetGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetGrant",
			OperationID:   "oauth-authorizations/get-grant",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "grant_id",
					In:   "path",
				}: params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetGrantParams
			Response = OAuthAuthorizationsGetGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetGrantParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetGrant(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetGrant(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest handles oauth-authorizations/get-or-create-authorization-for-app operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates a new authorization for the specified OAuth application, only if an authorization for that
// application doesn't already exist for the user. The URL includes the 20 character client ID for
// the OAuth app that is requesting the token. It returns the user's existing authorization for the
// application if one is present. Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsGetOrCreateAuthorizationForApp
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
			OperationID:   "oauth-authorizations/get-or-create-authorization-for-app",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest handles oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// This method will create a new authorization for the specified OAuth application, only if an
// authorization for that application and fingerprint do not already exist for the user. The URL
// includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint`
// is a unique string to distinguish an authorization from others created for the same client ID and
// user. It returns the user's existing authorization for the application if one is present.
// Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
			OperationID:   "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
				{
					Name: "fingerprint",
					In:   "path",
				}: params.Fingerprint,
			},
			Raw: r,
		}

		type (
			Request  = *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsListAuthorizationsRequest handles oauth-authorizations/list-authorizations operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations
func (s *Server) handleOAuthAuthorizationsListAuthorizationsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListAuthorizations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsListAuthorizations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsListAuthorizationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsListAuthorizationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsListAuthorizations",
			OperationID:   "oauth-authorizations/list-authorizations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "client_id",
					In:   "query",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListAuthorizationsParams
			Response = OAuthAuthorizationsListAuthorizationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsListGrantsRequest handles oauth-authorizations/list-grants operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// You can use this API to list the set of OAuth applications that have been granted access to your
// account. Unlike the [list your authorizations](https://docs.github.
// com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage
// individual tokens. This API will return one entry for each OAuth application that has been granted
// access to your account, regardless of the number of tokens an application has generated for your
// user. The list of OAuth applications returned matches what is shown on [the application
// authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
//
//	The `scopes` returned are the union of scopes authorized for the application. For example, if an
//
// application has one token with `repo` scope and another token with `user` scope, the grant will
// return `["repo", "user"]`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants
func (s *Server) handleOAuthAuthorizationsListGrantsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListGrants",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsListGrants
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsListGrantsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OAuthAuthorizationsListGrantsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsListGrants",
			OperationID:   "oauth-authorizations/list-grants",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "client_id",
					In:   "query",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListGrantsParams
			Response = OAuthAuthorizationsListGrantsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListGrantsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsListGrants(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListGrants(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOAuthAuthorizationsUpdateAuthorizationRequest handles oauth-authorizations/update-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// You can only send one of these scope keys at a time.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsUpdateAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsUpdateAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OAuthAuthorizationsUpdateAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOAuthAuthorizationsUpdateAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOAuthAuthorizationsUpdateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsUpdateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OAuthAuthorizationsUpdateAuthorization",
			OperationID:   "oauth-authorizations/update-authorization",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = OptOAuthAuthorizationsUpdateAuthorizationReq
			Params   = OAuthAuthorizationsUpdateAuthorizationParams
			Response = OAuthAuthorizationsUpdateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsUpdateAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsUpdateAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsBlockUserRequest handles orgs/block-user operation.
//
// Block a user from an organization.
//
// PUT /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsBlockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsBlockUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsBlockUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsBlockUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsBlockUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsBlockUser",
			OperationID:   "orgs/block-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsBlockUserParams
			Response = OrgsBlockUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsBlockUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsBlockUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsBlockUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsBlockUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCancelInvitationRequest handles orgs/cancel-invitation operation.
//
// Cancel an organization invitation. In order to cancel an organization invitation, the
// authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (s *Server) handleOrgsCancelInvitationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCancelInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCancelInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCancelInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCancelInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCancelInvitation",
			OperationID:   "orgs/cancel-invitation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCancelInvitationParams
			Response = OrgsCancelInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCancelInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCancelInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCancelInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCancelInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckBlockedUserRequest handles orgs/check-blocked-user operation.
//
// Check if a user is blocked by an organization.
//
// GET /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsCheckBlockedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckBlockedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCheckBlockedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCheckBlockedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckBlockedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckBlockedUser",
			OperationID:   "orgs/check-blocked-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckBlockedUserParams
			Response = OrgsCheckBlockedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckBlockedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckBlockedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckBlockedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckMembershipForUserRequest handles orgs/check-membership-for-user operation.
//
// Check if a user is, publicly or privately, a member of the organization.
//
// GET /orgs/{org}/members/{username}
func (s *Server) handleOrgsCheckMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCheckMembershipForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCheckMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckMembershipForUser",
			OperationID:   "orgs/check-membership-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckMembershipForUserParams
			Response = OrgsCheckMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCheckPublicMembershipForUserRequest handles orgs/check-public-membership-for-user operation.
//
// Check public organization membership for a user.
//
// GET /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsCheckPublicMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckPublicMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCheckPublicMembershipForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCheckPublicMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsCheckPublicMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCheckPublicMembershipForUser",
			OperationID:   "orgs/check-public-membership-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckPublicMembershipForUserParams
			Response = OrgsCheckPublicMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckPublicMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckPublicMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckPublicMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsConvertMemberToOutsideCollaboratorRequest handles orgs/convert-member-to-outside-collaborator operation.
//
// When an organization member is converted to an outside collaborator, they'll only have access to
// the repositories that their current team membership allows. The user will no longer be a member of
// the organization. For more information, see "[Converting an organization member to an outside
// collaborator](https://help.github.
// com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsConvertMemberToOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsConvertMemberToOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsConvertMemberToOutsideCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsConvertMemberToOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsConvertMemberToOutsideCollaborator",
			OperationID:   "orgs/convert-member-to-outside-collaborator",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsConvertMemberToOutsideCollaboratorParams
			Response = OrgsConvertMemberToOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsConvertMemberToOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCreateInvitationRequest handles orgs/create-invitation operation.
//
// Invite people to an organization by using their GitHub user ID or their email address. In order to
// create invitations in an organization, the authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /orgs/{org}/invitations
func (s *Server) handleOrgsCreateInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCreateInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCreateInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsCreateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCreateInvitation",
			OperationID:   "orgs/create-invitation",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsCreateInvitationReq
			Params   = OrgsCreateInvitationParams
			Response = OrgsCreateInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCreateInvitation(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCreateInvitation(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsCreateWebhookRequest handles orgs/create-webhook operation.
//
// Here's how you can create a hook that posts payloads in JSON format:.
//
// POST /orgs/{org}/hooks
func (s *Server) handleOrgsCreateWebhookRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsCreateWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsCreateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsCreateWebhook",
			OperationID:   "orgs/create-webhook",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *OrgsCreateWebhookReq
			Params   = OrgsCreateWebhookParams
			Response = OrgsCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCreateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCreateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsDeleteWebhookRequest handles orgs/delete-webhook operation.
//
// Delete an organization webhook.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsDeleteWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsDeleteWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsDeleteWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsDeleteWebhook",
			OperationID:   "orgs/delete-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsDeleteWebhookParams
			Response = OrgsDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsDeleteWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsDeleteWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetRequest handles orgs/get operation.
//
// To see many of the organization response values, you need to be an authenticated organization
// owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
// the organization requires all members, billing managers, and outside collaborators to enable
// [two-factor authentication](https://help.github.
// com/articles/securing-your-account-with-two-factor-authentication-2fa/).
// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
// about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example
// response, see 'Response with GitHub plan information' below.".
//
// GET /orgs/{org}
func (s *Server) handleOrgsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGet",
			OperationID:   "orgs/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetParams
			Response = OrgsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetAuditLogRequest handles orgs/get-audit-log operation.
//
// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for
// your organization](https://docs.github.
// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
// To use this endpoint, you must be an organization owner, and you must use an access token with the
// `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use
// this endpoint.
//
// GET /orgs/{org}/audit-log
func (s *Server) handleOrgsGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetAuditLog
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetAuditLogParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetAuditLog",
			OperationID:   "orgs/get-audit-log",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "phrase",
					In:   "query",
				}: params.Phrase,
				{
					Name: "include",
					In:   "query",
				}: params.Include,
				{
					Name: "after",
					In:   "query",
				}: params.After,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetAuditLog(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetAuditLog(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetMembershipForAuthenticatedUserRequest handles orgs/get-membership-for-authenticated-user operation.
//
// Get an organization membership for the authenticated user.
//
// GET /user/memberships/orgs/{org}
func (s *Server) handleOrgsGetMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetMembershipForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetMembershipForAuthenticatedUser",
			OperationID:   "orgs/get-membership-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForAuthenticatedUserParams
			Response = OrgsGetMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetMembershipForUserRequest handles orgs/get-membership-for-user operation.
//
// In order to get a user's membership with an organization, the authenticated user must be an
// organization member. The `state` parameter in the response can be used to identify the user's
// membership status.
//
// GET /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsGetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetMembershipForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetMembershipForUser",
			OperationID:   "orgs/get-membership-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForUserParams
			Response = OrgsGetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookRequest handles orgs/get-webhook operation.
//
// Returns a webhook configured in an organization. To get only the webhook `config` properties, see
// "[Get a webhook configuration for an
// organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization).".
//
// GET /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsGetWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhook",
			OperationID:   "orgs/get-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookParams
			Response = OrgsGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookConfigForOrgRequest handles orgs/get-webhook-config-for-org operation.
//
// Returns the webhook configuration for an organization. To get more information about the webhook,
// including the `active` state and `events`, use "[Get an organization webhook
// ](/rest/reference/orgs#get-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:read` permission.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsGetWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetWebhookConfigForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetWebhookConfigForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhookConfigForOrg",
			OperationID:   "orgs/get-webhook-config-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookConfigForOrgParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhookConfigForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookConfigForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsGetWebhookDeliveryRequest handles orgs/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleOrgsGetWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsGetWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsGetWebhookDelivery",
			OperationID:   "orgs/get-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookDeliveryParams
			Response = OrgsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListRequest handles orgs/list operation.
//
// Lists all organizations, in the order that they were created on GitHub.
// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of organizations.
//
// GET /organizations
func (s *Server) handleOrgsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsList",
			OperationID:   "orgs/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListParams
			Response = OrgsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListBlockedUsersRequest handles orgs/list-blocked-users operation.
//
// List the users blocked by an organization.
//
// GET /orgs/{org}/blocks
func (s *Server) handleOrgsListBlockedUsersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListBlockedUsers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListBlockedUsers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListBlockedUsersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListBlockedUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListBlockedUsers",
			OperationID:   "orgs/list-blocked-users",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListBlockedUsersParams
			Response = OrgsListBlockedUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListBlockedUsersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListBlockedUsers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListBlockedUsers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListFailedInvitationsRequest handles orgs/list-failed-invitations operation.
//
// The return hash contains `failed_at` and `failed_reason` fields which represent the time at which
// the invitation failed and the reason for the failure.
//
// GET /orgs/{org}/failed_invitations
func (s *Server) handleOrgsListFailedInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListFailedInvitations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListFailedInvitations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListFailedInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListFailedInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListFailedInvitations",
			OperationID:   "orgs/list-failed-invitations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListFailedInvitationsParams
			Response = OrgsListFailedInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListFailedInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListFailedInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListFailedInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListForAuthenticatedUserRequest handles orgs/list-for-authenticated-user operation.
//
// List organizations for the authenticated user.
// **OAuth scope requirements**
// This only lists organizations that your authorization allows you to operate on in some way (e.g.,
// you can list teams with `read:org` scope, you can publicize your organization membership with
// `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth
// requests with insufficient scope receive a `403 Forbidden` response.
//
// GET /user/orgs
func (s *Server) handleOrgsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListForAuthenticatedUser",
			OperationID:   "orgs/list-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForAuthenticatedUserParams
			Response = OrgsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListForUserRequest handles orgs/list-for-user operation.
//
// List [public organization memberships](https://help.github.
// com/articles/publicizing-or-concealing-organization-membership) for the specified user.
// This method only lists _public_ memberships, regardless of authentication. If you need to fetch
// all of the organization memberships (public and private) for the authenticated user, use the [List
// organizations for the authenticated user](https://docs.github.
// com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
//
// GET /users/{username}/orgs
func (s *Server) handleOrgsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrgsListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListForUser",
			OperationID:   "orgs/list-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForUserParams
			Response = *OrgsListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListInvitationTeamsRequest handles orgs/list-invitation-teams operation.
//
// List all teams associated with an invitation. In order to see invitations in an organization, the
// authenticated user must be an organization owner.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (s *Server) handleOrgsListInvitationTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListInvitationTeams",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListInvitationTeams
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListInvitationTeamsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListInvitationTeamsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListInvitationTeams",
			OperationID:   "orgs/list-invitation-teams",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListInvitationTeamsParams
			Response = OrgsListInvitationTeamsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListInvitationTeamsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListInvitationTeams(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListInvitationTeams(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListMembersRequest handles orgs/list-members operation.
//
// List all users who are members of an organization. If the authenticated user is also a member of
// this organization then both concealed and public members will be returned.
//
// GET /orgs/{org}/members
func (s *Server) handleOrgsListMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListMembers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListMembersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListMembersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListMembers",
			OperationID:   "orgs/list-members",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembersParams
			Response = OrgsListMembersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListMembers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListMembers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListMembershipsForAuthenticatedUserRequest handles orgs/list-memberships-for-authenticated-user operation.
//
// List organization memberships for the authenticated user.
//
// GET /user/memberships/orgs
func (s *Server) handleOrgsListMembershipsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembershipsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListMembershipsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListMembershipsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListMembershipsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListMembershipsForAuthenticatedUser",
			OperationID:   "orgs/list-memberships-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembershipsForAuthenticatedUserParams
			Response = OrgsListMembershipsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembershipsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembershipsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListOutsideCollaboratorsRequest handles orgs/list-outside-collaborators operation.
//
// List all users who are outside collaborators of an organization.
//
// GET /orgs/{org}/outside_collaborators
func (s *Server) handleOrgsListOutsideCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListOutsideCollaborators",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListOutsideCollaborators
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListOutsideCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrgsListOutsideCollaboratorsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListOutsideCollaborators",
			OperationID:   "orgs/list-outside-collaborators",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListOutsideCollaboratorsParams
			Response = *OrgsListOutsideCollaboratorsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListOutsideCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListOutsideCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListOutsideCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListPendingInvitationsRequest handles orgs/list-pending-invitations operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// GET /orgs/{org}/invitations
func (s *Server) handleOrgsListPendingInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPendingInvitations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListPendingInvitations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListPendingInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListPendingInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListPendingInvitations",
			OperationID:   "orgs/list-pending-invitations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPendingInvitationsParams
			Response = OrgsListPendingInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPendingInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListPendingInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListPendingInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListPublicMembersRequest handles orgs/list-public-members operation.
//
// Members of an organization can choose to have their membership publicized or not.
//
// GET /orgs/{org}/public_members
func (s *Server) handleOrgsListPublicMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPublicMembers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListPublicMembers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListPublicMembersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrgsListPublicMembersOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListPublicMembers",
			OperationID:   "orgs/list-public-members",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPublicMembersParams
			Response = *OrgsListPublicMembersOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPublicMembersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListPublicMembers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListPublicMembers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListSamlSSOAuthorizationsRequest handles orgs/list-saml-sso-authorizations operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `read:org` scope can list all credential
// authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either
// personal access tokens or SSH keys that organization members have authorized for the organization.
// For more information, see [About authentication with SAML single sign-on](https://help.github.
// com/en/articles/about-authentication-with-saml-single-sign-on).
//
// GET /orgs/{org}/credential-authorizations
func (s *Server) handleOrgsListSamlSSOAuthorizationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListSamlSSOAuthorizations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListSamlSSOAuthorizations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListSamlSSOAuthorizationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []CredentialAuthorization
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListSamlSSOAuthorizations",
			OperationID:   "orgs/list-saml-sso-authorizations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListSamlSSOAuthorizationsParams
			Response = []CredentialAuthorization
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListSamlSSOAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListSamlSSOAuthorizations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListSamlSSOAuthorizations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListWebhookDeliveriesRequest handles orgs/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (s *Server) handleOrgsListWebhookDeliveriesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListWebhookDeliveries
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListWebhookDeliveries",
			OperationID:   "orgs/list-webhook-deliveries",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhookDeliveriesParams
			Response = OrgsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsListWebhooksRequest handles orgs/list-webhooks operation.
//
// List organization webhooks.
//
// GET /orgs/{org}/hooks
func (s *Server) handleOrgsListWebhooksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhooks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsListWebhooks
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsListWebhooksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsListWebhooks",
			OperationID:   "orgs/list-webhooks",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhooksParams
			Response = OrgsListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListWebhooks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListWebhooks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsPingWebhookRequest handles orgs/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (s *Server) handleOrgsPingWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsPingWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsPingWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsPingWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsPingWebhook",
			OperationID:   "orgs/ping-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsPingWebhookParams
			Response = OrgsPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsPingWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsPingWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRedeliverWebhookDeliveryRequest handles orgs/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for a webhook configured in an organization.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleOrgsRedeliverWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRedeliverWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRedeliverWebhookDelivery",
			OperationID:   "orgs/redeliver-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRedeliverWebhookDeliveryParams
			Response = OrgsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveMemberRequest handles orgs/remove-member operation.
//
// Removing a user from this list will remove them from all teams and they will no longer have any
// access to the organization's repositories.
//
// DELETE /orgs/{org}/members/{username}
func (s *Server) handleOrgsRemoveMemberRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMember",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRemoveMember
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRemoveMemberParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveMemberRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveMember",
			OperationID:   "orgs/remove-member",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMemberParams
			Response = OrgsRemoveMemberRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMemberParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveMember(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMember(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveMembershipForUserRequest handles orgs/remove-membership-for-user operation.
//
// In order to remove a user's membership with an organization, the authenticated user must be an
// organization owner.
// If the specified user is an active member of the organization, this will remove them from the
// organization. If the specified user has been invited to the organization, this will cancel their
// invitation. The specified user will receive an email notification in both cases.
//
// DELETE /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsRemoveMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRemoveMembershipForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRemoveMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveMembershipForUser",
			OperationID:   "orgs/remove-membership-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMembershipForUserParams
			Response = OrgsRemoveMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMembershipForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveOutsideCollaboratorRequest handles orgs/remove-outside-collaborator operation.
//
// Removing a user from this list will remove them from all the organization's repositories.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsRemoveOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRemoveOutsideCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRemoveOutsideCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveOutsideCollaborator",
			OperationID:   "orgs/remove-outside-collaborator",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveOutsideCollaboratorParams
			Response = OrgsRemoveOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveOutsideCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveOutsideCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemovePublicMembershipForAuthenticatedUserRequest handles orgs/remove-public-membership-for-authenticated-user operation.
//
// Remove public organization membership for the authenticated user.
//
// DELETE /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsRemovePublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemovePublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRemovePublicMembershipForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrgsRemovePublicMembershipForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemovePublicMembershipForAuthenticatedUser",
			OperationID:   "orgs/remove-public-membership-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemovePublicMembershipForAuthenticatedUserParams
			Response = *OrgsRemovePublicMembershipForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemovePublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsRemoveSamlSSOAuthorizationRequest handles orgs/remove-saml-sso-authorization operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `admin:org` scope can remove a credential
// authorization for an organization that uses SAML SSO. Once you remove someone's credential
// authorization, they will need to create a new personal access token or SSH key and authorize it
// for the organization they want to access.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (s *Server) handleOrgsRemoveSamlSSOAuthorizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveSamlSSOAuthorization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsRemoveSamlSSOAuthorization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsRemoveSamlSSOAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsRemoveSamlSSOAuthorization",
			OperationID:   "orgs/remove-saml-sso-authorization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "credential_id",
					In:   "path",
				}: params.CredentialID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveSamlSSOAuthorizationParams
			Response = OrgsRemoveSamlSSOAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveSamlSSOAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsSetMembershipForUserRequest handles orgs/set-membership-for-user operation.
//
// Only authenticated organization owners can add a member to the organization or update the member's
// role.
// *   If the authenticated user is _adding_ a member to the organization, the invited user will
// receive an email inviting them to the organization. The user's [membership status](https://docs.
// github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until
// they accept the invitation.
// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the
// authenticated user changes a member's role to `admin`, the affected user will receive an email
// notifying them that they've been made an organization owner. If the authenticated user changes an
// owner's role to `member`, no email will be sent.
// **Rate limits**
// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour
// period. If the organization is more than one month old or on a paid plan, the limit is 500
// invitations per 24 hour period.
//
// PUT /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsSetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsSetMembershipForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsSetMembershipForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsSetMembershipForUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsSetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsSetMembershipForUser",
			OperationID:   "orgs/set-membership-for-user",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsSetMembershipForUserReq
			Params   = OrgsSetMembershipForUserParams
			Response = OrgsSetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsSetMembershipForUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsSetMembershipForUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetMembershipForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsSetPublicMembershipForAuthenticatedUserRequest handles orgs/set-public-membership-for-authenticated-user operation.
//
// The user can publicize their own membership. (A user cannot publicize the membership for another
// user.)
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsSetPublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetPublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsSetPublicMembershipForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response OrgsSetPublicMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsSetPublicMembershipForAuthenticatedUser",
			OperationID:   "orgs/set-public-membership-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsSetPublicMembershipForAuthenticatedUserParams
			Response = OrgsSetPublicMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetPublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUnblockUserRequest handles orgs/unblock-user operation.
//
// Unblock a user from an organization.
//
// DELETE /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsUnblockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUnblockUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsUnblockUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsUnblockUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *OrgsUnblockUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUnblockUser",
			OperationID:   "orgs/unblock-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsUnblockUserParams
			Response = *OrgsUnblockUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUnblockUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.OrgsUnblockUser(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.OrgsUnblockUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateMembershipForAuthenticatedUserRequest handles orgs/update-membership-for-authenticated-user operation.
//
// Update an organization membership for the authenticated user.
//
// PATCH /user/memberships/orgs/{org}
func (s *Server) handleOrgsUpdateMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsUpdateMembershipForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsUpdateMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateMembershipForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateMembershipForAuthenticatedUser",
			OperationID:   "orgs/update-membership-for-authenticated-user",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *OrgsUpdateMembershipForAuthenticatedUserReq
			Params   = OrgsUpdateMembershipForAuthenticatedUserParams
			Response = OrgsUpdateMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateWebhookRequest handles orgs/update-webhook operation.
//
// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be
// overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new
// `secret` or the secret will be removed. If you are only updating individual webhook `config`
// properties, use "[Update a webhook configuration for an
// organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization).".
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsUpdateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsUpdateWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsUpdateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateWebhook",
			OperationID:   "orgs/update-webhook",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookReq
			Params   = OrgsUpdateWebhookParams
			Response = OrgsUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleOrgsUpdateWebhookConfigForOrgRequest handles orgs/update-webhook-config-for-org operation.
//
// Updates the webhook configuration for an organization. To update more information about the
// webhook, including the `active` state and `events`, use "[Update an organization webhook
// ](/rest/reference/orgs#update-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:write` permission.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsUpdateWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().OrgsUpdateWebhookConfigForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeOrgsUpdateWebhookConfigForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeOrgsUpdateWebhookConfigForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "OrgsUpdateWebhookConfigForOrg",
			OperationID:   "orgs/update-webhook-config-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookConfigForOrgReq
			Params   = OrgsUpdateWebhookConfigForOrgParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForAuthenticatedUserRequest handles packages/delete-package-for-authenticated-user operation.
//
// Deletes a package owned by the authenticated user. You cannot delete a public package if any
// version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for
// further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForAuthenticatedUser",
			OperationID:   "packages/delete-package-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForAuthenticatedUserParams
			Response = PackagesDeletePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForOrgRequest handles packages/delete-package-for-org operation.
//
// Deletes an entire package in an organization. You cannot delete a public package if any version of
// the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForOrg",
			OperationID:   "packages/delete-package-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForOrgParams
			Response = PackagesDeletePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageForUserRequest handles packages/delete-package-for-user operation.
//
// Deletes an entire package for a user. You cannot delete a public package if any version of the
// package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageForUser",
			OperationID:   "packages/delete-package-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForUserParams
			Response = PackagesDeletePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForAuthenticatedUserRequest handles packages/delete-package-version-for-authenticated-user operation.
//
// Deletes a specific package version for a package owned by the authenticated user.  If the package
// is public and the package version has more than 5,000 downloads, you cannot delete the package
// version. In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageVersionForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForAuthenticatedUser",
			OperationID:   "packages/delete-package-version-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForAuthenticatedUserParams
			Response = PackagesDeletePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForOrgRequest handles packages/delete-package-version-for-org operation.
//
// Deletes a specific package version in an organization. If the package is public and the package
// version has more than 5,000 downloads, you cannot delete the package version. In this scenario,
// contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageVersionForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageVersionForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForOrg",
			OperationID:   "packages/delete-package-version-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForOrgParams
			Response = PackagesDeletePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesDeletePackageVersionForUserRequest handles packages/delete-package-version-for-user operation.
//
// Deletes a specific package version for a user. If the package is public and the package version
// has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
// GitHub support for further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesDeletePackageVersionForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesDeletePackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesDeletePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesDeletePackageVersionForUser",
			OperationID:   "packages/delete-package-version-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForUserParams
			Response = PackagesDeletePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest handles packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// Returns all package versions for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest handles packages/get-all-package-versions-for-package-owned-by-org operation.
//
// Returns all package versions for a package owned by an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetAllPackageVersionsForPackageOwnedByOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest handles packages/get-all-package-versions-for-package-owned-by-user operation.
//
// Returns all package versions for a public package owned by a specified user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetAllPackageVersionsForPackageOwnedByUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesGetAllPackageVersionsForPackageOwnedByUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetAllPackageVersionsForPackageOwnedByUser",
			OperationID:   "packages/get-all-package-versions-for-package-owned-by-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForAuthenticatedUserRequest handles packages/get-package-for-authenticated-user operation.
//
// Gets a specific package for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForAuthenticatedUser",
			OperationID:   "packages/get-package-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForAuthenticatedUserParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForOrganizationRequest handles packages/get-package-for-organization operation.
//
// Gets a specific package in an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForOrganizationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageForOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForOrganization",
			OperationID:   "packages/get-package-for-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForOrganizationParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageForUserRequest handles packages/get-package-for-user operation.
//
// Gets a specific package metadata for a public package owned by a user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageForUser",
			OperationID:   "packages/get-package-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForUserParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForAuthenticatedUserRequest handles packages/get-package-version-for-authenticated-user operation.
//
// Gets a specific package version for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageVersionForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForAuthenticatedUser",
			OperationID:   "packages/get-package-version-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForAuthenticatedUserParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForOrganizationRequest handles packages/get-package-version-for-organization operation.
//
// Gets a specific package version in an organization.
// You must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForOrganizationRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageVersionForOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageVersionForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForOrganization",
			OperationID:   "packages/get-package-version-for-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForOrganizationParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesGetPackageVersionForUserRequest handles packages/get-package-version-for-user operation.
//
// Gets a specific package version for a public package owned by a specified user.
// At this time, to use this endpoint, you must authenticate using an access token with the
// `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesGetPackageVersionForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesGetPackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesGetPackageVersionForUser",
			OperationID:   "packages/get-package-version-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForUserParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForAuthenticatedUserRequest handles packages/list-packages-for-authenticated-user operation.
//
// Lists packages owned by the authenticated user within the user's namespace.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages
func (s *Server) handlePackagesListPackagesForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesListPackagesForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesListPackagesForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForAuthenticatedUser",
			OperationID:   "packages/list-packages-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForAuthenticatedUserParams
			Response = []Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForOrganizationRequest handles packages/list-packages-for-organization operation.
//
// Lists all packages in an organization readable by the user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages
func (s *Server) handlePackagesListPackagesForOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForOrganization",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesListPackagesForOrganization
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesListPackagesForOrganizationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesListPackagesForOrganizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForOrganization",
			OperationID:   "packages/list-packages-for-organization",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForOrganizationParams
			Response = PackagesListPackagesForOrganizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForOrganization(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesListPackagesForUserRequest handles packages/list-packages-for-user operation.
//
// Lists all packages in a user's namespace for which the requesting user has access.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages
func (s *Server) handlePackagesListPackagesForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesListPackagesForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesListPackagesForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesListPackagesForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesListPackagesForUser",
			OperationID:   "packages/list-packages-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForUserParams
			Response = PackagesListPackagesForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForAuthenticatedUserRequest handles packages/restore-package-for-authenticated-user operation.
//
// Restores a package owned by the authenticated user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForAuthenticatedUser",
			OperationID:   "packages/restore-package-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForAuthenticatedUserParams
			Response = PackagesRestorePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForOrgRequest handles packages/restore-package-for-org operation.
//
// Restores an entire package in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForOrg",
			OperationID:   "packages/restore-package-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForOrgParams
			Response = PackagesRestorePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageForUserRequest handles packages/restore-package-for-user operation.
//
// Restores an entire package for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageForUser",
			OperationID:   "packages/restore-package-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForUserParams
			Response = PackagesRestorePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForAuthenticatedUserRequest handles packages/restore-package-version-for-authenticated-user operation.
//
// Restores a package version owned by the authenticated user.
// You can restore a deleted package version under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageVersionForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForAuthenticatedUser",
			OperationID:   "packages/restore-package-version-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForAuthenticatedUserParams
			Response = PackagesRestorePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForOrgRequest handles packages/restore-package-version-for-org operation.
//
// Restores a specific package version in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageVersionForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageVersionForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForOrg",
			OperationID:   "packages/restore-package-version-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForOrgParams
			Response = PackagesRestorePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePackagesRestorePackageVersionForUserRequest handles packages/restore-package-version-for-user operation.
//
// Restores a specific package version for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PackagesRestorePackageVersionForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePackagesRestorePackageVersionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PackagesRestorePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PackagesRestorePackageVersionForUser",
			OperationID:   "packages/restore-package-version-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForUserParams
			Response = PackagesRestorePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsAddCollaboratorRequest handles projects/add-collaborator operation.
//
// Adds a collaborator to an organization project and sets their permission level. You must be an
// organization owner or a project `admin` to add a collaborator.
//
// PUT /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsAddCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsAddCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsAddCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsAddCollaborator",
			OperationID:   "projects/add-collaborator",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptNilProjectsAddCollaboratorReq
			Params   = ProjectsAddCollaboratorParams
			Response = ProjectsAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsAddCollaborator(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsAddCollaborator(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsAddCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateColumnRequest handles projects/create-column operation.
//
// Create a project column.
//
// POST /projects/{project_id}/columns
func (s *Server) handleProjectsCreateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateColumn",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsCreateColumn
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsCreateColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateColumn",
			OperationID:   "projects/create-column",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateColumnReq
			Params   = ProjectsCreateColumnParams
			Response = ProjectsCreateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForAuthenticatedUserRequest handles projects/create-for-authenticated-user operation.
//
// Create a user project.
//
// POST /user/projects
func (s *Server) handleProjectsCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsCreateForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeProjectsCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForAuthenticatedUser",
			OperationID:   "projects/create-for-authenticated-user",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *ProjectsCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ProjectsCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForOrgRequest handles projects/create-for-org operation.
//
// Creates an organization project board. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /orgs/{org}/projects
func (s *Server) handleProjectsCreateForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsCreateForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsCreateForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForOrg",
			OperationID:   "projects/create-for-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateForOrgReq
			Params   = ProjectsCreateForOrgParams
			Response = ProjectsCreateForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsCreateForRepoRequest handles projects/create-for-repo operation.
//
// Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsCreateForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsCreateForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsCreateForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsCreateForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsCreateForRepo",
			OperationID:   "projects/create-for-repo",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateForRepoReq
			Params   = ProjectsCreateForRepoParams
			Response = ProjectsCreateForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteRequest handles projects/delete operation.
//
// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
//
// DELETE /projects/{project_id}
func (s *Server) handleProjectsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsDelete
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDelete",
			OperationID:   "projects/delete",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteParams
			Response = ProjectsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteCardRequest handles projects/delete-card operation.
//
// Delete a project card.
//
// DELETE /projects/columns/cards/{card_id}
func (s *Server) handleProjectsDeleteCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteCard",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsDeleteCard
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsDeleteCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDeleteCard",
			OperationID:   "projects/delete-card",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteCardParams
			Response = ProjectsDeleteCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDeleteCard(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteCard(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsDeleteColumnRequest handles projects/delete-column operation.
//
// Delete a project column.
//
// DELETE /projects/columns/{column_id}
func (s *Server) handleProjectsDeleteColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteColumn",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsDeleteColumn
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsDeleteColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsDeleteColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsDeleteColumn",
			OperationID:   "projects/delete-column",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteColumnParams
			Response = ProjectsDeleteColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDeleteColumn(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteColumn(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetRequest handles projects/get operation.
//
// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do
// not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status
// is returned.
//
// GET /projects/{project_id}
func (s *Server) handleProjectsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGet",
			OperationID:   "projects/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetParams
			Response = ProjectsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetCardRequest handles projects/get-card operation.
//
// Get a project card.
//
// GET /projects/columns/cards/{card_id}
func (s *Server) handleProjectsGetCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetCard",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsGetCard
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsGetCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetCard",
			OperationID:   "projects/get-card",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetCardParams
			Response = ProjectsGetCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetCard(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetCard(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetColumnRequest handles projects/get-column operation.
//
// Get a project column.
//
// GET /projects/columns/{column_id}
func (s *Server) handleProjectsGetColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetColumn",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsGetColumn
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsGetColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetColumn",
			OperationID:   "projects/get-column",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetColumnParams
			Response = ProjectsGetColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetColumn(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetColumn(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsGetPermissionForUserRequest handles projects/get-permission-for-user operation.
//
// Returns the collaborator's permission level for an organization project. Possible values for the
// `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project
// `admin` to review a user's permission level.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (s *Server) handleProjectsGetPermissionForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetPermissionForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsGetPermissionForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsGetPermissionForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsGetPermissionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsGetPermissionForUser",
			OperationID:   "projects/get-permission-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetPermissionForUserParams
			Response = ProjectsGetPermissionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetPermissionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetPermissionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetPermissionForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetPermissionForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListCardsRequest handles projects/list-cards operation.
//
// List project cards.
//
// GET /projects/columns/{column_id}/cards
func (s *Server) handleProjectsListCardsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCards",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListCards
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListCardsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListCardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListCards",
			OperationID:   "projects/list-cards",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
				{
					Name: "archived_state",
					In:   "query",
				}: params.ArchivedState,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCardsParams
			Response = ProjectsListCardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListCards(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListCards(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListCollaboratorsRequest handles projects/list-collaborators operation.
//
// Lists the collaborators for an organization project. For a project, the list of collaborators
// includes outside collaborators, organization members that are direct collaborators, organization
// members with access through team memberships, organization members with access through default
// organization permissions, and organization owners. You must be an organization owner or a project
// `admin` to list collaborators.
//
// GET /projects/{project_id}/collaborators
func (s *Server) handleProjectsListCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCollaborators",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListCollaborators
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListCollaborators",
			OperationID:   "projects/list-collaborators",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCollaboratorsParams
			Response = ProjectsListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListColumnsRequest handles projects/list-columns operation.
//
// List project columns.
//
// GET /projects/{project_id}/columns
func (s *Server) handleProjectsListColumnsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListColumns",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListColumns
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListColumnsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListColumnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListColumns",
			OperationID:   "projects/list-columns",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListColumnsParams
			Response = ProjectsListColumnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListColumnsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListColumns(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListColumns(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForOrgRequest handles projects/list-for-org operation.
//
// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /orgs/{org}/projects
func (s *Server) handleProjectsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForOrg",
			OperationID:   "projects/list-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForOrgParams
			Response = ProjectsListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForRepoRequest handles projects/list-for-repo operation.
//
// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForRepo",
			OperationID:   "projects/list-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForRepoParams
			Response = ProjectsListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsListForUserRequest handles projects/list-for-user operation.
//
// List user projects.
//
// GET /users/{username}/projects
func (s *Server) handleProjectsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsListForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsListForUser",
			OperationID:   "projects/list-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForUserParams
			Response = ProjectsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsMoveCardRequest handles projects/move-card operation.
//
// Move a project card.
//
// POST /projects/columns/cards/{card_id}/moves
func (s *Server) handleProjectsMoveCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveCard",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsMoveCard
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsMoveCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsMoveCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsMoveCard",
			OperationID:   "projects/move-card",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsMoveCardReq
			Params   = ProjectsMoveCardParams
			Response = ProjectsMoveCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsMoveCard(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsMoveCard(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsMoveColumnRequest handles projects/move-column operation.
//
// Move a project column.
//
// POST /projects/columns/{column_id}/moves
func (s *Server) handleProjectsMoveColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveColumn",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsMoveColumn
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsMoveColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsMoveColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsMoveColumn",
			OperationID:   "projects/move-column",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsMoveColumnReq
			Params   = ProjectsMoveColumnParams
			Response = ProjectsMoveColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsMoveColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsMoveColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsRemoveCollaboratorRequest handles projects/remove-collaborator operation.
//
// Removes a collaborator from an organization project. You must be an organization owner or a
// project `admin` to remove a collaborator.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsRemoveCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsRemoveCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsRemoveCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProjectsRemoveCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsRemoveCollaborator",
			OperationID:   "projects/remove-collaborator",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsRemoveCollaboratorParams
			Response = ProjectsRemoveCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsRemoveCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsRemoveCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsRemoveCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateRequest handles projects/update operation.
//
// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled.
// If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410
// Gone` status is returned.
//
// PATCH /projects/{project_id}
func (s *Server) handleProjectsUpdateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsUpdate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdate",
			OperationID:   "projects/update",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateReq
			Params   = ProjectsUpdateParams
			Response = ProjectsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateCardRequest handles projects/update-card operation.
//
// Update an existing project card.
//
// PATCH /projects/columns/cards/{card_id}
func (s *Server) handleProjectsUpdateCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateCard",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsUpdateCard
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsUpdateCardParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdateCard",
			OperationID:   "projects/update-card",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateCardReq
			Params   = ProjectsUpdateCardParams
			Response = ProjectsUpdateCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdateCard(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateCard(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProjectsUpdateColumnRequest handles projects/update-column operation.
//
// Update an existing project column.
//
// PATCH /projects/columns/{column_id}
func (s *Server) handleProjectsUpdateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateColumn",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ProjectsUpdateColumn
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeProjectsUpdateColumnParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeProjectsUpdateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProjectsUpdateColumn",
			OperationID:   "projects/update-column",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsUpdateColumnReq
			Params   = ProjectsUpdateColumnParams
			Response = ProjectsUpdateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdateColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateColumn(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCheckIfMergedRequest handles pulls/check-if-merged operation.
//
// Check if a pull request has been merged.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsCheckIfMergedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCheckIfMerged",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsCheckIfMerged
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsCheckIfMergedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsCheckIfMergedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCheckIfMerged",
			OperationID:   "pulls/check-if-merged",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsCheckIfMergedParams
			Response = PullsCheckIfMergedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCheckIfMergedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCheckIfMerged(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCheckIfMerged(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateRequest handles pulls/create operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
// You can create a new pull request.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsCreate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreate",
			OperationID:   "pulls/create",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReq
			Params   = PullsCreateParams
			Response = PullsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReplyForReviewCommentRequest handles pulls/create-reply-for-review-comment operation.
//
// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of
// the review comment you are replying to. This must be the ID of a _top-level review comment_, not a
// reply to that comment. Replies to replies are not supported.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (s *Server) handlePullsCreateReplyForReviewCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReplyForReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsCreateReplyForReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsCreateReplyForReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReplyForReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReplyForReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReplyForReviewComment",
			OperationID:   "pulls/create-reply-for-review-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReplyForReviewCommentReq
			Params   = PullsCreateReplyForReviewCommentParams
			Response = PullsCreateReplyForReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReplyForReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReplyForReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReplyForReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReviewRequest handles pulls/create-review operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in
// the response.
// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of
// that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media
// type](https://docs.github.
// com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request
// diff, add this media type to the `Accept` header of a call to the [single pull
// request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
// The `position` value equals the number of lines down from the first "@@" hunk header in the file
// you want to add a comment. The line just below the "@@" line is position 1, the next line is
// position 2, and so on. The position in the diff continues to increase through lines of whitespace
// and additional hunks until the beginning of a new file.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsCreateReviewRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsCreateReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsCreateReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReview",
			OperationID:   "pulls/create-review",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsCreateReviewReq
			Params   = PullsCreateReviewParams
			Response = PullsCreateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsCreateReviewCommentRequest handles pulls/create-review-comment operation.
//
// Creates a review comment in the pull request diff. To add a regular comment to a pull request
// timeline, see "[Create an issue comment](https://docs.github.
// com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using
// `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than
// one line in the pull request diff.
// You can still create a review comment using the `position` parameter. When you use `position`, the
// `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information,
// see the [`comfort-fade` preview notice](https://docs.github.
// com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
// **Note:** The position value equals the number of lines down from the first "@@" hunk header in
// the file you want to add a comment. The line just below the "@@" line is position 1, the next line
// is position 2, and so on. The position in the diff continues to increase through lines of
// whitespace and additional hunks until the beginning of a new file.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsCreateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsCreateReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsCreateReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsCreateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsCreateReviewComment",
			OperationID:   "pulls/create-review-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReviewCommentReq
			Params   = PullsCreateReviewCommentParams
			Response = PullsCreateReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDeletePendingReviewRequest handles pulls/delete-pending-review operation.
//
// Delete a pending review for a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsDeletePendingReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeletePendingReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsDeletePendingReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsDeletePendingReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsDeletePendingReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDeletePendingReview",
			OperationID:   "pulls/delete-pending-review",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeletePendingReviewParams
			Response = PullsDeletePendingReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeletePendingReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDeletePendingReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDeletePendingReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDeleteReviewCommentRequest handles pulls/delete-review-comment operation.
//
// Deletes a review comment.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsDeleteReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeleteReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsDeleteReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsDeleteReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsDeleteReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDeleteReviewComment",
			OperationID:   "pulls/delete-review-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeleteReviewCommentParams
			Response = PullsDeleteReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeleteReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDeleteReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDeleteReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsDismissReviewRequest handles pulls/dismiss-review operation.
//
// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.
// com/rest/reference/repos#branches), you must be a repository administrator or be included in the
// list of people or teams who can dismiss pull request reviews.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (s *Server) handlePullsDismissReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDismissReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsDismissReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsDismissReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsDismissReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsDismissReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsDismissReview",
			OperationID:   "pulls/dismiss-review",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsDismissReviewReq
			Params   = PullsDismissReviewParams
			Response = PullsDismissReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDismissReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDismissReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDismissReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetRequest handles pulls/get operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists details of a pull request by providing its number.
// When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or
// [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub
// creates a merge commit to test whether the pull request can be automatically merged into the base
// branch. This test commit is not added to the base branch or the head branch. You can review the
// status of the test commit using the `mergeable` key. For more information, see "[Checking
// mergeability of pull requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`,
// then GitHub has started a background job to compute the mergeability. After giving the job time to
// complete, resubmit the request. When the job finishes, you will see a non-`null` value for the
// `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be
// the SHA of the _test_ merge commit.
// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request.
// Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge
// commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how
// you merged the pull request:
//   - If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/),
//     `merge_commit_sha` represents the SHA of the merge commit.
//   - If merged via a [squash](https://help.github.
//
// com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha`
// represents the SHA of the squashed commit on the base branch.
// *   If [rebased](https://help.github.
// com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha`
// represents the commit that the base branch was updated to.
// Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGet",
			OperationID:   "pulls/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetParams
			Response = PullsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetReviewRequest handles pulls/get-review operation.
//
// Get a review for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsGetReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsGetReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsGetReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGetReview",
			OperationID:   "pulls/get-review",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewParams
			Response = PullsGetReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGetReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGetReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsGetReviewCommentRequest handles pulls/get-review-comment operation.
//
// Provides details for a review comment.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsGetReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsGetReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsGetReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsGetReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsGetReviewComment",
			OperationID:   "pulls/get-review-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewCommentParams
			Response = PullsGetReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGetReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGetReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListRequest handles pulls/list operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsListRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsList",
			OperationID:   "pulls/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "head",
					In:   "query",
				}: params.Head,
				{
					Name: "base",
					In:   "query",
				}: params.Base,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListParams
			Response = PullsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListCommentsForReviewRequest handles pulls/list-comments-for-review operation.
//
// List comments for a specific pull request review.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (s *Server) handlePullsListCommentsForReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommentsForReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListCommentsForReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListCommentsForReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListCommentsForReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListCommentsForReview",
			OperationID:   "pulls/list-comments-for-review",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommentsForReviewParams
			Response = PullsListCommentsForReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommentsForReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListCommentsForReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListCommentsForReview(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListCommitsRequest handles pulls/list-commits operation.
//
// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull
// requests with more than 250 commits, use the [List commits](https://docs.github.
// com/rest/reference/repos#list-commits) endpoint.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (s *Server) handlePullsListCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListCommits
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PullsListCommitsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListCommits",
			OperationID:   "pulls/list-commits",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommitsParams
			Response = *PullsListCommitsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListFilesRequest handles pulls/list-files operation.
//
// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per
// page by default.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (s *Server) handlePullsListFilesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListFiles",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListFiles
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListFilesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PullsListFilesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListFiles",
			OperationID:   "pulls/list-files",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListFilesParams
			Response = PullsListFilesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListFilesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListFiles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListFiles(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListFilesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListRequestedReviewersRequest handles pulls/list-requested-reviewers operation.
//
// List requested reviewers for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsListRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListRequestedReviewers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListRequestedReviewersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PullRequestReviewRequestHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListRequestedReviewers",
			OperationID:   "pulls/list-requested-reviewers",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListRequestedReviewersParams
			Response = *PullRequestReviewRequestHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListRequestedReviewers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListRequestedReviewers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewCommentsRequest handles pulls/list-review-comments operation.
//
// Lists all review comments for a pull request. By default, review comments are in ascending order
// by ID.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsListReviewCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewComments",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListReviewComments
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListReviewCommentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PullsListReviewCommentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviewComments",
			OperationID:   "pulls/list-review-comments",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsParams
			Response = *PullsListReviewCommentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviewComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviewComments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewCommentsForRepoRequest handles pulls/list-review-comments-for-repo operation.
//
// Lists review comments for all pull requests in a repository. By default, review comments are in
// ascending order by ID.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (s *Server) handlePullsListReviewCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListReviewCommentsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListReviewCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PullsListReviewCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviewCommentsForRepo",
			OperationID:   "pulls/list-review-comments-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsForRepoParams
			Response = *PullsListReviewCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviewCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviewCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsListReviewsRequest handles pulls/list-reviews operation.
//
// The list of reviews returns in chronological order.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsListReviewsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviews",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsListReviews
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsListReviewsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PullsListReviewsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsListReviews",
			OperationID:   "pulls/list-reviews",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewsParams
			Response = *PullsListReviewsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviews(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviews(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsMergeRequest handles pulls/merge operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsMergeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsMerge",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsMerge
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsMergeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsMerge",
			OperationID:   "pulls/merge",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsMergeReq
			Params   = PullsMergeParams
			Response = PullsMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsMergeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsMerge(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsMerge(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsMergeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsRemoveRequestedReviewersRequest handles pulls/remove-requested-reviewers operation.
//
// Remove requested reviewers from a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsRemoveRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsRemoveRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsRemoveRequestedReviewers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsRemoveRequestedReviewersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsRemoveRequestedReviewersRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsRemoveRequestedReviewersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsRemoveRequestedReviewers",
			OperationID:   "pulls/remove-requested-reviewers",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = *PullsRemoveRequestedReviewersReq
			Params   = PullsRemoveRequestedReviewersParams
			Response = PullsRemoveRequestedReviewersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsRemoveRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsRemoveRequestedReviewers(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsRemoveRequestedReviewers(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsRemoveRequestedReviewersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsSubmitReviewRequest handles pulls/submit-review operation.
//
// Submit a review for a pull request.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (s *Server) handlePullsSubmitReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsSubmitReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsSubmitReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsSubmitReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsSubmitReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsSubmitReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsSubmitReview",
			OperationID:   "pulls/submit-review",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsSubmitReviewReq
			Params   = PullsSubmitReviewParams
			Response = PullsSubmitReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsSubmitReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsSubmitReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsSubmitReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateRequest handles pulls/update operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsUpdate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdate",
			OperationID:   "pulls/update",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsUpdateReq
			Params   = PullsUpdateParams
			Response = PullsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateBranchRequest handles pulls/update-branch operation.
//
// Updates the pull request branch with the latest upstream changes by merging HEAD from the base
// branch into the pull request branch.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (s *Server) handlePullsUpdateBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsUpdateBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsUpdateBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateBranch",
			OperationID:   "pulls/update-branch",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsUpdateBranchReq
			Params   = PullsUpdateBranchParams
			Response = PullsUpdateBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateBranch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateBranch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateReviewRequest handles pulls/update-review operation.
//
// Update the review summary comment with new text.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsUpdateReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReview",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsUpdateReview
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsUpdateReviewParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateReview",
			OperationID:   "pulls/update-review",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsUpdateReviewReq
			Params   = PullsUpdateReviewParams
			Response = PullsUpdateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateReview(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handlePullsUpdateReviewCommentRequest handles pulls/update-review-comment operation.
//
// Enables you to edit a review comment.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsUpdateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().PullsUpdateReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodePullsUpdateReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePullsUpdateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PullRequestReviewComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "PullsUpdateReviewComment",
			OperationID:   "pulls/update-review-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsUpdateReviewCommentReq
			Params   = PullsUpdateReviewCommentParams
			Response = *PullRequestReviewComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRateLimitGetRequest handles rate-limit/get operation.
//
// **Note:** Accessing this endpoint does not count against your REST API rate limit.
// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating
// existing code, you should use the `core` object instead of the `rate` object. The `core` object
// contains the same information that is present in the `rate` object.
//
// GET /rate_limit
func (s *Server) handleRateLimitGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RateLimitGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().RateLimitGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response RateLimitGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RateLimitGet",
			OperationID:   "rate-limit/get",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RateLimitGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RateLimitGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.RateLimitGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRateLimitGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForCommitCommentRequest handles reactions/create-for-commit-comment operation.
//
// Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this commit
// comment.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForCommitComment",
			OperationID:   "reactions/create-for-commit-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForCommitCommentReq
			Params   = ReactionsCreateForCommitCommentParams
			Response = ReactionsCreateForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForIssueRequest handles reactions/create-for-issue operation.
//
// Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with
// an HTTP `200` status means that you already added the reaction type to this issue.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsCreateForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssue",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForIssue
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForIssueRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForIssue",
			OperationID:   "reactions/create-for-issue",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForIssueReq
			Params   = ReactionsCreateForIssueParams
			Response = ReactionsCreateForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForIssue(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssue(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForIssueCommentRequest handles reactions/create-for-issue-comment operation.
//
// Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this issue
// comment.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssueComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForIssueComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForIssueCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForIssueComment",
			OperationID:   "reactions/create-for-issue-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForIssueCommentReq
			Params   = ReactionsCreateForIssueCommentParams
			Response = ReactionsCreateForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForIssueComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssueComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForPullRequestReviewCommentRequest handles reactions/create-for-pull-request-review-comment operation.
//
// Create a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already
// added the reaction type to this pull request review comment.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForPullRequestReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForPullRequestReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForPullRequestReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForPullRequestReviewComment",
			OperationID:   "reactions/create-for-pull-request-review-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForPullRequestReviewCommentReq
			Params   = ReactionsCreateForPullRequestReviewCommentParams
			Response = ReactionsCreateForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForPullRequestReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForReleaseRequest handles reactions/create-for-release operation.
//
// Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A
// response with a `Status: 200 OK` means that you already added the reaction type to this release.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (s *Server) handleReactionsCreateForReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForRelease",
			OperationID:   "reactions/create-for-release",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForReleaseReq
			Params   = ReactionsCreateForReleaseParams
			Response = ReactionsCreateForReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentInOrgRequest handles reactions/create-for-team-discussion-comment-in-org operation.
//
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForTeamDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionCommentInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionCommentInOrg",
			OperationID:   "reactions/create-for-team-discussion-comment-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionCommentInOrgReq
			Params   = ReactionsCreateForTeamDiscussionCommentInOrgParams
			Response = ReactionsCreateForTeamDiscussionCommentInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentLegacyRequest handles reactions/create-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Create reaction for a team discussion
// comment](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForTeamDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionCommentLegacy",
			OperationID:   "reactions/create-for-team-discussion-comment-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionCommentLegacyReq
			Params   = ReactionsCreateForTeamDiscussionCommentLegacyParams
			Response = *Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionInOrgRequest handles reactions/create-for-team-discussion-in-org operation.
//
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForTeamDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionInOrg",
			OperationID:   "reactions/create-for-team-discussion-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionInOrgReq
			Params   = ReactionsCreateForTeamDiscussionInOrgParams
			Response = ReactionsCreateForTeamDiscussionInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsCreateForTeamDiscussionLegacyRequest handles reactions/create-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create reaction for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsCreateForTeamDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReactionsCreateForTeamDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsCreateForTeamDiscussionLegacy",
			OperationID:   "reactions/create-for-team-discussion-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionLegacyReq
			Params   = ReactionsCreateForTeamDiscussionLegacyParams
			Response = *Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForCommitCommentRequest handles reactions/delete-for-commit-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForCommitCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForCommitCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForCommitComment",
			OperationID:   "reactions/delete-for-commit-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForCommitCommentParams
			Response = *ReactionsDeleteForCommitCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForIssueRequest handles reactions/delete-for-issue operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
// Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssue",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForIssue
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForIssueNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForIssue",
			OperationID:   "reactions/delete-for-issue",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueParams
			Response = *ReactionsDeleteForIssueNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForIssue(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForIssueCommentRequest handles reactions/delete-for-issue-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete
// /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssueComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForIssueComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForIssueCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForIssueComment",
			OperationID:   "reactions/delete-for-issue-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueCommentParams
			Response = *ReactionsDeleteForIssueCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForIssueComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForIssueComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForPullRequestCommentRequest handles reactions/delete-for-pull-request-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
// Delete a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForPullRequestCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForPullRequestComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForPullRequestComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForPullRequestCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForPullRequestCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForPullRequestComment",
			OperationID:   "reactions/delete-for-pull-request-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForPullRequestCommentParams
			Response = *ReactionsDeleteForPullRequestCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForPullRequestCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForPullRequestComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForPullRequestComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForTeamDiscussionRequest handles reactions/delete-for-team-discussion operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForTeamDiscussion
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForTeamDiscussionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForTeamDiscussion",
			OperationID:   "reactions/delete-for-team-discussion",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionParams
			Response = *ReactionsDeleteForTeamDiscussionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteForTeamDiscussionCommentRequest handles reactions/delete-for-team-discussion-comment operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionCommentRequest(args [5]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussionComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteForTeamDiscussionComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsDeleteForTeamDiscussionCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteForTeamDiscussionComment",
			OperationID:   "reactions/delete-for-team-discussion-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionCommentParams
			Response = *ReactionsDeleteForTeamDiscussionCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsDeleteLegacyRequest handles reactions/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions
// API. We recommend migrating your existing code to use the new delete reactions endpoints. For more
// information, see this [blog post](https://developer.github.
// com/changes/2020-02-26-new-delete-reactions-endpoints/).
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team
// discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion
// comment](https://docs.github.com/rest/reference/teams#discussion-comments).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /reactions/{reaction_id}
func (s *Server) handleReactionsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsDeleteLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsDeleteLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsDeleteLegacy",
			OperationID:   "reactions/delete-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteLegacyParams
			Response = ReactionsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsDeleteLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForCommitCommentRequest handles reactions/list-for-commit-comment operation.
//
// List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForCommitComment",
			OperationID:   "reactions/list-for-commit-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForCommitCommentParams
			Response = ReactionsListForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForIssueRequest handles reactions/list-for-issue operation.
//
// List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsListForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssue",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForIssue
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForIssueParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForIssue",
			OperationID:   "reactions/list-for-issue",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueParams
			Response = ReactionsListForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForIssue(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssue(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForIssueCommentRequest handles reactions/list-for-issue-comment operation.
//
// List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssueComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForIssueComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForIssueCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForIssueComment",
			OperationID:   "reactions/list-for-issue-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueCommentParams
			Response = ReactionsListForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForIssueComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssueComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForPullRequestReviewCommentRequest handles reactions/list-for-pull-request-review-comment operation.
//
// List the reactions to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForPullRequestReviewComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForPullRequestReviewCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReactionsListForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForPullRequestReviewComment",
			OperationID:   "reactions/list-for-pull-request-review-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForPullRequestReviewCommentParams
			Response = ReactionsListForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForPullRequestReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForPullRequestReviewComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionCommentInOrgRequest handles reactions/list-for-team-discussion-comment-in-org operation.
//
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForTeamDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsListForTeamDiscussionCommentInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionCommentInOrg",
			OperationID:   "reactions/list-for-team-discussion-comment-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentInOrgParams
			Response = *ReactionsListForTeamDiscussionCommentInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionCommentLegacyRequest handles reactions/list-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team discussion
// comment`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForTeamDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsListForTeamDiscussionCommentLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionCommentLegacy",
			OperationID:   "reactions/list-for-team-discussion-comment-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentLegacyParams
			Response = *ReactionsListForTeamDiscussionCommentLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionInOrgRequest handles reactions/list-for-team-discussion-in-org operation.
//
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForTeamDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsListForTeamDiscussionInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionInOrg",
			OperationID:   "reactions/list-for-team-discussion-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionInOrgParams
			Response = *ReactionsListForTeamDiscussionInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReactionsListForTeamDiscussionLegacyRequest handles reactions/list-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReactionsListForTeamDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReactionsListForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReactionsListForTeamDiscussionLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReactionsListForTeamDiscussionLegacy",
			OperationID:   "reactions/list-for-team-discussion-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionLegacyParams
			Response = *ReactionsListForTeamDiscussionLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAcceptInvitationRequest handles repos/accept-invitation operation.
//
// Accept a repository invitation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (s *Server) handleReposAcceptInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAcceptInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAcceptInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAcceptInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposAcceptInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAcceptInvitation",
			OperationID:   "repos/accept-invitation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposAcceptInvitationParams
			Response = ReposAcceptInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAcceptInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAcceptInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAcceptInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddAppAccessRestrictionsRequest handles repos/add-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposAddAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAddAppAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAddAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddAppAccessRestrictions",
			OperationID:   "repos/add-app-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddAppAccessRestrictionsReq
			Params   = ReposAddAppAccessRestrictionsParams
			Response = ReposAddAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddCollaboratorRequest handles repos/add-collaborator operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// For more information the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// The invitee will receive a notification that they have been invited to the repository, which they
// must accept or decline. They may do this via the notifications page, the email they receive, or by
// using the [repository invitations API endpoints](https://docs.github.
// com/rest/reference/repos#invitations).
// **Rate limits**
// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no
// limit if you are inviting organization members to an organization repository.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposAddCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAddCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAddCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddCollaborator",
			OperationID:   "repos/add-collaborator",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddCollaboratorReq
			Params   = ReposAddCollaboratorParams
			Response = ReposAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddCollaborator(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddCollaborator(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddStatusCheckContextsRequest handles repos/add-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposAddStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAddStatusCheckContexts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAddStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddStatusCheckContexts",
			OperationID:   "repos/add-status-check-contexts",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddStatusCheckContextsReq
			Params   = ReposAddStatusCheckContextsParams
			Response = ReposAddStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddTeamAccessRestrictionsRequest handles repos/add-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified teams push access for this branch. You can also give push access to child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposAddTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAddTeamAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAddTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddTeamAccessRestrictions",
			OperationID:   "repos/add-team-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddTeamAccessRestrictionsReq
			Params   = ReposAddTeamAccessRestrictionsParams
			Response = ReposAddTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposAddUserAccessRestrictionsRequest handles repos/add-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified people push access for this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposAddUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposAddUserAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposAddUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposAddUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposAddUserAccessRestrictions",
			OperationID:   "repos/add-user-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddUserAccessRestrictionsReq
			Params   = ReposAddUserAccessRestrictionsParams
			Response = ReposAddUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCheckCollaboratorRequest handles repos/check-collaborator operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposCheckCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCheckCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCheckCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCheckCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCheckCollaborator",
			OperationID:   "repos/check-collaborator",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckCollaboratorParams
			Response = ReposCheckCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCheckCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCheckCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCheckVulnerabilityAlertsRequest handles repos/check-vulnerability-alerts operation.
//
// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user
// must have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposCheckVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCheckVulnerabilityAlerts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCheckVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCheckVulnerabilityAlertsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCheckVulnerabilityAlerts",
			OperationID:   "repos/check-vulnerability-alerts",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckVulnerabilityAlertsParams
			Response = ReposCheckVulnerabilityAlertsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCheckVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCheckVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCompareCommitsRequest handles repos/compare-commits operation.
//
// The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in
// `repo`. To compare branches across other repositories in the same network as `repo`, use the
// format `<USERNAME>:branch`.
// The response from the API is equivalent to running the `git log base..head` command; however,
// commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
// The response also includes details on the files that were changed between the two commits. This
// includes the status of the change (for example, if a file was added, removed, modified, or
// renamed), and details of the change itself. For example, files with a `renamed` status have a
// `previous_filename` field showing the previous filename of the file, and files with a `modified`
// status have a `patch` field showing the changes made to the file.
// **Working with large comparisons**
// To process a response with a large number of commits, you can use (`per_page` or `page`) to
// paginate the results. When using paging, the list of changed files is only returned with page 1,
// but includes all changed files for the entire comparison. For more information on working with
// pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
// When calling this API without any paging parameters (`per_page` or `page`), the returned list is
// limited to 250 commits and the last commit in the list is the most recent of the entire comparison.
//
//	When a paging parameter is specified, the first commit in the returned list of each page is the
//
// earliest.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (s *Server) handleReposCompareCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCompareCommits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCompareCommits
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCompareCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCompareCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCompareCommits",
			OperationID:   "repos/compare-commits",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "basehead",
					In:   "path",
				}: params.Basehead,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCompareCommitsParams
			Response = ReposCompareCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCompareCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCompareCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCompareCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateAutolinkRequest handles repos/create-autolink operation.
//
// Users with admin access to the repository can create an autolink.
//
// POST /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposCreateAutolinkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateAutolink",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateAutolink
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateAutolinkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateAutolink",
			OperationID:   "repos/create-autolink",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateAutolinkReq
			Params   = ReposCreateAutolinkParams
			Response = ReposCreateAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateAutolink(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateAutolink(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitCommentRequest handles repos/create-commit-comment operation.
//
// Create a comment for a commit using its `:commit_sha`.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposCreateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitComment",
			OperationID:   "repos/create-commit-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateCommitCommentReq
			Params   = ReposCreateCommitCommentParams
			Response = ReposCreateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitSignatureProtectionRequest handles repos/create-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// require signed commits on a branch. You must enable branch protection to require signed commits.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposCreateCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateCommitSignatureProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposCreateCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitSignatureProtection",
			OperationID:   "repos/create-commit-signature-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCreateCommitSignatureProtectionParams
			Response = ReposCreateCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateCommitStatusRequest handles repos/create-commit-status operation.
//
// Users with push access in a repository can create commit statuses for a given SHA.
// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
// create more than 1000 statuses will result in a validation error.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (s *Server) handleReposCreateCommitStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateCommitStatus
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateCommitStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateCommitStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *StatusHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateCommitStatus",
			OperationID:   "repos/create-commit-status",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "path",
				}: params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateCommitStatusReq
			Params   = ReposCreateCommitStatusParams
			Response = *StatusHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitStatus(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitStatus(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeployKeyRequest handles repos/create-deploy-key operation.
//
// You can create a read-only deploy key.
//
// POST /repos/{owner}/{repo}/keys
func (s *Server) handleReposCreateDeployKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateDeployKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeployKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeployKey",
			OperationID:   "repos/create-deploy-key",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeployKeyReq
			Params   = ReposCreateDeployKeyParams
			Response = ReposCreateDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeployKey(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployKey(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeploymentRequest handles repos/create-deployment operation.
//
// Deployments offer a few configurable parameters with certain defaults.
// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and
// verify them
// before we merge a pull request.
// The `environment` parameter allows deployments to be issued to different runtime environments.
// Teams often have
// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`.
// This parameter
// makes it easier to track which environments have requested deployments. The default environment is
// `production`.
// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's
// default branch. If
// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If
// the merge succeeds,
// the API will return a successful merge commit. If merge conflicts prevent the merge from
// succeeding, the API will
// return a failure response.
// By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every
// submitted context must be in a `success`
// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be
// `success`, or to
// specify contexts that have not yet been submitted. You are not required to use commit statuses to
// deploy. If you do
// not require any contexts or create any commit statuses, the deployment will always succeed.
// The `payload` parameter is available for any extra information that a deployment system might need.
//
//	It is a JSON text
//
// field that will be passed on when a deployment event is dispatched.
// The `task` parameter is used by the deployment system to allow different execution paths. In the
// web world this might
// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a
// flag to compile an
// application with debugging enabled.
// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
// #### Merged branch response
// You will see this response when GitHub automatically merges the base branch into the topic branch
// instead of creating
// a deployment. This auto-merge happens when:
// *   Auto-merge option is enabled in the repository
// *   Topic branch does not include the latest changes on the base branch, which is `master` in the
// response example
// *   There are no merge conflicts
// If there are no new commits in the base branch, a new request to create a deployment should give a
// successful
// response.
// #### Merge conflict response
// This error happens when the `auto_merge` option is enabled and when the default branch (in this
// case `master`), can't
// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge
// conflicts.
// #### Failed commit status checks
// This error happens when the `required_contexts` parameter indicates that one or more contexts need
// to have a `success`
// status for the commit to be deployed, but one or more of the required contexts do not have a state
// of `success`.
//
// POST /repos/{owner}/{repo}/deployments
func (s *Server) handleReposCreateDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateDeployment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeploymentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeployment",
			OperationID:   "repos/create-deployment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeploymentReq
			Params   = ReposCreateDeploymentParams
			Response = ReposCreateDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeployment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDeploymentStatusRequest handles repos/create-deployment-status operation.
//
// Users with `push` access can create deployment statuses for a given deployment.
// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo
// contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposCreateDeploymentStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateDeploymentStatus
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateDeploymentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDeploymentStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDeploymentStatus",
			OperationID:   "repos/create-deployment-status",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeploymentStatusReq
			Params   = ReposCreateDeploymentStatusParams
			Response = ReposCreateDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeploymentStatus(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeploymentStatus(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateDispatchEventRequest handles repos/create-dispatch-event operation.
//
// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want
// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook.
//
//	You must configure your GitHub Actions workflow or GitHub App to run when the
//
// `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
// "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
// The `client_payload` parameter is available for any extra information that your workflow might
// need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched.
//
//	For example, the `client_payload` can include a message that a user would like to send using a
//
// GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
// This endpoint requires write access to the repository by providing either:
// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access
// token for the command line](https://help.github.
// com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help
// documentation.
// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
// This input example shows how you can use the `client_payload` as a test to debug your workflow.
//
// POST /repos/{owner}/{repo}/dispatches
func (s *Server) handleReposCreateDispatchEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDispatchEvent",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateDispatchEvent
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateDispatchEventParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateDispatchEventRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDispatchEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateDispatchEvent",
			OperationID:   "repos/create-dispatch-event",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDispatchEventReq
			Params   = ReposCreateDispatchEventParams
			Response = ReposCreateDispatchEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDispatchEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDispatchEvent(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDispatchEvent(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDispatchEventResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateForAuthenticatedUserRequest handles repos/create-for-authenticated-user operation.
//
// Creates a new repository for the authenticated user.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /user/repos
func (s *Server) handleReposCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeReposCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateForAuthenticatedUser",
			OperationID:   "repos/create-for-authenticated-user",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *ReposCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ReposCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateForkRequest handles repos/create-fork operation.
//
// Create a fork for the authenticated user.
// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time
// before you can access the git objects. If this takes longer than 5 minutes, be sure to contact
// [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
//
// POST /repos/{owner}/{repo}/forks
func (s *Server) handleReposCreateForkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateFork",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateFork
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateForkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateForkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateFork",
			OperationID:   "repos/create-fork",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateForkReq
			Params   = ReposCreateForkParams
			Response = ReposCreateForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateForkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateFork(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateFork(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateInOrgRequest handles repos/create-in-org operation.
//
// Creates a new repository in the specified organization. The authenticated user must be a member of
// the organization.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /orgs/{org}/repos
func (s *Server) handleReposCreateInOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateInOrg",
			OperationID:   "repos/create-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateInOrgReq
			Params   = ReposCreateInOrgParams
			Response = ReposCreateInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateOrUpdateFileContentsRequest handles repos/create-or-update-file-contents operation.
//
// Creates a new file or replaces an existing file in a repository.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposCreateOrUpdateFileContentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateOrUpdateFileContents",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateOrUpdateFileContents
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateOrUpdateFileContentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateOrUpdateFileContentsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateOrUpdateFileContentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateOrUpdateFileContents",
			OperationID:   "repos/create-or-update-file-contents",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "path",
					In:   "path",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateOrUpdateFileContentsReq
			Params   = ReposCreateOrUpdateFileContentsParams
			Response = ReposCreateOrUpdateFileContentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateOrUpdateFileContentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateOrUpdateFileContentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreatePagesSiteRequest handles repos/create-pages-site operation.
//
// Configures a GitHub Pages site. For more information, see "[About GitHub
// Pages](/github/working-with-github-pages/about-github-pages).".
//
// POST /repos/{owner}/{repo}/pages
func (s *Server) handleReposCreatePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreatePagesSite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreatePagesSite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreatePagesSiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreatePagesSiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreatePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreatePagesSite",
			OperationID:   "repos/create-pages-site",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = NilReposCreatePagesSiteReq
			Params   = ReposCreatePagesSiteParams
			Response = ReposCreatePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreatePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreatePagesSite(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreatePagesSite(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreatePagesSiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateReleaseRequest handles repos/create-release operation.
//
// Users with push access to the repository can create a release.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/releases
func (s *Server) handleReposCreateReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateRelease",
			OperationID:   "repos/create-release",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateReleaseReq
			Params   = ReposCreateReleaseParams
			Response = ReposCreateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateUsingTemplateRequest handles repos/create-using-template operation.
//
// Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
// route parameters to specify the repository to use as the template. The authenticated user must own
// or be a member of an organization that owns the repository. To check if a repository is available
// to use as a template, get the repository's information using the [Get a repository](https://docs.
// github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is
// `true`.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (s *Server) handleReposCreateUsingTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateUsingTemplate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateUsingTemplate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateUsingTemplateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateUsingTemplateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositoryHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateUsingTemplate",
			OperationID:   "repos/create-using-template",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "template_owner",
					In:   "path",
				}: params.TemplateOwner,
				{
					Name: "template_repo",
					In:   "path",
				}: params.TemplateRepo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateUsingTemplateReq
			Params   = ReposCreateUsingTemplateParams
			Response = *RepositoryHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateUsingTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateUsingTemplate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateUsingTemplate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposCreateWebhookRequest handles repos/create-webhook operation.
//
// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`.
// Multiple webhooks can
// share the same `config` as long as those webhooks do not have any `events` that overlap.
//
// POST /repos/{owner}/{repo}/hooks
func (s *Server) handleReposCreateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposCreateWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposCreateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposCreateWebhook",
			OperationID:   "repos/create-webhook",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateWebhookReq
			Params   = ReposCreateWebhookParams
			Response = ReposCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeclineInvitationRequest handles repos/decline-invitation operation.
//
// Decline a repository invitation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (s *Server) handleReposDeclineInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeclineInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeclineInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeclineInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeclineInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeclineInvitation",
			OperationID:   "repos/decline-invitation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeclineInvitationParams
			Response = ReposDeclineInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeclineInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeclineInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeclineInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteRequest handles repos/delete operation.
//
// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
// If an organization owner has configured the organization to prevent members from deleting
// organization-owned
// repositories, you will get a `403 Forbidden` response.
//
// DELETE /repos/{owner}/{repo}
func (s *Server) handleReposDeleteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDelete
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDelete",
			OperationID:   "repos/delete",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteParams
			Response = ReposDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAccessRestrictionsRequest handles repos/delete-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Disables the ability to restrict who can push to this branch.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposDeleteAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteAccessRestrictionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAccessRestrictions",
			OperationID:   "repos/delete-access-restrictions",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAccessRestrictionsParams
			Response = *ReposDeleteAccessRestrictionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteAccessRestrictions(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteAccessRestrictions(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAdminBranchProtectionRequest handles repos/delete-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removing admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposDeleteAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteAdminBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAdminBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAdminBranchProtection",
			OperationID:   "repos/delete-admin-branch-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAdminBranchProtectionParams
			Response = ReposDeleteAdminBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAnEnvironmentRequest handles repos/delete-an-environment operation.
//
// You must authenticate using an access token with the repo scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (s *Server) handleReposDeleteAnEnvironmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAnEnvironment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteAnEnvironment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteAnEnvironmentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteAnEnvironmentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAnEnvironment",
			OperationID:   "repos/delete-an-environment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAnEnvironmentParams
			Response = *ReposDeleteAnEnvironmentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAnEnvironmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteAnEnvironment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteAnEnvironment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteAutolinkRequest handles repos/delete-autolink operation.
//
// This deletes a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposDeleteAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAutolink",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteAutolink
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteAutolink",
			OperationID:   "repos/delete-autolink",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "autolink_id",
					In:   "path",
				}: params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAutolinkParams
			Response = ReposDeleteAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteAutolink(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteAutolink(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteBranchProtectionRequest handles repos/delete-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposDeleteBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteBranchProtection",
			OperationID:   "repos/delete-branch-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteBranchProtectionParams
			Response = ReposDeleteBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteCommitCommentRequest handles repos/delete-commit-comment operation.
//
// Delete a commit comment.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposDeleteCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteCommitComment",
			OperationID:   "repos/delete-commit-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitCommentParams
			Response = ReposDeleteCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteCommitSignatureProtectionRequest handles repos/delete-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// disable required signed commits on a branch. You must enable branch protection to require signed
// commits.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposDeleteCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteCommitSignatureProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteCommitSignatureProtection",
			OperationID:   "repos/delete-commit-signature-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitSignatureProtectionParams
			Response = ReposDeleteCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteDeployKeyRequest handles repos/delete-deploy-key operation.
//
// Deploy keys are immutable. If you need to update a key, remove the key and create a new one
// instead.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposDeleteDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteDeployKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteDeployKeyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteDeployKey",
			OperationID:   "repos/delete-deploy-key",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeployKeyParams
			Response = *ReposDeleteDeployKeyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteDeployKey(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteDeployKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteDeploymentRequest handles repos/delete-deployment operation.
//
// To ensure there can always be an active deployment, you can only delete an _inactive_ deployment.
// Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
// To set a deployment as inactive, you must:
// *   Create a new deployment that is active so that the system has a record of the current state,
// then delete the previously active deployment.
// *   Mark the active deployment as inactive by adding any non-successful deployment status.
// For more information, see "[Create a deployment](https://docs.github.
// com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.
// github.com/rest/reference/repos#create-a-deployment-status).".
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposDeleteDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteDeployment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteDeployment",
			OperationID:   "repos/delete-deployment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeploymentParams
			Response = ReposDeleteDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteFileRequest handles repos/delete-file operation.
//
// Deletes a file in a repository.
// You can provide an additional `committer` parameter, which is an object containing information
// about the committer. Or, you can provide an `author` parameter, which is an object containing
// information about the author.
// The `author` section is optional and is filled in with the `committer` information if omitted. If
// the `committer` information is omitted, the authenticated user's information is used.
// You must provide values for both `name` and `email`, whether you choose to use `author` or
// `committer`. Otherwise, you'll receive a `422` status code.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposDeleteFileRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteFile",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteFile
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteFileParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposDeleteFileRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposDeleteFileRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteFile",
			OperationID:   "repos/delete-file",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "path",
					In:   "path",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = *ReposDeleteFileReq
			Params   = ReposDeleteFileParams
			Response = ReposDeleteFileRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteFileParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteFile(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteFile(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteFileResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteInvitationRequest handles repos/delete-invitation operation.
//
// Delete a repository invitation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposDeleteInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteInvitationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteInvitation",
			OperationID:   "repos/delete-invitation",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteInvitationParams
			Response = *ReposDeleteInvitationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteInvitation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeletePagesSiteRequest handles repos/delete-pages-site operation.
//
// Delete a GitHub Pages site.
//
// DELETE /repos/{owner}/{repo}/pages
func (s *Server) handleReposDeletePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePagesSite",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeletePagesSite
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeletePagesSiteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeletePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeletePagesSite",
			OperationID:   "repos/delete-pages-site",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePagesSiteParams
			Response = ReposDeletePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeletePagesSite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeletePagesSite(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePagesSiteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeletePullRequestReviewProtectionRequest handles repos/delete-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposDeletePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeletePullRequestReviewProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeletePullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeletePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeletePullRequestReviewProtection",
			OperationID:   "repos/delete-pull-request-review-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePullRequestReviewProtectionParams
			Response = ReposDeletePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeletePullRequestReviewProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeletePullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteReleaseRequest handles repos/delete-release operation.
//
// Users with push access to the repository can delete a release.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposDeleteReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteReleaseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteRelease",
			OperationID:   "repos/delete-release",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseParams
			Response = *ReposDeleteReleaseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteRelease(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteReleaseAssetRequest handles repos/delete-release-asset operation.
//
// Delete a release asset.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposDeleteReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteReleaseAsset
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDeleteReleaseAssetNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteReleaseAsset",
			OperationID:   "repos/delete-release-asset",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseAssetParams
			Response = *ReposDeleteReleaseAssetNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteReleaseAsset(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteReleaseAsset(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDeleteWebhookRequest handles repos/delete-webhook operation.
//
// Delete a repository webhook.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposDeleteWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDeleteWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDeleteWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDeleteWebhook",
			OperationID:   "repos/delete-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteWebhookParams
			Response = ReposDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableAutomatedSecurityFixesRequest handles repos/disable-automated-security-fixes operation.
//
// Disables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposDisableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDisableAutomatedSecurityFixes
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDisableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDisableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableAutomatedSecurityFixes",
			OperationID:   "repos/disable-automated-security-fixes",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableAutomatedSecurityFixesParams
			Response = *ReposDisableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableLfsForRepoRequest handles repos/disable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// DELETE /repos/{owner}/{repo}/lfs
func (s *Server) handleReposDisableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDisableLfsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDisableLfsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDisableLfsForRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableLfsForRepo",
			OperationID:   "repos/disable-lfs-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableLfsForRepoParams
			Response = *ReposDisableLfsForRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableLfsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableLfsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDisableVulnerabilityAlertsRequest handles repos/disable-vulnerability-alerts operation.
//
// Disables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposDisableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDisableVulnerabilityAlerts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDisableVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDisableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDisableVulnerabilityAlerts",
			OperationID:   "repos/disable-vulnerability-alerts",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableVulnerabilityAlertsParams
			Response = *ReposDisableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDownloadTarballArchiveRequest handles repos/download-tarball-archive operation.
//
// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (s *Server) handleReposDownloadTarballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadTarballArchive",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDownloadTarballArchive
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDownloadTarballArchiveParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDownloadTarballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDownloadTarballArchive",
			OperationID:   "repos/download-tarball-archive",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadTarballArchiveParams
			Response = *ReposDownloadTarballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadTarballArchiveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDownloadTarballArchive(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDownloadTarballArchive(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposDownloadZipballArchiveRequest handles repos/download-zipball-archive operation.
//
// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (s *Server) handleReposDownloadZipballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadZipballArchive",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposDownloadZipballArchive
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposDownloadZipballArchiveParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposDownloadZipballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposDownloadZipballArchive",
			OperationID:   "repos/download-zipball-archive",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadZipballArchiveParams
			Response = *ReposDownloadZipballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadZipballArchiveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDownloadZipballArchive(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDownloadZipballArchive(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableAutomatedSecurityFixesRequest handles repos/enable-automated-security-fixes operation.
//
// Enables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposEnableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposEnableAutomatedSecurityFixes
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposEnableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposEnableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableAutomatedSecurityFixes",
			OperationID:   "repos/enable-automated-security-fixes",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableAutomatedSecurityFixesParams
			Response = *ReposEnableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableLfsForRepoRequest handles repos/enable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// PUT /repos/{owner}/{repo}/lfs
func (s *Server) handleReposEnableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposEnableLfsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposEnableLfsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposEnableLfsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableLfsForRepo",
			OperationID:   "repos/enable-lfs-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableLfsForRepoParams
			Response = ReposEnableLfsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposEnableLfsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposEnableLfsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposEnableVulnerabilityAlertsRequest handles repos/enable-vulnerability-alerts operation.
//
// Enables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposEnableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposEnableVulnerabilityAlerts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposEnableVulnerabilityAlertsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposEnableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposEnableVulnerabilityAlerts",
			OperationID:   "repos/enable-vulnerability-alerts",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableVulnerabilityAlertsParams
			Response = *ReposEnableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposEnableVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposEnableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetRequest handles repos/get operation.
//
// The `parent` and `source` objects are present when the repository is a fork. `parent` is the
// repository this repository was forked from, `source` is the ultimate source for the network.
//
// GET /repos/{owner}/{repo}
func (s *Server) handleReposGetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGet
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGet",
			OperationID:   "repos/get",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParams
			Response = ReposGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAccessRestrictionsRequest handles repos/get-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists who has access to this protected branch.
// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned
// repositories.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposGetAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAccessRestrictions",
			OperationID:   "repos/get-access-restrictions",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAccessRestrictionsParams
			Response = ReposGetAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAccessRestrictions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAccessRestrictions(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAdminBranchProtectionRequest handles repos/get-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposGetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAdminBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAdminBranchProtection",
			OperationID:   "repos/get-admin-branch-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAdminBranchProtectionParams
			Response = *ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAllStatusCheckContextsRequest handles repos/get-all-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposGetAllStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAllStatusCheckContexts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAllStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAllStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAllStatusCheckContexts",
			OperationID:   "repos/get-all-status-check-contexts",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllStatusCheckContextsParams
			Response = ReposGetAllStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAllStatusCheckContexts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAllStatusCheckContexts(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAllTopicsRequest handles repos/get-all-topics operation.
//
// Get all repository topics.
//
// GET /repos/{owner}/{repo}/topics
func (s *Server) handleReposGetAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllTopics",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAllTopics
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAllTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAllTopics",
			OperationID:   "repos/get-all-topics",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllTopicsParams
			Response = ReposGetAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAllTopics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAllTopics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAppsWithAccessToProtectedBranchRequest handles repos/get-apps-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with
// `write` access to the `contents` permission can be added as authorized actors on a protected
// branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposGetAppsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAppsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAppsWithAccessToProtectedBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAppsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAppsWithAccessToProtectedBranch",
			OperationID:   "repos/get-apps-with-access-to-protected-branch",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAppsWithAccessToProtectedBranchParams
			Response = ReposGetAppsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAppsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetAutolinkRequest handles repos/get-autolink operation.
//
// This returns a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposGetAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAutolink",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetAutolink
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetAutolinkParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetAutolink",
			OperationID:   "repos/get-autolink",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "autolink_id",
					In:   "path",
				}: params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAutolinkParams
			Response = ReposGetAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAutolink(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAutolink(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetBranchRequest handles repos/get-branch operation.
//
// Get a branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (s *Server) handleReposGetBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetBranch",
			OperationID:   "repos/get-branch",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchParams
			Response = ReposGetBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetBranchProtectionRequest handles repos/get-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposGetBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetBranchProtection",
			OperationID:   "repos/get-branch-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchProtectionParams
			Response = ReposGetBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetClonesRequest handles repos/get-clones operation.
//
// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (s *Server) handleReposGetClonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetClones",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetClones
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetClonesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetClonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetClones",
			OperationID:   "repos/get-clones",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per",
					In:   "query",
				}: params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetClonesParams
			Response = ReposGetClonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetClonesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetClones(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetClones(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetClonesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCodeFrequencyStatsRequest handles repos/get-code-frequency-stats operation.
//
// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (s *Server) handleReposGetCodeFrequencyStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCodeFrequencyStats",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCodeFrequencyStats
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCodeFrequencyStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCodeFrequencyStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCodeFrequencyStats",
			OperationID:   "repos/get-code-frequency-stats",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCodeFrequencyStatsParams
			Response = ReposGetCodeFrequencyStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCodeFrequencyStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCodeFrequencyStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCodeFrequencyStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCollaboratorPermissionLevelRequest handles repos/get-collaborator-permission-level operation.
//
// Checks the repository permission of a collaborator. The possible repository permissions are
// `admin`, `write`, `read`, and `none`.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (s *Server) handleReposGetCollaboratorPermissionLevelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCollaboratorPermissionLevel",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCollaboratorPermissionLevel
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCollaboratorPermissionLevelParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCollaboratorPermissionLevelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCollaboratorPermissionLevel",
			OperationID:   "repos/get-collaborator-permission-level",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCollaboratorPermissionLevelParams
			Response = ReposGetCollaboratorPermissionLevelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCollaboratorPermissionLevelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCombinedStatusForRefRequest handles repos/get-combined-status-for-ref operation.
//
// Users with pull access in a repository can access a combined view of commit statuses for a given
// ref. The ref can be a SHA, a branch name, or a tag name.
// The most recent status for each context is returned, up to 100. This field
// [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there
// are over 100 contexts.
// Additionally, a combined `state` is returned. The `state` is one of:
// *   **failure** if any of the contexts report as `error` or `failure`
// *   **pending** if there are no statuses or a context is `pending`
// *   **success** if the latest status for all contexts is `success`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (s *Server) handleReposGetCombinedStatusForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCombinedStatusForRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCombinedStatusForRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCombinedStatusForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCombinedStatusForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCombinedStatusForRef",
			OperationID:   "repos/get-combined-status-for-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCombinedStatusForRefParams
			Response = ReposGetCombinedStatusForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCombinedStatusForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCombinedStatusForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCombinedStatusForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitRequest handles repos/get-commit operation.
//
// Returns the contents of a single commit reference. You must have `read` access for the repository
// to use this endpoint.
// **Note:** If there are more than 300 files in the commit diff, the response will include
// pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains
// the static commit information, and the only changes are to the file listing.
// You can pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and
// `patch` formats. Diffs with binary data will have no `patch` property.
// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
// type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header.
//
//	You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local
//
// reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (s *Server) handleReposGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommit",
			OperationID:   "repos/get-commit",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitParams
			Response = ReposGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitActivityStatsRequest handles repos/get-commit-activity-stats operation.
//
// Returns the last year of commit activity grouped by week. The `days` array is a group of commits
// per day, starting on `Sunday`.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (s *Server) handleReposGetCommitActivityStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitActivityStats",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCommitActivityStats
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCommitActivityStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitActivityStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitActivityStats",
			OperationID:   "repos/get-commit-activity-stats",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitActivityStatsParams
			Response = ReposGetCommitActivityStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitActivityStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitActivityStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitActivityStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitCommentRequest handles repos/get-commit-comment operation.
//
// Get a commit comment.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposGetCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitComment",
			OperationID:   "repos/get-commit-comment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitCommentParams
			Response = ReposGetCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitComment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommitSignatureProtectionRequest handles repos/get-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// check whether a branch requires signed commits. An enabled status of `true` indicates you must
// sign commits on this branch. For more information, see [Signing commits with GPG](https://help.
// github.com/articles/signing-commits-with-gpg) in GitHub Help.
// **Note**: You must enable branch protection to require signed commits.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposGetCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCommitSignatureProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCommitSignatureProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommitSignatureProtection",
			OperationID:   "repos/get-commit-signature-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitSignatureProtectionParams
			Response = ReposGetCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetCommunityProfileMetricsRequest handles repos/get-community-profile-metrics operation.
//
// This endpoint will return all community profile metrics, including an
// overall health score, repository description, the presence of documentation, detected
// code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
// README, and CONTRIBUTING files.
// The `health_percentage` score is defined as a percentage of how many of
// these four documents are present: README, CONTRIBUTING, LICENSE, and
// CODE_OF_CONDUCT. For example, if all four documents are present, then
// the `health_percentage` is `100`. If only one is present, then the
// `health_percentage` is `25`.
// `content_reports_enabled` is only returned for organization-owned repositories.
//
// GET /repos/{owner}/{repo}/community/profile
func (s *Server) handleReposGetCommunityProfileMetricsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommunityProfileMetrics",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetCommunityProfileMetrics
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetCommunityProfileMetricsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CommunityProfile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetCommunityProfileMetrics",
			OperationID:   "repos/get-community-profile-metrics",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommunityProfileMetricsParams
			Response = *CommunityProfile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommunityProfileMetricsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommunityProfileMetrics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommunityProfileMetrics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetContributorsStatsRequest handles repos/get-contributors-stats operation.
//
// Returns the `total` number of commits authored by the contributor. In addition, the response
// includes a Weekly Hash (`weeks` array) with the following information:
// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
// *   `a` - Number of additions
// *   `d` - Number of deletions
// *   `c` - Number of commits.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (s *Server) handleReposGetContributorsStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetContributorsStats",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetContributorsStats
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetContributorsStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetContributorsStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetContributorsStats",
			OperationID:   "repos/get-contributors-stats",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetContributorsStatsParams
			Response = ReposGetContributorsStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetContributorsStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetContributorsStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetContributorsStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeployKeyRequest handles repos/get-deploy-key operation.
//
// Get a deploy key.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposGetDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployKey",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetDeployKey
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetDeployKeyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeployKey",
			OperationID:   "repos/get-deploy-key",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeployKeyParams
			Response = ReposGetDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeployKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeployKey(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeploymentRequest handles repos/get-deployment operation.
//
// Get a deployment.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposGetDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetDeployment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetDeploymentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeployment",
			OperationID:   "repos/get-deployment",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentParams
			Response = ReposGetDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeployment(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetDeploymentStatusRequest handles repos/get-deployment-status operation.
//
// Users with pull access can view a deployment status for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (s *Server) handleReposGetDeploymentStatusRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetDeploymentStatus
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetDeploymentStatusParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetDeploymentStatus",
			OperationID:   "repos/get-deployment-status",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
				{
					Name: "status_id",
					In:   "path",
				}: params.StatusID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentStatusParams
			Response = ReposGetDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeploymentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeploymentStatus(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetLatestPagesBuildRequest handles repos/get-latest-pages-build operation.
//
// Get latest Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (s *Server) handleReposGetLatestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetLatestPagesBuild
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetLatestPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetLatestPagesBuild",
			OperationID:   "repos/get-latest-pages-build",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestPagesBuildParams
			Response = *PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetLatestPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetLatestPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetLatestReleaseRequest handles repos/get-latest-release operation.
//
// View the latest published full release for the repository.
// The latest release is the most recent non-prerelease, non-draft release, sorted by the
// `created_at` attribute. The `created_at` attribute is the date of the commit used for the release,
// and not the date when the release was drafted or published.
//
// GET /repos/{owner}/{repo}/releases/latest
func (s *Server) handleReposGetLatestReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetLatestRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetLatestReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Release
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetLatestRelease",
			OperationID:   "repos/get-latest-release",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestReleaseParams
			Response = *Release
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetLatestRelease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetLatestRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesRequest handles repos/get-pages operation.
//
// Get a GitHub Pages site.
//
// GET /repos/{owner}/{repo}/pages
func (s *Server) handleReposGetPagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPages",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetPages
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetPagesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPagesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPages",
			OperationID:   "repos/get-pages",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesParams
			Response = ReposGetPagesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPages(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesBuildRequest handles repos/get-pages-build operation.
//
// Get GitHub Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (s *Server) handleReposGetPagesBuildRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesBuild",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetPagesBuild
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPagesBuild",
			OperationID:   "repos/get-pages-build",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "build_id",
					In:   "path",
				}: params.BuildID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesBuildParams
			Response = *PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPagesHealthCheckRequest handles repos/get-pages-health-check operation.
//
// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
// GitHub Pages.
// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous
// background task to get the results for the domain. After the background task completes, subsequent
// requests to this endpoint return a `200 OK` status with the health check results in the response.
// Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and
// `administration:write` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/pages/health
func (s *Server) handleReposGetPagesHealthCheckRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesHealthCheck",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetPagesHealthCheck
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetPagesHealthCheckParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPagesHealthCheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPagesHealthCheck",
			OperationID:   "repos/get-pages-health-check",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesHealthCheckParams
			Response = ReposGetPagesHealthCheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesHealthCheckParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPagesHealthCheck(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPagesHealthCheck(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetParticipationStatsRequest handles repos/get-participation-stats operation.
//
// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
// everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit
// counts for non-owners, you can subtract `owner` from `all`.
// The array order is oldest week (index 0) to most recent week.
//
// GET /repos/{owner}/{repo}/stats/participation
func (s *Server) handleReposGetParticipationStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetParticipationStats",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetParticipationStats
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetParticipationStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetParticipationStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetParticipationStats",
			OperationID:   "repos/get-participation-stats",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParticipationStatsParams
			Response = ReposGetParticipationStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParticipationStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetParticipationStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetParticipationStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPullRequestReviewProtectionRequest handles repos/get-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposGetPullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetPullRequestReviewProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetPullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ProtectedBranchPullRequestReview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPullRequestReviewProtection",
			OperationID:   "repos/get-pull-request-review-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPullRequestReviewProtectionParams
			Response = *ProtectedBranchPullRequestReview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPullRequestReviewProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetPunchCardStatsRequest handles repos/get-punch-card-stats operation.
//
// Each array contains the day number, hour number, and number of commits:
// *   `0-6`: Sunday - Saturday
// *   `0-23`: Hour of day
// *   Number of commits
// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on
// Tuesdays. All times are based on the time zone of individual commits.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (s *Server) handleReposGetPunchCardStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPunchCardStats",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetPunchCardStats
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetPunchCardStatsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetPunchCardStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetPunchCardStats",
			OperationID:   "repos/get-punch-card-stats",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPunchCardStatsParams
			Response = ReposGetPunchCardStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPunchCardStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPunchCardStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPunchCardStats(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReadmeRequest handles repos/get-readme operation.
//
// Gets the preferred README for a repository.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme
func (s *Server) handleReposGetReadmeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadme",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetReadme
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetReadmeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReadmeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReadme",
			OperationID:   "repos/get-readme",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeParams
			Response = ReposGetReadmeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReadme(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReadme(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReadmeInDirectoryRequest handles repos/get-readme-in-directory operation.
//
// Gets the README from a repository directory.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (s *Server) handleReposGetReadmeInDirectoryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadmeInDirectory",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetReadmeInDirectory
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetReadmeInDirectoryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReadmeInDirectoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReadmeInDirectory",
			OperationID:   "repos/get-readme-in-directory",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "dir",
					In:   "path",
				}: params.Dir,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeInDirectoryParams
			Response = ReposGetReadmeInDirectoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeInDirectoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReadmeInDirectory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReadmeInDirectory(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeInDirectoryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseRequest handles repos/get-release operation.
//
// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release
// assets. This key is a [hypermedia resource](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia).
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposGetReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetRelease",
			OperationID:   "repos/get-release",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseParams
			Response = ReposGetReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetRelease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetRelease(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseAssetRequest handles repos/get-release-asset operation.
//
// To download the asset's binary content, set the `Accept` header of the request to
// [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
// either redirect the client to the location, or stream it directly if possible. API clients should
// handle both a `200` or `302` response.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposGetReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetReleaseAsset
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseAssetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReleaseAsset",
			OperationID:   "repos/get-release-asset",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseAssetParams
			Response = ReposGetReleaseAssetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReleaseAsset(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseAsset(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetReleaseByTagRequest handles repos/get-release-by-tag operation.
//
// Get a published release with the specified tag.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (s *Server) handleReposGetReleaseByTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseByTag",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetReleaseByTag
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetReleaseByTagParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetReleaseByTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetReleaseByTag",
			OperationID:   "repos/get-release-by-tag",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tag",
					In:   "path",
				}: params.Tag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseByTagParams
			Response = ReposGetReleaseByTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseByTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReleaseByTag(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseByTag(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetStatusChecksProtectionRequest handles repos/get-status-checks-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposGetStatusChecksProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetStatusChecksProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetStatusChecksProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetStatusChecksProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetStatusChecksProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetStatusChecksProtection",
			OperationID:   "repos/get-status-checks-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetStatusChecksProtectionParams
			Response = ReposGetStatusChecksProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetStatusChecksProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetStatusChecksProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetStatusChecksProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTeamsWithAccessToProtectedBranchRequest handles repos/get-teams-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the teams who have push access to this branch. The list includes child teams.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposGetTeamsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTeamsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetTeamsWithAccessToProtectedBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTeamsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTeamsWithAccessToProtectedBranch",
			OperationID:   "repos/get-teams-with-access-to-protected-branch",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTeamsWithAccessToProtectedBranchParams
			Response = ReposGetTeamsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTeamsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTopPathsRequest handles repos/get-top-paths operation.
//
// Get the top 10 popular contents over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (s *Server) handleReposGetTopPathsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopPaths",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetTopPaths
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetTopPathsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTopPathsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTopPaths",
			OperationID:   "repos/get-top-paths",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopPathsParams
			Response = ReposGetTopPathsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopPathsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTopPaths(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTopPaths(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetTopReferrersRequest handles repos/get-top-referrers operation.
//
// Get the top 10 referrers over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (s *Server) handleReposGetTopReferrersRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopReferrers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetTopReferrers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetTopReferrersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetTopReferrersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetTopReferrers",
			OperationID:   "repos/get-top-referrers",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopReferrersParams
			Response = ReposGetTopReferrersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopReferrersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTopReferrers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTopReferrers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetUsersWithAccessToProtectedBranchRequest handles repos/get-users-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the people who have push access to this branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposGetUsersWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetUsersWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetUsersWithAccessToProtectedBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetUsersWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetUsersWithAccessToProtectedBranch",
			OperationID:   "repos/get-users-with-access-to-protected-branch",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetUsersWithAccessToProtectedBranchParams
			Response = ReposGetUsersWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetUsersWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetViewsRequest handles repos/get-views operation.
//
// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/views
func (s *Server) handleReposGetViewsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetViews",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetViews
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetViewsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetViewsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetViews",
			OperationID:   "repos/get-views",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per",
					In:   "query",
				}: params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetViewsParams
			Response = ReposGetViewsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetViewsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetViews(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetViews(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetViewsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookRequest handles repos/get-webhook operation.
//
// Returns a webhook configured in a repository. To get only the webhook `config` properties, see
// "[Get a webhook configuration for a
// repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposGetWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhook",
			OperationID:   "repos/get-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookParams
			Response = ReposGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookConfigForRepoRequest handles repos/get-webhook-config-for-repo operation.
//
// Returns the webhook configuration for a repository. To get more information about the webhook,
// including the `active` state and `events`, use "[Get a repository
// webhook](/rest/reference/orgs#get-a-repository-webhook)."
// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:read` permission.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposGetWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetWebhookConfigForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetWebhookConfigForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhookConfigForRepo",
			OperationID:   "repos/get-webhook-config-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookConfigForRepoParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhookConfigForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookConfigForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposGetWebhookDeliveryRequest handles repos/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleReposGetWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposGetWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposGetWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposGetWebhookDelivery",
			OperationID:   "repos/get-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookDeliveryParams
			Response = ReposGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListAutolinksRequest handles repos/list-autolinks operation.
//
// This returns a list of autolinks configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposListAutolinksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListAutolinks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListAutolinks
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListAutolinksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Autolink
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListAutolinks",
			OperationID:   "repos/list-autolinks",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListAutolinksParams
			Response = []Autolink
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListAutolinksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListAutolinks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListAutolinks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListBranchesRequest handles repos/list-branches operation.
//
// List branches.
//
// GET /repos/{owner}/{repo}/branches
func (s *Server) handleReposListBranchesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranches",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListBranches
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListBranchesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListBranchesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListBranches",
			OperationID:   "repos/list-branches",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "protected",
					In:   "query",
				}: params.Protected,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesParams
			Response = ReposListBranchesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListBranches(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListBranches(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListBranchesForHeadCommitRequest handles repos/list-branches-for-head-commit operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (s *Server) handleReposListBranchesForHeadCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranchesForHeadCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListBranchesForHeadCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListBranchesForHeadCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListBranchesForHeadCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListBranchesForHeadCommit",
			OperationID:   "repos/list-branches-for-head-commit",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesForHeadCommitParams
			Response = ReposListBranchesForHeadCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesForHeadCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListBranchesForHeadCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListBranchesForHeadCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesForHeadCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCollaboratorsRequest handles repos/list-collaborators operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators
func (s *Server) handleReposListCollaboratorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCollaborators",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListCollaborators
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListCollaboratorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCollaborators",
			OperationID:   "repos/list-collaborators",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCollaboratorsParams
			Response = ReposListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCollaborators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommentsForCommitRequest handles repos/list-comments-for-commit operation.
//
// Use the `:commit_sha` to specify the commit that will have its comments listed.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposListCommentsForCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommentsForCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListCommentsForCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListCommentsForCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListCommentsForCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommentsForCommit",
			OperationID:   "repos/list-comments-for-commit",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommentsForCommitParams
			Response = *ReposListCommentsForCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommentsForCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommentsForCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommentsForCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitCommentsForRepoRequest handles repos/list-commit-comments-for-repo operation.
//
// Commit Comments use [these custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types). You can read more about the use of media types in
// the API [here](https://docs.github.com/rest/overview/media-types/).
// Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/comments
func (s *Server) handleReposListCommitCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListCommitCommentsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListCommitCommentsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListCommitCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommitCommentsForRepo",
			OperationID:   "repos/list-commit-comments-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitCommentsForRepoParams
			Response = *ReposListCommitCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommitCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommitCommentsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitStatusesForRefRequest handles repos/list-commit-statuses-for-ref operation.
//
// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a
// SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
// status in the list will be the latest one.
// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (s *Server) handleReposListCommitStatusesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitStatusesForRef",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListCommitStatusesForRef
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListCommitStatusesForRefParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommitStatusesForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommitStatusesForRef",
			OperationID:   "repos/list-commit-statuses-for-ref",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitStatusesForRefParams
			Response = ReposListCommitStatusesForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitStatusesForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommitStatusesForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommitStatusesForRef(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListCommitsRequest handles repos/list-commits operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits
func (s *Server) handleReposListCommitsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListCommits
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListCommits",
			OperationID:   "repos/list-commits",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "query",
				}: params.Sha,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "author",
					In:   "query",
				}: params.Author,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "until",
					In:   "query",
				}: params.Until,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitsParams
			Response = ReposListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListContributorsRequest handles repos/list-contributors operation.
//
// Lists contributors to the specified repository and sorts them by the number of commits per
// contributor in descending order. This endpoint may return information that is a few hours old
// because the GitHub REST API v3 caches contributor data to improve performance.
// GitHub identifies contributors by author email address. This endpoint groups contribution counts
// by GitHub user, which includes all associated email addresses. To improve performance, only the
// first 500 author email addresses in the repository link to GitHub users. The rest will appear as
// anonymous contributors without associated GitHub user information.
//
// GET /repos/{owner}/{repo}/contributors
func (s *Server) handleReposListContributorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListContributors",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListContributors
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListContributorsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListContributorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListContributors",
			OperationID:   "repos/list-contributors",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "anon",
					In:   "query",
				}: params.Anon,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListContributorsParams
			Response = ReposListContributorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListContributorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListContributors(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListContributors(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListContributorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeployKeysRequest handles repos/list-deploy-keys operation.
//
// List deploy keys.
//
// GET /repos/{owner}/{repo}/keys
func (s *Server) handleReposListDeployKeysRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployKeys",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListDeployKeys
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListDeployKeysParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListDeployKeysOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeployKeys",
			OperationID:   "repos/list-deploy-keys",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeployKeysParams
			Response = *ReposListDeployKeysOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeployKeysParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeployKeys(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeployKeys(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeploymentStatusesRequest handles repos/list-deployment-statuses operation.
//
// Users with pull access can view deployment statuses for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposListDeploymentStatusesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeploymentStatuses",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListDeploymentStatuses
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListDeploymentStatusesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListDeploymentStatusesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeploymentStatuses",
			OperationID:   "repos/list-deployment-statuses",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentStatusesParams
			Response = ReposListDeploymentStatusesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentStatusesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeploymentStatuses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeploymentStatuses(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListDeploymentsRequest handles repos/list-deployments operation.
//
// Simple filtering of deployments is available via query parameters:.
//
// GET /repos/{owner}/{repo}/deployments
func (s *Server) handleReposListDeploymentsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployments",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListDeployments
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListDeploymentsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListDeploymentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListDeployments",
			OperationID:   "repos/list-deployments",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "query",
				}: params.Sha,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "task",
					In:   "query",
				}: params.Task,
				{
					Name: "environment",
					In:   "query",
				}: params.Environment,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentsParams
			Response = *ReposListDeploymentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeployments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeployments(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForAuthenticatedUserRequest handles repos/list-for-authenticated-user operation.
//
// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
//
// GET /user/repos
func (s *Server) handleReposListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForAuthenticatedUser",
			OperationID:   "repos/list-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForAuthenticatedUserParams
			Response = ReposListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForOrgRequest handles repos/list-for-org operation.
//
// Lists repositories for the specified organization.
//
// GET /orgs/{org}/repos
func (s *Server) handleReposListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForOrg",
			OperationID:   "repos/list-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForOrgParams
			Response = *ReposListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForUserRequest handles repos/list-for-user operation.
//
// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list
// internal repositories for the specified user.
//
// GET /users/{username}/repos
func (s *Server) handleReposListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForUser",
			OperationID:   "repos/list-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForUserParams
			Response = *ReposListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListForksRequest handles repos/list-forks operation.
//
// List forks.
//
// GET /repos/{owner}/{repo}/forks
func (s *Server) handleReposListForksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListForks
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListForksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListForks",
			OperationID:   "repos/list-forks",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForksParams
			Response = ReposListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListInvitationsRequest handles repos/list-invitations operation.
//
// When authenticating as a user with admin rights to a repository, this endpoint will list all
// currently open repository invitations.
//
// GET /repos/{owner}/{repo}/invitations
func (s *Server) handleReposListInvitationsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListInvitations
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListInvitationsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListInvitationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListInvitations",
			OperationID:   "repos/list-invitations",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsParams
			Response = *ReposListInvitationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListInvitations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListInvitationsForAuthenticatedUserRequest handles repos/list-invitations-for-authenticated-user operation.
//
// When authenticating as a user, this endpoint will list all currently open repository invitations
// for that user.
//
// GET /user/repository_invitations
func (s *Server) handleReposListInvitationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListInvitationsForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListInvitationsForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListInvitationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListInvitationsForAuthenticatedUser",
			OperationID:   "repos/list-invitations-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsForAuthenticatedUserParams
			Response = ReposListInvitationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListLanguagesRequest handles repos/list-languages operation.
//
// Lists languages for the specified repository. The value shown for each language is the number of
// bytes of code written in that language.
//
// GET /repos/{owner}/{repo}/languages
func (s *Server) handleReposListLanguagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListLanguages",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListLanguages
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListLanguagesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response Language
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListLanguages",
			OperationID:   "repos/list-languages",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListLanguagesParams
			Response = Language
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListLanguagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListLanguages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListLanguages(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPagesBuildsRequest handles repos/list-pages-builds operation.
//
// List GitHub Pages builds.
//
// GET /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposListPagesBuildsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPagesBuilds",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListPagesBuilds
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListPagesBuildsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListPagesBuildsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPagesBuilds",
			OperationID:   "repos/list-pages-builds",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPagesBuildsParams
			Response = *ReposListPagesBuildsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPagesBuildsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPagesBuilds(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPagesBuilds(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPublicRequest handles repos/list-public operation.
//
// Lists all public repositories in the order that they were created.
// Note:
// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users
// on the enterprise.
// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page
// of repositories.
//
// GET /repositories
func (s *Server) handleReposListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPublic",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListPublic
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListPublicParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPublic",
			OperationID:   "repos/list-public",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPublicParams
			Response = ReposListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPublicParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPublic(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPublic(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPublicResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListPullRequestsAssociatedWithCommitRequest handles repos/list-pull-requests-associated-with-commit operation.
//
// Lists the merged pull request that introduced the commit to the repository. If the commit is not
// present in the default branch, additionally returns open pull requests associated with the commit.
// The results may include open and closed pull requests. Additional preview headers may be required
// to see certain details for associated pull requests, such as whether a pull request is in a draft
// state. For more information about previews that might affect this endpoint, see the [List pull
// requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (s *Server) handleReposListPullRequestsAssociatedWithCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPullRequestsAssociatedWithCommit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListPullRequestsAssociatedWithCommit
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListPullRequestsAssociatedWithCommitParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListPullRequestsAssociatedWithCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListPullRequestsAssociatedWithCommit",
			OperationID:   "repos/list-pull-requests-associated-with-commit",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPullRequestsAssociatedWithCommitParams
			Response = *ReposListPullRequestsAssociatedWithCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPullRequestsAssociatedWithCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListReleaseAssetsRequest handles repos/list-release-assets operation.
//
// List release assets.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposListReleaseAssetsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleaseAssets",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListReleaseAssets
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListReleaseAssetsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListReleaseAssetsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListReleaseAssets",
			OperationID:   "repos/list-release-assets",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleaseAssetsParams
			Response = *ReposListReleaseAssetsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleaseAssetsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListReleaseAssets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListReleaseAssets(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListReleasesRequest handles repos/list-releases operation.
//
// This returns a list of releases, which does not include regular Git tags that have not been
// associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.
// github.com/rest/reference/repos#list-repository-tags).
// Information about published releases are available to everyone. Only users with push access will
// receive listings for draft releases.
//
// GET /repos/{owner}/{repo}/releases
func (s *Server) handleReposListReleasesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleases",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListReleases
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListReleasesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListReleasesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListReleases",
			OperationID:   "repos/list-releases",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleasesParams
			Response = ReposListReleasesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleasesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListReleases(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListReleases(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleasesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListTagsRequest handles repos/list-tags operation.
//
// List repository tags.
//
// GET /repos/{owner}/{repo}/tags
func (s *Server) handleReposListTagsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTags",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListTags
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListTagsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListTagsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListTags",
			OperationID:   "repos/list-tags",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTagsParams
			Response = *ReposListTagsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTagsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListTags(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListTags(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTagsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListTeamsRequest handles repos/list-teams operation.
//
// List repository teams.
//
// GET /repos/{owner}/{repo}/teams
func (s *Server) handleReposListTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTeams",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListTeams
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListTeamsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposListTeamsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListTeams",
			OperationID:   "repos/list-teams",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTeamsParams
			Response = *ReposListTeamsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTeamsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListTeams(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListTeams(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTeamsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListWebhookDeliveriesRequest handles repos/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (s *Server) handleReposListWebhookDeliveriesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListWebhookDeliveries
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListWebhookDeliveriesParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListWebhookDeliveries",
			OperationID:   "repos/list-webhook-deliveries",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhookDeliveriesParams
			Response = ReposListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhookDeliveriesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposListWebhooksRequest handles repos/list-webhooks operation.
//
// List repository webhooks.
//
// GET /repos/{owner}/{repo}/hooks
func (s *Server) handleReposListWebhooksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhooks",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposListWebhooks
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposListWebhooksParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposListWebhooks",
			OperationID:   "repos/list-webhooks",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhooksParams
			Response = ReposListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListWebhooks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListWebhooks(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposMergeRequest handles repos/merge operation.
//
// Merge a branch.
//
// POST /repos/{owner}/{repo}/merges
func (s *Server) handleReposMergeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMerge",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposMerge
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposMergeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposMerge",
			OperationID:   "repos/merge",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposMergeReq
			Params   = ReposMergeParams
			Response = ReposMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposMerge(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposMerge(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposMergeUpstreamRequest handles repos/merge-upstream operation.
//
// **Note:** This endpoint is currently in beta and subject to change.
// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (s *Server) handleReposMergeUpstreamRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMergeUpstream",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposMergeUpstream
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposMergeUpstreamParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposMergeUpstreamRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeUpstreamRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposMergeUpstream",
			OperationID:   "repos/merge-upstream",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposMergeUpstreamReq
			Params   = ReposMergeUpstreamParams
			Response = ReposMergeUpstreamRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeUpstreamParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposMergeUpstream(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposMergeUpstream(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposPingWebhookRequest handles repos/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (s *Server) handleReposPingWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposPingWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposPingWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposPingWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposPingWebhook",
			OperationID:   "repos/ping-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposPingWebhookParams
			Response = ReposPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposPingWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposPingWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRedeliverWebhookDeliveryRequest handles repos/redeliver-webhook-delivery operation.
//
// Redeliver a webhook delivery for a webhook configured in a repository.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleReposRedeliverWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRedeliverWebhookDelivery
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRedeliverWebhookDelivery",
			OperationID:   "repos/redeliver-webhook-delivery",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRedeliverWebhookDeliveryParams
			Response = ReposRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveAppAccessRestrictionsRequest handles repos/remove-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposRemoveAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveAppAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveAppAccessRestrictions",
			OperationID:   "repos/remove-app-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveAppAccessRestrictionsReq
			Params   = ReposRemoveAppAccessRestrictionsParams
			Response = ReposRemoveAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveCollaboratorRequest handles repos/remove-collaborator operation.
//
// Remove a repository collaborator.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposRemoveCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveCollaborator
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveCollaboratorParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposRemoveCollaboratorNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveCollaborator",
			OperationID:   "repos/remove-collaborator",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveCollaboratorParams
			Response = *ReposRemoveCollaboratorNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposRemoveCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposRemoveCollaborator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveStatusCheckContextsRequest handles repos/remove-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposRemoveStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveStatusCheckContexts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveStatusCheckContexts",
			OperationID:   "repos/remove-status-check-contexts",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveStatusCheckContextsReq
			Params   = ReposRemoveStatusCheckContextsParams
			Response = ReposRemoveStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveStatusCheckProtectionRequest handles repos/remove-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposRemoveStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveStatusCheckProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveStatusCheckProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ReposRemoveStatusCheckProtectionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveStatusCheckProtection",
			OperationID:   "repos/remove-status-check-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveStatusCheckProtectionParams
			Response = *ReposRemoveStatusCheckProtectionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposRemoveStatusCheckProtection(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposRemoveStatusCheckProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveTeamAccessRestrictionsRequest handles repos/remove-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a team to push to this branch. You can also remove push access for child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The
// list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposRemoveTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveTeamAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveTeamAccessRestrictions",
			OperationID:   "repos/remove-team-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveTeamAccessRestrictionsReq
			Params   = ReposRemoveTeamAccessRestrictionsParams
			Response = ReposRemoveTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRemoveUserAccessRestrictionsRequest handles repos/remove-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a user to push to this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposRemoveUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRemoveUserAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRemoveUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRemoveUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRemoveUserAccessRestrictions",
			OperationID:   "repos/remove-user-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveUserAccessRestrictionsReq
			Params   = ReposRemoveUserAccessRestrictionsParams
			Response = ReposRemoveUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRenameBranchRequest handles repos/rename-branch operation.
//
// Renames a branch in a repository.
// **Note:** Although the API responds immediately, the branch rename process might take some extra
// time to complete in the background. You won't be able to push to the old branch name while the
// rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.
// com/github/administering-a-repository/renaming-a-branch)".
// The permissions required to use this endpoint depends on whether you are renaming the default
// branch.
// To rename a non-default branch:
// * Users must have push access.
// * GitHub Apps must have the `contents:write` repository permission.
// To rename the default branch:
// * Users must have admin or owner permissions.
// * GitHub Apps must have the `administration:write` repository permission.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (s *Server) handleReposRenameBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRenameBranch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRenameBranch
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRenameBranchParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposRenameBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRenameBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRenameBranch",
			OperationID:   "repos/rename-branch",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRenameBranchReq
			Params   = ReposRenameBranchParams
			Response = ReposRenameBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRenameBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRenameBranch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRenameBranch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRenameBranchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposReplaceAllTopicsRequest handles repos/replace-all-topics operation.
//
// Replace all repository topics.
//
// PUT /repos/{owner}/{repo}/topics
func (s *Server) handleReposReplaceAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposReplaceAllTopics",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposReplaceAllTopics
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposReplaceAllTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposReplaceAllTopicsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposReplaceAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposReplaceAllTopics",
			OperationID:   "repos/replace-all-topics",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposReplaceAllTopicsReq
			Params   = ReposReplaceAllTopicsParams
			Response = ReposReplaceAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposReplaceAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposReplaceAllTopics(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposReplaceAllTopics(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposRequestPagesBuildRequest handles repos/request-pages-build operation.
//
// You can request that your site be built from the latest revision on the default branch. This has
// the same effect as pushing a commit to your default branch, but does not require an additional
// commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
// Build requests are limited to one concurrent build per repository and one concurrent build per
// requester. If you request a build while another is still in progress, the second request will be
// queued until the first completes.
//
// POST /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposRequestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRequestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposRequestPagesBuild
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposRequestPagesBuildParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PageBuildStatus
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposRequestPagesBuild",
			OperationID:   "repos/request-pages-build",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRequestPagesBuildParams
			Response = *PageBuildStatus
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRequestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRequestPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRequestPagesBuild(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetAdminBranchProtectionRequest handles repos/set-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Adding admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposSetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposSetAdminBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposSetAdminBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetAdminBranchProtection",
			OperationID:   "repos/set-admin-branch-protection",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposSetAdminBranchProtectionParams
			Response = *ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetAppAccessRestrictionsRequest handles repos/set-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of apps that have push access to this branch. This removes all apps that
// previously had push access and grants push access to the new list of apps. Only installed GitHub
// Apps with `write` access to the `contents` permission can be added as authorized actors on a
// protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposSetAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposSetAppAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposSetAppAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetAppAccessRestrictions",
			OperationID:   "repos/set-app-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetAppAccessRestrictionsReq
			Params   = ReposSetAppAccessRestrictionsParams
			Response = ReposSetAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAppAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetStatusCheckContextsRequest handles repos/set-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposSetStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposSetStatusCheckContexts
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposSetStatusCheckContextsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetStatusCheckContexts",
			OperationID:   "repos/set-status-check-contexts",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetStatusCheckContextsReq
			Params   = ReposSetStatusCheckContextsParams
			Response = ReposSetStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetStatusCheckContextsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetTeamAccessRestrictionsRequest handles repos/set-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of teams that have push access to this branch. This removes all teams that
// previously had push access and grants push access to the new list of teams. Team restrictions
// include child teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposSetTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposSetTeamAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposSetTeamAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetTeamAccessRestrictions",
			OperationID:   "repos/set-team-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetTeamAccessRestrictionsReq
			Params   = ReposSetTeamAccessRestrictionsParams
			Response = ReposSetTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetTeamAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposSetUserAccessRestrictionsRequest handles repos/set-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of people that have push access to this branch. This removes all people that
// previously had push access and grants push access to the new list of people.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposSetUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposSetUserAccessRestrictions
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposSetUserAccessRestrictionsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposSetUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposSetUserAccessRestrictions",
			OperationID:   "repos/set-user-access-restrictions",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetUserAccessRestrictionsReq
			Params   = ReposSetUserAccessRestrictionsParams
			Response = ReposSetUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetUserAccessRestrictionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposTestPushWebhookRequest handles repos/test-push-webhook operation.
//
// This will trigger the hook with the latest push to the current repository if the hook is
// subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
// respond with 204 but no test POST will be generated.
// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (s *Server) handleReposTestPushWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTestPushWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposTestPushWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposTestPushWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReposTestPushWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposTestPushWebhook",
			OperationID:   "repos/test-push-webhook",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposTestPushWebhookParams
			Response = ReposTestPushWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTestPushWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposTestPushWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposTestPushWebhook(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposTransferRequest handles repos/transfer operation.
//
// A transfer request will need to be accepted by the new owner when transferring a personal
// repository to another user. The response will contain the original `owner`, and the transfer will
// continue asynchronously. For more details on the requirements to transfer personal and
// organization-owned repositories, see [about repository transfers](https://help.github.
// com/articles/about-repository-transfers/).
//
// POST /repos/{owner}/{repo}/transfer
func (s *Server) handleReposTransferRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTransfer",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposTransfer
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposTransferParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposTransferRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *MinimalRepository
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposTransfer",
			OperationID:   "repos/transfer",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposTransferReq
			Params   = ReposTransferParams
			Response = *MinimalRepository
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTransferParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposTransfer(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposTransfer(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTransferResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateRequest handles repos/update operation.
//
// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.
// github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
//
// PATCH /repos/{owner}/{repo}
func (s *Server) handleReposUpdateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdate",
			OperationID:   "repos/update",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReq
			Params   = ReposUpdateParams
			Response = ReposUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateBranchProtectionRequest handles repos/update-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Protecting a branch requires admin or owner permissions to the repository.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
// **Note**: The list of users, apps, and teams in total is limited to 100 items.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposUpdateBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateBranchProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateBranchProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateBranchProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateBranchProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateBranchProtection",
			OperationID:   "repos/update-branch-protection",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUpdateBranchProtectionReq
			Params   = ReposUpdateBranchProtectionParams
			Response = ReposUpdateBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateBranchProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateBranchProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateCommitCommentRequest handles repos/update-commit-comment operation.
//
// Update a commit comment.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposUpdateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateCommitComment",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateCommitComment
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateCommitCommentParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateCommitComment",
			OperationID:   "repos/update-commit-comment",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUpdateCommitCommentReq
			Params   = ReposUpdateCommitCommentParams
			Response = ReposUpdateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateCommitComment(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateInvitationRequest handles repos/update-invitation operation.
//
// Update a repository invitation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposUpdateInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateInvitation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateInvitation
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateInvitationParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositoryInvitation
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateInvitation",
			OperationID:   "repos/update-invitation",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateInvitationReq
			Params   = ReposUpdateInvitationParams
			Response = *RepositoryInvitation
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateInvitation(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateInvitation(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdatePullRequestReviewProtectionRequest handles repos/update-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating pull request review enforcement requires admin or owner permissions to the repository and
// branch protection to be enabled.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposUpdatePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdatePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdatePullRequestReviewProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdatePullRequestReviewProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdatePullRequestReviewProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdatePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdatePullRequestReviewProtection",
			OperationID:   "repos/update-pull-request-review-protection",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdatePullRequestReviewProtectionReq
			Params   = ReposUpdatePullRequestReviewProtectionParams
			Response = ReposUpdatePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdatePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdatePullRequestReviewProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateReleaseRequest handles repos/update-release operation.
//
// Users with push access to the repository can edit a release.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposUpdateReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateRelease",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateRelease
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateReleaseParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateRelease",
			OperationID:   "repos/update-release",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseReq
			Params   = ReposUpdateReleaseParams
			Response = ReposUpdateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateRelease(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateReleaseAssetRequest handles repos/update-release-asset operation.
//
// Users with push access to the repository can edit a release asset.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposUpdateReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateReleaseAsset
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateReleaseAssetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ReleaseAsset
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateReleaseAsset",
			OperationID:   "repos/update-release-asset",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseAssetReq
			Params   = ReposUpdateReleaseAssetParams
			Response = *ReleaseAsset
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateReleaseAsset(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateReleaseAsset(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateStatusCheckProtectionRequest handles repos/update-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating required status checks requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposUpdateStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateStatusCheckProtection
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateStatusCheckProtectionParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateStatusCheckProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateStatusCheckProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateStatusCheckProtection",
			OperationID:   "repos/update-status-check-protection",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateStatusCheckProtectionReq
			Params   = ReposUpdateStatusCheckProtectionParams
			Response = ReposUpdateStatusCheckProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateStatusCheckProtectionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateWebhookRequest handles repos/update-webhook operation.
//
// Updates a webhook configured in a repository. If you previously had a `secret` set, you must
// provide the same `secret` or set a new `secret` or the secret will be removed. If you are only
// updating individual webhook `config` properties, use "[Update a webhook configuration for a
// repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposUpdateWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateWebhook
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateWebhookParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateWebhook",
			OperationID:   "repos/update-webhook",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookReq
			Params   = ReposUpdateWebhookParams
			Response = ReposUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUpdateWebhookConfigForRepoRequest handles repos/update-webhook-config-for-repo operation.
//
// Updates the webhook configuration for a repository. To update more information about the webhook,
// including the `active` state and `events`, use "[Update a repository
// webhook](/rest/reference/orgs#update-a-repository-webhook)."
// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:write` permission.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposUpdateWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUpdateWebhookConfigForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUpdateWebhookConfigForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUpdateWebhookConfigForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUpdateWebhookConfigForRepo",
			OperationID:   "repos/update-webhook-config-for-repo",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookConfigForRepoReq
			Params   = ReposUpdateWebhookConfigForRepoParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleReposUploadReleaseAssetRequest handles repos/upload-release-asset operation.
//
// This endpoint makes use of [a Hypermedia relation](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The
// endpoint you call to upload release assets is specific to your release. Use the `upload_url`
// returned in
// the response of the [Create a release endpoint](https://docs.github.
// com/rest/reference/repos#create-a-release) to upload a release asset.
// You need to use an HTTP client which supports [SNI](http://en.wikipedia.
// org/wiki/Server_Name_Indication) to make calls to this endpoint.
// Most libraries will set the required `Content-Length` header automatically. Use the required
// `Content-Type` header to provide the media type of the asset. For a list of media types, see
// [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
// `application/zip`
// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw
// binary content of the asset as the request body. Everything else about the endpoint is the same as
// the rest of the API. For example,
// you'll still need to pass your authentication to be able to upload an asset.
// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an
// empty asset with a state of `starter`. It can be safely deleted.
// **Notes:**
// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and
// leading or trailing periods. The "[List assets for a release](https://docs.github.
// com/rest/reference/repos#list-assets-for-a-release)"
// endpoint lists the renamed filenames. For more information and help, contact [GitHub
// Support](https://support.github.com/contact?tags=dotcom-rest-api).
// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an
// error and must delete the old file before you can re-upload the new asset.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposUploadReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/upload-release-asset"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUploadReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ReposUploadReleaseAsset
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeReposUploadReleaseAssetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeReposUploadReleaseAssetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ReleaseAsset
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ReposUploadReleaseAsset",
			OperationID:   "repos/upload-release-asset",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
				{
					Name: "name",
					In:   "query",
				}: params.Name,
				{
					Name: "label",
					In:   "query",
				}: params.Label,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUploadReleaseAssetReqWithContentType
			Params   = ReposUploadReleaseAssetParams
			Response = *ReleaseAsset
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUploadReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUploadReleaseAsset(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUploadReleaseAsset(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUploadReleaseAssetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleScimDeleteUserFromOrgRequest handles scim/delete-user-from-org operation.
//
// Delete a SCIM user from an organization.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (s *Server) handleScimDeleteUserFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ScimDeleteUserFromOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().ScimDeleteUserFromOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeScimDeleteUserFromOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ScimDeleteUserFromOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ScimDeleteUserFromOrg",
			OperationID:   "scim/delete-user-from-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ScimDeleteUserFromOrgParams
			Response = ScimDeleteUserFromOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackScimDeleteUserFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ScimDeleteUserFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ScimDeleteUserFromOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchCodeRequest handles search/code operation.
//
// Searches for query terms inside of a file. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for code, you can get text match metadata for the file **content** and file
// **path** fields when you pass the `text-match` media type. For more details about how to receive
// highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the definition of the `addClass` function inside
// [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
// `q=addClass+in:file+language:js+repo:jquery/jquery`
// This query searches for the keyword `addClass` within a file's contents. The query limits the
// search to files where the language is JavaScript in the `jquery/jquery` repository.
// #### Considerations for code search
// Due to the complexity of searching code, there are a few restrictions on how searches are
// performed:
// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
// *   Only files smaller than 384 KB are searchable.
// *   You must always include at least one search term when searching source code. For example,
// searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code)
// is not valid, while [`amazing
// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
//
// GET /search/code
func (s *Server) handleSearchCodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCode",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchCode
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchCodeParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchCode",
			OperationID:   "search/code",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCodeParams
			Response = SearchCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchCode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchCode(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCodeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchCommitsRequest handles search/commits operation.
//
// Find commits via various criteria on the default branch (usually `master`). This method returns up
// to 100 results [per page](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for commits, you can get text match metadata for the **message** field when you
// provide the `text-match` media type. For more details about how to receive highlighted search
// results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to find commits related to CSS in the
// [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look
// something like this:
// `q=repo:octocat/Spoon-Knife+css`.
//
// GET /search/commits
func (s *Server) handleSearchCommitsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCommits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchCommits
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchCommitsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchCommits",
			OperationID:   "search/commits",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCommitsParams
			Response = SearchCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchCommits(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCommitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchIssuesAndPullRequestsRequest handles search/issues-and-pull-requests operation.
//
// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for issues, you can get text match metadata for the issue **title**, issue **body**,
//
//	and issue **comment body** fields when you pass the `text-match` media type. For more details
//
// about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might
// look something like this.
// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The
// search runs across repositories whose primary language is Python. The results are sorted by
// creation date in ascending order, which means the oldest issues appear first in the search results.
// **Note:** For [user-to-server](https://docs.github.
// com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)
// GitHub App requests, you can't retrieve a combination of issues and pull requests in a single
// query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an
// HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you
// must send separate queries for issues and pull requests. For more information about the `is`
// qualifier, see "[Searching only issues or pull requests](https://docs.github.
// com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).".
//
// GET /search/issues
func (s *Server) handleSearchIssuesAndPullRequestsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchIssuesAndPullRequests",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchIssuesAndPullRequests
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchIssuesAndPullRequestsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchIssuesAndPullRequestsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchIssuesAndPullRequests",
			OperationID:   "search/issues-and-pull-requests",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchIssuesAndPullRequestsParams
			Response = SearchIssuesAndPullRequestsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchIssuesAndPullRequestsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchIssuesAndPullRequests(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchIssuesAndPullRequests(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchIssuesAndPullRequestsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchLabelsRequest handles search/labels operation.
//
// Find labels in a repository with names or descriptions that match search keywords. Returns up to
// 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for labels, you can get text match metadata for the label **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`,
// or `enhancement`. Your query might look like this:
// `q=bug+defect+enhancement&repository_id=64778136`
// The labels that best match the query appear first in the search results.
//
// GET /search/labels
func (s *Server) handleSearchLabelsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchLabels",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchLabels
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchLabelsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchLabels",
			OperationID:   "search/labels",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "query",
				}: params.RepositoryID,
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchLabelsParams
			Response = SearchLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchLabelsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchLabels(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchLabels(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchLabelsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchReposRequest handles search/repos operation.
//
// Find repositories via various criteria. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for repositories, you can get text match metadata for the **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to search for popular Tetris repositories written in assembly code, your
// query might look like this:
// `q=tetris+language:assembly&sort=stars&order=desc`
// This query searches for repositories with the word `tetris` in the name, the description, or the
// README. The results are limited to repositories where the primary language is assembly. The
// results are sorted by stars in descending order, so that the most popular repositories appear
// first in the search results.
// When you include the `mercy` preview header, you can also search for multiple topics by adding
// more `topic:` instances. For example, your query might look like this:
// `q=topic:ruby+topic:rails`.
//
// GET /search/repositories
func (s *Server) handleSearchReposRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchRepos",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchRepos
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchReposParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchReposRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchRepos",
			OperationID:   "search/repos",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchReposParams
			Response = SearchReposRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchReposParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchRepos(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchRepos(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchReposResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchTopicsRequest handles search/topics operation.
//
// Find topics via various criteria. Results are sorted by best match. This method returns up to 100
// results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list
// of qualifiers.
// When searching for topics, you can get text match metadata for the topic's **short\_description**,
// **description**, **name**, or **display\_name** field when you pass the `text-match` media type.
// For more details about how to receive highlighted search results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to search for topics related to Ruby that are featured on https://github.
// com/topics. Your query might look like this:
// `q=ruby+is:featured`
// This query searches for topics with the keyword `ruby` and limits the results to find only topics
// that are featured. The topics that are the best match for the query appear first in the search
// results.
//
// GET /search/topics
func (s *Server) handleSearchTopicsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchTopics",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchTopics
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchTopicsParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchTopics",
			OperationID:   "search/topics",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchTopicsParams
			Response = SearchTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchTopics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchTopics(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchTopicsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSearchUsersRequest handles search/users operation.
//
// Find users via various criteria. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for users, you can get text match metadata for the issue **login**, **email**, and
// **name** fields when you pass the `text-match` media type. For more details about highlighting
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you're looking for a list of popular users, you might try this query:
// `q=tom+repos:%3E42+followers:%3E1000`
// This query searches for users with the name `tom`. The results are restricted to users with more
// than 42 repositories and over 1,000 followers.
//
// GET /search/users
func (s *Server) handleSearchUsersRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchUsers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SearchUsers
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSearchUsersParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SearchUsers",
			OperationID:   "search/users",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchUsersParams
			Response = SearchUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchUsersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchUsers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchUsers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchUsersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningGetAlertRequest handles secret-scanning/get-alert operation.
//
// Gets a single secret scanning alert detected in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SecretScanningGetAlert
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSecretScanningGetAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningGetAlert",
			OperationID:   "secret-scanning/get-alert",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningGetAlertParams
			Response = SecretScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningGetAlert(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningGetAlert(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningListAlertsForOrgRequest handles secret-scanning/list-alerts-for-org operation.
//
// Lists all secret scanning alerts for all eligible repositories in an organization, from newest to
// oldest.
// To use this endpoint, you must be an administrator for the repository or organization, and you
// must use an access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /orgs/{org}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SecretScanningListAlertsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSecretScanningListAlertsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningListAlertsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningListAlertsForOrg",
			OperationID:   "secret-scanning/list-alerts-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "secret_type",
					In:   "query",
				}: params.SecretType,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForOrgParams
			Response = SecretScanningListAlertsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningListAlertsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningListAlertsForRepoRequest handles secret-scanning/list-alerts-for-repo operation.
//
// Lists all secret scanning alerts for a private repository, from newest to oldest. To use this
// endpoint, you must be an administrator for the repository or organization, and you must use an
// access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SecretScanningListAlertsForRepo
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSecretScanningListAlertsForRepoParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SecretScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningListAlertsForRepo",
			OperationID:   "secret-scanning/list-alerts-for-repo",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "secret_type",
					In:   "query",
				}: params.SecretType,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForRepoParams
			Response = SecretScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningListAlertsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleSecretScanningUpdateAlertRequest handles secret-scanning/update-alert operation.
//
// Updates the status of a secret scanning alert in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().SecretScanningUpdateAlert
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeSecretScanningUpdateAlertParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeSecretScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SecretScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "SecretScanningUpdateAlert",
			OperationID:   "secret-scanning/update-alert",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = *SecretScanningUpdateAlertReq
			Params   = SecretScanningUpdateAlertParams
			Response = SecretScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningUpdateAlert(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddMemberLegacyRequest handles teams/add-member-legacy operation.
//
// The "Add team member" endpoint (described below) is deprecated.
// We recommend using the [Add or update team membership for a user](https://docs.github.
// com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you
// to invite new organization members to your teams.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To add someone to a team, the authenticated user must be an organization owner or a team
// maintainer in the team they're changing. The person being added to the team must be a member of
// the team's organization.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/members/{username}
func (s *Server) handleTeamsAddMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddMemberLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsAddMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddMemberLegacy",
			OperationID:   "teams/add-member-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsAddMemberLegacyParams
			Response = TeamsAddMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserInOrgRequest handles teams/add-or-update-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Adds an organization member to a team. An authenticated organization owner or team maintainer can
// add organization members to a team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// An organization owner can add someone who is not part of the team's organization to a team. When
// an organization owner adds someone to a team who is not an organization member, this endpoint will
// send an invitation to the person via email. This newly-created membership will be in the "pending"
// state until the person accepts the invitation, at which point the membership will transition to
// the "active" state and the user will be added as a member of the team.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateMembershipForUserInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateMembershipForUserInOrg",
			OperationID:   "teams/add-or-update-membership-for-user-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserInOrgReq
			Params   = TeamsAddOrUpdateMembershipForUserInOrgParams
			Response = TeamsAddOrUpdateMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserLegacyRequest handles teams/add-or-update-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team membership for a
// user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// If the user is already a member of the team's organization, this endpoint will add the user to the
// team. To add a membership between an organization member and a team, the authenticated user must
// be an organization owner or a team maintainer.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to
// the user via email. This newly-created membership will be in the "pending" state until the user
// accepts the invitation, at which point the membership will transition to the "active" state and
// the user will be added as a member of the team. To add a membership between an unaffiliated user
// and a team, the authenticated user must be an organization owner.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateMembershipForUserLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateMembershipForUserLegacy",
			OperationID:   "teams/add-or-update-membership-for-user-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserLegacyReq
			Params   = TeamsAddOrUpdateMembershipForUserLegacyParams
			Response = TeamsAddOrUpdateMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsInOrgRequest handles teams/add-or-update-project-permissions-in-org operation.
//
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateProjectPermissionsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateProjectPermissionsInOrg",
			OperationID:   "teams/add-or-update-project-permissions-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq
			Params   = TeamsAddOrUpdateProjectPermissionsInOrgParams
			Response = TeamsAddOrUpdateProjectPermissionsInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsLegacyRequest handles teams/add-or-update-project-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team project
// permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions)
// endpoint.
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateProjectPermissionsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateProjectPermissionsLegacy",
			OperationID:   "teams/add-or-update-project-permissions-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateProjectPermissionsLegacyReq
			Params   = TeamsAddOrUpdateProjectPermissionsLegacyParams
			Response = TeamsAddOrUpdateProjectPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsInOrgRequest handles teams/add-or-update-repo-permissions-in-org operation.
//
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to
// set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP
// verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
// For more information about the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateRepoPermissionsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamsAddOrUpdateRepoPermissionsInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateRepoPermissionsInOrg",
			OperationID:   "teams/add-or-update-repo-permissions-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsInOrgReq
			Params   = TeamsAddOrUpdateRepoPermissionsInOrgParams
			Response = *TeamsAddOrUpdateRepoPermissionsInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsLegacyRequest handles teams/add-or-update-repo-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Add or update team repository
// permissions](https://docs.github.
// com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsAddOrUpdateRepoPermissionsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateRepoPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsAddOrUpdateRepoPermissionsLegacy",
			OperationID:   "teams/add-or-update-repo-permissions-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsLegacyReq
			Params   = TeamsAddOrUpdateRepoPermissionsLegacyParams
			Response = TeamsAddOrUpdateRepoPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForProjectInOrgRequest handles teams/check-permissions-for-project-in-org operation.
//
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCheckPermissionsForProjectInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForProjectInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForProjectInOrg",
			OperationID:   "teams/check-permissions-for-project-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectInOrgParams
			Response = TeamsCheckPermissionsForProjectInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForProjectLegacyRequest handles teams/check-permissions-for-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project)
// endpoint.
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCheckPermissionsForProjectLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForProjectLegacy",
			OperationID:   "teams/check-permissions-for-project-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectLegacyParams
			Response = TeamsCheckPermissionsForProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForRepoInOrgRequest handles teams/check-permissions-for-repo-in-org operation.
//
// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a
// repository. Repositories inherited through a parent team will also be checked.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response
// status.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCheckPermissionsForRepoInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForRepoInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForRepoInOrg",
			OperationID:   "teams/check-permissions-for-repo-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoInOrgParams
			Response = TeamsCheckPermissionsForRepoInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCheckPermissionsForRepoLegacyRequest handles teams/check-permissions-for-repo-legacy operation.
//
// **Note**: Repositories inherited through a parent team will also be checked.
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository)
// endpoint.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `Accept` header:.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCheckPermissionsForRepoLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsCheckPermissionsForRepoLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCheckPermissionsForRepoLegacy",
			OperationID:   "teams/check-permissions-for-repo-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoLegacyParams
			Response = TeamsCheckPermissionsForRepoLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateRequest handles teams/create operation.
//
// To create a team, the authenticated user must be a member or owner of `{org}`. By default,
// organization members can create teams. Organization owners can limit team creation to organization
// owners. For more information, see "[Setting team creation permissions](https://help.github.
// com/en/articles/setting-team-creation-permissions-in-your-organization)."
// When you create a new team, you automatically become a team maintainer without explicitly adding
// yourself to the optional array of `maintainers`. For more information, see "[About
// teams](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
//
// POST /orgs/{org}/teams
func (s *Server) handleTeamsCreateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreate
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreate",
			OperationID:   "teams/create",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateReq
			Params   = TeamsCreateParams
			Response = TeamsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreate(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionCommentInOrgRequest handles teams/create-discussion-comment-in-org operation.
//
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionCommentInOrg",
			OperationID:   "teams/create-discussion-comment-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionCommentInOrgReq
			Params   = TeamsCreateDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionCommentLegacyRequest handles teams/create-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Create a discussion
// comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionCommentLegacy",
			OperationID:   "teams/create-discussion-comment-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionCommentLegacyReq
			Params   = TeamsCreateDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionInOrgRequest handles teams/create-discussion-in-org operation.
//
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsCreateDiscussionInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionInOrg",
			OperationID:   "teams/create-discussion-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionInOrgReq
			Params   = TeamsCreateDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateDiscussionLegacyRequest handles teams/create-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.
// github.com/rest/reference/teams#create-a-discussion) endpoint.
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions
func (s *Server) handleTeamsCreateDiscussionLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateDiscussionLegacy",
			OperationID:   "teams/create-discussion-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionLegacyReq
			Params   = TeamsCreateDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest handles teams/create-or-update-idp-group-connections-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateOrUpdateIdpGroupConnectionsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
			OperationID:   "teams/create-or-update-idp-group-connections-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
			Response = *GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest handles teams/create-or-update-idp-group-connections-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create or update IdP group
// connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsCreateOrUpdateIdpGroupConnectionsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
			OperationID:   "teams/create-or-update-idp-group-connections-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams
			Response = TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionCommentInOrgRequest handles teams/delete-discussion-comment-in-org operation.
//
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsDeleteDiscussionCommentInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionCommentInOrg",
			OperationID:   "teams/delete-discussion-comment-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentInOrgParams
			Response = *TeamsDeleteDiscussionCommentInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionCommentLegacyRequest handles teams/delete-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a discussion
// comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsDeleteDiscussionCommentLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionCommentLegacy",
			OperationID:   "teams/delete-discussion-comment-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentLegacyParams
			Response = *TeamsDeleteDiscussionCommentLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionInOrgRequest handles teams/delete-discussion-in-org operation.
//
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsDeleteDiscussionInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionInOrg",
			OperationID:   "teams/delete-discussion-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionInOrgParams
			Response = *TeamsDeleteDiscussionInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteDiscussionLegacyRequest handles teams/delete-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.
// github.com/rest/reference/teams#delete-a-discussion) endpoint.
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsDeleteDiscussionLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteDiscussionLegacy",
			OperationID:   "teams/delete-discussion-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionLegacyParams
			Response = *TeamsDeleteDiscussionLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteInOrgRequest handles teams/delete-in-org operation.
//
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsDeleteInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsDeleteInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteInOrg",
			OperationID:   "teams/delete-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteInOrgParams
			Response = *TeamsDeleteInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsDeleteLegacyRequest handles teams/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a team](https://docs.github.
// com/rest/reference/teams#delete-a-team) endpoint.
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}
func (s *Server) handleTeamsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsDeleteLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsDeleteLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsDeleteLegacy",
			OperationID:   "teams/delete-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteLegacyParams
			Response = TeamsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsDeleteLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsDeleteLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetByNameRequest handles teams/get-by-name operation.
//
// Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}`.
//
// GET /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsGetByNameRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetByName",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetByName
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetByNameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetByNameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetByName",
			OperationID:   "teams/get-by-name",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetByNameParams
			Response = TeamsGetByNameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetByNameParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetByName(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetByName(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionCommentInOrgRequest handles teams/get-discussion-comment-in-org operation.
//
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionCommentInOrg",
			OperationID:   "teams/get-discussion-comment-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionCommentLegacyRequest handles teams/get-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.
// github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionCommentLegacy",
			OperationID:   "teams/get-discussion-comment-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionInOrgRequest handles teams/get-discussion-in-org operation.
//
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionInOrg",
			OperationID:   "teams/get-discussion-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetDiscussionLegacyRequest handles teams/get-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.
// com/rest/reference/teams#get-a-discussion) endpoint.
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetDiscussionLegacy",
			OperationID:   "teams/get-discussion-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetLegacyRequest handles teams/get-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the [Get a team by name](https://docs.github.
// com/rest/reference/teams#get-a-team-by-name) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}
func (s *Server) handleTeamsGetLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetLegacy",
			OperationID:   "teams/get-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetLegacyParams
			Response = TeamsGetLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMemberLegacyRequest handles teams/get-member-legacy operation.
//
// The "Get team member" endpoint (described below) is deprecated.
// We recommend using the [Get team membership for a user](https://docs.github.
// com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get
// both active and pending memberships.
// To list members in a team, the team must be visible to the authenticated user.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members/{username}
func (s *Server) handleTeamsGetMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetMemberLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMemberLegacy",
			OperationID:   "teams/get-member-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMemberLegacyParams
			Response = TeamsGetMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMembershipForUserInOrgRequest handles teams/get-membership-for-user-in-org operation.
//
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetMembershipForUserInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMembershipForUserInOrg",
			OperationID:   "teams/get-membership-for-user-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserInOrgParams
			Response = TeamsGetMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMembershipForUserInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsGetMembershipForUserLegacyRequest handles teams/get-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get team membership for a
// user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsGetMembershipForUserLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsGetMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsGetMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsGetMembershipForUserLegacy",
			OperationID:   "teams/get-membership-for-user-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserLegacyParams
			Response = TeamsGetMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMembershipForUserLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListRequest handles teams/list operation.
//
// Lists all teams in an organization that are visible to the authenticated user.
//
// GET /orgs/{org}/teams
func (s *Server) handleTeamsListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsList",
			OperationID:   "teams/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListParams
			Response = TeamsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListChildInOrgRequest handles teams/list-child-in-org operation.
//
// Lists the child teams of the team specified by `{team_slug}`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/teams`.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (s *Server) handleTeamsListChildInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListChildInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListChildInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListChildInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListChildInOrg",
			OperationID:   "teams/list-child-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildInOrgParams
			Response = *TeamsListChildInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListChildInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListChildInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListChildLegacyRequest handles teams/list-child-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.
// com/rest/reference/teams#list-child-teams) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/teams
func (s *Server) handleTeamsListChildLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListChildLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListChildLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListChildLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListChildLegacy",
			OperationID:   "teams/list-child-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildLegacyParams
			Response = TeamsListChildLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListChildLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListChildLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionCommentsInOrgRequest handles teams/list-discussion-comments-in-org operation.
//
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListDiscussionCommentsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListDiscussionCommentsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListDiscussionCommentsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionCommentsInOrg",
			OperationID:   "teams/list-discussion-comments-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsInOrgParams
			Response = *TeamsListDiscussionCommentsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionCommentsLegacyRequest handles teams/list-discussion-comments-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List discussion comments](https://docs.
// github.com/rest/reference/teams#list-discussion-comments) endpoint.
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListDiscussionCommentsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListDiscussionCommentsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListDiscussionCommentsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionCommentsLegacy",
			OperationID:   "teams/list-discussion-comments-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsLegacyParams
			Response = *TeamsListDiscussionCommentsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionsInOrgRequest handles teams/list-discussions-in-org operation.
//
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsListDiscussionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListDiscussionsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListDiscussionsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListDiscussionsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionsInOrg",
			OperationID:   "teams/list-discussions-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "pinned",
					In:   "query",
				}: params.Pinned,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsInOrgParams
			Response = *TeamsListDiscussionsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListDiscussionsLegacyRequest handles teams/list-discussions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.
// com/rest/reference/teams#list-discussions) endpoint.
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions
func (s *Server) handleTeamsListDiscussionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListDiscussionsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListDiscussionsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListDiscussionsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListDiscussionsLegacy",
			OperationID:   "teams/list-discussions-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsLegacyParams
			Response = *TeamsListDiscussionsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListForAuthenticatedUserRequest handles teams/list-for-authenticated-user operation.
//
// List all of the teams across all of the organizations to which the authenticated user belongs.
// This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via
// [OAuth](https://docs.github.com/apps/building-oauth-apps/).
//
// GET /user/teams
func (s *Server) handleTeamsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListForAuthenticatedUser",
			OperationID:   "teams/list-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListForAuthenticatedUserParams
			Response = TeamsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsForLegacyRequest handles teams/list-idp-groups-for-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List IdP groups for a
// team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsForLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListIdpGroupsForLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListIdpGroupsForLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListIdpGroupsForLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsForLegacy",
			OperationID:   "teams/list-idp-groups-for-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForLegacyParams
			Response = TeamsListIdpGroupsForLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsForLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsForOrgRequest handles teams/list-idp-groups-for-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups available in an organization. You can limit your page results using the `per_page`
// parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next
// page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination
// explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89).".
//
// GET /orgs/{org}/team-sync/groups
func (s *Server) handleTeamsListIdpGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListIdpGroupsForOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListIdpGroupsForOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GroupMappingHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsForOrg",
			OperationID:   "teams/list-idp-groups-for-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForOrgParams
			Response = *GroupMappingHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListIdpGroupsInOrgRequest handles teams/list-idp-groups-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListIdpGroupsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListIdpGroupsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListIdpGroupsInOrg",
			OperationID:   "teams/list-idp-groups-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsInOrgParams
			Response = *GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListMembersInOrgRequest handles teams/list-members-in-org operation.
//
// Team members will include the members of child teams.
// To list members in a team, the team must be visible to the authenticated user.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (s *Server) handleTeamsListMembersInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListMembersInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListMembersInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListMembersInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListMembersInOrg",
			OperationID:   "teams/list-members-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersInOrgParams
			Response = *TeamsListMembersInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListMembersInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListMembersInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListMembersLegacyRequest handles teams/list-members-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team members`](https://docs.github.
// com/rest/reference/teams#list-team-members) endpoint.
// Team members will include the members of child teams.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members
func (s *Server) handleTeamsListMembersLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListMembersLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListMembersLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListMembersLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListMembersLegacy",
			OperationID:   "teams/list-members-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersLegacyParams
			Response = TeamsListMembersLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListMembersLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListMembersLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListPendingInvitationsInOrgRequest handles teams/list-pending-invitations-in-org operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/invitations`.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (s *Server) handleTeamsListPendingInvitationsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListPendingInvitationsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListPendingInvitationsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListPendingInvitationsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListPendingInvitationsInOrg",
			OperationID:   "teams/list-pending-invitations-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsInOrgParams
			Response = *TeamsListPendingInvitationsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListPendingInvitationsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListPendingInvitationsLegacyRequest handles teams/list-pending-invitations-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List pending team
// invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/invitations
func (s *Server) handleTeamsListPendingInvitationsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListPendingInvitationsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListPendingInvitationsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListPendingInvitationsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListPendingInvitationsLegacy",
			OperationID:   "teams/list-pending-invitations-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsLegacyParams
			Response = *TeamsListPendingInvitationsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListPendingInvitationsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListProjectsInOrgRequest handles teams/list-projects-in-org operation.
//
// Lists the organization projects for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects`.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (s *Server) handleTeamsListProjectsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListProjectsInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListProjectsInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListProjectsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListProjectsInOrg",
			OperationID:   "teams/list-projects-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsInOrgParams
			Response = *TeamsListProjectsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListProjectsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListProjectsLegacyRequest handles teams/list-projects-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team projects`](https://docs.
// github.com/rest/reference/teams#list-team-projects) endpoint.
// Lists the organization projects for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects
func (s *Server) handleTeamsListProjectsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListProjectsLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListProjectsLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListProjectsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListProjectsLegacy",
			OperationID:   "teams/list-projects-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsLegacyParams
			Response = TeamsListProjectsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListProjectsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListReposInOrgRequest handles teams/list-repos-in-org operation.
//
// Lists a team's repositories visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos`.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (s *Server) handleTeamsListReposInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListReposInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListReposInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsListReposInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListReposInOrg",
			OperationID:   "teams/list-repos-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposInOrgParams
			Response = *TeamsListReposInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListReposInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListReposInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsListReposLegacyRequest handles teams/list-repos-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List team repositories](https://docs.
// github.com/rest/reference/teams#list-team-repositories) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos
func (s *Server) handleTeamsListReposLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsListReposLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsListReposLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsListReposLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsListReposLegacy",
			OperationID:   "teams/list-repos-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposLegacyParams
			Response = TeamsListReposLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListReposLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListReposLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMemberLegacyRequest handles teams/remove-member-legacy operation.
//
// The "Remove team member" endpoint (described below) is deprecated.
// We recommend using the [Remove team membership for a user](https://docs.github.
// com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to
// remove both active and pending memberships.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an
// owner of the org that the team is associated with. Removing a team member does not delete the user,
//
//	it just removes them from the team.
//
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/members/{username}
func (s *Server) handleTeamsRemoveMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveMemberLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveMemberLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMemberLegacy",
			OperationID:   "teams/remove-member-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMemberLegacyParams
			Response = TeamsRemoveMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMemberLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMembershipForUserInOrgRequest handles teams/remove-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveMembershipForUserInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMembershipForUserInOrg",
			OperationID:   "teams/remove-membership-for-user-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserInOrgParams
			Response = TeamsRemoveMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveMembershipForUserLegacyRequest handles teams/remove-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove team membership for a
// user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveMembershipForUserLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveMembershipForUserLegacy",
			OperationID:   "teams/remove-membership-for-user-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserLegacyParams
			Response = TeamsRemoveMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveProjectInOrgRequest handles teams/remove-project-in-org operation.
//
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. This endpoint removes the project from the team, but does not delete the project.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveProjectInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveProjectInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsRemoveProjectInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveProjectInOrg",
			OperationID:   "teams/remove-project-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectInOrgParams
			Response = *TeamsRemoveProjectInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveProjectInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveProjectInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveProjectLegacyRequest handles teams/remove-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a project from a
// team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveProjectLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveProjectLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response TeamsRemoveProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveProjectLegacy",
			OperationID:   "teams/remove-project-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectLegacyParams
			Response = TeamsRemoveProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveProjectLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveProjectLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveRepoInOrgRequest handles teams/remove-repo-in-org operation.
//
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team. This
// does not delete the repository, it just removes it from the team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveRepoInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveRepoInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsRemoveRepoInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveRepoInOrg",
			OperationID:   "teams/remove-repo-in-org",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoInOrgParams
			Response = *TeamsRemoveRepoInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveRepoInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveRepoInOrg(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsRemoveRepoLegacyRequest handles teams/remove-repo-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a repository from a
// team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team.
// NOTE: This does not delete the repository, it just removes it from the team.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsRemoveRepoLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsRemoveRepoLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *TeamsRemoveRepoLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsRemoveRepoLegacy",
			OperationID:   "teams/remove-repo-legacy",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoLegacyParams
			Response = *TeamsRemoveRepoLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveRepoLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveRepoLegacy(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionCommentInOrgRequest handles teams/update-discussion-comment-in-org operation.
//
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateDiscussionCommentInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionCommentInOrg",
			OperationID:   "teams/update-discussion-comment-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateDiscussionCommentInOrgReq
			Params   = TeamsUpdateDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionCommentLegacyRequest handles teams/update-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion
// comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateDiscussionCommentLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionCommentLegacy",
			OperationID:   "teams/update-discussion-comment-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateDiscussionCommentLegacyReq
			Params   = TeamsUpdateDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionInOrgRequest handles teams/update-discussion-in-org operation.
//
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateDiscussionInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateDiscussionInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionInOrg",
			OperationID:   "teams/update-discussion-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionInOrgReq
			Params   = TeamsUpdateDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateDiscussionLegacyRequest handles teams/update-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.
// com/rest/reference/teams#update-a-discussion) endpoint.
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateDiscussionLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateDiscussionLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateDiscussionLegacy",
			OperationID:   "teams/update-discussion-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionLegacyReq
			Params   = TeamsUpdateDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateInOrgRequest handles teams/update-in-org operation.
//
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}`.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsUpdateInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateInOrg",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateInOrg
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateInOrgParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamFull
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateInOrg",
			OperationID:   "teams/update-in-org",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateInOrgReq
			Params   = TeamsUpdateInOrgParams
			Response = *TeamFull
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateInOrg(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTeamsUpdateLegacyRequest handles teams/update-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a team](https://docs.github.
// com/rest/reference/teams#update-a-team) endpoint.
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}
func (s *Server) handleTeamsUpdateLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateLegacy",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().TeamsUpdateLegacy
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeTeamsUpdateLegacyParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTeamsUpdateLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsUpdateLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TeamsUpdateLegacy",
			OperationID:   "teams/update-legacy",
			Op:            op,
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateLegacyReq
			Params   = TeamsUpdateLegacyParams
			Response = TeamsUpdateLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateLegacy(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateLegacyResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersAddEmailForAuthenticatedRequest handles users/add-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// POST /user/emails
func (s *Server) handleUsersAddEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersAddEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersAddEmailForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersAddEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersAddEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersAddEmailForAuthenticated",
			OperationID:   "users/add-email-for-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptUsersAddEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersAddEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersAddEmailForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersAddEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersAddEmailForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersBlockRequest handles users/block operation.
//
// Block a user.
//
// PUT /user/blocks/{username}
func (s *Server) handleUsersBlockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersBlock
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersBlockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersBlock",
			OperationID:   "users/block",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersBlockParams
			Response = UsersBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersBlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckBlockedRequest handles users/check-blocked operation.
//
// Check if a user is blocked by the authenticated user.
//
// GET /user/blocks/{username}
func (s *Server) handleUsersCheckBlockedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckBlocked",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersCheckBlocked
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersCheckBlockedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckBlockedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckBlocked",
			OperationID:   "users/check-blocked",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckBlockedParams
			Response = UsersCheckBlockedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckBlockedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckBlocked(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckBlocked(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckFollowingForUserRequest handles users/check-following-for-user operation.
//
// Check if a user follows another user.
//
// GET /users/{username}/following/{target_user}
func (s *Server) handleUsersCheckFollowingForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersCheckFollowingForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersCheckFollowingForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckFollowingForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckFollowingForUser",
			OperationID:   "users/check-following-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "target_user",
					In:   "path",
				}: params.TargetUser,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckFollowingForUserParams
			Response = UsersCheckFollowingForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckFollowingForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckFollowingForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCheckPersonIsFollowedByAuthenticatedRequest handles users/check-person-is-followed-by-authenticated operation.
//
// Check if a person is followed by the authenticated user.
//
// GET /user/following/{username}
func (s *Server) handleUsersCheckPersonIsFollowedByAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckPersonIsFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersCheckPersonIsFollowedByAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersCheckPersonIsFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCheckPersonIsFollowedByAuthenticated",
			OperationID:   "users/check-person-is-followed-by-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckPersonIsFollowedByAuthenticatedParams
			Response = UsersCheckPersonIsFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckPersonIsFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCreateGpgKeyForAuthenticatedRequest handles users/create-gpg-key-for-authenticated operation.
//
// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via
// Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/gpg_keys
func (s *Server) handleUsersCreateGpgKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreateGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersCreateGpgKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersCreateGpgKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreateGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCreateGpgKeyForAuthenticated",
			OperationID:   "users/create-gpg-key-for-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *UsersCreateGpgKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreateGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreateGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersCreatePublicSSHKeyForAuthenticatedRequest handles users/create-public-ssh-key-for-authenticated operation.
//
// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/keys
func (s *Server) handleUsersCreatePublicSSHKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreatePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersCreatePublicSSHKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersCreatePublicSSHKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreatePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersCreatePublicSSHKeyForAuthenticated",
			OperationID:   "users/create-public-ssh-key-for-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *UsersCreatePublicSSHKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreatePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreatePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeleteEmailForAuthenticatedRequest handles users/delete-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// DELETE /user/emails
func (s *Server) handleUsersDeleteEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersDeleteEmailForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersDeleteEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersDeleteEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeleteEmailForAuthenticated",
			OperationID:   "users/delete-email-for-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptUsersDeleteEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersDeleteEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeleteEmailForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeleteEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteEmailForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeleteGpgKeyForAuthenticatedRequest handles users/delete-gpg-key-for-authenticated operation.
//
// Removes a GPG key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersDeleteGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersDeleteGpgKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersDeleteGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersDeleteGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeleteGpgKeyForAuthenticated",
			OperationID:   "users/delete-gpg-key-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gpg_key_id",
					In:   "path",
				}: params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeleteGpgKeyForAuthenticatedParams
			Response = UsersDeleteGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeleteGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersDeletePublicSSHKeyForAuthenticatedRequest handles users/delete-public-ssh-key-for-authenticated operation.
//
// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/keys/{key_id}
func (s *Server) handleUsersDeletePublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeletePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersDeletePublicSSHKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersDeletePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersDeletePublicSSHKeyForAuthenticated",
			OperationID:   "users/delete-public-ssh-key-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeletePublicSSHKeyForAuthenticatedParams
			Response = UsersDeletePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeletePublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersFollowRequest handles users/follow operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with
// the `user:follow` scope.
//
// PUT /user/following/{username}
func (s *Server) handleUsersFollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersFollow",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersFollow
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersFollowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersFollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersFollow",
			OperationID:   "users/follow",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersFollowParams
			Response = UsersFollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersFollowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersFollow(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersFollow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersFollowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetAuthenticatedRequest handles users/get-authenticated operation.
//
// If the authenticated user is authenticated through basic authentication or OAuth with the `user`
// scope, then the response lists public and private profile information.
// If the authenticated user is authenticated through OAuth without the `user` scope, then the
// response lists only public profile information.
//
// GET /user
func (s *Server) handleUsersGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersGetAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response UsersGetAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetAuthenticated",
			OperationID:   "users/get-authenticated",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersGetAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetByUsernameRequest handles users/get-by-username operation.
//
// Provides publicly available information about someone with a GitHub account.
// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a
// user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
// authorizing users for GitHub Apps](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details
// about authentication. For an example response, see 'Response with GitHub plan information' below"
// The `email` key in the following response is the publicly visible email address from your GitHub
// [profile page](https://github.com/settings/profile). When setting up your profile, you can select
// a primary email address to be “public” which provides an email entry for this endpoint. If you
// do not set a public email address for `email`, then it will have a value of `null`. You only see
// publicly visible email addresses when authenticated with GitHub. For more information, see
// [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
// The Emails API enables you to list all of your email addresses, and toggle a primary email to be
// visible publicly. For more information, see "[Emails API](https://docs.github.
// com/rest/reference/users#emails)".
//
// GET /users/{username}
func (s *Server) handleUsersGetByUsernameRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetByUsername",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersGetByUsername
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersGetByUsernameParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetByUsernameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetByUsername",
			OperationID:   "users/get-by-username",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetByUsernameParams
			Response = UsersGetByUsernameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetByUsernameParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetByUsername(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetByUsername(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetContextForUserRequest handles users/get-context-for-user operation.
//
// Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
// scope. You can find out more about someone in relation to their pull requests, issues,
// repositories, and organizations.
// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which
// returns more information than without the parameters. For example, if you wanted to find out more
// about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
// ```shell
// curl -u username:token
// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
// ```.
//
// GET /users/{username}/hovercard
func (s *Server) handleUsersGetContextForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetContextForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersGetContextForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersGetContextForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetContextForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetContextForUser",
			OperationID:   "users/get-context-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "subject_type",
					In:   "query",
				}: params.SubjectType,
				{
					Name: "subject_id",
					In:   "query",
				}: params.SubjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetContextForUserParams
			Response = UsersGetContextForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetContextForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetContextForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetContextForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetContextForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetGpgKeyForAuthenticatedRequest handles users/get-gpg-key-for-authenticated operation.
//
// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or
// via OAuth with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersGetGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersGetGpgKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersGetGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetGpgKeyForAuthenticated",
			OperationID:   "users/get-gpg-key-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "gpg_key_id",
					In:   "path",
				}: params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetGpgKeyForAuthenticatedParams
			Response = UsersGetGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersGetPublicSSHKeyForAuthenticatedRequest handles users/get-public-ssh-key-for-authenticated operation.
//
// View extended details for a single public SSH key. Requires that you are authenticated via Basic
// Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys/{key_id}
func (s *Server) handleUsersGetPublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetPublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersGetPublicSSHKeyForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersGetPublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersGetPublicSSHKeyForAuthenticated",
			OperationID:   "users/get-public-ssh-key-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetPublicSSHKeyForAuthenticatedParams
			Response = UsersGetPublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetPublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListRequest handles users/list operation.
//
// Lists all users, in the order that they signed up on GitHub. This list includes personal user
// accounts and organization accounts.
// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of users.
//
// GET /users
func (s *Server) handleUsersListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersList",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersList
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersList",
			OperationID:   "users/list",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListParams
			Response = UsersListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersList(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListBlockedByAuthenticatedRequest handles users/list-blocked-by-authenticated operation.
//
// List the users you've blocked on your personal account.
//
// GET /user/blocks
func (s *Server) handleUsersListBlockedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListBlockedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListBlockedByAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response UsersListBlockedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListBlockedByAuthenticated",
			OperationID:   "users/list-blocked-by-authenticated",
			Op:            op,
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersListBlockedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListBlockedByAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListBlockedByAuthenticated(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListEmailsForAuthenticatedRequest handles users/list-emails-for-authenticated operation.
//
// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint
// is accessible with the `user:email` scope.
//
// GET /user/emails
func (s *Server) handleUsersListEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListEmailsForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListEmailsForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListEmailsForAuthenticated",
			OperationID:   "users/list-emails-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListEmailsForAuthenticatedParams
			Response = UsersListEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListEmailsForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowedByAuthenticatedRequest handles users/list-followed-by-authenticated operation.
//
// Lists the people who the authenticated user follows.
//
// GET /user/following
func (s *Server) handleUsersListFollowedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListFollowedByAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListFollowedByAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowedByAuthenticated",
			OperationID:   "users/list-followed-by-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowedByAuthenticatedParams
			Response = UsersListFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowedByAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowersForAuthenticatedUserRequest handles users/list-followers-for-authenticated-user operation.
//
// Lists the people following the authenticated user.
//
// GET /user/followers
func (s *Server) handleUsersListFollowersForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListFollowersForAuthenticatedUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListFollowersForAuthenticatedUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListFollowersForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowersForAuthenticatedUser",
			OperationID:   "users/list-followers-for-authenticated-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForAuthenticatedUserParams
			Response = UsersListFollowersForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowersForUserRequest handles users/list-followers-for-user operation.
//
// Lists the people following the specified user.
//
// GET /users/{username}/followers
func (s *Server) handleUsersListFollowersForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListFollowersForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListFollowersForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *UsersListFollowersForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowersForUser",
			OperationID:   "users/list-followers-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForUserParams
			Response = *UsersListFollowersForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowersForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListFollowingForUserRequest handles users/list-following-for-user operation.
//
// Lists the people who the specified user follows.
//
// GET /users/{username}/following
func (s *Server) handleUsersListFollowingForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListFollowingForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListFollowingForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *UsersListFollowingForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListFollowingForUser",
			OperationID:   "users/list-following-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowingForUserParams
			Response = *UsersListFollowingForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowingForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowingForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListGpgKeysForAuthenticatedRequest handles users/list-gpg-keys-for-authenticated operation.
//
// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth
// with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys
func (s *Server) handleUsersListGpgKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListGpgKeysForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListGpgKeysForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListGpgKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListGpgKeysForAuthenticated",
			OperationID:   "users/list-gpg-keys-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForAuthenticatedParams
			Response = UsersListGpgKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListGpgKeysForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListGpgKeysForUserRequest handles users/list-gpg-keys-for-user operation.
//
// Lists the GPG keys for a user. This information is accessible by anyone.
//
// GET /users/{username}/gpg_keys
func (s *Server) handleUsersListGpgKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListGpgKeysForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListGpgKeysForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *UsersListGpgKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListGpgKeysForUser",
			OperationID:   "users/list-gpg-keys-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForUserParams
			Response = *UsersListGpgKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListGpgKeysForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicEmailsForAuthenticatedRequest handles users/list-public-emails-for-authenticated operation.
//
// Lists your publicly visible email address, which you can set with the [Set primary email
// visibility for the authenticated user](https://docs.github.
// com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This
// endpoint is accessible with the `user:email` scope.
//
// GET /user/public_emails
func (s *Server) handleUsersListPublicEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListPublicEmailsForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListPublicEmailsForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListPublicEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicEmailsForAuthenticated",
			OperationID:   "users/list-public-emails-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicEmailsForAuthenticatedParams
			Response = UsersListPublicEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicKeysForUserRequest handles users/list-public-keys-for-user operation.
//
// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
//
// GET /users/{username}/keys
func (s *Server) handleUsersListPublicKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicKeysForUser",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListPublicKeysForUser
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListPublicKeysForUserParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *UsersListPublicKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicKeysForUser",
			OperationID:   "users/list-public-keys-for-user",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicKeysForUserParams
			Response = *UsersListPublicKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicKeysForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicKeysForUser(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersListPublicSSHKeysForAuthenticatedRequest handles users/list-public-ssh-keys-for-authenticated operation.
//
// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys
func (s *Server) handleUsersListPublicSSHKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicSSHKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersListPublicSSHKeysForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersListPublicSSHKeysForAuthenticatedParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersListPublicSSHKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersListPublicSSHKeysForAuthenticated",
			OperationID:   "users/list-public-ssh-keys-for-authenticated",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicSSHKeysForAuthenticatedParams
			Response = UsersListPublicSSHKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicSSHKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest handles users/set-primary-email-visibility-for-authenticated operation.
//
// Sets the visibility for your primary email addresses.
//
// PATCH /user/email/visibility
func (s *Server) handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersSetPrimaryEmailVisibilityForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersSetPrimaryEmailVisibilityForAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersSetPrimaryEmailVisibilityForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersSetPrimaryEmailVisibilityForAuthenticated",
			OperationID:   "users/set-primary-email-visibility-for-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *UsersSetPrimaryEmailVisibilityForAuthenticatedReq
			Params   = struct{}
			Response = UsersSetPrimaryEmailVisibilityForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUnblockRequest handles users/unblock operation.
//
// Unblock a user.
//
// DELETE /user/blocks/{username}
func (s *Server) handleUsersUnblockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnblock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersUnblock
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersUnblockParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersUnblockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUnblock",
			OperationID:   "users/unblock",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnblockParams
			Response = UsersUnblockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnblockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUnblock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUnblock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnblockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUnfollowRequest handles users/unfollow operation.
//
// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth
// with the `user:follow` scope.
//
// DELETE /user/following/{username}
func (s *Server) handleUsersUnfollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnfollow",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersUnfollow
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	params, err := decodeUsersUnfollowParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response UsersUnfollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUnfollow",
			OperationID:   "users/unfollow",
			Op:            op,
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnfollowParams
			Response = UsersUnfollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnfollowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUnfollow(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUnfollow(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUsersUpdateAuthenticatedRequest handles users/update-authenticated operation.
//
// **Note:** If your email is set to private and you send an `email` parameter as part of this
// request to update your profile, your privacy settings are still enforced: the email address will
// not be displayed on your public profile or via the API.
//
// PATCH /user
func (s *Server) handleUsersUpdateAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUpdateAuthenticated",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		op          = getPaths().UsersUpdateAuthenticated
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name:      op.Name,
			ID:        op.ID,
			Operation: op,
		}
	)
	request, close, err := s.decodeUsersUpdateAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersUpdateAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UsersUpdateAuthenticated",
			OperationID:   "users/update-authenticated",
			Op:            op,
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = OptUsersUpdateAuthenticatedReq
			Params   = struct{}
			Response = UsersUpdateAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUpdateAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUpdateAuthenticated(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUpdateAuthenticatedResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
